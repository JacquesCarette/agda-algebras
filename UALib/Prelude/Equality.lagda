---
layout: default
title : UALib.Prelude.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This is the [UALib.Prelude.Equality][] module of the [Agda Universal Algebra Library][].

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

module Prelude.Equality where

open import Prelude.Preliminaries public

\end{code}

#### <a id="definitional-equality">Definitional equality</a>

Here we discuss what is probably the most important type in [MLTT][]. It is called *definitional equality*. This concept is easily understood, at least heuristically, with the following slogan:

*Definitional equality is the substitution-preserving equivalence relation generated by definitions.*

We will make this precise below, but first let us quote from a primary source.

In [An Intuitionistic Theory of Types: Predicative Part](https://www.sciencedirect.com/science/article/pii/S0049237X08719451), Per Martin-Löof offers the following definition (italics added):<sup>[1](Prelude.Equality.html#fn1)</sup>

"*Definitional equality* is defined to be the equivalence relation, that is, reflexive, symmetric and transitive relation, which is generated by the principles that a definiendum is always definitionally equal to its definiens and that definitional equality is preserved under substitution."<sup>[2](Prelude.Equality.html#fn2)

To be sure we understand what this means, let `:=` denote the relation with respect to which `x` is related to `y` (denoted `x := y`) if and only if `y` *is the definition of* `x`.  Then the definitional equality relation `≡` is the reflexive, symmetric, transitive, substitutive closure of `:=`. By *subsitutive closure* we mean closure under the following *substitution rule*.

<!--
\begin{prooftree}
\AxiomC{`\{A : 𝓤 ̇\}\{B : A → 𝓦 ̇\}\{x y : A\}`}
\AxiomC{`x ≡ y`}
\Rightlabel{(subst)}
\BinaryInfC{`B x ≡ B y`}
\end{prooftree}
-->

```agda
    {A : 𝓤 ̇} {B : A → 𝓦 ̇} {x y : A}   x ≡ y
    ------------------------------------------
                B x ≡ B y
```

The datatype we use to represent definitional equality is imported from the Identity-Type module of the [Type Topology][] library, but apart from superficial syntactic differences, it is equivalent to the identity type used in all other Agda libraries we know of.  We repeat the definition here for easy reference.

\begin{code}

module hide-refl {𝓤 : Universe} where

 data _≡_ {𝓤} {A : 𝓤 ̇ } : A → A → 𝓤 ̇ where refl : {x : A} → x ≡ x

open import Identity-Type renaming (_≡_ to infix 0 _≡_) public

\end{code}

Whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we invoke `refl`.  If we need to make explicit the implicit argument `x`, then we use `refl {x = x}`.

Of course `≡` is an equivalence relation and the formal proof of this fact is trivial. We don't need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

\begin{code}

module _  {𝓤 : Universe}{A : 𝓤 ̇ }  where

 ≡-symmetric : (x y : A) → x ≡ y → y ≡ x
 ≡-symmetric _ _ refl = refl

 ≡-sym : {x y : A} → x ≡ y → y ≡ x
 ≡-sym refl = refl

 ≡-transitive : (x y z : A) → x ≡ y → y ≡ z → x ≡ z
 ≡-transitive _ _ _ refl refl = refl

 ≡-trans : {x y z : A} → x ≡ y → y ≡ z → x ≡ z
 ≡-trans refl refl = refl

\end{code}

The only difference between `≡-symmetric` and `≡-sym` (respectively, `≡-transitive` and `≡-trans`) is that the latter has fewer explicit arguments, which is sometimes convenient.

We prove that `≡` obeys the substitution rule (subst) in the next subsection (see the definition of `ap` below), but first we define some syntactic sugar that will make it easier to apply symmetry and transitivity of `≡` in proofs.<sup>[3](Prelude.Equality.html#fn3)</sup>

\begin{code}

module hide-sym-trans {𝓤 : Universe} {A : 𝓤 ̇ } where

 _⁻¹ : {x y : A} → x ≡ y → y ≡ x
 p ⁻¹ = ≡-sym p

\end{code}

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` . Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.

\begin{code}

 _∙_ : {x y z : A} → x ≡ y → y ≡ z → x ≡ z
 p ∙ q = ≡-trans p q

\end{code}

As usual, we import the original definitions from the [Type Topology][] library.

\begin{code}

open import MGS-MLTT using (_⁻¹; _∙_) public

\end{code}

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Prelude.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[2](Preliminaries.Equality.html#fn2)</sup>

\begin{code}

module hide-id-transport {𝓤 𝓦 : Universe} where

 𝑖𝑑 : {𝓧 : Universe} (X : 𝓧 ̇ ) → X → X
 𝑖𝑑 X = λ x → x

 transport : {A : 𝓤 ̇ } (B : A → 𝓦 ̇ ) {x y : A} → x ≡ y → B x → B y
 transport B (refl {x = x}) = 𝑖𝑑 (B x)

open import MGS-MLTT using (𝑖𝑑; transport) public

\end{code}

As usual, we display definitions of existing types (here, `𝑖𝑑` and `transport`) in a hidden module and then imported their original definition from [Type Topology][].

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

\begin{code}

module hide-ap  {𝓤 𝓦 : Universe}{A : 𝓤 ̇}{B : 𝓦 ̇} where

 ap : (f : A → B){x y : A} → x ≡ y → f x ≡ f y
 ap f {x} p = transport (λ - → f x ≡ f -) p (refl {x = f x})

open import MGS-MLTT using (ap) public

\end{code}

Here's a useful variation of `ap` that we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][] (transcribed into TypeTopology/UALib notation of course).

\begin{code}

module _ {𝓤 𝓦 : Universe} where

 cong-app : {A : 𝓤 ̇}{B : A → 𝓦 ̇}{f g : Π B} → f ≡ g → ∀ x → f x ≡ g x
 cong-app refl _ = refl

\end{code}





-------------------------------------

#### <a id="equality-fn">Notes</a>

<span class="footnote">
<ol>
<li id="fn1"> Per Martin-Löf, *An intuitionistic theory of types: predicative part*, Logic Colloquium '73 (Bristol, 1973), 73--118, Studies in Logic and the Foundations of Mathematics, Vol. 80, 1975.</li>
<li id="fn:def"> The *definiendum* is the left-hand side of a defining equation, the *definiens* is the right-hand side. For readers who have never generated an equivalence relation: the *reflexive closure* of `R ⊆ A × A `is the union of `R` and all pairs of the form `(a , a)`; the *symmetric closure* is the union of `R` and its inverse `{(y , x) : (x , y) ∈ R}`; we leave it to the reader to come up with the correct definition of transitive closure.</li>
<li id="fn:unicode"> **Unicode Hints** ([agda2-mode][]). `\^-\^1 ↝ ⁻¹`; `\Mii\Mid ↝ 𝑖𝑑`; `\. ↝ ∙`. In general, for information about a character, place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</li>
<li id="fn:church"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170). See also [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).</li>
</ol>
</span>

<br>
<br>

[← Prelude.Preliminaries ](Prelude.Preliminaries.html)
<span style="float:right;">[Prelude.Extensionality →](Prelude.Extensionality.html)</span>

{% include UALib.Links.md %}


<!-- NO LONGER USED

#### <a id="≡-intro-and-≡-elim-for-nondependent-pairs">≡-intro and ≡-elim for nondependent pairs</a>

We conclude the Equality module with some occasionally useful introduction and elimination rules for the equality relation on (nondependent) pair types.

 ≡-elim-left : {A₁ A₂ : 𝓤 ̇}{B₁ B₂ : 𝓦 ̇} → (A₁ , B₁) ≡ (A₂ , B₂) → A₁ ≡ A₂
 ≡-elim-left e = ap fst e


 ≡-elim-right : {A₁ A₂ : 𝓤 ̇}{B₁ B₂ : 𝓦 ̇} → (A₁ , B₁) ≡ (A₂ , B₂) → B₁ ≡ B₂
 ≡-elim-right e = ap snd e


 ≡-×-intro : {A₁ A₂ : 𝓤 ̇} {B₁ B₂ : 𝓦 ̇} → A₁ ≡ A₂ → B₁ ≡ B₂ → (A₁ , B₁) ≡ (A₂ , B₂)
 ≡-×-intro refl refl = refl


 ≡-×-int : {A : 𝓤 ̇}{B : 𝓦 ̇}{a x : A}{b y : B} → a ≡ x → b ≡ y → (a , b) ≡ (x , y)
 ≡-×-int refl refl = refl

-->
