---
layout: default
title : UALib.Prelude.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This section describes the [UALib.Prelude.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="291" class="Symbol">{-#</a> <a id="295" class="Keyword">OPTIONS</a> <a id="303" class="Pragma">--without-K</a> <a id="315" class="Pragma">--exact-split</a> <a id="329" class="Pragma">--safe</a> <a id="336" class="Symbol">#-}</a>

<a id="341" class="Keyword">module</a> <a id="348" href="Prelude.Equality.html" class="Module">Prelude.Equality</a> <a id="365" class="Keyword">where</a>

<a id="372" class="Keyword">open</a> <a id="377" class="Keyword">import</a> <a id="384" href="Prelude.Preliminaries.html" class="Module">Prelude.Preliminaries</a> <a id="406" class="Keyword">public</a>

</pre>

#### <a id="refl">refl</a>

The type referred to as "reflexivity" or "refl" is a very basic but important one. It represents [definitional equality](https://ncatlab.org/nlab/show/equality#definitional_equality).

The `refl` type we use is a standard one. It is defined in the `Identity-Type` module of the [Type Topology][] library, but apart from syntax it is equivalent to the identity type used in most other Agda libraries.

We make `refl` available by importing it from the `Identity-Type` module.  However, we first repeat the definition here (inside a hidden submodule) for clarity. (See [the remark about hidden modules](Prelude.Equality.html#fn3) in the [third footnote](Prelude.Preliminaries.html#fn3).html#fn1) of the [Prelude.Preliminaries][] module.)

<pre class="Agda">

<a id="1205" class="Keyword">module</a> <a id="hide-refl"></a><a id="1212" href="Prelude.Equality.html#1212" class="Module">hide-refl</a> <a id="1222" class="Symbol">{</a><a id="1223" href="Prelude.Equality.html#1223" class="Bound">𝓤</a> <a id="1225" class="Symbol">:</a> <a id="1227" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="1235" class="Symbol">}</a> <a id="1237" class="Keyword">where</a>

 <a id="1245" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="1250" href="Prelude.Equality.html#1250" class="Datatype Operator">_≡_</a> <a id="1254" class="Symbol">{</a><a id="1255" href="Prelude.Equality.html#1255" class="Bound">𝓤</a><a id="1256" class="Symbol">}</a> <a id="1258" class="Symbol">{</a><a id="1259" href="Prelude.Equality.html#1259" class="Bound">X</a> <a id="1261" class="Symbol">:</a> <a id="1263" href="Prelude.Equality.html#1255" class="Bound">𝓤</a> <a id="1265" href="Universes.html#403" class="Function Operator">̇</a> <a id="1267" class="Symbol">}</a> <a id="1269" class="Symbol">:</a> <a id="1271" href="Prelude.Equality.html#1259" class="Bound">X</a> <a id="1273" class="Symbol">→</a> <a id="1275" href="Prelude.Equality.html#1259" class="Bound">X</a> <a id="1277" class="Symbol">→</a> <a id="1279" href="Prelude.Equality.html#1255" class="Bound">𝓤</a> <a id="1281" href="Universes.html#403" class="Function Operator">̇</a> <a id="1283" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="1289" href="Prelude.Equality.html#1289" class="InductiveConstructor">refl</a> <a id="1294" class="Symbol">:</a> <a id="1296" class="Symbol">{</a><a id="1297" href="Prelude.Equality.html#1297" class="Bound">x</a> <a id="1299" class="Symbol">:</a> <a id="1301" href="Prelude.Equality.html#1259" class="Bound">X</a><a id="1302" class="Symbol">}</a> <a id="1304" class="Symbol">→</a> <a id="1306" href="Prelude.Equality.html#1297" class="Bound">x</a> <a id="1308" href="Prelude.Equality.html#1250" class="Datatype Operator">≡</a> <a id="1310" href="Prelude.Equality.html#1297" class="Bound">x</a>

<a id="1313" class="Keyword">open</a> <a id="1318" class="Keyword">import</a> <a id="1325" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="1339" class="Keyword">renaming</a> <a id="1348" class="Symbol">(</a><a id="1349" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="1353" class="Symbol">to</a> <a id="1356" class="Keyword">infix</a> <a id="1362" class="Number">0</a> <a id="_≡_"></a><a id="1364" href="Prelude.Equality.html#1364" class="Datatype Operator">_≡_</a><a id="1367" class="Symbol">)</a> <a id="1369" class="Keyword">public</a>

</pre>

Thus, whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we can invoke `refl`.  If we need to make `x` explicit, we use `refl {x = x}`.

Of course `≡` is an equivalence relation and the formal proof of this fact is trivial. We don't even need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

<pre class="Agda">

<a id="1828" class="Keyword">module</a> <a id="1835" href="Prelude.Equality.html#1835" class="Module">_</a>  <a id="1838" class="Symbol">{</a><a id="1839" href="Prelude.Equality.html#1839" class="Bound">𝓤</a> <a id="1841" class="Symbol">:</a> <a id="1843" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="1851" class="Symbol">}{</a><a id="1853" href="Prelude.Equality.html#1853" class="Bound">X</a> <a id="1855" class="Symbol">:</a> <a id="1857" href="Prelude.Equality.html#1839" class="Bound">𝓤</a> <a id="1859" href="Universes.html#403" class="Function Operator">̇</a> <a id="1861" class="Symbol">}</a>  <a id="1864" class="Keyword">where</a>

 <a id="1872" href="Prelude.Equality.html#1872" class="Function">≡-symmetric</a> <a id="1884" class="Symbol">:</a> <a id="1886" class="Symbol">(</a><a id="1887" href="Prelude.Equality.html#1887" class="Bound">x</a> <a id="1889" href="Prelude.Equality.html#1889" class="Bound">y</a> <a id="1891" class="Symbol">:</a> <a id="1893" href="Prelude.Equality.html#1853" class="Bound">X</a><a id="1894" class="Symbol">)</a> <a id="1896" class="Symbol">→</a> <a id="1898" href="Prelude.Equality.html#1887" class="Bound">x</a> <a id="1900" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="1902" href="Prelude.Equality.html#1889" class="Bound">y</a> <a id="1904" class="Symbol">→</a> <a id="1906" href="Prelude.Equality.html#1889" class="Bound">y</a> <a id="1908" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="1910" href="Prelude.Equality.html#1887" class="Bound">x</a>
 <a id="1913" href="Prelude.Equality.html#1872" class="Function">≡-symmetric</a> <a id="1925" class="Symbol">_</a> <a id="1927" class="Symbol">_</a> <a id="1929" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="1934" class="Symbol">=</a> <a id="1936" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="1943" href="Prelude.Equality.html#1943" class="Function">≡-sym</a> <a id="1949" class="Symbol">:</a> <a id="1951" class="Symbol">{</a><a id="1952" href="Prelude.Equality.html#1952" class="Bound">x</a> <a id="1954" href="Prelude.Equality.html#1954" class="Bound">y</a> <a id="1956" class="Symbol">:</a> <a id="1958" href="Prelude.Equality.html#1853" class="Bound">X</a><a id="1959" class="Symbol">}</a> <a id="1961" class="Symbol">→</a> <a id="1963" href="Prelude.Equality.html#1952" class="Bound">x</a> <a id="1965" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="1967" href="Prelude.Equality.html#1954" class="Bound">y</a> <a id="1969" class="Symbol">→</a> <a id="1971" href="Prelude.Equality.html#1954" class="Bound">y</a> <a id="1973" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="1975" href="Prelude.Equality.html#1952" class="Bound">x</a>
 <a id="1978" href="Prelude.Equality.html#1943" class="Function">≡-sym</a> <a id="1984" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="1989" class="Symbol">=</a> <a id="1991" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="1998" href="Prelude.Equality.html#1998" class="Function">≡-transitive</a> <a id="2011" class="Symbol">:</a> <a id="2013" class="Symbol">(</a><a id="2014" href="Prelude.Equality.html#2014" class="Bound">x</a> <a id="2016" href="Prelude.Equality.html#2016" class="Bound">y</a> <a id="2018" href="Prelude.Equality.html#2018" class="Bound">z</a> <a id="2020" class="Symbol">:</a> <a id="2022" href="Prelude.Equality.html#1853" class="Bound">X</a><a id="2023" class="Symbol">)</a> <a id="2025" class="Symbol">→</a> <a id="2027" href="Prelude.Equality.html#2014" class="Bound">x</a> <a id="2029" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2031" href="Prelude.Equality.html#2016" class="Bound">y</a> <a id="2033" class="Symbol">→</a> <a id="2035" href="Prelude.Equality.html#2016" class="Bound">y</a> <a id="2037" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2039" href="Prelude.Equality.html#2018" class="Bound">z</a> <a id="2041" class="Symbol">→</a> <a id="2043" href="Prelude.Equality.html#2014" class="Bound">x</a> <a id="2045" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2047" href="Prelude.Equality.html#2018" class="Bound">z</a>
 <a id="2050" href="Prelude.Equality.html#1998" class="Function">≡-transitive</a> <a id="2063" class="Symbol">_</a> <a id="2065" class="Symbol">_</a> <a id="2067" class="Symbol">_</a> <a id="2069" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2074" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2079" class="Symbol">=</a> <a id="2081" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="2088" href="Prelude.Equality.html#2088" class="Function">≡-trans</a> <a id="2096" class="Symbol">:</a> <a id="2098" class="Symbol">{</a><a id="2099" href="Prelude.Equality.html#2099" class="Bound">x</a> <a id="2101" href="Prelude.Equality.html#2101" class="Bound">y</a> <a id="2103" href="Prelude.Equality.html#2103" class="Bound">z</a> <a id="2105" class="Symbol">:</a> <a id="2107" href="Prelude.Equality.html#1853" class="Bound">X</a><a id="2108" class="Symbol">}</a> <a id="2110" class="Symbol">→</a> <a id="2112" href="Prelude.Equality.html#2099" class="Bound">x</a> <a id="2114" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2116" href="Prelude.Equality.html#2101" class="Bound">y</a> <a id="2118" class="Symbol">→</a> <a id="2120" href="Prelude.Equality.html#2101" class="Bound">y</a> <a id="2122" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2124" href="Prelude.Equality.html#2103" class="Bound">z</a> <a id="2126" class="Symbol">→</a> <a id="2128" href="Prelude.Equality.html#2099" class="Bound">x</a> <a id="2130" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2132" href="Prelude.Equality.html#2103" class="Bound">z</a>
 <a id="2135" href="Prelude.Equality.html#2088" class="Function">≡-trans</a> <a id="2143" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2148" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2153" class="Symbol">=</a> <a id="2155" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

The only difference between `≡-symmetric` and `≡-sym` (respectively, `≡-transitive` and `≡-trans`) is that the latter has fewer explicit arguments, which is sometimes convenient.

Many proofs make abundant use of the symmetry of `_≡_`, and the following syntactic sugar can often improve the readability of such proofs.<sup>[2](Prelude.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="2549" class="Keyword">module</a> <a id="hide-sym-trans"></a><a id="2556" href="Prelude.Equality.html#2556" class="Module">hide-sym-trans</a> <a id="2571" class="Symbol">{</a><a id="2572" href="Prelude.Equality.html#2572" class="Bound">𝓤</a> <a id="2574" class="Symbol">:</a> <a id="2576" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2584" class="Symbol">}</a> <a id="2586" class="Keyword">where</a>

 <a id="hide-sym-trans._⁻¹"></a><a id="2594" href="Prelude.Equality.html#2594" class="Function Operator">_⁻¹</a> <a id="2598" class="Symbol">:</a> <a id="2600" class="Symbol">{</a><a id="2601" href="Prelude.Equality.html#2601" class="Bound">X</a> <a id="2603" class="Symbol">:</a> <a id="2605" href="Prelude.Equality.html#2572" class="Bound">𝓤</a> <a id="2607" href="Universes.html#403" class="Function Operator">̇</a> <a id="2609" class="Symbol">}</a> <a id="2611" class="Symbol">→</a> <a id="2613" class="Symbol">{</a><a id="2614" href="Prelude.Equality.html#2614" class="Bound">x</a> <a id="2616" href="Prelude.Equality.html#2616" class="Bound">y</a> <a id="2618" class="Symbol">:</a> <a id="2620" href="Prelude.Equality.html#2601" class="Bound">X</a><a id="2621" class="Symbol">}</a> <a id="2623" class="Symbol">→</a> <a id="2625" href="Prelude.Equality.html#2614" class="Bound">x</a> <a id="2627" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2629" href="Prelude.Equality.html#2616" class="Bound">y</a> <a id="2631" class="Symbol">→</a> <a id="2633" href="Prelude.Equality.html#2616" class="Bound">y</a> <a id="2635" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2637" href="Prelude.Equality.html#2614" class="Bound">x</a>
 <a id="2640" href="Prelude.Equality.html#2640" class="Bound">p</a> <a id="2642" href="Prelude.Equality.html#2594" class="Function Operator">⁻¹</a> <a id="2645" class="Symbol">=</a> <a id="2647" href="Prelude.Equality.html#1943" class="Function">≡-sym</a> <a id="2653" href="Prelude.Equality.html#2640" class="Bound">p</a>

</pre>

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` .

Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.<sup>[2](Prelude.Equality.html#fn2)</sup>

<pre class="Agda">

 <a id="hide-sym-trans._∙_"></a><a id="2954" href="Prelude.Equality.html#2954" class="Function Operator">_∙_</a> <a id="2958" class="Symbol">:</a> <a id="2960" class="Symbol">{</a><a id="2961" href="Prelude.Equality.html#2961" class="Bound">X</a> <a id="2963" class="Symbol">:</a> <a id="2965" href="Prelude.Equality.html#2572" class="Bound">𝓤</a> <a id="2967" href="Universes.html#403" class="Function Operator">̇</a> <a id="2969" class="Symbol">}</a> <a id="2971" class="Symbol">{</a><a id="2972" href="Prelude.Equality.html#2972" class="Bound">x</a> <a id="2974" href="Prelude.Equality.html#2974" class="Bound">y</a> <a id="2976" href="Prelude.Equality.html#2976" class="Bound">z</a> <a id="2978" class="Symbol">:</a> <a id="2980" href="Prelude.Equality.html#2961" class="Bound">X</a><a id="2981" class="Symbol">}</a> <a id="2983" class="Symbol">→</a> <a id="2985" href="Prelude.Equality.html#2972" class="Bound">x</a> <a id="2987" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2989" href="Prelude.Equality.html#2974" class="Bound">y</a> <a id="2991" class="Symbol">→</a> <a id="2993" href="Prelude.Equality.html#2974" class="Bound">y</a> <a id="2995" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="2997" href="Prelude.Equality.html#2976" class="Bound">z</a> <a id="2999" class="Symbol">→</a> <a id="3001" href="Prelude.Equality.html#2972" class="Bound">x</a> <a id="3003" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="3005" href="Prelude.Equality.html#2976" class="Bound">z</a>
 <a id="3008" href="Prelude.Equality.html#3008" class="Bound">p</a> <a id="3010" href="Prelude.Equality.html#2954" class="Function Operator">∙</a> <a id="3012" href="Prelude.Equality.html#3012" class="Bound">q</a> <a id="3014" class="Symbol">=</a> <a id="3016" href="Prelude.Equality.html#2088" class="Function">≡-trans</a> <a id="3024" href="Prelude.Equality.html#3008" class="Bound">p</a> <a id="3026" href="Prelude.Equality.html#3012" class="Bound">q</a>

<a id="3029" class="Keyword">open</a> <a id="3034" class="Keyword">import</a> <a id="3041" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="3050" class="Keyword">using</a> <a id="3056" class="Symbol">(</a><a id="3057" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="3060" class="Symbol">;</a> <a id="3062" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="3065" class="Symbol">)</a> <a id="3067" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[3](Prelude.Equality.html#fn3)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.

<pre class="Agda">

<a id="3713" class="Keyword">module</a> <a id="hide-transport"></a><a id="3720" href="Prelude.Equality.html#3720" class="Module">hide-transport</a> <a id="3735" class="Symbol">{</a><a id="3736" href="Prelude.Equality.html#3736" class="Bound">𝓤</a> <a id="3738" href="Prelude.Equality.html#3738" class="Bound">𝓦</a> <a id="3740" class="Symbol">:</a> <a id="3742" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3750" class="Symbol">}</a> <a id="3752" class="Keyword">where</a>

 <a id="hide-transport.𝑖𝑑"></a><a id="3760" href="Prelude.Equality.html#3760" class="Function">𝑖𝑑</a> <a id="3763" class="Symbol">:</a> <a id="3765" class="Symbol">{</a><a id="3766" href="Prelude.Equality.html#3766" class="Bound">𝓧</a> <a id="3768" class="Symbol">:</a> <a id="3770" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3778" class="Symbol">}</a> <a id="3780" class="Symbol">(</a><a id="3781" href="Prelude.Equality.html#3781" class="Bound">X</a> <a id="3783" class="Symbol">:</a> <a id="3785" href="Prelude.Equality.html#3766" class="Bound">𝓧</a> <a id="3787" href="Universes.html#403" class="Function Operator">̇</a> <a id="3789" class="Symbol">)</a> <a id="3791" class="Symbol">→</a> <a id="3793" href="Prelude.Equality.html#3781" class="Bound">X</a> <a id="3795" class="Symbol">→</a> <a id="3797" href="Prelude.Equality.html#3781" class="Bound">X</a>
 <a id="3800" href="Prelude.Equality.html#3760" class="Function">𝑖𝑑</a> <a id="3803" href="Prelude.Equality.html#3803" class="Bound">X</a> <a id="3805" class="Symbol">=</a> <a id="3807" class="Symbol">λ</a> <a id="3809" href="Prelude.Equality.html#3809" class="Bound">x</a> <a id="3811" class="Symbol">→</a> <a id="3813" href="Prelude.Equality.html#3809" class="Bound">x</a>

 <a id="hide-transport.transport"></a><a id="3817" href="Prelude.Equality.html#3817" class="Function">transport</a> <a id="3827" class="Symbol">:</a> <a id="3829" class="Symbol">{</a><a id="3830" href="Prelude.Equality.html#3830" class="Bound">X</a> <a id="3832" class="Symbol">:</a> <a id="3834" href="Prelude.Equality.html#3736" class="Bound">𝓤</a> <a id="3836" href="Universes.html#403" class="Function Operator">̇</a> <a id="3838" class="Symbol">}</a> <a id="3840" class="Symbol">(</a><a id="3841" href="Prelude.Equality.html#3841" class="Bound">A</a> <a id="3843" class="Symbol">:</a> <a id="3845" href="Prelude.Equality.html#3830" class="Bound">X</a> <a id="3847" class="Symbol">→</a> <a id="3849" href="Prelude.Equality.html#3738" class="Bound">𝓦</a> <a id="3851" href="Universes.html#403" class="Function Operator">̇</a> <a id="3853" class="Symbol">)</a> <a id="3855" class="Symbol">{</a><a id="3856" href="Prelude.Equality.html#3856" class="Bound">x</a> <a id="3858" href="Prelude.Equality.html#3858" class="Bound">y</a> <a id="3860" class="Symbol">:</a> <a id="3862" href="Prelude.Equality.html#3830" class="Bound">X</a><a id="3863" class="Symbol">}</a> <a id="3865" class="Symbol">→</a> <a id="3867" href="Prelude.Equality.html#3856" class="Bound">x</a> <a id="3869" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="3871" href="Prelude.Equality.html#3858" class="Bound">y</a> <a id="3873" class="Symbol">→</a> <a id="3875" href="Prelude.Equality.html#3841" class="Bound">A</a> <a id="3877" href="Prelude.Equality.html#3856" class="Bound">x</a> <a id="3879" class="Symbol">→</a> <a id="3881" href="Prelude.Equality.html#3841" class="Bound">A</a> <a id="3883" href="Prelude.Equality.html#3858" class="Bound">y</a>
 <a id="3886" href="Prelude.Equality.html#3817" class="Function">transport</a> <a id="3896" href="Prelude.Equality.html#3896" class="Bound">A</a> <a id="3898" class="Symbol">(</a><a id="3899" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3904" class="Symbol">{</a><a id="3905" class="Argument">x</a> <a id="3907" class="Symbol">=</a> <a id="3909" href="Prelude.Equality.html#3909" class="Bound">x</a><a id="3910" class="Symbol">})</a> <a id="3913" class="Symbol">=</a> <a id="3915" href="Prelude.Equality.html#3760" class="Function">𝑖𝑑</a> <a id="3918" class="Symbol">(</a><a id="3919" href="Prelude.Equality.html#3896" class="Bound">A</a> <a id="3921" href="Prelude.Equality.html#3909" class="Bound">x</a><a id="3922" class="Symbol">)</a>

<a id="3925" class="Keyword">open</a> <a id="3930" class="Keyword">import</a> <a id="3937" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="3946" class="Keyword">using</a> <a id="3952" class="Symbol">(</a><a id="3953" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="3955" class="Symbol">;</a> <a id="3957" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="3966" class="Symbol">)</a> <a id="3968" class="Keyword">public</a>

</pre>

As usual, we display `transport` in a hidden module and then imported the existing definition from [Type Topology][].<sup>[1](Preliminaries.Equality.html#fn1)</sup> See [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="4947" class="Keyword">module</a> <a id="hide-ap"></a><a id="4954" href="Prelude.Equality.html#4954" class="Module">hide-ap</a>  <a id="4963" class="Symbol">{</a><a id="4964" href="Prelude.Equality.html#4964" class="Bound">𝓤</a> <a id="4966" class="Symbol">:</a> <a id="4968" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="4976" class="Symbol">}</a> <a id="4978" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="4986" href="Prelude.Equality.html#4986" class="Function">ap</a> <a id="4989" class="Symbol">:</a> <a id="4991" class="Symbol">{</a><a id="4992" href="Prelude.Equality.html#4992" class="Bound">X</a> <a id="4994" class="Symbol">:</a> <a id="4996" href="Prelude.Equality.html#4964" class="Bound">𝓤</a> <a id="4998" href="Universes.html#403" class="Function Operator">̇</a><a id="4999" class="Symbol">}{</a><a id="5001" href="Prelude.Equality.html#5001" class="Bound">Y</a> <a id="5003" class="Symbol">:</a> <a id="5005" href="Universes.html#262" class="Generalizable">𝓥</a> <a id="5007" href="Universes.html#403" class="Function Operator">̇</a><a id="5008" class="Symbol">}(</a><a id="5010" href="Prelude.Equality.html#5010" class="Bound">f</a> <a id="5012" class="Symbol">:</a> <a id="5014" href="Prelude.Equality.html#4992" class="Bound">X</a> <a id="5016" class="Symbol">→</a> <a id="5018" href="Prelude.Equality.html#5001" class="Bound">Y</a><a id="5019" class="Symbol">){</a><a id="5021" href="Prelude.Equality.html#5021" class="Bound">a</a> <a id="5023" href="Prelude.Equality.html#5023" class="Bound">b</a> <a id="5025" class="Symbol">:</a> <a id="5027" href="Prelude.Equality.html#4992" class="Bound">X</a><a id="5028" class="Symbol">}</a> <a id="5030" class="Symbol">→</a> <a id="5032" href="Prelude.Equality.html#5021" class="Bound">a</a> <a id="5034" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="5036" href="Prelude.Equality.html#5023" class="Bound">b</a> <a id="5038" class="Symbol">→</a> <a id="5040" href="Prelude.Equality.html#5010" class="Bound">f</a> <a id="5042" href="Prelude.Equality.html#5021" class="Bound">a</a> <a id="5044" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="5046" href="Prelude.Equality.html#5010" class="Bound">f</a> <a id="5048" href="Prelude.Equality.html#5023" class="Bound">b</a>
 <a id="5051" href="Prelude.Equality.html#4986" class="Function">ap</a> <a id="5054" href="Prelude.Equality.html#5054" class="Bound">f</a> <a id="5056" class="Symbol">{</a><a id="5057" href="Prelude.Equality.html#5057" class="Bound">a</a><a id="5058" class="Symbol">}</a> <a id="5060" href="Prelude.Equality.html#5060" class="Bound">p</a> <a id="5062" class="Symbol">=</a> <a id="5064" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="5074" class="Symbol">(λ</a> <a id="5077" href="Prelude.Equality.html#5077" class="Bound">-</a> <a id="5079" class="Symbol">→</a> <a id="5081" href="Prelude.Equality.html#5054" class="Bound">f</a> <a id="5083" href="Prelude.Equality.html#5057" class="Bound">a</a> <a id="5085" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="5087" href="Prelude.Equality.html#5054" class="Bound">f</a> <a id="5089" href="Prelude.Equality.html#5077" class="Bound">-</a><a id="5090" class="Symbol">)</a> <a id="5092" href="Prelude.Equality.html#5060" class="Bound">p</a> <a id="5094" class="Symbol">(</a><a id="5095" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5100" class="Symbol">{</a><a id="5101" class="Argument">x</a> <a id="5103" class="Symbol">=</a> <a id="5105" href="Prelude.Equality.html#5054" class="Bound">f</a> <a id="5107" href="Prelude.Equality.html#5057" class="Bound">a</a><a id="5108" class="Symbol">})</a>

<a id="5112" class="Keyword">open</a> <a id="5117" class="Keyword">import</a> <a id="5124" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5133" class="Keyword">using</a> <a id="5139" class="Symbol">(</a><a id="5140" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="5142" class="Symbol">)</a> <a id="5144" class="Keyword">public</a>

</pre>

We now define some variations of `ap` that are sometimes useful.

<pre class="Agda">

<a id="5244" class="Keyword">module</a> <a id="5251" href="Prelude.Equality.html#5251" class="Module">_</a> <a id="5253" class="Symbol">{</a><a id="5254" href="Prelude.Equality.html#5254" class="Bound">𝓤</a> <a id="5256" href="Prelude.Equality.html#5256" class="Bound">𝓦</a> <a id="5258" class="Symbol">:</a> <a id="5260" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5268" class="Symbol">}</a> <a id="5270" class="Keyword">where</a>

 <a id="5278" href="Prelude.Equality.html#5278" class="Function">ap-cong</a> <a id="5286" class="Symbol">:</a> <a id="5288" class="Symbol">{</a><a id="5289" href="Prelude.Equality.html#5289" class="Bound">A</a> <a id="5291" class="Symbol">:</a> <a id="5293" href="Prelude.Equality.html#5254" class="Bound">𝓤</a> <a id="5295" href="Universes.html#403" class="Function Operator">̇</a><a id="5296" class="Symbol">}{</a><a id="5298" href="Prelude.Equality.html#5298" class="Bound">B</a> <a id="5300" class="Symbol">:</a> <a id="5302" href="Prelude.Equality.html#5256" class="Bound">𝓦</a> <a id="5304" href="Universes.html#403" class="Function Operator">̇</a><a id="5305" class="Symbol">}{</a><a id="5307" href="Prelude.Equality.html#5307" class="Bound">f</a> <a id="5309" href="Prelude.Equality.html#5309" class="Bound">g</a> <a id="5311" class="Symbol">:</a> <a id="5313" href="Prelude.Equality.html#5289" class="Bound">A</a> <a id="5315" class="Symbol">→</a> <a id="5317" href="Prelude.Equality.html#5298" class="Bound">B</a><a id="5318" class="Symbol">}{</a><a id="5320" href="Prelude.Equality.html#5320" class="Bound">a</a> <a id="5322" href="Prelude.Equality.html#5322" class="Bound">b</a> <a id="5324" class="Symbol">:</a> <a id="5326" href="Prelude.Equality.html#5289" class="Bound">A</a><a id="5327" class="Symbol">}</a> <a id="5329" class="Symbol">→</a> <a id="5331" href="Prelude.Equality.html#5307" class="Bound">f</a> <a id="5333" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="5335" href="Prelude.Equality.html#5309" class="Bound">g</a> <a id="5337" class="Symbol">→</a> <a id="5339" href="Prelude.Equality.html#5320" class="Bound">a</a> <a id="5341" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="5343" href="Prelude.Equality.html#5322" class="Bound">b</a> <a id="5345" class="Symbol">→</a> <a id="5347" href="Prelude.Equality.html#5307" class="Bound">f</a> <a id="5349" href="Prelude.Equality.html#5320" class="Bound">a</a> <a id="5351" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="5353" href="Prelude.Equality.html#5309" class="Bound">g</a> <a id="5355" href="Prelude.Equality.html#5322" class="Bound">b</a>
 <a id="5358" href="Prelude.Equality.html#5278" class="Function">ap-cong</a> <a id="5366" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5371" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5376" class="Symbol">=</a> <a id="5378" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

We sometimes need a version of this that works for [dependent types][], such as the following (which we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][], transcribed into MHE/UALib notation of course):

<pre class="Agda">

 <a id="5649" href="Prelude.Equality.html#5649" class="Function">cong-app</a> <a id="5658" class="Symbol">:</a> <a id="5660" class="Symbol">{</a><a id="5661" href="Prelude.Equality.html#5661" class="Bound">A</a> <a id="5663" class="Symbol">:</a> <a id="5665" href="Prelude.Equality.html#5254" class="Bound">𝓤</a> <a id="5667" href="Universes.html#403" class="Function Operator">̇</a><a id="5668" class="Symbol">}{</a><a id="5670" href="Prelude.Equality.html#5670" class="Bound">B</a> <a id="5672" class="Symbol">:</a> <a id="5674" href="Prelude.Equality.html#5661" class="Bound">A</a> <a id="5676" class="Symbol">→</a> <a id="5678" href="Prelude.Equality.html#5256" class="Bound">𝓦</a> <a id="5680" href="Universes.html#403" class="Function Operator">̇</a><a id="5681" class="Symbol">}{</a><a id="5683" href="Prelude.Equality.html#5683" class="Bound">f</a> <a id="5685" href="Prelude.Equality.html#5685" class="Bound">g</a> <a id="5687" class="Symbol">:</a> <a id="5689" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="5691" href="Prelude.Equality.html#5670" class="Bound">B</a><a id="5692" class="Symbol">}</a> <a id="5694" class="Symbol">→</a> <a id="5696" href="Prelude.Equality.html#5683" class="Bound">f</a> <a id="5698" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="5700" href="Prelude.Equality.html#5685" class="Bound">g</a> <a id="5702" class="Symbol">→</a> <a id="5704" class="Symbol">∀</a> <a id="5706" href="Prelude.Equality.html#5706" class="Bound">a</a> <a id="5708" class="Symbol">→</a> <a id="5710" href="Prelude.Equality.html#5683" class="Bound">f</a> <a id="5712" href="Prelude.Equality.html#5706" class="Bound">a</a> <a id="5714" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="5716" href="Prelude.Equality.html#5685" class="Bound">g</a> <a id="5718" href="Prelude.Equality.html#5706" class="Bound">a</a>
 <a id="5721" href="Prelude.Equality.html#5649" class="Function">cong-app</a> <a id="5730" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5735" class="Symbol">_</a> <a id="5737" class="Symbol">=</a> <a id="5739" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>




#### <a id="≡-intro-and-≡-elim-for-nondependent-pairs">≡-intro and ≡-elim for nondependent pairs</a>

We conclude the Equality module with some occasionally useful introduction and elimination rules for the equality relation on (nondependent) pair types.


<pre class="Agda">

 <a id="6032" href="Prelude.Equality.html#6032" class="Function">≡-elim-left</a> <a id="6044" class="Symbol">:</a> <a id="6046" class="Symbol">{</a><a id="6047" href="Prelude.Equality.html#6047" class="Bound">A₁</a> <a id="6050" href="Prelude.Equality.html#6050" class="Bound">A₂</a> <a id="6053" class="Symbol">:</a> <a id="6055" href="Prelude.Equality.html#5254" class="Bound">𝓤</a> <a id="6057" href="Universes.html#403" class="Function Operator">̇</a><a id="6058" class="Symbol">}{</a><a id="6060" href="Prelude.Equality.html#6060" class="Bound">B₁</a> <a id="6063" href="Prelude.Equality.html#6063" class="Bound">B₂</a> <a id="6066" class="Symbol">:</a> <a id="6068" href="Prelude.Equality.html#5256" class="Bound">𝓦</a> <a id="6070" href="Universes.html#403" class="Function Operator">̇</a><a id="6071" class="Symbol">}</a> <a id="6073" class="Symbol">→</a> <a id="6075" class="Symbol">(</a><a id="6076" href="Prelude.Equality.html#6047" class="Bound">A₁</a> <a id="6079" href="Prelude.Preliminaries.html#10361" class="InductiveConstructor Operator">,</a> <a id="6081" href="Prelude.Equality.html#6060" class="Bound">B₁</a><a id="6083" class="Symbol">)</a> <a id="6085" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6087" class="Symbol">(</a><a id="6088" href="Prelude.Equality.html#6050" class="Bound">A₂</a> <a id="6091" href="Prelude.Preliminaries.html#10361" class="InductiveConstructor Operator">,</a> <a id="6093" href="Prelude.Equality.html#6063" class="Bound">B₂</a><a id="6095" class="Symbol">)</a> <a id="6097" class="Symbol">→</a> <a id="6099" href="Prelude.Equality.html#6047" class="Bound">A₁</a> <a id="6102" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6104" href="Prelude.Equality.html#6050" class="Bound">A₂</a>
 <a id="6108" href="Prelude.Equality.html#6032" class="Function">≡-elim-left</a> <a id="6120" href="Prelude.Equality.html#6120" class="Bound">e</a> <a id="6122" class="Symbol">=</a> <a id="6124" href="MGS-MLTT.html#6613" class="Function">ap</a> <a id="6127" href="Prelude.Preliminaries.html#10860" class="Function">fst</a> <a id="6131" href="Prelude.Equality.html#6120" class="Bound">e</a>


 <a id="6136" href="Prelude.Equality.html#6136" class="Function">≡-elim-right</a> <a id="6149" class="Symbol">:</a> <a id="6151" class="Symbol">{</a><a id="6152" href="Prelude.Equality.html#6152" class="Bound">A₁</a> <a id="6155" href="Prelude.Equality.html#6155" class="Bound">A₂</a> <a id="6158" class="Symbol">:</a> <a id="6160" href="Prelude.Equality.html#5254" class="Bound">𝓤</a> <a id="6162" href="Universes.html#403" class="Function Operator">̇</a><a id="6163" class="Symbol">}{</a><a id="6165" href="Prelude.Equality.html#6165" class="Bound">B₁</a> <a id="6168" href="Prelude.Equality.html#6168" class="Bound">B₂</a> <a id="6171" class="Symbol">:</a> <a id="6173" href="Prelude.Equality.html#5256" class="Bound">𝓦</a> <a id="6175" href="Universes.html#403" class="Function Operator">̇</a><a id="6176" class="Symbol">}</a> <a id="6178" class="Symbol">→</a> <a id="6180" class="Symbol">(</a><a id="6181" href="Prelude.Equality.html#6152" class="Bound">A₁</a> <a id="6184" href="Prelude.Preliminaries.html#10361" class="InductiveConstructor Operator">,</a> <a id="6186" href="Prelude.Equality.html#6165" class="Bound">B₁</a><a id="6188" class="Symbol">)</a> <a id="6190" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6192" class="Symbol">(</a><a id="6193" href="Prelude.Equality.html#6155" class="Bound">A₂</a> <a id="6196" href="Prelude.Preliminaries.html#10361" class="InductiveConstructor Operator">,</a> <a id="6198" href="Prelude.Equality.html#6168" class="Bound">B₂</a><a id="6200" class="Symbol">)</a> <a id="6202" class="Symbol">→</a> <a id="6204" href="Prelude.Equality.html#6165" class="Bound">B₁</a> <a id="6207" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6209" href="Prelude.Equality.html#6168" class="Bound">B₂</a>
 <a id="6213" href="Prelude.Equality.html#6136" class="Function">≡-elim-right</a> <a id="6226" href="Prelude.Equality.html#6226" class="Bound">e</a> <a id="6228" class="Symbol">=</a> <a id="6230" href="MGS-MLTT.html#6613" class="Function">ap</a> <a id="6233" href="Prelude.Preliminaries.html#10938" class="Function">snd</a> <a id="6237" href="Prelude.Equality.html#6226" class="Bound">e</a>


 <a id="6242" href="Prelude.Equality.html#6242" class="Function">≡-×-intro</a> <a id="6252" class="Symbol">:</a> <a id="6254" class="Symbol">{</a><a id="6255" href="Prelude.Equality.html#6255" class="Bound">A₁</a> <a id="6258" href="Prelude.Equality.html#6258" class="Bound">A₂</a> <a id="6261" class="Symbol">:</a> <a id="6263" href="Prelude.Equality.html#5254" class="Bound">𝓤</a> <a id="6265" href="Universes.html#403" class="Function Operator">̇</a><a id="6266" class="Symbol">}</a> <a id="6268" class="Symbol">{</a><a id="6269" href="Prelude.Equality.html#6269" class="Bound">B₁</a> <a id="6272" href="Prelude.Equality.html#6272" class="Bound">B₂</a> <a id="6275" class="Symbol">:</a> <a id="6277" href="Prelude.Equality.html#5256" class="Bound">𝓦</a> <a id="6279" href="Universes.html#403" class="Function Operator">̇</a><a id="6280" class="Symbol">}</a> <a id="6282" class="Symbol">→</a> <a id="6284" href="Prelude.Equality.html#6255" class="Bound">A₁</a> <a id="6287" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6289" href="Prelude.Equality.html#6258" class="Bound">A₂</a> <a id="6292" class="Symbol">→</a> <a id="6294" href="Prelude.Equality.html#6269" class="Bound">B₁</a> <a id="6297" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6299" href="Prelude.Equality.html#6272" class="Bound">B₂</a> <a id="6302" class="Symbol">→</a> <a id="6304" class="Symbol">(</a><a id="6305" href="Prelude.Equality.html#6255" class="Bound">A₁</a> <a id="6308" href="Prelude.Preliminaries.html#10361" class="InductiveConstructor Operator">,</a> <a id="6310" href="Prelude.Equality.html#6269" class="Bound">B₁</a><a id="6312" class="Symbol">)</a> <a id="6314" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6316" class="Symbol">(</a><a id="6317" href="Prelude.Equality.html#6258" class="Bound">A₂</a> <a id="6320" href="Prelude.Preliminaries.html#10361" class="InductiveConstructor Operator">,</a> <a id="6322" href="Prelude.Equality.html#6272" class="Bound">B₂</a><a id="6324" class="Symbol">)</a>
 <a id="6327" href="Prelude.Equality.html#6242" class="Function">≡-×-intro</a> <a id="6337" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6342" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6347" class="Symbol">=</a> <a id="6349" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>


 <a id="6357" href="Prelude.Equality.html#6357" class="Function">≡-×-int</a> <a id="6365" class="Symbol">:</a> <a id="6367" class="Symbol">{</a><a id="6368" href="Prelude.Equality.html#6368" class="Bound">A</a> <a id="6370" class="Symbol">:</a> <a id="6372" href="Prelude.Equality.html#5254" class="Bound">𝓤</a> <a id="6374" href="Universes.html#403" class="Function Operator">̇</a><a id="6375" class="Symbol">}{</a><a id="6377" href="Prelude.Equality.html#6377" class="Bound">B</a> <a id="6379" class="Symbol">:</a> <a id="6381" href="Prelude.Equality.html#5256" class="Bound">𝓦</a> <a id="6383" href="Universes.html#403" class="Function Operator">̇</a><a id="6384" class="Symbol">}{</a><a id="6386" href="Prelude.Equality.html#6386" class="Bound">a</a> <a id="6388" href="Prelude.Equality.html#6388" class="Bound">x</a> <a id="6390" class="Symbol">:</a> <a id="6392" href="Prelude.Equality.html#6368" class="Bound">A</a><a id="6393" class="Symbol">}{</a><a id="6395" href="Prelude.Equality.html#6395" class="Bound">b</a> <a id="6397" href="Prelude.Equality.html#6397" class="Bound">y</a> <a id="6399" class="Symbol">:</a> <a id="6401" href="Prelude.Equality.html#6377" class="Bound">B</a><a id="6402" class="Symbol">}</a> <a id="6404" class="Symbol">→</a> <a id="6406" href="Prelude.Equality.html#6386" class="Bound">a</a> <a id="6408" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6410" href="Prelude.Equality.html#6388" class="Bound">x</a> <a id="6412" class="Symbol">→</a> <a id="6414" href="Prelude.Equality.html#6395" class="Bound">b</a> <a id="6416" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6418" href="Prelude.Equality.html#6397" class="Bound">y</a> <a id="6420" class="Symbol">→</a> <a id="6422" class="Symbol">(</a><a id="6423" href="Prelude.Equality.html#6386" class="Bound">a</a> <a id="6425" href="Prelude.Preliminaries.html#10361" class="InductiveConstructor Operator">,</a> <a id="6427" href="Prelude.Equality.html#6395" class="Bound">b</a><a id="6428" class="Symbol">)</a> <a id="6430" href="Prelude.Equality.html#1364" class="Datatype Operator">≡</a> <a id="6432" class="Symbol">(</a><a id="6433" href="Prelude.Equality.html#6388" class="Bound">x</a> <a id="6435" href="Prelude.Preliminaries.html#10361" class="InductiveConstructor Operator">,</a> <a id="6437" href="Prelude.Equality.html#6397" class="Bound">y</a><a id="6438" class="Symbol">)</a>
 <a id="6441" href="Prelude.Equality.html#6357" class="Function">≡-×-int</a> <a id="6449" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6454" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6459" class="Symbol">=</a> <a id="6461" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>
</pre>

-------------------------------------


<sup>1</sup><span class="footnote" id="fn1"> **Unicode Hints**. In [agda2-mode][] type `⁻¹` as `\^-\^1`, type `𝑖𝑑` as `\Mii\Mid`, and type `∙` as `\.`. In general, to get information about a given unicode character (e.g., how to type it) place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>

<sup>2</sup><span class="footnote" id="fn2"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170).

<p></p>
<p></p>


[← Prelude.Preliminaries ](Prelude.Preliminaries.html)
<span style="float:right;">[Prelude.Extensionality →](Prelude.Extensionality.html)</span>

{% include UALib.Links.md %}
