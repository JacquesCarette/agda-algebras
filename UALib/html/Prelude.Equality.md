---
layout: default
title : UALib.Prelude.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This is the [UALib.Prelude.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="276" class="Symbol">{-#</a> <a id="280" class="Keyword">OPTIONS</a> <a id="288" class="Pragma">--without-K</a> <a id="300" class="Pragma">--exact-split</a> <a id="314" class="Pragma">--safe</a> <a id="321" class="Symbol">#-}</a>

<a id="326" class="Keyword">module</a> <a id="333" href="Prelude.Equality.html" class="Module">Prelude.Equality</a> <a id="350" class="Keyword">where</a>

<a id="357" class="Keyword">open</a> <a id="362" class="Keyword">import</a> <a id="369" href="Prelude.Preliminaries.html" class="Module">Prelude.Preliminaries</a> <a id="391" class="Keyword">public</a>

</pre>

#### <a id="definitional-equality">Definitional equality</a>

Here we discuss what is probably the most important type in [MLTT][]. It is called *definitional equality*. This concept is easily understood, at least heuristically, with the following slogan:

*Definitional equality is the substitution-preserving equivalence relation generated by definitions.*

We will make this precise below, but first let us quote from a primary source.

In [An Intuitionistic Theory of Types: Predicative Part](https://www.sciencedirect.com/science/article/pii/S0049237X08719451), Per Martin-Löof offers the following definition (italics added):<sup>[1](Prelude.Equality.html#fn1)</sup>

"*Definitional equality* is defined to be the equivalence relation, that is, reflexive, symmetric and transitive relation, which is generated by the principles that a definiendum is always definitionally equal to its definiens and that definitional equality is preserved under substitution."<sup>[2](Prelude.Equality.html#fn2)

To be sure we understand what this means, let `:=` denote the relation with respect to which `x` is related to `y` (denoted `x := y`) if and only if `y` *is the definition of* `x`.  Then the definitional equality relation `≡` is the reflexive, symmetric, transitive, substitutive closure of `:=`. By *subsitutive closure* we mean closure under the following *substitution rule*.

<!--
\begin{prooftree}
\AxiomC{`\{A : 𝓤 ̇\}\{B : A → 𝓦 ̇\}\{x y : A\}`}
\AxiomC{`x ≡ y`}
\Rightlabel{(subst)}
\BinaryInfC{`B x ≡ B y`}
\end{prooftree}
-->

```agda
    {A : 𝓤 ̇} {B : A → 𝓦 ̇} {x y : A}   x ≡ y
    ------------------------------------------
                B x ≡ B y
```

The datatype we use to represent definitional equality is imported from the Identity-Type module of the [Type Topology][] library, but apart from superficial syntactic differences, it is equivalent to the identity type used in all other Agda libraries we know of.  We repeat the definition here for easy reference.

<pre class="Agda">

<a id="2411" class="Keyword">module</a> <a id="hide-refl"></a><a id="2418" href="Prelude.Equality.html#2418" class="Module">hide-refl</a> <a id="2428" class="Symbol">{</a><a id="2429" href="Prelude.Equality.html#2429" class="Bound">𝓤</a> <a id="2431" class="Symbol">:</a> <a id="2433" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2441" class="Symbol">}</a> <a id="2443" class="Keyword">where</a>

 <a id="2451" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="2456" href="Prelude.Equality.html#2456" class="Datatype Operator">_≡_</a> <a id="2460" class="Symbol">{</a><a id="2461" href="Prelude.Equality.html#2461" class="Bound">𝓤</a><a id="2462" class="Symbol">}</a> <a id="2464" class="Symbol">{</a><a id="2465" href="Prelude.Equality.html#2465" class="Bound">A</a> <a id="2467" class="Symbol">:</a> <a id="2469" href="Prelude.Equality.html#2461" class="Bound">𝓤</a> <a id="2471" href="Universes.html#403" class="Function Operator">̇</a> <a id="2473" class="Symbol">}</a> <a id="2475" class="Symbol">:</a> <a id="2477" href="Prelude.Equality.html#2465" class="Bound">A</a> <a id="2479" class="Symbol">→</a> <a id="2481" href="Prelude.Equality.html#2465" class="Bound">A</a> <a id="2483" class="Symbol">→</a> <a id="2485" href="Prelude.Equality.html#2461" class="Bound">𝓤</a> <a id="2487" href="Universes.html#403" class="Function Operator">̇</a> <a id="2489" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="2495" href="Prelude.Equality.html#2495" class="InductiveConstructor">refl</a> <a id="2500" class="Symbol">:</a> <a id="2502" class="Symbol">{</a><a id="2503" href="Prelude.Equality.html#2503" class="Bound">x</a> <a id="2505" class="Symbol">:</a> <a id="2507" href="Prelude.Equality.html#2465" class="Bound">A</a><a id="2508" class="Symbol">}</a> <a id="2510" class="Symbol">→</a> <a id="2512" href="Prelude.Equality.html#2503" class="Bound">x</a> <a id="2514" href="Prelude.Equality.html#2456" class="Datatype Operator">≡</a> <a id="2516" href="Prelude.Equality.html#2503" class="Bound">x</a>

<a id="2519" class="Keyword">open</a> <a id="2524" class="Keyword">import</a> <a id="2531" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="2545" class="Keyword">renaming</a> <a id="2554" class="Symbol">(</a><a id="2555" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="2559" class="Symbol">to</a> <a id="2562" class="Keyword">infix</a> <a id="2568" class="Number">0</a> <a id="_≡_"></a><a id="2570" href="Prelude.Equality.html#2570" class="Datatype Operator">_≡_</a><a id="2573" class="Symbol">)</a> <a id="2575" class="Keyword">public</a>

</pre>

Whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we invoke `refl`.  If we need to make explicit the implicit argument `x`, then we use `refl {x = x}`.

Of course `≡` is an equivalence relation and the formal proof of this fact is trivial. We don't need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

<pre class="Agda">

<a id="3046" class="Keyword">module</a> <a id="3053" href="Prelude.Equality.html#3053" class="Module">_</a>  <a id="3056" class="Symbol">{</a><a id="3057" href="Prelude.Equality.html#3057" class="Bound">𝓤</a> <a id="3059" class="Symbol">:</a> <a id="3061" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3069" class="Symbol">}{</a><a id="3071" href="Prelude.Equality.html#3071" class="Bound">A</a> <a id="3073" class="Symbol">:</a> <a id="3075" href="Prelude.Equality.html#3057" class="Bound">𝓤</a> <a id="3077" href="Universes.html#403" class="Function Operator">̇</a> <a id="3079" class="Symbol">}</a>  <a id="3082" class="Keyword">where</a>

 <a id="3090" href="Prelude.Equality.html#3090" class="Function">≡-symmetric</a> <a id="3102" class="Symbol">:</a> <a id="3104" class="Symbol">(</a><a id="3105" href="Prelude.Equality.html#3105" class="Bound">x</a> <a id="3107" href="Prelude.Equality.html#3107" class="Bound">y</a> <a id="3109" class="Symbol">:</a> <a id="3111" href="Prelude.Equality.html#3071" class="Bound">A</a><a id="3112" class="Symbol">)</a> <a id="3114" class="Symbol">→</a> <a id="3116" href="Prelude.Equality.html#3105" class="Bound">x</a> <a id="3118" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3120" href="Prelude.Equality.html#3107" class="Bound">y</a> <a id="3122" class="Symbol">→</a> <a id="3124" href="Prelude.Equality.html#3107" class="Bound">y</a> <a id="3126" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3128" href="Prelude.Equality.html#3105" class="Bound">x</a>
 <a id="3131" href="Prelude.Equality.html#3090" class="Function">≡-symmetric</a> <a id="3143" class="Symbol">_</a> <a id="3145" class="Symbol">_</a> <a id="3147" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3152" class="Symbol">=</a> <a id="3154" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3161" href="Prelude.Equality.html#3161" class="Function">≡-sym</a> <a id="3167" class="Symbol">:</a> <a id="3169" class="Symbol">{</a><a id="3170" href="Prelude.Equality.html#3170" class="Bound">x</a> <a id="3172" href="Prelude.Equality.html#3172" class="Bound">y</a> <a id="3174" class="Symbol">:</a> <a id="3176" href="Prelude.Equality.html#3071" class="Bound">A</a><a id="3177" class="Symbol">}</a> <a id="3179" class="Symbol">→</a> <a id="3181" href="Prelude.Equality.html#3170" class="Bound">x</a> <a id="3183" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3185" href="Prelude.Equality.html#3172" class="Bound">y</a> <a id="3187" class="Symbol">→</a> <a id="3189" href="Prelude.Equality.html#3172" class="Bound">y</a> <a id="3191" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3193" href="Prelude.Equality.html#3170" class="Bound">x</a>
 <a id="3196" href="Prelude.Equality.html#3161" class="Function">≡-sym</a> <a id="3202" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3207" class="Symbol">=</a> <a id="3209" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3216" href="Prelude.Equality.html#3216" class="Function">≡-transitive</a> <a id="3229" class="Symbol">:</a> <a id="3231" class="Symbol">(</a><a id="3232" href="Prelude.Equality.html#3232" class="Bound">x</a> <a id="3234" href="Prelude.Equality.html#3234" class="Bound">y</a> <a id="3236" href="Prelude.Equality.html#3236" class="Bound">z</a> <a id="3238" class="Symbol">:</a> <a id="3240" href="Prelude.Equality.html#3071" class="Bound">A</a><a id="3241" class="Symbol">)</a> <a id="3243" class="Symbol">→</a> <a id="3245" href="Prelude.Equality.html#3232" class="Bound">x</a> <a id="3247" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3249" href="Prelude.Equality.html#3234" class="Bound">y</a> <a id="3251" class="Symbol">→</a> <a id="3253" href="Prelude.Equality.html#3234" class="Bound">y</a> <a id="3255" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3257" href="Prelude.Equality.html#3236" class="Bound">z</a> <a id="3259" class="Symbol">→</a> <a id="3261" href="Prelude.Equality.html#3232" class="Bound">x</a> <a id="3263" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3265" href="Prelude.Equality.html#3236" class="Bound">z</a>
 <a id="3268" href="Prelude.Equality.html#3216" class="Function">≡-transitive</a> <a id="3281" class="Symbol">_</a> <a id="3283" class="Symbol">_</a> <a id="3285" class="Symbol">_</a> <a id="3287" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3292" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3297" class="Symbol">=</a> <a id="3299" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3306" href="Prelude.Equality.html#3306" class="Function">≡-trans</a> <a id="3314" class="Symbol">:</a> <a id="3316" class="Symbol">{</a><a id="3317" href="Prelude.Equality.html#3317" class="Bound">x</a> <a id="3319" href="Prelude.Equality.html#3319" class="Bound">y</a> <a id="3321" href="Prelude.Equality.html#3321" class="Bound">z</a> <a id="3323" class="Symbol">:</a> <a id="3325" href="Prelude.Equality.html#3071" class="Bound">A</a><a id="3326" class="Symbol">}</a> <a id="3328" class="Symbol">→</a> <a id="3330" href="Prelude.Equality.html#3317" class="Bound">x</a> <a id="3332" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3334" href="Prelude.Equality.html#3319" class="Bound">y</a> <a id="3336" class="Symbol">→</a> <a id="3338" href="Prelude.Equality.html#3319" class="Bound">y</a> <a id="3340" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3342" href="Prelude.Equality.html#3321" class="Bound">z</a> <a id="3344" class="Symbol">→</a> <a id="3346" href="Prelude.Equality.html#3317" class="Bound">x</a> <a id="3348" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3350" href="Prelude.Equality.html#3321" class="Bound">z</a>
 <a id="3353" href="Prelude.Equality.html#3306" class="Function">≡-trans</a> <a id="3361" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3366" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3371" class="Symbol">=</a> <a id="3373" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

The only difference between `≡-symmetric` and `≡-sym` (respectively, `≡-transitive` and `≡-trans`) is that the latter has fewer explicit arguments, which is sometimes convenient.

We prove that `≡` obeys the substitution rule (subst) in the next subsection (see the definition of `ap` below), but first we define some syntactic sugar that will make it easier to apply symmetry and transitivity of `≡` in proofs.<sup>[3](Prelude.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="3859" class="Keyword">module</a> <a id="hide-sym-trans"></a><a id="3866" href="Prelude.Equality.html#3866" class="Module">hide-sym-trans</a> <a id="3881" class="Symbol">{</a><a id="3882" href="Prelude.Equality.html#3882" class="Bound">𝓤</a> <a id="3884" class="Symbol">:</a> <a id="3886" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3894" class="Symbol">}</a> <a id="3896" class="Symbol">{</a><a id="3897" href="Prelude.Equality.html#3897" class="Bound">A</a> <a id="3899" class="Symbol">:</a> <a id="3901" href="Prelude.Equality.html#3882" class="Bound">𝓤</a> <a id="3903" href="Universes.html#403" class="Function Operator">̇</a> <a id="3905" class="Symbol">}</a> <a id="3907" class="Keyword">where</a>

 <a id="hide-sym-trans._⁻¹"></a><a id="3915" href="Prelude.Equality.html#3915" class="Function Operator">_⁻¹</a> <a id="3919" class="Symbol">:</a> <a id="3921" class="Symbol">{</a><a id="3922" href="Prelude.Equality.html#3922" class="Bound">x</a> <a id="3924" href="Prelude.Equality.html#3924" class="Bound">y</a> <a id="3926" class="Symbol">:</a> <a id="3928" href="Prelude.Equality.html#3897" class="Bound">A</a><a id="3929" class="Symbol">}</a> <a id="3931" class="Symbol">→</a> <a id="3933" href="Prelude.Equality.html#3922" class="Bound">x</a> <a id="3935" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3937" href="Prelude.Equality.html#3924" class="Bound">y</a> <a id="3939" class="Symbol">→</a> <a id="3941" href="Prelude.Equality.html#3924" class="Bound">y</a> <a id="3943" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="3945" href="Prelude.Equality.html#3922" class="Bound">x</a>
 <a id="3948" href="Prelude.Equality.html#3948" class="Bound">p</a> <a id="3950" href="Prelude.Equality.html#3915" class="Function Operator">⁻¹</a> <a id="3953" class="Symbol">=</a> <a id="3955" href="Prelude.Equality.html#3161" class="Function">≡-sym</a> <a id="3961" href="Prelude.Equality.html#3948" class="Bound">p</a>

</pre>

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` . Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.

<pre class="Agda">

 <a id="hide-sym-trans._∙_"></a><a id="4220" href="Prelude.Equality.html#4220" class="Function Operator">_∙_</a> <a id="4224" class="Symbol">:</a> <a id="4226" class="Symbol">{</a><a id="4227" href="Prelude.Equality.html#4227" class="Bound">x</a> <a id="4229" href="Prelude.Equality.html#4229" class="Bound">y</a> <a id="4231" href="Prelude.Equality.html#4231" class="Bound">z</a> <a id="4233" class="Symbol">:</a> <a id="4235" href="Prelude.Equality.html#3897" class="Bound">A</a><a id="4236" class="Symbol">}</a> <a id="4238" class="Symbol">→</a> <a id="4240" href="Prelude.Equality.html#4227" class="Bound">x</a> <a id="4242" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="4244" href="Prelude.Equality.html#4229" class="Bound">y</a> <a id="4246" class="Symbol">→</a> <a id="4248" href="Prelude.Equality.html#4229" class="Bound">y</a> <a id="4250" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="4252" href="Prelude.Equality.html#4231" class="Bound">z</a> <a id="4254" class="Symbol">→</a> <a id="4256" href="Prelude.Equality.html#4227" class="Bound">x</a> <a id="4258" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="4260" href="Prelude.Equality.html#4231" class="Bound">z</a>
 <a id="4263" href="Prelude.Equality.html#4263" class="Bound">p</a> <a id="4265" href="Prelude.Equality.html#4220" class="Function Operator">∙</a> <a id="4267" href="Prelude.Equality.html#4267" class="Bound">q</a> <a id="4269" class="Symbol">=</a> <a id="4271" href="Prelude.Equality.html#3306" class="Function">≡-trans</a> <a id="4279" href="Prelude.Equality.html#4263" class="Bound">p</a> <a id="4281" href="Prelude.Equality.html#4267" class="Bound">q</a>

</pre>

As usual, we import the original definitions from the [Type Topology][] library.

<pre class="Agda">

<a id="4392" class="Keyword">open</a> <a id="4397" class="Keyword">import</a> <a id="4404" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="4413" class="Keyword">using</a> <a id="4419" class="Symbol">(</a><a id="4420" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="4423" class="Symbol">;</a> <a id="4425" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="4428" class="Symbol">)</a> <a id="4430" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Prelude.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[2](Preliminaries.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="5123" class="Keyword">module</a> <a id="hide-id-transport"></a><a id="5130" href="Prelude.Equality.html#5130" class="Module">hide-id-transport</a> <a id="5148" class="Symbol">{</a><a id="5149" href="Prelude.Equality.html#5149" class="Bound">𝓤</a> <a id="5151" href="Prelude.Equality.html#5151" class="Bound">𝓦</a> <a id="5153" class="Symbol">:</a> <a id="5155" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5163" class="Symbol">}</a> <a id="5165" class="Keyword">where</a>

 <a id="hide-id-transport.𝑖𝑑"></a><a id="5173" href="Prelude.Equality.html#5173" class="Function">𝑖𝑑</a> <a id="5176" class="Symbol">:</a> <a id="5178" class="Symbol">{</a><a id="5179" href="Prelude.Equality.html#5179" class="Bound">𝓤</a> <a id="5181" class="Symbol">:</a> <a id="5183" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5191" class="Symbol">}</a> <a id="5193" class="Symbol">(</a><a id="5194" href="Prelude.Equality.html#5194" class="Bound">A</a> <a id="5196" class="Symbol">:</a> <a id="5198" href="Prelude.Equality.html#5179" class="Bound">𝓤</a> <a id="5200" href="Universes.html#403" class="Function Operator">̇</a> <a id="5202" class="Symbol">)</a> <a id="5204" class="Symbol">→</a> <a id="5206" href="Prelude.Equality.html#5194" class="Bound">A</a> <a id="5208" class="Symbol">→</a> <a id="5210" href="Prelude.Equality.html#5194" class="Bound">A</a>
 <a id="5213" href="Prelude.Equality.html#5173" class="Function">𝑖𝑑</a> <a id="5216" href="Prelude.Equality.html#5216" class="Bound">A</a> <a id="5218" class="Symbol">=</a> <a id="5220" class="Symbol">λ</a> <a id="5222" href="Prelude.Equality.html#5222" class="Bound">x</a> <a id="5224" class="Symbol">→</a> <a id="5226" href="Prelude.Equality.html#5222" class="Bound">x</a>

 <a id="hide-id-transport.transport"></a><a id="5230" href="Prelude.Equality.html#5230" class="Function">transport</a> <a id="5240" class="Symbol">:</a> <a id="5242" class="Symbol">{</a><a id="5243" href="Prelude.Equality.html#5243" class="Bound">A</a> <a id="5245" class="Symbol">:</a> <a id="5247" href="Prelude.Equality.html#5149" class="Bound">𝓤</a> <a id="5249" href="Universes.html#403" class="Function Operator">̇</a> <a id="5251" class="Symbol">}</a> <a id="5253" class="Symbol">(</a><a id="5254" href="Prelude.Equality.html#5254" class="Bound">B</a> <a id="5256" class="Symbol">:</a> <a id="5258" href="Prelude.Equality.html#5243" class="Bound">A</a> <a id="5260" class="Symbol">→</a> <a id="5262" href="Prelude.Equality.html#5151" class="Bound">𝓦</a> <a id="5264" href="Universes.html#403" class="Function Operator">̇</a> <a id="5266" class="Symbol">)</a> <a id="5268" class="Symbol">{</a><a id="5269" href="Prelude.Equality.html#5269" class="Bound">x</a> <a id="5271" href="Prelude.Equality.html#5271" class="Bound">y</a> <a id="5273" class="Symbol">:</a> <a id="5275" href="Prelude.Equality.html#5243" class="Bound">A</a><a id="5276" class="Symbol">}</a> <a id="5278" class="Symbol">→</a> <a id="5280" href="Prelude.Equality.html#5269" class="Bound">x</a> <a id="5282" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="5284" href="Prelude.Equality.html#5271" class="Bound">y</a> <a id="5286" class="Symbol">→</a> <a id="5288" href="Prelude.Equality.html#5254" class="Bound">B</a> <a id="5290" href="Prelude.Equality.html#5269" class="Bound">x</a> <a id="5292" class="Symbol">→</a> <a id="5294" href="Prelude.Equality.html#5254" class="Bound">B</a> <a id="5296" href="Prelude.Equality.html#5271" class="Bound">y</a>
 <a id="5299" href="Prelude.Equality.html#5230" class="Function">transport</a> <a id="5309" href="Prelude.Equality.html#5309" class="Bound">B</a> <a id="5311" class="Symbol">(</a><a id="5312" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5317" class="Symbol">{</a><a id="5318" class="Argument">x</a> <a id="5320" class="Symbol">=</a> <a id="5322" href="Prelude.Equality.html#5322" class="Bound">x</a><a id="5323" class="Symbol">})</a> <a id="5326" class="Symbol">=</a> <a id="5328" href="Prelude.Equality.html#5173" class="Function">𝑖𝑑</a> <a id="5331" class="Symbol">(</a><a id="5332" href="Prelude.Equality.html#5309" class="Bound">B</a> <a id="5334" href="Prelude.Equality.html#5322" class="Bound">x</a><a id="5335" class="Symbol">)</a>

<a id="5338" class="Keyword">open</a> <a id="5343" class="Keyword">import</a> <a id="5350" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5359" class="Keyword">using</a> <a id="5365" class="Symbol">(</a><a id="5366" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="5368" class="Symbol">;</a> <a id="5370" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="5379" class="Symbol">)</a> <a id="5381" class="Keyword">public</a>

</pre>

As usual, we display definitions of existing types (here, `𝑖𝑑` and `transport`) in a hidden module and then imported their original definition from [Type Topology][].

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="6013" class="Keyword">module</a> <a id="hide-ap"></a><a id="6020" href="Prelude.Equality.html#6020" class="Module">hide-ap</a>  <a id="6029" class="Symbol">{</a><a id="6030" href="Prelude.Equality.html#6030" class="Bound">𝓤</a> <a id="6032" href="Prelude.Equality.html#6032" class="Bound">𝓦</a> <a id="6034" class="Symbol">:</a> <a id="6036" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6044" class="Symbol">}</a> <a id="6046" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="6054" href="Prelude.Equality.html#6054" class="Function">ap</a> <a id="6057" class="Symbol">:</a> <a id="6059" class="Symbol">{</a><a id="6060" href="Prelude.Equality.html#6060" class="Bound">A</a> <a id="6062" class="Symbol">:</a> <a id="6064" href="Prelude.Equality.html#6030" class="Bound">𝓤</a> <a id="6066" href="Universes.html#403" class="Function Operator">̇</a><a id="6067" class="Symbol">}{</a><a id="6069" href="Prelude.Equality.html#6069" class="Bound">B</a> <a id="6071" class="Symbol">:</a> <a id="6073" href="Prelude.Equality.html#6032" class="Bound">𝓦</a> <a id="6075" href="Universes.html#403" class="Function Operator">̇</a><a id="6076" class="Symbol">}(</a><a id="6078" href="Prelude.Equality.html#6078" class="Bound">f</a> <a id="6080" class="Symbol">:</a> <a id="6082" href="Prelude.Equality.html#6060" class="Bound">A</a> <a id="6084" class="Symbol">→</a> <a id="6086" href="Prelude.Equality.html#6069" class="Bound">B</a><a id="6087" class="Symbol">){</a><a id="6089" href="Prelude.Equality.html#6089" class="Bound">x</a> <a id="6091" href="Prelude.Equality.html#6091" class="Bound">y</a> <a id="6093" class="Symbol">:</a> <a id="6095" href="Prelude.Equality.html#6060" class="Bound">A</a><a id="6096" class="Symbol">}</a> <a id="6098" class="Symbol">→</a> <a id="6100" href="Prelude.Equality.html#6089" class="Bound">x</a> <a id="6102" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="6104" href="Prelude.Equality.html#6091" class="Bound">y</a> <a id="6106" class="Symbol">→</a> <a id="6108" href="Prelude.Equality.html#6078" class="Bound">f</a> <a id="6110" href="Prelude.Equality.html#6089" class="Bound">x</a> <a id="6112" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="6114" href="Prelude.Equality.html#6078" class="Bound">f</a> <a id="6116" href="Prelude.Equality.html#6091" class="Bound">y</a>
 <a id="6119" href="Prelude.Equality.html#6054" class="Function">ap</a> <a id="6122" href="Prelude.Equality.html#6122" class="Bound">f</a> <a id="6124" class="Symbol">{</a><a id="6125" href="Prelude.Equality.html#6125" class="Bound">x</a><a id="6126" class="Symbol">}</a> <a id="6128" href="Prelude.Equality.html#6128" class="Bound">p</a> <a id="6130" class="Symbol">=</a> <a id="6132" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="6142" class="Symbol">(λ</a> <a id="6145" href="Prelude.Equality.html#6145" class="Bound">-</a> <a id="6147" class="Symbol">→</a> <a id="6149" href="Prelude.Equality.html#6122" class="Bound">f</a> <a id="6151" href="Prelude.Equality.html#6125" class="Bound">x</a> <a id="6153" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="6155" href="Prelude.Equality.html#6122" class="Bound">f</a> <a id="6157" href="Prelude.Equality.html#6145" class="Bound">-</a><a id="6158" class="Symbol">)</a> <a id="6160" href="Prelude.Equality.html#6128" class="Bound">p</a> <a id="6162" class="Symbol">(</a><a id="6163" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6168" class="Symbol">{</a><a id="6169" class="Argument">x</a> <a id="6171" class="Symbol">=</a> <a id="6173" href="Prelude.Equality.html#6122" class="Bound">f</a> <a id="6175" href="Prelude.Equality.html#6125" class="Bound">x</a><a id="6176" class="Symbol">})</a>

<a id="6180" class="Keyword">open</a> <a id="6185" class="Keyword">import</a> <a id="6192" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="6201" class="Keyword">using</a> <a id="6207" class="Symbol">(</a><a id="6208" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="6210" class="Symbol">)</a> <a id="6212" class="Keyword">public</a>

</pre>

Here's a useful variation of `ap` that we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][] (transcribed into TypeTopology/UALib notation of course).

<pre class="Agda">

<a id="6431" class="Keyword">module</a> <a id="6438" href="Prelude.Equality.html#6438" class="Module">_</a> <a id="6440" class="Symbol">{</a><a id="6441" href="Prelude.Equality.html#6441" class="Bound">𝓤</a> <a id="6443" href="Prelude.Equality.html#6443" class="Bound">𝓦</a> <a id="6445" class="Symbol">:</a> <a id="6447" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6455" class="Symbol">}</a> <a id="6457" class="Keyword">where</a>

 <a id="6465" href="Prelude.Equality.html#6465" class="Function">cong-app</a> <a id="6474" class="Symbol">:</a> <a id="6476" class="Symbol">{</a><a id="6477" href="Prelude.Equality.html#6477" class="Bound">A</a> <a id="6479" class="Symbol">:</a> <a id="6481" href="Prelude.Equality.html#6441" class="Bound">𝓤</a> <a id="6483" href="Universes.html#403" class="Function Operator">̇</a><a id="6484" class="Symbol">}{</a><a id="6486" href="Prelude.Equality.html#6486" class="Bound">B</a> <a id="6488" class="Symbol">:</a> <a id="6490" href="Prelude.Equality.html#6477" class="Bound">A</a> <a id="6492" class="Symbol">→</a> <a id="6494" href="Prelude.Equality.html#6443" class="Bound">𝓦</a> <a id="6496" href="Universes.html#403" class="Function Operator">̇</a><a id="6497" class="Symbol">}{</a><a id="6499" href="Prelude.Equality.html#6499" class="Bound">f</a> <a id="6501" href="Prelude.Equality.html#6501" class="Bound">g</a> <a id="6503" class="Symbol">:</a> <a id="6505" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="6507" href="Prelude.Equality.html#6486" class="Bound">B</a><a id="6508" class="Symbol">}</a> <a id="6510" class="Symbol">→</a> <a id="6512" href="Prelude.Equality.html#6499" class="Bound">f</a> <a id="6514" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="6516" href="Prelude.Equality.html#6501" class="Bound">g</a> <a id="6518" class="Symbol">→</a> <a id="6520" class="Symbol">∀</a> <a id="6522" href="Prelude.Equality.html#6522" class="Bound">x</a> <a id="6524" class="Symbol">→</a> <a id="6526" href="Prelude.Equality.html#6499" class="Bound">f</a> <a id="6528" href="Prelude.Equality.html#6522" class="Bound">x</a> <a id="6530" href="Prelude.Equality.html#2570" class="Datatype Operator">≡</a> <a id="6532" href="Prelude.Equality.html#6501" class="Bound">g</a> <a id="6534" href="Prelude.Equality.html#6522" class="Bound">x</a>
 <a id="6537" href="Prelude.Equality.html#6465" class="Function">cong-app</a> <a id="6546" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6551" class="Symbol">_</a> <a id="6553" class="Symbol">=</a> <a id="6555" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>





-------------------------------------


<sup>1</sup><span class="footnote" id="fn1"> Per Martin-Löf, *An intuitionistic theory of types: predicative part*, Logic Colloquium '73 (Bristol, 1973), 73--118, Studies in Logic and the Foundations of Mathematics, Vol. 80, 1975.</span>

<sup>2</sup><span class="footnote" id="fn2"> The *definiendum* is the left-hand side of a defining equation, the *definiens* is the right-hand side. For readers who have never generated an equivalence relation: the *reflexive closure* of `R ⊆ A × A `is the union of `R` and all pairs of the form `(a , a)`; the *symmetric closure* is the union of `R` and its inverse `{(y , x) : (x , y) ∈ R}`; we leave it to the reader to come up with the correct definition of transitive closure.</span>

<sup>3</sup><span class="footnote" id="fn3"> **Unicode Hints** ([agda2-mode][]). `\^-\^1 ↝ ⁻¹`; `\Mii\Mid ↝ 𝑖𝑑`; `\. ↝ ∙`. In general, for information about a character, place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>



<sup>4</sup><span class="footnote" id="fn4"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170). See also [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).</span>

<br>
<br>

[← Prelude.Preliminaries ](Prelude.Preliminaries.html)
<span style="float:right;">[Prelude.Extensionality →](Prelude.Extensionality.html)</span>

{% include UALib.Links.md %}


