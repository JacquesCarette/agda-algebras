---
layout: default
title : UALib.Prelude.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This section describes the [UALib.Prelude.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="291" class="Symbol">{-#</a> <a id="295" class="Keyword">OPTIONS</a> <a id="303" class="Pragma">--without-K</a> <a id="315" class="Pragma">--exact-split</a> <a id="329" class="Pragma">--safe</a> <a id="336" class="Symbol">#-}</a>

<a id="341" class="Keyword">module</a> <a id="348" href="Prelude.Equality.html" class="Module">Prelude.Equality</a> <a id="365" class="Keyword">where</a>

<a id="372" class="Keyword">open</a> <a id="377" class="Keyword">import</a> <a id="384" href="Prelude.Preliminaries.html" class="Module">Prelude.Preliminaries</a> <a id="406" class="Keyword">public</a>

</pre>

#### <a id="refl">refl</a>

The type referred to as "reflexivity" or "refl" is a very basic but important one. It represents [definitional equality](https://ncatlab.org/nlab/show/equality#definitional_equality).

The `refl` type we use is a standard one. It is defined in the `Identity-Type` module of the [Type Topology][] library, but apart from syntax it is equivalent to the identity type used in most other Agda libraries.

We make `refl` available by importing it from the `Identity-Type` module.  However, we first repeat the definition here (inside a hidden submodule) for clarity.<sup>[1](Prelude.Equality.html#fn1)</sup>

<pre class="Agda">

<a id="1072" class="Keyword">module</a> <a id="hide-refl"></a><a id="1079" href="Prelude.Equality.html#1079" class="Module">hide-refl</a> <a id="1089" class="Symbol">{</a><a id="1090" href="Prelude.Equality.html#1090" class="Bound">𝓤</a> <a id="1092" class="Symbol">:</a> <a id="1094" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="1102" class="Symbol">}</a> <a id="1104" class="Keyword">where</a>

 <a id="1112" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="1117" href="Prelude.Equality.html#1117" class="Datatype Operator">_≡_</a> <a id="1121" class="Symbol">{</a><a id="1122" href="Prelude.Equality.html#1122" class="Bound">𝓤</a><a id="1123" class="Symbol">}</a> <a id="1125" class="Symbol">{</a><a id="1126" href="Prelude.Equality.html#1126" class="Bound">X</a> <a id="1128" class="Symbol">:</a> <a id="1130" href="Prelude.Equality.html#1122" class="Bound">𝓤</a> <a id="1132" href="Universes.html#403" class="Function Operator">̇</a> <a id="1134" class="Symbol">}</a> <a id="1136" class="Symbol">:</a> <a id="1138" href="Prelude.Equality.html#1126" class="Bound">X</a> <a id="1140" class="Symbol">→</a> <a id="1142" href="Prelude.Equality.html#1126" class="Bound">X</a> <a id="1144" class="Symbol">→</a> <a id="1146" href="Prelude.Equality.html#1122" class="Bound">𝓤</a> <a id="1148" href="Universes.html#403" class="Function Operator">̇</a> <a id="1150" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="1156" href="Prelude.Equality.html#1156" class="InductiveConstructor">refl</a> <a id="1161" class="Symbol">:</a> <a id="1163" class="Symbol">{</a><a id="1164" href="Prelude.Equality.html#1164" class="Bound">x</a> <a id="1166" class="Symbol">:</a> <a id="1168" href="Prelude.Equality.html#1126" class="Bound">X</a><a id="1169" class="Symbol">}</a> <a id="1171" class="Symbol">→</a> <a id="1173" href="Prelude.Equality.html#1164" class="Bound">x</a> <a id="1175" href="Prelude.Equality.html#1117" class="Datatype Operator">≡</a> <a id="1177" href="Prelude.Equality.html#1164" class="Bound">x</a>

<a id="1180" class="Keyword">open</a> <a id="1185" class="Keyword">import</a> <a id="1192" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="1206" class="Keyword">renaming</a> <a id="1215" class="Symbol">(</a><a id="1216" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="1220" class="Symbol">to</a> <a id="1223" class="Keyword">infix</a> <a id="1229" class="Number">0</a> <a id="_≡_"></a><a id="1231" href="Prelude.Equality.html#1231" class="Datatype Operator">_≡_</a><a id="1234" class="Symbol">)</a> <a id="1236" class="Keyword">public</a>

</pre>

Thus, whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we can invoke `refl`.  If we need to make `x` explicit, we use `refl {x = x}`.

Of course, `≡` is an equivalence relation, and the formalization of this fact is trivial. In fact, we don't even need to prove reflexivity, since it is the defining property of `≡`.  Here are the trivial proofs of symmetry and transitivity of `≡`.<sup>[2](Prelude.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="1747" class="Keyword">module</a> <a id="1754" href="Prelude.Equality.html#1754" class="Module">_</a>  <a id="1757" class="Symbol">{</a><a id="1758" href="Prelude.Equality.html#1758" class="Bound">𝓤</a> <a id="1760" class="Symbol">:</a> <a id="1762" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="1770" class="Symbol">}{</a><a id="1772" href="Prelude.Equality.html#1772" class="Bound">X</a> <a id="1774" class="Symbol">:</a> <a id="1776" href="Prelude.Equality.html#1758" class="Bound">𝓤</a> <a id="1778" href="Universes.html#403" class="Function Operator">̇</a> <a id="1780" class="Symbol">}</a>  <a id="1783" class="Keyword">where</a>

 <a id="1791" href="Prelude.Equality.html#1791" class="Function">≡-symmetric</a> <a id="1803" class="Symbol">:</a> <a id="1805" class="Symbol">(</a><a id="1806" href="Prelude.Equality.html#1806" class="Bound">x</a> <a id="1808" href="Prelude.Equality.html#1808" class="Bound">y</a> <a id="1810" class="Symbol">:</a> <a id="1812" href="Prelude.Equality.html#1772" class="Bound">X</a><a id="1813" class="Symbol">)</a> <a id="1815" class="Symbol">→</a> <a id="1817" href="Prelude.Equality.html#1806" class="Bound">x</a> <a id="1819" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="1821" href="Prelude.Equality.html#1808" class="Bound">y</a> <a id="1823" class="Symbol">→</a> <a id="1825" href="Prelude.Equality.html#1808" class="Bound">y</a> <a id="1827" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="1829" href="Prelude.Equality.html#1806" class="Bound">x</a>
 <a id="1832" href="Prelude.Equality.html#1791" class="Function">≡-symmetric</a> <a id="1844" class="Symbol">_</a> <a id="1846" class="Symbol">_</a> <a id="1848" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="1853" class="Symbol">=</a> <a id="1855" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="1862" href="Prelude.Equality.html#1862" class="Function">≡-sym</a> <a id="1868" class="Symbol">:</a> <a id="1870" class="Symbol">{</a><a id="1871" href="Prelude.Equality.html#1871" class="Bound">x</a> <a id="1873" href="Prelude.Equality.html#1873" class="Bound">y</a> <a id="1875" class="Symbol">:</a> <a id="1877" href="Prelude.Equality.html#1772" class="Bound">X</a><a id="1878" class="Symbol">}</a> <a id="1880" class="Symbol">→</a> <a id="1882" href="Prelude.Equality.html#1871" class="Bound">x</a> <a id="1884" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="1886" href="Prelude.Equality.html#1873" class="Bound">y</a> <a id="1888" class="Symbol">→</a> <a id="1890" href="Prelude.Equality.html#1873" class="Bound">y</a> <a id="1892" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="1894" href="Prelude.Equality.html#1871" class="Bound">x</a>
 <a id="1897" href="Prelude.Equality.html#1862" class="Function">≡-sym</a> <a id="1903" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="1908" class="Symbol">=</a> <a id="1910" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="1917" href="Prelude.Equality.html#1917" class="Function">≡-transitive</a> <a id="1930" class="Symbol">:</a> <a id="1932" class="Symbol">(</a><a id="1933" href="Prelude.Equality.html#1933" class="Bound">x</a> <a id="1935" href="Prelude.Equality.html#1935" class="Bound">y</a> <a id="1937" href="Prelude.Equality.html#1937" class="Bound">z</a> <a id="1939" class="Symbol">:</a> <a id="1941" href="Prelude.Equality.html#1772" class="Bound">X</a><a id="1942" class="Symbol">)</a> <a id="1944" class="Symbol">→</a> <a id="1946" href="Prelude.Equality.html#1933" class="Bound">x</a> <a id="1948" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="1950" href="Prelude.Equality.html#1935" class="Bound">y</a> <a id="1952" class="Symbol">→</a> <a id="1954" href="Prelude.Equality.html#1935" class="Bound">y</a> <a id="1956" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="1958" href="Prelude.Equality.html#1937" class="Bound">z</a> <a id="1960" class="Symbol">→</a> <a id="1962" href="Prelude.Equality.html#1933" class="Bound">x</a> <a id="1964" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="1966" href="Prelude.Equality.html#1937" class="Bound">z</a>
 <a id="1969" href="Prelude.Equality.html#1917" class="Function">≡-transitive</a> <a id="1982" class="Symbol">_</a> <a id="1984" class="Symbol">_</a> <a id="1986" class="Symbol">_</a> <a id="1988" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="1993" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="1998" class="Symbol">=</a> <a id="2000" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="2007" href="Prelude.Equality.html#2007" class="Function">≡-trans</a> <a id="2015" class="Symbol">:</a> <a id="2017" class="Symbol">{</a><a id="2018" href="Prelude.Equality.html#2018" class="Bound">x</a> <a id="2020" href="Prelude.Equality.html#2020" class="Bound">y</a> <a id="2022" href="Prelude.Equality.html#2022" class="Bound">z</a> <a id="2024" class="Symbol">:</a> <a id="2026" href="Prelude.Equality.html#1772" class="Bound">X</a><a id="2027" class="Symbol">}</a> <a id="2029" class="Symbol">→</a> <a id="2031" href="Prelude.Equality.html#2018" class="Bound">x</a> <a id="2033" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2035" href="Prelude.Equality.html#2020" class="Bound">y</a> <a id="2037" class="Symbol">→</a> <a id="2039" href="Prelude.Equality.html#2020" class="Bound">y</a> <a id="2041" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2043" href="Prelude.Equality.html#2022" class="Bound">z</a> <a id="2045" class="Symbol">→</a> <a id="2047" href="Prelude.Equality.html#2018" class="Bound">x</a> <a id="2049" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2051" href="Prelude.Equality.html#2022" class="Bound">z</a>
 <a id="2054" href="Prelude.Equality.html#2007" class="Function">≡-trans</a> <a id="2062" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2067" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2072" class="Symbol">=</a> <a id="2074" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

The only difference between `≡-symmetric` and `≡-sym` (respectively, `≡-transitive` and `≡-trans`) is that the latter has fewer explicit arguments, which is sometimes convenient.

Many proofs make abundant use of the symmetry of `_≡_`, and the following syntactic sugar can often improve the readability of such proofs.<sup>[3](Prelude.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="2468" class="Keyword">module</a> <a id="hide-sym"></a><a id="2475" href="Prelude.Equality.html#2475" class="Module">hide-sym</a> <a id="2484" class="Symbol">{</a><a id="2485" href="Prelude.Equality.html#2485" class="Bound">𝓤</a> <a id="2487" class="Symbol">:</a> <a id="2489" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2497" class="Symbol">}</a> <a id="2499" class="Keyword">where</a>

 <a id="hide-sym._⁻¹"></a><a id="2507" href="Prelude.Equality.html#2507" class="Function Operator">_⁻¹</a> <a id="2511" class="Symbol">:</a> <a id="2513" class="Symbol">{</a><a id="2514" href="Prelude.Equality.html#2514" class="Bound">X</a> <a id="2516" class="Symbol">:</a> <a id="2518" href="Prelude.Equality.html#2485" class="Bound">𝓤</a> <a id="2520" href="Universes.html#403" class="Function Operator">̇</a> <a id="2522" class="Symbol">}</a> <a id="2524" class="Symbol">→</a> <a id="2526" class="Symbol">{</a><a id="2527" href="Prelude.Equality.html#2527" class="Bound">x</a> <a id="2529" href="Prelude.Equality.html#2529" class="Bound">y</a> <a id="2531" class="Symbol">:</a> <a id="2533" href="Prelude.Equality.html#2514" class="Bound">X</a><a id="2534" class="Symbol">}</a> <a id="2536" class="Symbol">→</a> <a id="2538" href="Prelude.Equality.html#2527" class="Bound">x</a> <a id="2540" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2542" href="Prelude.Equality.html#2529" class="Bound">y</a> <a id="2544" class="Symbol">→</a> <a id="2546" href="Prelude.Equality.html#2529" class="Bound">y</a> <a id="2548" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2550" href="Prelude.Equality.html#2527" class="Bound">x</a>
 <a id="2553" href="Prelude.Equality.html#2553" class="Bound">p</a> <a id="2555" href="Prelude.Equality.html#2507" class="Function Operator">⁻¹</a> <a id="2558" class="Symbol">=</a> <a id="2560" href="Prelude.Equality.html#1862" class="Function">≡-sym</a> <a id="2566" href="Prelude.Equality.html#2553" class="Bound">p</a>

<a id="2569" class="Keyword">open</a> <a id="2574" class="Keyword">import</a> <a id="2581" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="2590" class="Keyword">using</a> <a id="2596" class="Symbol">(</a><a id="2597" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="2600" class="Symbol">)</a> <a id="2602" class="Keyword">public</a>

</pre>

So, if we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` .

Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.<sup>[3](Prelude.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="2911" class="Keyword">module</a> <a id="hide-trans-dot"></a><a id="2918" href="Prelude.Equality.html#2918" class="Module">hide-trans-dot</a> <a id="2933" class="Symbol">{</a><a id="2934" href="Prelude.Equality.html#2934" class="Bound">𝓤</a> <a id="2936" class="Symbol">:</a> <a id="2938" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2946" class="Symbol">}</a> <a id="2948" class="Keyword">where</a>

 <a id="hide-trans-dot._∙_"></a><a id="2956" href="Prelude.Equality.html#2956" class="Function Operator">_∙_</a> <a id="2960" class="Symbol">:</a> <a id="2962" class="Symbol">{</a><a id="2963" href="Prelude.Equality.html#2963" class="Bound">X</a> <a id="2965" class="Symbol">:</a> <a id="2967" href="Prelude.Equality.html#2934" class="Bound">𝓤</a> <a id="2969" href="Universes.html#403" class="Function Operator">̇</a> <a id="2971" class="Symbol">}</a> <a id="2973" class="Symbol">{</a><a id="2974" href="Prelude.Equality.html#2974" class="Bound">x</a> <a id="2976" href="Prelude.Equality.html#2976" class="Bound">y</a> <a id="2978" href="Prelude.Equality.html#2978" class="Bound">z</a> <a id="2980" class="Symbol">:</a> <a id="2982" href="Prelude.Equality.html#2963" class="Bound">X</a><a id="2983" class="Symbol">}</a> <a id="2985" class="Symbol">→</a> <a id="2987" href="Prelude.Equality.html#2974" class="Bound">x</a> <a id="2989" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2991" href="Prelude.Equality.html#2976" class="Bound">y</a> <a id="2993" class="Symbol">→</a> <a id="2995" href="Prelude.Equality.html#2976" class="Bound">y</a> <a id="2997" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2999" href="Prelude.Equality.html#2978" class="Bound">z</a> <a id="3001" class="Symbol">→</a> <a id="3003" href="Prelude.Equality.html#2974" class="Bound">x</a> <a id="3005" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="3007" href="Prelude.Equality.html#2978" class="Bound">z</a>
 <a id="3010" href="Prelude.Equality.html#3010" class="Bound">p</a> <a id="3012" href="Prelude.Equality.html#2956" class="Function Operator">∙</a> <a id="3014" href="Prelude.Equality.html#3014" class="Bound">q</a> <a id="3016" class="Symbol">=</a> <a id="3018" href="Prelude.Equality.html#2007" class="Function">≡-trans</a> <a id="3026" href="Prelude.Equality.html#3010" class="Bound">p</a> <a id="3028" href="Prelude.Equality.html#3014" class="Bound">q</a>

<a id="3031" class="Keyword">open</a> <a id="3036" class="Keyword">import</a> <a id="3043" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="3052" class="Keyword">using</a> <a id="3058" class="Symbol">(</a><a id="3059" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="3062" class="Symbol">)</a> <a id="3064" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Prelude.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.

<pre class="Agda">

<a id="3710" class="Keyword">module</a> <a id="hide-transport"></a><a id="3717" href="Prelude.Equality.html#3717" class="Module">hide-transport</a> <a id="3732" class="Symbol">{</a><a id="3733" href="Prelude.Equality.html#3733" class="Bound">𝓤</a> <a id="3735" href="Prelude.Equality.html#3735" class="Bound">𝓦</a> <a id="3737" class="Symbol">:</a> <a id="3739" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3747" class="Symbol">}</a> <a id="3749" class="Keyword">where</a>

 <a id="hide-transport.𝑖𝑑"></a><a id="3757" href="Prelude.Equality.html#3757" class="Function">𝑖𝑑</a> <a id="3760" class="Symbol">:</a> <a id="3762" class="Symbol">{</a><a id="3763" href="Prelude.Equality.html#3763" class="Bound">𝓧</a> <a id="3765" class="Symbol">:</a> <a id="3767" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3775" class="Symbol">}</a> <a id="3777" class="Symbol">(</a><a id="3778" href="Prelude.Equality.html#3778" class="Bound">X</a> <a id="3780" class="Symbol">:</a> <a id="3782" href="Prelude.Equality.html#3763" class="Bound">𝓧</a> <a id="3784" href="Universes.html#403" class="Function Operator">̇</a> <a id="3786" class="Symbol">)</a> <a id="3788" class="Symbol">→</a> <a id="3790" href="Prelude.Equality.html#3778" class="Bound">X</a> <a id="3792" class="Symbol">→</a> <a id="3794" href="Prelude.Equality.html#3778" class="Bound">X</a>
 <a id="3797" href="Prelude.Equality.html#3757" class="Function">𝑖𝑑</a> <a id="3800" href="Prelude.Equality.html#3800" class="Bound">X</a> <a id="3802" class="Symbol">=</a> <a id="3804" class="Symbol">λ</a> <a id="3806" href="Prelude.Equality.html#3806" class="Bound">x</a> <a id="3808" class="Symbol">→</a> <a id="3810" href="Prelude.Equality.html#3806" class="Bound">x</a>

 <a id="hide-transport.transport"></a><a id="3814" href="Prelude.Equality.html#3814" class="Function">transport</a> <a id="3824" class="Symbol">:</a> <a id="3826" class="Symbol">{</a><a id="3827" href="Prelude.Equality.html#3827" class="Bound">X</a> <a id="3829" class="Symbol">:</a> <a id="3831" href="Prelude.Equality.html#3733" class="Bound">𝓤</a> <a id="3833" href="Universes.html#403" class="Function Operator">̇</a> <a id="3835" class="Symbol">}</a> <a id="3837" class="Symbol">(</a><a id="3838" href="Prelude.Equality.html#3838" class="Bound">A</a> <a id="3840" class="Symbol">:</a> <a id="3842" href="Prelude.Equality.html#3827" class="Bound">X</a> <a id="3844" class="Symbol">→</a> <a id="3846" href="Prelude.Equality.html#3735" class="Bound">𝓦</a> <a id="3848" href="Universes.html#403" class="Function Operator">̇</a> <a id="3850" class="Symbol">)</a> <a id="3852" class="Symbol">{</a><a id="3853" href="Prelude.Equality.html#3853" class="Bound">x</a> <a id="3855" href="Prelude.Equality.html#3855" class="Bound">y</a> <a id="3857" class="Symbol">:</a> <a id="3859" href="Prelude.Equality.html#3827" class="Bound">X</a><a id="3860" class="Symbol">}</a> <a id="3862" class="Symbol">→</a> <a id="3864" href="Prelude.Equality.html#3853" class="Bound">x</a> <a id="3866" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="3868" href="Prelude.Equality.html#3855" class="Bound">y</a> <a id="3870" class="Symbol">→</a> <a id="3872" href="Prelude.Equality.html#3838" class="Bound">A</a> <a id="3874" href="Prelude.Equality.html#3853" class="Bound">x</a> <a id="3876" class="Symbol">→</a> <a id="3878" href="Prelude.Equality.html#3838" class="Bound">A</a> <a id="3880" href="Prelude.Equality.html#3855" class="Bound">y</a>
 <a id="3883" href="Prelude.Equality.html#3814" class="Function">transport</a> <a id="3893" href="Prelude.Equality.html#3893" class="Bound">A</a> <a id="3895" class="Symbol">(</a><a id="3896" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3901" class="Symbol">{</a><a id="3902" class="Argument">x</a> <a id="3904" class="Symbol">=</a> <a id="3906" href="Prelude.Equality.html#3906" class="Bound">x</a><a id="3907" class="Symbol">})</a> <a id="3910" class="Symbol">=</a> <a id="3912" href="Prelude.Equality.html#3757" class="Function">𝑖𝑑</a> <a id="3915" class="Symbol">(</a><a id="3916" href="Prelude.Equality.html#3893" class="Bound">A</a> <a id="3918" href="Prelude.Equality.html#3906" class="Bound">x</a><a id="3919" class="Symbol">)</a>

<a id="3922" class="Keyword">open</a> <a id="3927" class="Keyword">import</a> <a id="3934" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="3943" class="Keyword">using</a> <a id="3949" class="Symbol">(</a><a id="3950" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="3952" class="Symbol">;</a> <a id="3954" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="3963" class="Symbol">)</a> <a id="3965" class="Keyword">public</a>

</pre>

As usual, we display `transport` in a hidden module and then imported the existing definition from [Type Topology][].<sup>[1](Preliminaries.Equality.html#fn1)</sup> See [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `x x' : X` of the domain, and an identity proof `p : x ≡ x'`, then we obtain a proof of `f x ≡ f x'` by simply applying the `ap` function like so, `ap f p : f x ≡ f x'`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="4948" class="Keyword">module</a> <a id="hide-ap"></a><a id="4955" href="Prelude.Equality.html#4955" class="Module">hide-ap</a>  <a id="4964" class="Symbol">{</a><a id="4965" href="Prelude.Equality.html#4965" class="Bound">𝓤</a> <a id="4967" class="Symbol">:</a> <a id="4969" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="4977" class="Symbol">}</a> <a id="4979" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="4987" href="Prelude.Equality.html#4987" class="Function">ap</a> <a id="4990" class="Symbol">:</a> <a id="4992" class="Symbol">{</a><a id="4993" href="Prelude.Equality.html#4993" class="Bound">X</a> <a id="4995" class="Symbol">:</a> <a id="4997" href="Prelude.Equality.html#4965" class="Bound">𝓤</a> <a id="4999" href="Universes.html#403" class="Function Operator">̇</a><a id="5000" class="Symbol">}{</a><a id="5002" href="Prelude.Equality.html#5002" class="Bound">Y</a> <a id="5004" class="Symbol">:</a> <a id="5006" href="Universes.html#262" class="Generalizable">𝓥</a> <a id="5008" href="Universes.html#403" class="Function Operator">̇</a><a id="5009" class="Symbol">}(</a><a id="5011" href="Prelude.Equality.html#5011" class="Bound">f</a> <a id="5013" class="Symbol">:</a> <a id="5015" href="Prelude.Equality.html#4993" class="Bound">X</a> <a id="5017" class="Symbol">→</a> <a id="5019" href="Prelude.Equality.html#5002" class="Bound">Y</a><a id="5020" class="Symbol">){</a><a id="5022" href="Prelude.Equality.html#5022" class="Bound">x</a> <a id="5024" href="Prelude.Equality.html#5024" class="Bound">x&#39;</a> <a id="5027" class="Symbol">:</a> <a id="5029" href="Prelude.Equality.html#4993" class="Bound">X</a><a id="5030" class="Symbol">}</a> <a id="5032" class="Symbol">→</a> <a id="5034" href="Prelude.Equality.html#5022" class="Bound">x</a> <a id="5036" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5038" href="Prelude.Equality.html#5024" class="Bound">x&#39;</a> <a id="5041" class="Symbol">→</a> <a id="5043" href="Prelude.Equality.html#5011" class="Bound">f</a> <a id="5045" href="Prelude.Equality.html#5022" class="Bound">x</a> <a id="5047" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5049" href="Prelude.Equality.html#5011" class="Bound">f</a> <a id="5051" href="Prelude.Equality.html#5024" class="Bound">x&#39;</a>
 <a id="5055" href="Prelude.Equality.html#4987" class="Function">ap</a> <a id="5058" href="Prelude.Equality.html#5058" class="Bound">f</a> <a id="5060" class="Symbol">{</a><a id="5061" href="Prelude.Equality.html#5061" class="Bound">x</a><a id="5062" class="Symbol">}{</a><a id="5064" href="Prelude.Equality.html#5064" class="Bound">x&#39;</a><a id="5066" class="Symbol">}</a> <a id="5068" href="Prelude.Equality.html#5068" class="Bound">p</a> <a id="5070" class="Symbol">=</a> <a id="5072" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="5082" class="Symbol">(λ</a> <a id="5085" href="Prelude.Equality.html#5085" class="Bound">-</a> <a id="5087" class="Symbol">→</a> <a id="5089" href="Prelude.Equality.html#5058" class="Bound">f</a> <a id="5091" href="Prelude.Equality.html#5061" class="Bound">x</a> <a id="5093" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5095" href="Prelude.Equality.html#5058" class="Bound">f</a> <a id="5097" href="Prelude.Equality.html#5085" class="Bound">-</a><a id="5098" class="Symbol">)</a> <a id="5100" href="Prelude.Equality.html#5068" class="Bound">p</a> <a id="5102" class="Symbol">(</a><a id="5103" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5108" class="Symbol">{</a><a id="5109" class="Argument">x</a> <a id="5111" class="Symbol">=</a> <a id="5113" href="Prelude.Equality.html#5058" class="Bound">f</a> <a id="5115" href="Prelude.Equality.html#5061" class="Bound">x</a><a id="5116" class="Symbol">})</a>

<a id="5120" class="Keyword">open</a> <a id="5125" class="Keyword">import</a> <a id="5132" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5141" class="Keyword">using</a> <a id="5147" class="Symbol">(</a><a id="5148" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="5150" class="Symbol">)</a> <a id="5152" class="Keyword">public</a>

</pre>

We now define some variations of `ap` that are sometimes useful.

<pre class="Agda">

<a id="5252" class="Keyword">module</a> <a id="5259" href="Prelude.Equality.html#5259" class="Module">_</a> <a id="5261" class="Symbol">{</a><a id="5262" href="Prelude.Equality.html#5262" class="Bound">𝓤</a> <a id="5264" href="Prelude.Equality.html#5264" class="Bound">𝓦</a> <a id="5266" class="Symbol">:</a> <a id="5268" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5276" class="Symbol">}</a> <a id="5278" class="Keyword">where</a>

 <a id="5286" href="Prelude.Equality.html#5286" class="Function">ap-cong</a> <a id="5294" class="Symbol">:</a> <a id="5296" class="Symbol">{</a><a id="5297" href="Prelude.Equality.html#5297" class="Bound">A</a> <a id="5299" class="Symbol">:</a> <a id="5301" href="Prelude.Equality.html#5262" class="Bound">𝓤</a> <a id="5303" href="Universes.html#403" class="Function Operator">̇</a><a id="5304" class="Symbol">}{</a><a id="5306" href="Prelude.Equality.html#5306" class="Bound">B</a> <a id="5308" class="Symbol">:</a> <a id="5310" href="Prelude.Equality.html#5264" class="Bound">𝓦</a> <a id="5312" href="Universes.html#403" class="Function Operator">̇</a><a id="5313" class="Symbol">}{</a><a id="5315" href="Prelude.Equality.html#5315" class="Bound">f</a> <a id="5317" href="Prelude.Equality.html#5317" class="Bound">g</a> <a id="5319" class="Symbol">:</a> <a id="5321" href="Prelude.Equality.html#5297" class="Bound">A</a> <a id="5323" class="Symbol">→</a> <a id="5325" href="Prelude.Equality.html#5306" class="Bound">B</a><a id="5326" class="Symbol">}{</a><a id="5328" href="Prelude.Equality.html#5328" class="Bound">a</a> <a id="5330" href="Prelude.Equality.html#5330" class="Bound">b</a> <a id="5332" class="Symbol">:</a> <a id="5334" href="Prelude.Equality.html#5297" class="Bound">A</a><a id="5335" class="Symbol">}</a> <a id="5337" class="Symbol">→</a> <a id="5339" href="Prelude.Equality.html#5315" class="Bound">f</a> <a id="5341" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5343" href="Prelude.Equality.html#5317" class="Bound">g</a> <a id="5345" class="Symbol">→</a> <a id="5347" href="Prelude.Equality.html#5328" class="Bound">a</a> <a id="5349" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5351" href="Prelude.Equality.html#5330" class="Bound">b</a> <a id="5353" class="Symbol">→</a> <a id="5355" href="Prelude.Equality.html#5315" class="Bound">f</a> <a id="5357" href="Prelude.Equality.html#5328" class="Bound">a</a> <a id="5359" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5361" href="Prelude.Equality.html#5317" class="Bound">g</a> <a id="5363" href="Prelude.Equality.html#5330" class="Bound">b</a>
 <a id="5366" href="Prelude.Equality.html#5286" class="Function">ap-cong</a> <a id="5374" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5379" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5384" class="Symbol">=</a> <a id="5386" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

We sometimes need a version of this that works for [dependent types][], such as the following (which we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][], transcribed into MHE/UALib notation of course):

<pre class="Agda">

 <a id="5657" href="Prelude.Equality.html#5657" class="Function">cong-app</a> <a id="5666" class="Symbol">:</a> <a id="5668" class="Symbol">{</a><a id="5669" href="Prelude.Equality.html#5669" class="Bound">A</a> <a id="5671" class="Symbol">:</a> <a id="5673" href="Prelude.Equality.html#5262" class="Bound">𝓤</a> <a id="5675" href="Universes.html#403" class="Function Operator">̇</a><a id="5676" class="Symbol">}{</a><a id="5678" href="Prelude.Equality.html#5678" class="Bound">B</a> <a id="5680" class="Symbol">:</a> <a id="5682" href="Prelude.Equality.html#5669" class="Bound">A</a> <a id="5684" class="Symbol">→</a> <a id="5686" href="Prelude.Equality.html#5264" class="Bound">𝓦</a> <a id="5688" href="Universes.html#403" class="Function Operator">̇</a><a id="5689" class="Symbol">}{</a><a id="5691" href="Prelude.Equality.html#5691" class="Bound">f</a> <a id="5693" href="Prelude.Equality.html#5693" class="Bound">g</a> <a id="5695" class="Symbol">:</a> <a id="5697" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="5699" href="Prelude.Equality.html#5678" class="Bound">B</a><a id="5700" class="Symbol">}</a> <a id="5702" class="Symbol">→</a> <a id="5704" href="Prelude.Equality.html#5691" class="Bound">f</a> <a id="5706" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5708" href="Prelude.Equality.html#5693" class="Bound">g</a> <a id="5710" class="Symbol">→</a> <a id="5712" class="Symbol">∀</a> <a id="5714" href="Prelude.Equality.html#5714" class="Bound">a</a> <a id="5716" class="Symbol">→</a> <a id="5718" href="Prelude.Equality.html#5691" class="Bound">f</a> <a id="5720" href="Prelude.Equality.html#5714" class="Bound">a</a> <a id="5722" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5724" href="Prelude.Equality.html#5693" class="Bound">g</a> <a id="5726" href="Prelude.Equality.html#5714" class="Bound">a</a>
 <a id="5729" href="Prelude.Equality.html#5657" class="Function">cong-app</a> <a id="5738" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5743" class="Symbol">_</a> <a id="5745" class="Symbol">=</a> <a id="5747" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>




#### <a id="≡-intro-and-≡-elim-for-nondependent-pairs">≡-intro and ≡-elim for nondependent pairs</a>

We conclude the Equality module with some occasionally useful introduction and elimination rules for the equality relation on (nondependent) pair types.


<pre class="Agda">

 <a id="6040" href="Prelude.Equality.html#6040" class="Function">≡-elim-left</a> <a id="6052" class="Symbol">:</a> <a id="6054" class="Symbol">{</a><a id="6055" href="Prelude.Equality.html#6055" class="Bound">A₁</a> <a id="6058" href="Prelude.Equality.html#6058" class="Bound">A₂</a> <a id="6061" class="Symbol">:</a> <a id="6063" href="Prelude.Equality.html#5262" class="Bound">𝓤</a> <a id="6065" href="Universes.html#403" class="Function Operator">̇</a><a id="6066" class="Symbol">}{</a><a id="6068" href="Prelude.Equality.html#6068" class="Bound">B₁</a> <a id="6071" href="Prelude.Equality.html#6071" class="Bound">B₂</a> <a id="6074" class="Symbol">:</a> <a id="6076" href="Prelude.Equality.html#5264" class="Bound">𝓦</a> <a id="6078" href="Universes.html#403" class="Function Operator">̇</a><a id="6079" class="Symbol">}</a> <a id="6081" class="Symbol">→</a> <a id="6083" class="Symbol">(</a><a id="6084" href="Prelude.Equality.html#6055" class="Bound">A₁</a> <a id="6087" href="MGS-MLTT.html#2929" class="InductiveConstructor Operator">,</a> <a id="6089" href="Prelude.Equality.html#6068" class="Bound">B₁</a><a id="6091" class="Symbol">)</a> <a id="6093" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6095" class="Symbol">(</a><a id="6096" href="Prelude.Equality.html#6058" class="Bound">A₂</a> <a id="6099" href="MGS-MLTT.html#2929" class="InductiveConstructor Operator">,</a> <a id="6101" href="Prelude.Equality.html#6071" class="Bound">B₂</a><a id="6103" class="Symbol">)</a> <a id="6105" class="Symbol">→</a> <a id="6107" href="Prelude.Equality.html#6055" class="Bound">A₁</a> <a id="6110" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6112" href="Prelude.Equality.html#6058" class="Bound">A₂</a>
 <a id="6116" href="Prelude.Equality.html#6040" class="Function">≡-elim-left</a> <a id="6128" href="Prelude.Equality.html#6128" class="Bound">e</a> <a id="6130" class="Symbol">=</a> <a id="6132" href="MGS-MLTT.html#6613" class="Function">ap</a> <a id="6135" href="Prelude.Preliminaries.html#13621" class="Function">fst</a> <a id="6139" href="Prelude.Equality.html#6128" class="Bound">e</a>


 <a id="6144" href="Prelude.Equality.html#6144" class="Function">≡-elim-right</a> <a id="6157" class="Symbol">:</a> <a id="6159" class="Symbol">{</a><a id="6160" href="Prelude.Equality.html#6160" class="Bound">A₁</a> <a id="6163" href="Prelude.Equality.html#6163" class="Bound">A₂</a> <a id="6166" class="Symbol">:</a> <a id="6168" href="Prelude.Equality.html#5262" class="Bound">𝓤</a> <a id="6170" href="Universes.html#403" class="Function Operator">̇</a><a id="6171" class="Symbol">}{</a><a id="6173" href="Prelude.Equality.html#6173" class="Bound">B₁</a> <a id="6176" href="Prelude.Equality.html#6176" class="Bound">B₂</a> <a id="6179" class="Symbol">:</a> <a id="6181" href="Prelude.Equality.html#5264" class="Bound">𝓦</a> <a id="6183" href="Universes.html#403" class="Function Operator">̇</a><a id="6184" class="Symbol">}</a> <a id="6186" class="Symbol">→</a> <a id="6188" class="Symbol">(</a><a id="6189" href="Prelude.Equality.html#6160" class="Bound">A₁</a> <a id="6192" href="MGS-MLTT.html#2929" class="InductiveConstructor Operator">,</a> <a id="6194" href="Prelude.Equality.html#6173" class="Bound">B₁</a><a id="6196" class="Symbol">)</a> <a id="6198" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6200" class="Symbol">(</a><a id="6201" href="Prelude.Equality.html#6163" class="Bound">A₂</a> <a id="6204" href="MGS-MLTT.html#2929" class="InductiveConstructor Operator">,</a> <a id="6206" href="Prelude.Equality.html#6176" class="Bound">B₂</a><a id="6208" class="Symbol">)</a> <a id="6210" class="Symbol">→</a> <a id="6212" href="Prelude.Equality.html#6173" class="Bound">B₁</a> <a id="6215" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6217" href="Prelude.Equality.html#6176" class="Bound">B₂</a>
 <a id="6221" href="Prelude.Equality.html#6144" class="Function">≡-elim-right</a> <a id="6234" href="Prelude.Equality.html#6234" class="Bound">e</a> <a id="6236" class="Symbol">=</a> <a id="6238" href="MGS-MLTT.html#6613" class="Function">ap</a> <a id="6241" href="Prelude.Preliminaries.html#13699" class="Function">snd</a> <a id="6245" href="Prelude.Equality.html#6234" class="Bound">e</a>


 <a id="6250" href="Prelude.Equality.html#6250" class="Function">≡-×-intro</a> <a id="6260" class="Symbol">:</a> <a id="6262" class="Symbol">{</a><a id="6263" href="Prelude.Equality.html#6263" class="Bound">A₁</a> <a id="6266" href="Prelude.Equality.html#6266" class="Bound">A₂</a> <a id="6269" class="Symbol">:</a> <a id="6271" href="Prelude.Equality.html#5262" class="Bound">𝓤</a> <a id="6273" href="Universes.html#403" class="Function Operator">̇</a><a id="6274" class="Symbol">}</a> <a id="6276" class="Symbol">{</a><a id="6277" href="Prelude.Equality.html#6277" class="Bound">B₁</a> <a id="6280" href="Prelude.Equality.html#6280" class="Bound">B₂</a> <a id="6283" class="Symbol">:</a> <a id="6285" href="Prelude.Equality.html#5264" class="Bound">𝓦</a> <a id="6287" href="Universes.html#403" class="Function Operator">̇</a><a id="6288" class="Symbol">}</a> <a id="6290" class="Symbol">→</a> <a id="6292" href="Prelude.Equality.html#6263" class="Bound">A₁</a> <a id="6295" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6297" href="Prelude.Equality.html#6266" class="Bound">A₂</a> <a id="6300" class="Symbol">→</a> <a id="6302" href="Prelude.Equality.html#6277" class="Bound">B₁</a> <a id="6305" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6307" href="Prelude.Equality.html#6280" class="Bound">B₂</a> <a id="6310" class="Symbol">→</a> <a id="6312" class="Symbol">(</a><a id="6313" href="Prelude.Equality.html#6263" class="Bound">A₁</a> <a id="6316" href="MGS-MLTT.html#2929" class="InductiveConstructor Operator">,</a> <a id="6318" href="Prelude.Equality.html#6277" class="Bound">B₁</a><a id="6320" class="Symbol">)</a> <a id="6322" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6324" class="Symbol">(</a><a id="6325" href="Prelude.Equality.html#6266" class="Bound">A₂</a> <a id="6328" href="MGS-MLTT.html#2929" class="InductiveConstructor Operator">,</a> <a id="6330" href="Prelude.Equality.html#6280" class="Bound">B₂</a><a id="6332" class="Symbol">)</a>
 <a id="6335" href="Prelude.Equality.html#6250" class="Function">≡-×-intro</a> <a id="6345" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6350" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6355" class="Symbol">=</a> <a id="6357" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>


 <a id="6365" href="Prelude.Equality.html#6365" class="Function">≡-×-int</a> <a id="6373" class="Symbol">:</a> <a id="6375" class="Symbol">{</a><a id="6376" href="Prelude.Equality.html#6376" class="Bound">A</a> <a id="6378" class="Symbol">:</a> <a id="6380" href="Prelude.Equality.html#5262" class="Bound">𝓤</a> <a id="6382" href="Universes.html#403" class="Function Operator">̇</a><a id="6383" class="Symbol">}{</a><a id="6385" href="Prelude.Equality.html#6385" class="Bound">B</a> <a id="6387" class="Symbol">:</a> <a id="6389" href="Prelude.Equality.html#5264" class="Bound">𝓦</a> <a id="6391" href="Universes.html#403" class="Function Operator">̇</a><a id="6392" class="Symbol">}{</a><a id="6394" href="Prelude.Equality.html#6394" class="Bound">a</a> <a id="6396" href="Prelude.Equality.html#6396" class="Bound">x</a> <a id="6398" class="Symbol">:</a> <a id="6400" href="Prelude.Equality.html#6376" class="Bound">A</a><a id="6401" class="Symbol">}{</a><a id="6403" href="Prelude.Equality.html#6403" class="Bound">b</a> <a id="6405" href="Prelude.Equality.html#6405" class="Bound">y</a> <a id="6407" class="Symbol">:</a> <a id="6409" href="Prelude.Equality.html#6385" class="Bound">B</a><a id="6410" class="Symbol">}</a> <a id="6412" class="Symbol">→</a> <a id="6414" href="Prelude.Equality.html#6394" class="Bound">a</a> <a id="6416" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6418" href="Prelude.Equality.html#6396" class="Bound">x</a> <a id="6420" class="Symbol">→</a> <a id="6422" href="Prelude.Equality.html#6403" class="Bound">b</a> <a id="6424" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6426" href="Prelude.Equality.html#6405" class="Bound">y</a> <a id="6428" class="Symbol">→</a> <a id="6430" class="Symbol">(</a><a id="6431" href="Prelude.Equality.html#6394" class="Bound">a</a> <a id="6433" href="MGS-MLTT.html#2929" class="InductiveConstructor Operator">,</a> <a id="6435" href="Prelude.Equality.html#6403" class="Bound">b</a><a id="6436" class="Symbol">)</a> <a id="6438" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6440" class="Symbol">(</a><a id="6441" href="Prelude.Equality.html#6396" class="Bound">x</a> <a id="6443" href="MGS-MLTT.html#2929" class="InductiveConstructor Operator">,</a> <a id="6445" href="Prelude.Equality.html#6405" class="Bound">y</a><a id="6446" class="Symbol">)</a>
 <a id="6449" href="Prelude.Equality.html#6365" class="Function">≡-×-int</a> <a id="6457" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6462" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6467" class="Symbol">=</a> <a id="6469" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>
</pre>

-------------------------------------

<sup>1</sup><span class="footnote" id="fn1">To hide code from the rest of the development, we enclose it in a named module.  For example, the code inside the `hide-refl` module will not conflict with the original definitions from the [Type Topology][] library, even though we import the latter right after repeating their definitions.  As long as we don't invoke `open hide-refl`, the code inside the `hide-refl` module remains essentially hidden (though Agda *will* type-check this code). It may seem odd to both define things in the hidden module only to immediately import the definition that we actually use, but we do this in an attempt to exhibit all of the types on which the [UALib][] depends, in a clear and self-contained way, while also ensuring that this cannot be misinterpreted as a claim to originality.</span>

<sup>2</sup><span class="footnote" id="fn2"> Here we put the definition inside an *anonymous module*, which starts with the `module` keyword followed by an underscore (instead of a module name). The purpose is simply to move the postulated typing judgments (the "parameters" of the module, e.g., `𝓤 : Universe` and `X : 𝓤 ̇` out of the way so they don't obfuscate the definitions inside the module.</span>

<sup>3</sup><span class="footnote" id="fn3"> **Unicode Hints**. In [agda2-mode][] type `⁻¹` as `\^-\^1`, type `𝑖𝑑` as `\Mii\Mid`, and type `∙` as `\.`. In general, to get information about a given unicode character (e.g., how to type it) place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>

<sup>4</sup><span class="footnote" id="fn4"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170).

<p></p>
<p></p>


[← Prelude.Preliminaries ](Prelude.Preliminaries.html)
<span style="float:right;">[Prelude.Extensionality →](Prelude.Extensionality.html)</span>

{% include UALib.Links.md %}
