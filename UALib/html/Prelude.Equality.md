---
layout: default
title : UALib.Prelude.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This is the [UALib.Prelude.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="276" class="Symbol">{-#</a> <a id="280" class="Keyword">OPTIONS</a> <a id="288" class="Pragma">--without-K</a> <a id="300" class="Pragma">--exact-split</a> <a id="314" class="Pragma">--safe</a> <a id="321" class="Symbol">#-}</a>

<a id="326" class="Keyword">module</a> <a id="333" href="Prelude.Equality.html" class="Module">Prelude.Equality</a> <a id="350" class="Keyword">where</a>

<a id="357" class="Keyword">open</a> <a id="362" class="Keyword">import</a> <a id="369" href="Prelude.Preliminaries.html" class="Module">Prelude.Preliminaries</a> <a id="391" class="Keyword">public</a>

</pre>

#### <a id="definitional-equality">Definitional equality</a>

Here we discuss what is probably the most important type in [MLTT][]. It is called *definitional equality*. This concept is easily understood, at least heuristically, with the following slogan:

*Definitional equality is the substitution-preserving equivalence relation generated by definitions.*

We will make this precise below, but first let us quote from a primary source. Per Martin-Löof offers the following definition (italics added):<sup>[1](Prelude.Equality.html#fn1)</sup>

"*Definitional equality* is defined to be the equivalence relation, that is, reflexive, symmetric and transitive relation, which is generated by the principles that a definiendum is always definitionally equal to its definiens and that definitional equality is preserved under substitution."<sup>[2](Prelude.Equality.html#fn2)

To be sure we understand what this means, let `:=` denote the relation with respect to which `x` is related to `y` (denoted `x := y`) if and only if `y` *is the definition of* `x`.  Then the definitional equality relation `≡` is the reflexive, symmetric, transitive, substitutive closure of `:=`. By *subsitutive closure* we mean closure under the following *substitution rule*.

<!--
\begin{prooftree}
\AxiomC{`\{A : 𝓤 ̇\}\{B : A → 𝓦 ̇\}\{x y : A\}`}
\AxiomC{`x ≡ y`}
\Rightlabel{(subst)}
\BinaryInfC{`B x ≡ B y`}
\end{prooftree}
-->

```agda
    {A : 𝓤 ̇} {B : A → 𝓦 ̇} {x y : A}   x ≡ y
    ------------------------------------------
                B x ≡ B y
```

The datatype we use to represent definitional equality is imported from the Identity-Type module of the [Type Topology][] library, but apart from superficial syntactic differences, it is equivalent to the identity type used in all other Agda libraries we know of.  We repeat the definition here for easy reference.

<pre class="Agda">

<a id="2283" class="Keyword">module</a> <a id="hide-refl"></a><a id="2290" href="Prelude.Equality.html#2290" class="Module">hide-refl</a> <a id="2300" class="Symbol">{</a><a id="2301" href="Prelude.Equality.html#2301" class="Bound">𝓤</a> <a id="2303" class="Symbol">:</a> <a id="2305" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2313" class="Symbol">}</a> <a id="2315" class="Keyword">where</a>

 <a id="2323" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="2328" href="Prelude.Equality.html#2328" class="Datatype Operator">_≡_</a> <a id="2332" class="Symbol">{</a><a id="2333" href="Prelude.Equality.html#2333" class="Bound">𝓤</a><a id="2334" class="Symbol">}</a> <a id="2336" class="Symbol">{</a><a id="2337" href="Prelude.Equality.html#2337" class="Bound">A</a> <a id="2339" class="Symbol">:</a> <a id="2341" href="Prelude.Equality.html#2333" class="Bound">𝓤</a> <a id="2343" href="Universes.html#403" class="Function Operator">̇</a> <a id="2345" class="Symbol">}</a> <a id="2347" class="Symbol">:</a> <a id="2349" href="Prelude.Equality.html#2337" class="Bound">A</a> <a id="2351" class="Symbol">→</a> <a id="2353" href="Prelude.Equality.html#2337" class="Bound">A</a> <a id="2355" class="Symbol">→</a> <a id="2357" href="Prelude.Equality.html#2333" class="Bound">𝓤</a> <a id="2359" href="Universes.html#403" class="Function Operator">̇</a> <a id="2361" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="2367" href="Prelude.Equality.html#2367" class="InductiveConstructor">refl</a> <a id="2372" class="Symbol">:</a> <a id="2374" class="Symbol">{</a><a id="2375" href="Prelude.Equality.html#2375" class="Bound">x</a> <a id="2377" class="Symbol">:</a> <a id="2379" href="Prelude.Equality.html#2337" class="Bound">A</a><a id="2380" class="Symbol">}</a> <a id="2382" class="Symbol">→</a> <a id="2384" href="Prelude.Equality.html#2375" class="Bound">x</a> <a id="2386" href="Prelude.Equality.html#2328" class="Datatype Operator">≡</a> <a id="2388" href="Prelude.Equality.html#2375" class="Bound">x</a>

<a id="2391" class="Keyword">open</a> <a id="2396" class="Keyword">import</a> <a id="2403" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="2417" class="Keyword">renaming</a> <a id="2426" class="Symbol">(</a><a id="2427" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="2431" class="Symbol">to</a> <a id="2434" class="Keyword">infix</a> <a id="2440" class="Number">0</a> <a id="_≡_"></a><a id="2442" href="Prelude.Equality.html#2442" class="Datatype Operator">_≡_</a><a id="2445" class="Symbol">)</a> <a id="2447" class="Keyword">public</a>

</pre>

Whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we invoke `refl`.  If we need to make explicit the implicit argument `x`, then we use `refl\{x = x\}`.

Of course `≡` is an equivalence relation and the formal proof of this fact is trivial. We don't need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

<pre class="Agda">

<a id="2919" class="Keyword">module</a> <a id="2926" href="Prelude.Equality.html#2926" class="Module">_</a>  <a id="2929" class="Symbol">{</a><a id="2930" href="Prelude.Equality.html#2930" class="Bound">𝓤</a> <a id="2932" class="Symbol">:</a> <a id="2934" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2942" class="Symbol">}{</a><a id="2944" href="Prelude.Equality.html#2944" class="Bound">A</a> <a id="2946" class="Symbol">:</a> <a id="2948" href="Prelude.Equality.html#2930" class="Bound">𝓤</a> <a id="2950" href="Universes.html#403" class="Function Operator">̇</a> <a id="2952" class="Symbol">}</a>  <a id="2955" class="Keyword">where</a>

 <a id="2963" href="Prelude.Equality.html#2963" class="Function">≡-symmetric</a> <a id="2975" class="Symbol">:</a> <a id="2977" class="Symbol">(</a><a id="2978" href="Prelude.Equality.html#2978" class="Bound">x</a> <a id="2980" href="Prelude.Equality.html#2980" class="Bound">y</a> <a id="2982" class="Symbol">:</a> <a id="2984" href="Prelude.Equality.html#2944" class="Bound">A</a><a id="2985" class="Symbol">)</a> <a id="2987" class="Symbol">→</a> <a id="2989" href="Prelude.Equality.html#2978" class="Bound">x</a> <a id="2991" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="2993" href="Prelude.Equality.html#2980" class="Bound">y</a> <a id="2995" class="Symbol">→</a> <a id="2997" href="Prelude.Equality.html#2980" class="Bound">y</a> <a id="2999" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3001" href="Prelude.Equality.html#2978" class="Bound">x</a>
 <a id="3004" href="Prelude.Equality.html#2963" class="Function">≡-symmetric</a> <a id="3016" class="Symbol">_</a> <a id="3018" class="Symbol">_</a> <a id="3020" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3025" class="Symbol">=</a> <a id="3027" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3034" href="Prelude.Equality.html#3034" class="Function">≡-sym</a> <a id="3040" class="Symbol">:</a> <a id="3042" class="Symbol">{</a><a id="3043" href="Prelude.Equality.html#3043" class="Bound">x</a> <a id="3045" href="Prelude.Equality.html#3045" class="Bound">y</a> <a id="3047" class="Symbol">:</a> <a id="3049" href="Prelude.Equality.html#2944" class="Bound">A</a><a id="3050" class="Symbol">}</a> <a id="3052" class="Symbol">→</a> <a id="3054" href="Prelude.Equality.html#3043" class="Bound">x</a> <a id="3056" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3058" href="Prelude.Equality.html#3045" class="Bound">y</a> <a id="3060" class="Symbol">→</a> <a id="3062" href="Prelude.Equality.html#3045" class="Bound">y</a> <a id="3064" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3066" href="Prelude.Equality.html#3043" class="Bound">x</a>
 <a id="3069" href="Prelude.Equality.html#3034" class="Function">≡-sym</a> <a id="3075" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3080" class="Symbol">=</a> <a id="3082" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3089" href="Prelude.Equality.html#3089" class="Function">≡-transitive</a> <a id="3102" class="Symbol">:</a> <a id="3104" class="Symbol">(</a><a id="3105" href="Prelude.Equality.html#3105" class="Bound">x</a> <a id="3107" href="Prelude.Equality.html#3107" class="Bound">y</a> <a id="3109" href="Prelude.Equality.html#3109" class="Bound">z</a> <a id="3111" class="Symbol">:</a> <a id="3113" href="Prelude.Equality.html#2944" class="Bound">A</a><a id="3114" class="Symbol">)</a> <a id="3116" class="Symbol">→</a> <a id="3118" href="Prelude.Equality.html#3105" class="Bound">x</a> <a id="3120" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3122" href="Prelude.Equality.html#3107" class="Bound">y</a> <a id="3124" class="Symbol">→</a> <a id="3126" href="Prelude.Equality.html#3107" class="Bound">y</a> <a id="3128" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3130" href="Prelude.Equality.html#3109" class="Bound">z</a> <a id="3132" class="Symbol">→</a> <a id="3134" href="Prelude.Equality.html#3105" class="Bound">x</a> <a id="3136" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3138" href="Prelude.Equality.html#3109" class="Bound">z</a>
 <a id="3141" href="Prelude.Equality.html#3089" class="Function">≡-transitive</a> <a id="3154" class="Symbol">_</a> <a id="3156" class="Symbol">_</a> <a id="3158" class="Symbol">_</a> <a id="3160" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3165" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3170" class="Symbol">=</a> <a id="3172" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3179" href="Prelude.Equality.html#3179" class="Function">≡-trans</a> <a id="3187" class="Symbol">:</a> <a id="3189" class="Symbol">{</a><a id="3190" href="Prelude.Equality.html#3190" class="Bound">x</a> <a id="3192" href="Prelude.Equality.html#3192" class="Bound">y</a> <a id="3194" href="Prelude.Equality.html#3194" class="Bound">z</a> <a id="3196" class="Symbol">:</a> <a id="3198" href="Prelude.Equality.html#2944" class="Bound">A</a><a id="3199" class="Symbol">}</a> <a id="3201" class="Symbol">→</a> <a id="3203" href="Prelude.Equality.html#3190" class="Bound">x</a> <a id="3205" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3207" href="Prelude.Equality.html#3192" class="Bound">y</a> <a id="3209" class="Symbol">→</a> <a id="3211" href="Prelude.Equality.html#3192" class="Bound">y</a> <a id="3213" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3215" href="Prelude.Equality.html#3194" class="Bound">z</a> <a id="3217" class="Symbol">→</a> <a id="3219" href="Prelude.Equality.html#3190" class="Bound">x</a> <a id="3221" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3223" href="Prelude.Equality.html#3194" class="Bound">z</a>
 <a id="3226" href="Prelude.Equality.html#3179" class="Function">≡-trans</a> <a id="3234" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3239" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3244" class="Symbol">=</a> <a id="3246" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

The only difference between `≡-symmetric` and `≡-sym` (respectively, `≡-transitive` and `≡-trans`) is that the latter has fewer explicit arguments, which is sometimes convenient.

We prove that `≡` obeys the substitution rule (subst) in the next subsection (see the definition of `ap` below), but first we define some syntactic sugar that will make it easier to apply symmetry and transitivity of `≡` in proofs.<sup>[3](Prelude.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="3732" class="Keyword">module</a> <a id="hide-sym-trans"></a><a id="3739" href="Prelude.Equality.html#3739" class="Module">hide-sym-trans</a> <a id="3754" class="Symbol">{</a><a id="3755" href="Prelude.Equality.html#3755" class="Bound">𝓤</a> <a id="3757" class="Symbol">:</a> <a id="3759" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3767" class="Symbol">}</a> <a id="3769" class="Symbol">{</a><a id="3770" href="Prelude.Equality.html#3770" class="Bound">A</a> <a id="3772" class="Symbol">:</a> <a id="3774" href="Prelude.Equality.html#3755" class="Bound">𝓤</a> <a id="3776" href="Universes.html#403" class="Function Operator">̇</a> <a id="3778" class="Symbol">}</a> <a id="3780" class="Keyword">where</a>

 <a id="hide-sym-trans._⁻¹"></a><a id="3788" href="Prelude.Equality.html#3788" class="Function Operator">_⁻¹</a> <a id="3792" class="Symbol">:</a> <a id="3794" class="Symbol">{</a><a id="3795" href="Prelude.Equality.html#3795" class="Bound">x</a> <a id="3797" href="Prelude.Equality.html#3797" class="Bound">y</a> <a id="3799" class="Symbol">:</a> <a id="3801" href="Prelude.Equality.html#3770" class="Bound">A</a><a id="3802" class="Symbol">}</a> <a id="3804" class="Symbol">→</a> <a id="3806" href="Prelude.Equality.html#3795" class="Bound">x</a> <a id="3808" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3810" href="Prelude.Equality.html#3797" class="Bound">y</a> <a id="3812" class="Symbol">→</a> <a id="3814" href="Prelude.Equality.html#3797" class="Bound">y</a> <a id="3816" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="3818" href="Prelude.Equality.html#3795" class="Bound">x</a>
 <a id="3821" href="Prelude.Equality.html#3821" class="Bound">p</a> <a id="3823" href="Prelude.Equality.html#3788" class="Function Operator">⁻¹</a> <a id="3826" class="Symbol">=</a> <a id="3828" href="Prelude.Equality.html#3034" class="Function">≡-sym</a> <a id="3834" href="Prelude.Equality.html#3821" class="Bound">p</a>

</pre>

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` . Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.

<pre class="Agda">

 <a id="hide-sym-trans._∙_"></a><a id="4093" href="Prelude.Equality.html#4093" class="Function Operator">_∙_</a> <a id="4097" class="Symbol">:</a> <a id="4099" class="Symbol">{</a><a id="4100" href="Prelude.Equality.html#4100" class="Bound">x</a> <a id="4102" href="Prelude.Equality.html#4102" class="Bound">y</a> <a id="4104" href="Prelude.Equality.html#4104" class="Bound">z</a> <a id="4106" class="Symbol">:</a> <a id="4108" href="Prelude.Equality.html#3770" class="Bound">A</a><a id="4109" class="Symbol">}</a> <a id="4111" class="Symbol">→</a> <a id="4113" href="Prelude.Equality.html#4100" class="Bound">x</a> <a id="4115" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="4117" href="Prelude.Equality.html#4102" class="Bound">y</a> <a id="4119" class="Symbol">→</a> <a id="4121" href="Prelude.Equality.html#4102" class="Bound">y</a> <a id="4123" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="4125" href="Prelude.Equality.html#4104" class="Bound">z</a> <a id="4127" class="Symbol">→</a> <a id="4129" href="Prelude.Equality.html#4100" class="Bound">x</a> <a id="4131" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="4133" href="Prelude.Equality.html#4104" class="Bound">z</a>
 <a id="4136" href="Prelude.Equality.html#4136" class="Bound">p</a> <a id="4138" href="Prelude.Equality.html#4093" class="Function Operator">∙</a> <a id="4140" href="Prelude.Equality.html#4140" class="Bound">q</a> <a id="4142" class="Symbol">=</a> <a id="4144" href="Prelude.Equality.html#3179" class="Function">≡-trans</a> <a id="4152" href="Prelude.Equality.html#4136" class="Bound">p</a> <a id="4154" href="Prelude.Equality.html#4140" class="Bound">q</a>

</pre>

As usual, we import the original definitions from the [Type Topology][] library.

<pre class="Agda">

<a id="4265" class="Keyword">open</a> <a id="4270" class="Keyword">import</a> <a id="4277" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="4286" class="Keyword">using</a> <a id="4292" class="Symbol">(</a><a id="4293" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="4296" class="Symbol">;</a> <a id="4298" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="4301" class="Symbol">)</a> <a id="4303" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Prelude.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[2](Preliminaries.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="4996" class="Keyword">module</a> <a id="hide-id-transport"></a><a id="5003" href="Prelude.Equality.html#5003" class="Module">hide-id-transport</a> <a id="5021" class="Symbol">{</a><a id="5022" href="Prelude.Equality.html#5022" class="Bound">𝓤</a> <a id="5024" href="Prelude.Equality.html#5024" class="Bound">𝓦</a> <a id="5026" class="Symbol">:</a> <a id="5028" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5036" class="Symbol">}</a> <a id="5038" class="Keyword">where</a>

 <a id="hide-id-transport.𝑖𝑑"></a><a id="5046" href="Prelude.Equality.html#5046" class="Function">𝑖𝑑</a> <a id="5049" class="Symbol">:</a> <a id="5051" class="Symbol">{</a><a id="5052" href="Prelude.Equality.html#5052" class="Bound">𝓧</a> <a id="5054" class="Symbol">:</a> <a id="5056" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5064" class="Symbol">}</a> <a id="5066" class="Symbol">(</a><a id="5067" href="Prelude.Equality.html#5067" class="Bound">X</a> <a id="5069" class="Symbol">:</a> <a id="5071" href="Prelude.Equality.html#5052" class="Bound">𝓧</a> <a id="5073" href="Universes.html#403" class="Function Operator">̇</a> <a id="5075" class="Symbol">)</a> <a id="5077" class="Symbol">→</a> <a id="5079" href="Prelude.Equality.html#5067" class="Bound">X</a> <a id="5081" class="Symbol">→</a> <a id="5083" href="Prelude.Equality.html#5067" class="Bound">X</a>
 <a id="5086" href="Prelude.Equality.html#5046" class="Function">𝑖𝑑</a> <a id="5089" href="Prelude.Equality.html#5089" class="Bound">X</a> <a id="5091" class="Symbol">=</a> <a id="5093" class="Symbol">λ</a> <a id="5095" href="Prelude.Equality.html#5095" class="Bound">x</a> <a id="5097" class="Symbol">→</a> <a id="5099" href="Prelude.Equality.html#5095" class="Bound">x</a>

 <a id="hide-id-transport.transport"></a><a id="5103" href="Prelude.Equality.html#5103" class="Function">transport</a> <a id="5113" class="Symbol">:</a> <a id="5115" class="Symbol">{</a><a id="5116" href="Prelude.Equality.html#5116" class="Bound">A</a> <a id="5118" class="Symbol">:</a> <a id="5120" href="Prelude.Equality.html#5022" class="Bound">𝓤</a> <a id="5122" href="Universes.html#403" class="Function Operator">̇</a> <a id="5124" class="Symbol">}</a> <a id="5126" class="Symbol">(</a><a id="5127" href="Prelude.Equality.html#5127" class="Bound">B</a> <a id="5129" class="Symbol">:</a> <a id="5131" href="Prelude.Equality.html#5116" class="Bound">A</a> <a id="5133" class="Symbol">→</a> <a id="5135" href="Prelude.Equality.html#5024" class="Bound">𝓦</a> <a id="5137" href="Universes.html#403" class="Function Operator">̇</a> <a id="5139" class="Symbol">)</a> <a id="5141" class="Symbol">{</a><a id="5142" href="Prelude.Equality.html#5142" class="Bound">x</a> <a id="5144" href="Prelude.Equality.html#5144" class="Bound">y</a> <a id="5146" class="Symbol">:</a> <a id="5148" href="Prelude.Equality.html#5116" class="Bound">A</a><a id="5149" class="Symbol">}</a> <a id="5151" class="Symbol">→</a> <a id="5153" href="Prelude.Equality.html#5142" class="Bound">x</a> <a id="5155" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="5157" href="Prelude.Equality.html#5144" class="Bound">y</a> <a id="5159" class="Symbol">→</a> <a id="5161" href="Prelude.Equality.html#5127" class="Bound">B</a> <a id="5163" href="Prelude.Equality.html#5142" class="Bound">x</a> <a id="5165" class="Symbol">→</a> <a id="5167" href="Prelude.Equality.html#5127" class="Bound">B</a> <a id="5169" href="Prelude.Equality.html#5144" class="Bound">y</a>
 <a id="5172" href="Prelude.Equality.html#5103" class="Function">transport</a> <a id="5182" href="Prelude.Equality.html#5182" class="Bound">B</a> <a id="5184" class="Symbol">(</a><a id="5185" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5190" class="Symbol">{</a><a id="5191" class="Argument">x</a> <a id="5193" class="Symbol">=</a> <a id="5195" href="Prelude.Equality.html#5195" class="Bound">x</a><a id="5196" class="Symbol">})</a> <a id="5199" class="Symbol">=</a> <a id="5201" href="Prelude.Equality.html#5046" class="Function">𝑖𝑑</a> <a id="5204" class="Symbol">(</a><a id="5205" href="Prelude.Equality.html#5182" class="Bound">B</a> <a id="5207" href="Prelude.Equality.html#5195" class="Bound">x</a><a id="5208" class="Symbol">)</a>

<a id="5211" class="Keyword">open</a> <a id="5216" class="Keyword">import</a> <a id="5223" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5232" class="Keyword">using</a> <a id="5238" class="Symbol">(</a><a id="5239" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="5241" class="Symbol">;</a> <a id="5243" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="5252" class="Symbol">)</a> <a id="5254" class="Keyword">public</a>

</pre>

As usual, we display definitions of existing types (here, `𝑖𝑑` and `transport`) in a hidden module and then imported their original definition from [Type Topology][].

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="5886" class="Keyword">module</a> <a id="hide-ap"></a><a id="5893" href="Prelude.Equality.html#5893" class="Module">hide-ap</a>  <a id="5902" class="Symbol">{</a><a id="5903" href="Prelude.Equality.html#5903" class="Bound">𝓤</a> <a id="5905" href="Prelude.Equality.html#5905" class="Bound">𝓦</a> <a id="5907" class="Symbol">:</a> <a id="5909" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5917" class="Symbol">}{</a><a id="5919" href="Prelude.Equality.html#5919" class="Bound">A</a> <a id="5921" class="Symbol">:</a> <a id="5923" href="Prelude.Equality.html#5903" class="Bound">𝓤</a> <a id="5925" href="Universes.html#403" class="Function Operator">̇</a><a id="5926" class="Symbol">}{</a><a id="5928" href="Prelude.Equality.html#5928" class="Bound">B</a> <a id="5930" class="Symbol">:</a> <a id="5932" href="Prelude.Equality.html#5905" class="Bound">𝓦</a> <a id="5934" href="Universes.html#403" class="Function Operator">̇</a><a id="5935" class="Symbol">}</a> <a id="5937" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="5945" href="Prelude.Equality.html#5945" class="Function">ap</a> <a id="5948" class="Symbol">:</a> <a id="5950" class="Symbol">(</a><a id="5951" href="Prelude.Equality.html#5951" class="Bound">f</a> <a id="5953" class="Symbol">:</a> <a id="5955" href="Prelude.Equality.html#5919" class="Bound">A</a> <a id="5957" class="Symbol">→</a> <a id="5959" href="Prelude.Equality.html#5928" class="Bound">B</a><a id="5960" class="Symbol">){</a><a id="5962" href="Prelude.Equality.html#5962" class="Bound">x</a> <a id="5964" href="Prelude.Equality.html#5964" class="Bound">y</a> <a id="5966" class="Symbol">:</a> <a id="5968" href="Prelude.Equality.html#5919" class="Bound">A</a><a id="5969" class="Symbol">}</a> <a id="5971" class="Symbol">→</a> <a id="5973" href="Prelude.Equality.html#5962" class="Bound">x</a> <a id="5975" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="5977" href="Prelude.Equality.html#5964" class="Bound">y</a> <a id="5979" class="Symbol">→</a> <a id="5981" href="Prelude.Equality.html#5951" class="Bound">f</a> <a id="5983" href="Prelude.Equality.html#5962" class="Bound">x</a> <a id="5985" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="5987" href="Prelude.Equality.html#5951" class="Bound">f</a> <a id="5989" href="Prelude.Equality.html#5964" class="Bound">y</a>
 <a id="5992" href="Prelude.Equality.html#5945" class="Function">ap</a> <a id="5995" href="Prelude.Equality.html#5995" class="Bound">f</a> <a id="5997" class="Symbol">{</a><a id="5998" href="Prelude.Equality.html#5998" class="Bound">x</a><a id="5999" class="Symbol">}</a> <a id="6001" href="Prelude.Equality.html#6001" class="Bound">p</a> <a id="6003" class="Symbol">=</a> <a id="6005" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="6015" class="Symbol">(λ</a> <a id="6018" href="Prelude.Equality.html#6018" class="Bound">-</a> <a id="6020" class="Symbol">→</a> <a id="6022" href="Prelude.Equality.html#5995" class="Bound">f</a> <a id="6024" href="Prelude.Equality.html#5998" class="Bound">x</a> <a id="6026" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="6028" href="Prelude.Equality.html#5995" class="Bound">f</a> <a id="6030" href="Prelude.Equality.html#6018" class="Bound">-</a><a id="6031" class="Symbol">)</a> <a id="6033" href="Prelude.Equality.html#6001" class="Bound">p</a> <a id="6035" class="Symbol">(</a><a id="6036" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6041" class="Symbol">{</a><a id="6042" class="Argument">x</a> <a id="6044" class="Symbol">=</a> <a id="6046" href="Prelude.Equality.html#5995" class="Bound">f</a> <a id="6048" href="Prelude.Equality.html#5998" class="Bound">x</a><a id="6049" class="Symbol">})</a>

<a id="6053" class="Keyword">open</a> <a id="6058" class="Keyword">import</a> <a id="6065" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="6074" class="Keyword">using</a> <a id="6080" class="Symbol">(</a><a id="6081" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="6083" class="Symbol">)</a> <a id="6085" class="Keyword">public</a>

</pre>

Here's a useful variation of `ap` that we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][] (transcribed into TypeTopology/UALib notation of course).

<pre class="Agda">

<a id="6304" class="Keyword">module</a> <a id="6311" href="Prelude.Equality.html#6311" class="Module">_</a> <a id="6313" class="Symbol">{</a><a id="6314" href="Prelude.Equality.html#6314" class="Bound">𝓤</a> <a id="6316" href="Prelude.Equality.html#6316" class="Bound">𝓦</a> <a id="6318" class="Symbol">:</a> <a id="6320" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6328" class="Symbol">}</a> <a id="6330" class="Keyword">where</a>

 <a id="6338" href="Prelude.Equality.html#6338" class="Function">cong-app</a> <a id="6347" class="Symbol">:</a> <a id="6349" class="Symbol">{</a><a id="6350" href="Prelude.Equality.html#6350" class="Bound">A</a> <a id="6352" class="Symbol">:</a> <a id="6354" href="Prelude.Equality.html#6314" class="Bound">𝓤</a> <a id="6356" href="Universes.html#403" class="Function Operator">̇</a><a id="6357" class="Symbol">}{</a><a id="6359" href="Prelude.Equality.html#6359" class="Bound">B</a> <a id="6361" class="Symbol">:</a> <a id="6363" href="Prelude.Equality.html#6350" class="Bound">A</a> <a id="6365" class="Symbol">→</a> <a id="6367" href="Prelude.Equality.html#6316" class="Bound">𝓦</a> <a id="6369" href="Universes.html#403" class="Function Operator">̇</a><a id="6370" class="Symbol">}{</a><a id="6372" href="Prelude.Equality.html#6372" class="Bound">f</a> <a id="6374" href="Prelude.Equality.html#6374" class="Bound">g</a> <a id="6376" class="Symbol">:</a> <a id="6378" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="6380" href="Prelude.Equality.html#6359" class="Bound">B</a><a id="6381" class="Symbol">}</a> <a id="6383" class="Symbol">→</a> <a id="6385" href="Prelude.Equality.html#6372" class="Bound">f</a> <a id="6387" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="6389" href="Prelude.Equality.html#6374" class="Bound">g</a> <a id="6391" class="Symbol">→</a> <a id="6393" class="Symbol">∀</a> <a id="6395" href="Prelude.Equality.html#6395" class="Bound">x</a> <a id="6397" class="Symbol">→</a> <a id="6399" href="Prelude.Equality.html#6372" class="Bound">f</a> <a id="6401" href="Prelude.Equality.html#6395" class="Bound">x</a> <a id="6403" href="Prelude.Equality.html#2442" class="Datatype Operator">≡</a> <a id="6405" href="Prelude.Equality.html#6374" class="Bound">g</a> <a id="6407" href="Prelude.Equality.html#6395" class="Bound">x</a>
 <a id="6410" href="Prelude.Equality.html#6338" class="Function">cong-app</a> <a id="6419" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6424" class="Symbol">_</a> <a id="6426" class="Symbol">=</a> <a id="6428" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>





-------------------------------------


<sup>1</sup><span class="footnote" id="fn1"> Per Martin-Löf, *An intuitionistic theory of types: predicative part*, Logic Colloquium '73 (Bristol, 1973), 73--118, Studies in Logic and the Foundations of Mathematics, Vol. 80, 1975.

<sup>2</sup><span class="footnote" id="fn2"> The *definiendum* is the left-hand side of a defining equation, the *definiens* is the right-hand side. For readers who have never generated an equivalence relation: the *reflexive closure* of `R ⊆ A × A `is the union of `R` and all pairs of the form `(a , a)`; the *symmetric closure* is the union of R and its inverse `\{(y , x) : (x , y) ∈ R\}`; we leave it to the reader to come up with the correct definition of transitive closure.

<sup>3</sup><span class="footnote" id="fn3"> **Unicode Hints** ([agda2-mode][]). `\^-\^1 ↝ ⁻¹`; `\Mii\Mid ↝ 𝑖𝑑`; `\. ↝ ∙`. In general, for information about a character, place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>



<sup>4</sup><span class="footnote" id="fn4"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170). See also [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).<span>

<p></p>
<p></p>


[← Prelude.Preliminaries ](Prelude.Preliminaries.html)
<span style="float:right;">[Prelude.Extensionality →](Prelude.Extensionality.html)</span>

{% include UALib.Links.md %}


<!-- NO LONGER USED

#### <a id="≡-intro-and-≡-elim-for-nondependent-pairs">≡-intro and ≡-elim for nondependent pairs</a>

We conclude the Equality module with some occasionally useful introduction and elimination rules for the equality relation on (nondependent) pair types.

 ≡-elim-left : {A₁ A₂ : 𝓤 ̇}{B₁ B₂ : 𝓦 ̇} → (A₁ , B₁) ≡ (A₂ , B₂) → A₁ ≡ A₂
 ≡-elim-left e = ap fst e


 ≡-elim-right : {A₁ A₂ : 𝓤 ̇}{B₁ B₂ : 𝓦 ̇} → (A₁ , B₁) ≡ (A₂ , B₂) → B₁ ≡ B₂
 ≡-elim-right e = ap snd e


 ≡-×-intro : {A₁ A₂ : 𝓤 ̇} {B₁ B₂ : 𝓦 ̇} → A₁ ≡ A₂ → B₁ ≡ B₂ → (A₁ , B₁) ≡ (A₂ , B₂)
 ≡-×-intro refl refl = refl


 ≡-×-int : {A : 𝓤 ̇}{B : 𝓦 ̇}{a x : A}{b y : B} → a ≡ x → b ≡ y → (a , b) ≡ (x , y)
 ≡-×-int refl refl = refl

-->
