---
layout: default
title : UALib.Prelude.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This section describes the [UALib.Prelude.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="291" class="Symbol">{-#</a> <a id="295" class="Keyword">OPTIONS</a> <a id="303" class="Pragma">--without-K</a> <a id="315" class="Pragma">--exact-split</a> <a id="329" class="Pragma">--safe</a> <a id="336" class="Symbol">#-}</a>

<a id="341" class="Keyword">module</a> <a id="348" href="Prelude.Equality.html" class="Module">Prelude.Equality</a> <a id="365" class="Keyword">where</a>

<a id="372" class="Keyword">open</a> <a id="377" class="Keyword">import</a> <a id="384" href="Prelude.Preliminaries.html" class="Module">Prelude.Preliminaries</a> <a id="406" class="Keyword">public</a>

</pre>

#### <a id="refl">refl</a>

The type referred to as "reflexivity" or "refl" is a very basic but important one. It represents [definitional equality](https://ncatlab.org/nlab/show/equality#definitional_equality).

The `refl` type we use is a standard one. It is defined in the `Identity-Type` module of the [Type Topology][] library, but apart from syntax it is equivalent to the identity type used in most other Agda libraries.

We make `refl` available by importing it from the `Identity-Type` module.  However, we first repeat the definition here (inside a hidden submodule) for clarity.<sup>[1](Prelude.Equality.html#fn1)</sup>

<pre class="Agda">

<a id="1072" class="Keyword">module</a> <a id="hide-refl"></a><a id="1079" href="Prelude.Equality.html#1079" class="Module">hide-refl</a> <a id="1089" class="Symbol">{</a><a id="1090" href="Prelude.Equality.html#1090" class="Bound">𝓤</a> <a id="1092" class="Symbol">:</a> <a id="1094" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="1102" class="Symbol">}</a> <a id="1104" class="Keyword">where</a>

 <a id="1112" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="1117" href="Prelude.Equality.html#1117" class="Datatype Operator">_≡_</a> <a id="1121" class="Symbol">{</a><a id="1122" href="Prelude.Equality.html#1122" class="Bound">𝓤</a><a id="1123" class="Symbol">}</a> <a id="1125" class="Symbol">{</a><a id="1126" href="Prelude.Equality.html#1126" class="Bound">X</a> <a id="1128" class="Symbol">:</a> <a id="1130" href="Prelude.Equality.html#1122" class="Bound">𝓤</a> <a id="1132" href="Universes.html#403" class="Function Operator">̇</a> <a id="1134" class="Symbol">}</a> <a id="1136" class="Symbol">:</a> <a id="1138" href="Prelude.Equality.html#1126" class="Bound">X</a> <a id="1140" class="Symbol">→</a> <a id="1142" href="Prelude.Equality.html#1126" class="Bound">X</a> <a id="1144" class="Symbol">→</a> <a id="1146" href="Prelude.Equality.html#1122" class="Bound">𝓤</a> <a id="1148" href="Universes.html#403" class="Function Operator">̇</a> <a id="1150" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="1156" href="Prelude.Equality.html#1156" class="InductiveConstructor">refl</a> <a id="1161" class="Symbol">:</a> <a id="1163" class="Symbol">{</a><a id="1164" href="Prelude.Equality.html#1164" class="Bound">x</a> <a id="1166" class="Symbol">:</a> <a id="1168" href="Prelude.Equality.html#1126" class="Bound">X</a><a id="1169" class="Symbol">}</a> <a id="1171" class="Symbol">→</a> <a id="1173" href="Prelude.Equality.html#1164" class="Bound">x</a> <a id="1175" href="Prelude.Equality.html#1117" class="Datatype Operator">≡</a> <a id="1177" href="Prelude.Equality.html#1164" class="Bound">x</a>

<a id="1180" class="Keyword">open</a> <a id="1185" class="Keyword">import</a> <a id="1192" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="1206" class="Keyword">renaming</a> <a id="1215" class="Symbol">(</a><a id="1216" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="1220" class="Symbol">to</a> <a id="1223" class="Keyword">infix</a> <a id="1229" class="Number">0</a> <a id="_≡_"></a><a id="1231" href="Prelude.Equality.html#1231" class="Datatype Operator">_≡_</a> <a id="1235" class="Symbol">;</a> <a id="1237" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="1242" class="Symbol">to</a> <a id="refl"></a><a id="1245" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a><a id="1249" class="Symbol">)</a> <a id="1251" class="Keyword">public</a>

</pre>

Since `refl _` is used so often, the following convenient shorthand is also provided in the [Type Topology][] library.

<pre class="Agda">

<a id="1405" class="Keyword">pattern</a> <a id="refl"></a><a id="1413" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="1418" href="Prelude.Equality.html#1432" class="Bound">x</a> <a id="1420" class="Symbol">=</a> <a id="1422" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="1427" class="Symbol">{</a>x <a id="1430" class="Symbol">=</a> <a id="1432" href="Prelude.Equality.html#1432" class="Bound">x</a><a id="1433" class="Symbol">}</a>
</pre>

Thus, whenever we need to complete a proof by simply asserting that `x`, or the (possibly implicit) thing in question, is definitionally equal to itself, we can invoke `refl x`, or (in the implicit case) `refl _` or even `𝓇ℯ𝒻𝓁`. (The `pattern` directive above is what makes last option available.)


Let us now formalize the obvious fact that `≡` is an equivalence relation.

First we import the original definitions of `_≡_` and `refl` from the [Type Topology][] library. (The definition given above, inside the `hide-refl` module, was merely for illustration.)

<pre class="Agda">


<a id="2026" class="Keyword">module</a> <a id="2033" href="Prelude.Equality.html#2033" class="Module">_</a>  <a id="2036" class="Symbol">{</a><a id="2037" href="Prelude.Equality.html#2037" class="Bound">𝓤</a> <a id="2039" class="Symbol">:</a> <a id="2041" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2049" class="Symbol">}{</a><a id="2051" href="Prelude.Equality.html#2051" class="Bound">X</a> <a id="2053" class="Symbol">:</a> <a id="2055" href="Prelude.Equality.html#2037" class="Bound">𝓤</a> <a id="2057" href="Universes.html#403" class="Function Operator">̇</a> <a id="2059" class="Symbol">}</a>  <a id="2062" class="Keyword">where</a>
 <a id="2069" href="Prelude.Equality.html#2069" class="Function">≡-rfl</a> <a id="2075" class="Symbol">:</a> <a id="2077" class="Symbol">(</a><a id="2078" href="Prelude.Equality.html#2078" class="Bound">x</a> <a id="2080" class="Symbol">:</a> <a id="2082" href="Prelude.Equality.html#2051" class="Bound">X</a><a id="2083" class="Symbol">)</a> <a id="2085" class="Symbol">→</a> <a id="2087" href="Prelude.Equality.html#2078" class="Bound">x</a> <a id="2089" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2091" href="Prelude.Equality.html#2078" class="Bound">x</a>
 <a id="2094" href="Prelude.Equality.html#2069" class="Function">≡-rfl</a> <a id="2100" class="Symbol">_</a> <a id="2102" class="Symbol">=</a> <a id="2104" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a>

 <a id="2111" href="Prelude.Equality.html#2111" class="Function">≡-sym</a> <a id="2117" class="Symbol">:</a> <a id="2119" class="Symbol">(</a><a id="2120" href="Prelude.Equality.html#2120" class="Bound">x</a> <a id="2122" href="Prelude.Equality.html#2122" class="Bound">y</a> <a id="2124" class="Symbol">:</a> <a id="2126" href="Prelude.Equality.html#2051" class="Bound">X</a><a id="2127" class="Symbol">)</a> <a id="2129" class="Symbol">→</a> <a id="2131" href="Prelude.Equality.html#2120" class="Bound">x</a> <a id="2133" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2135" href="Prelude.Equality.html#2122" class="Bound">y</a> <a id="2137" class="Symbol">→</a> <a id="2139" href="Prelude.Equality.html#2122" class="Bound">y</a> <a id="2141" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2143" href="Prelude.Equality.html#2120" class="Bound">x</a>
 <a id="2146" href="Prelude.Equality.html#2111" class="Function">≡-sym</a> <a id="2152" class="Symbol">_</a> <a id="2154" class="Symbol">_</a> <a id="2156" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="2161" class="Symbol">=</a> <a id="2163" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a>

 <a id="2170" href="Prelude.Equality.html#2170" class="Function">≡-SYM</a> <a id="2176" class="Symbol">:</a> <a id="2178" class="Symbol">{</a><a id="2179" href="Prelude.Equality.html#2179" class="Bound">x</a> <a id="2181" href="Prelude.Equality.html#2181" class="Bound">y</a> <a id="2183" class="Symbol">:</a> <a id="2185" href="Prelude.Equality.html#2051" class="Bound">X</a><a id="2186" class="Symbol">}</a> <a id="2188" class="Symbol">→</a> <a id="2190" href="Prelude.Equality.html#2179" class="Bound">x</a> <a id="2192" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2194" href="Prelude.Equality.html#2181" class="Bound">y</a> <a id="2196" class="Symbol">→</a> <a id="2198" href="Prelude.Equality.html#2181" class="Bound">y</a> <a id="2200" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2202" href="Prelude.Equality.html#2179" class="Bound">x</a>
 <a id="2205" href="Prelude.Equality.html#2170" class="Function">≡-SYM</a> <a id="2211" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="2216" class="Symbol">=</a> <a id="2218" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a>

 <a id="2225" href="Prelude.Equality.html#2225" class="Function">≡-trans</a> <a id="2233" class="Symbol">:</a> <a id="2235" class="Symbol">(</a><a id="2236" href="Prelude.Equality.html#2236" class="Bound">x</a> <a id="2238" href="Prelude.Equality.html#2238" class="Bound">y</a> <a id="2240" href="Prelude.Equality.html#2240" class="Bound">z</a> <a id="2242" class="Symbol">:</a> <a id="2244" href="Prelude.Equality.html#2051" class="Bound">X</a><a id="2245" class="Symbol">)</a> <a id="2247" class="Symbol">→</a> <a id="2249" href="Prelude.Equality.html#2236" class="Bound">x</a> <a id="2251" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2253" href="Prelude.Equality.html#2238" class="Bound">y</a> <a id="2255" class="Symbol">→</a> <a id="2257" href="Prelude.Equality.html#2238" class="Bound">y</a> <a id="2259" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2261" href="Prelude.Equality.html#2240" class="Bound">z</a> <a id="2263" class="Symbol">→</a> <a id="2265" href="Prelude.Equality.html#2236" class="Bound">x</a> <a id="2267" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2269" href="Prelude.Equality.html#2240" class="Bound">z</a>
 <a id="2272" href="Prelude.Equality.html#2225" class="Function">≡-trans</a> <a id="2280" class="Symbol">_</a> <a id="2282" class="Symbol">_</a> <a id="2284" class="Symbol">_</a> <a id="2286" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="2291" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="2296" class="Symbol">=</a> <a id="2298" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a>

 <a id="2305" href="Prelude.Equality.html#2305" class="Function">≡-Trans</a> <a id="2313" class="Symbol">:</a> <a id="2315" class="Symbol">(</a><a id="2316" href="Prelude.Equality.html#2316" class="Bound">x</a> <a id="2318" class="Symbol">:</a> <a id="2320" href="Prelude.Equality.html#2051" class="Bound">X</a><a id="2321" class="Symbol">){</a><a id="2323" href="Prelude.Equality.html#2323" class="Bound">y</a> <a id="2325" class="Symbol">:</a> <a id="2327" href="Prelude.Equality.html#2051" class="Bound">X</a><a id="2328" class="Symbol">}(</a><a id="2330" href="Prelude.Equality.html#2330" class="Bound">z</a> <a id="2332" class="Symbol">:</a> <a id="2334" href="Prelude.Equality.html#2051" class="Bound">X</a><a id="2335" class="Symbol">)</a> <a id="2337" class="Symbol">→</a> <a id="2339" href="Prelude.Equality.html#2316" class="Bound">x</a> <a id="2341" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2343" href="Prelude.Equality.html#2323" class="Bound">y</a> <a id="2345" class="Symbol">→</a> <a id="2347" href="Prelude.Equality.html#2323" class="Bound">y</a> <a id="2349" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2351" href="Prelude.Equality.html#2330" class="Bound">z</a> <a id="2353" class="Symbol">→</a> <a id="2355" href="Prelude.Equality.html#2316" class="Bound">x</a> <a id="2357" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2359" href="Prelude.Equality.html#2330" class="Bound">z</a>
 <a id="2362" href="Prelude.Equality.html#2305" class="Function">≡-Trans</a> <a id="2370" class="Symbol">_</a> <a id="2372" class="Symbol">_</a> <a id="2374" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="2379" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="2384" class="Symbol">=</a> <a id="2386" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a>

 <a id="2393" href="Prelude.Equality.html#2393" class="Function">≡-TRANS</a> <a id="2401" class="Symbol">:</a> <a id="2403" class="Symbol">{</a><a id="2404" href="Prelude.Equality.html#2404" class="Bound">x</a> <a id="2406" href="Prelude.Equality.html#2406" class="Bound">y</a> <a id="2408" href="Prelude.Equality.html#2408" class="Bound">z</a> <a id="2410" class="Symbol">:</a> <a id="2412" href="Prelude.Equality.html#2051" class="Bound">X</a><a id="2413" class="Symbol">}</a> <a id="2415" class="Symbol">→</a> <a id="2417" href="Prelude.Equality.html#2404" class="Bound">x</a> <a id="2419" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2421" href="Prelude.Equality.html#2406" class="Bound">y</a> <a id="2423" class="Symbol">→</a> <a id="2425" href="Prelude.Equality.html#2406" class="Bound">y</a> <a id="2427" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2429" href="Prelude.Equality.html#2408" class="Bound">z</a> <a id="2431" class="Symbol">→</a> <a id="2433" href="Prelude.Equality.html#2404" class="Bound">x</a> <a id="2435" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="2437" href="Prelude.Equality.html#2408" class="Bound">z</a>
 <a id="2440" href="Prelude.Equality.html#2393" class="Function">≡-TRANS</a> <a id="2448" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="2453" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a> <a id="2458" class="Symbol">=</a> <a id="2460" href="Prelude.Equality.html#1245" class="InductiveConstructor">𝓇ℯ𝒻𝓁</a>
</pre>

The only difference between `≡-trans` and `≡-Trans` is that the second argument to `≡-Trans` is implicit so we can omit it when applying `≡-Trans`.  This is sometimes convenient; after all, `≡-Trans` is used to prove that the first and last arguments are the same, and often we don't care about the middle argument. Similarly, we sometimes don't need any of the arguments explicitly; in such cases `≡-TRANS` is easier to apply.

We use the symmetry of `_≡_` very often and we can sometimes improve the readability of a proof by employing some syntactic sugar.<sup>[2](Prelude.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="3093" class="Keyword">module</a> <a id="hide-sym"></a><a id="3100" href="Prelude.Equality.html#3100" class="Module">hide-sym</a> <a id="3109" class="Symbol">{</a><a id="3110" href="Prelude.Equality.html#3110" class="Bound">𝓤</a> <a id="3112" class="Symbol">:</a> <a id="3114" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3122" class="Symbol">}</a> <a id="3124" class="Keyword">where</a>

 <a id="hide-sym._⁻¹"></a><a id="3132" href="Prelude.Equality.html#3132" class="Function Operator">_⁻¹</a> <a id="3136" class="Symbol">:</a> <a id="3138" class="Symbol">{</a><a id="3139" href="Prelude.Equality.html#3139" class="Bound">X</a> <a id="3141" class="Symbol">:</a> <a id="3143" href="Prelude.Equality.html#3110" class="Bound">𝓤</a> <a id="3145" href="Universes.html#403" class="Function Operator">̇</a> <a id="3147" class="Symbol">}</a> <a id="3149" class="Symbol">→</a> <a id="3151" class="Symbol">{</a><a id="3152" href="Prelude.Equality.html#3152" class="Bound">x</a> <a id="3154" href="Prelude.Equality.html#3154" class="Bound">y</a> <a id="3156" class="Symbol">:</a> <a id="3158" href="Prelude.Equality.html#3139" class="Bound">X</a><a id="3159" class="Symbol">}</a> <a id="3161" class="Symbol">→</a> <a id="3163" href="Prelude.Equality.html#3152" class="Bound">x</a> <a id="3165" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="3167" href="Prelude.Equality.html#3154" class="Bound">y</a> <a id="3169" class="Symbol">→</a> <a id="3171" href="Prelude.Equality.html#3154" class="Bound">y</a> <a id="3173" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="3175" href="Prelude.Equality.html#3152" class="Bound">x</a>
 <a id="3178" href="Prelude.Equality.html#3178" class="Bound">p</a> <a id="3180" href="Prelude.Equality.html#3132" class="Function Operator">⁻¹</a> <a id="3183" class="Symbol">=</a> <a id="3185" href="Prelude.Equality.html#2170" class="Function">≡-SYM</a> <a id="3191" href="Prelude.Equality.html#3178" class="Bound">p</a>

<a id="3194" class="Keyword">open</a> <a id="3199" class="Keyword">import</a> <a id="3206" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="3215" class="Keyword">using</a> <a id="3221" class="Symbol">(</a><a id="3222" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="3225" class="Symbol">)</a> <a id="3227" class="Keyword">public</a>

</pre>

So, if we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-SYM p` we can use the more elegant and intuitive `p ⁻¹` .

Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.<sup>[2](Prelude.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="3548" class="Keyword">module</a> <a id="hide-trans"></a><a id="3555" href="Prelude.Equality.html#3555" class="Module">hide-trans</a> <a id="3566" class="Symbol">{</a><a id="3567" href="Prelude.Equality.html#3567" class="Bound">𝓤</a> <a id="3569" class="Symbol">:</a> <a id="3571" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3579" class="Symbol">}</a> <a id="3581" class="Keyword">where</a>

 <a id="hide-trans._∙_"></a><a id="3589" href="Prelude.Equality.html#3589" class="Function Operator">_∙_</a> <a id="3593" class="Symbol">:</a> <a id="3595" class="Symbol">{</a><a id="3596" href="Prelude.Equality.html#3596" class="Bound">X</a> <a id="3598" class="Symbol">:</a> <a id="3600" href="Prelude.Equality.html#3567" class="Bound">𝓤</a> <a id="3602" href="Universes.html#403" class="Function Operator">̇</a> <a id="3604" class="Symbol">}</a> <a id="3606" class="Symbol">{</a><a id="3607" href="Prelude.Equality.html#3607" class="Bound">x</a> <a id="3609" href="Prelude.Equality.html#3609" class="Bound">y</a> <a id="3611" href="Prelude.Equality.html#3611" class="Bound">z</a> <a id="3613" class="Symbol">:</a> <a id="3615" href="Prelude.Equality.html#3596" class="Bound">X</a><a id="3616" class="Symbol">}</a> <a id="3618" class="Symbol">→</a> <a id="3620" href="Prelude.Equality.html#3607" class="Bound">x</a> <a id="3622" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="3624" href="Prelude.Equality.html#3609" class="Bound">y</a> <a id="3626" class="Symbol">→</a> <a id="3628" href="Prelude.Equality.html#3609" class="Bound">y</a> <a id="3630" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="3632" href="Prelude.Equality.html#3611" class="Bound">z</a> <a id="3634" class="Symbol">→</a> <a id="3636" href="Prelude.Equality.html#3607" class="Bound">x</a> <a id="3638" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="3640" href="Prelude.Equality.html#3611" class="Bound">z</a>
 <a id="3643" href="Prelude.Equality.html#3643" class="Bound">p</a> <a id="3645" href="Prelude.Equality.html#3589" class="Function Operator">∙</a> <a id="3647" href="Prelude.Equality.html#3647" class="Bound">q</a> <a id="3649" class="Symbol">=</a> <a id="3651" href="Prelude.Equality.html#2393" class="Function">≡-TRANS</a> <a id="3659" href="Prelude.Equality.html#3643" class="Bound">p</a> <a id="3661" href="Prelude.Equality.html#3647" class="Bound">q</a>

<a id="3664" class="Keyword">open</a> <a id="3669" class="Keyword">import</a> <a id="3676" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="3685" class="Keyword">using</a> <a id="3691" class="Symbol">(</a><a id="3692" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="3695" class="Symbol">)</a> <a id="3697" class="Keyword">public</a>

</pre>

#### <a id="functions-preserve-refl">Functions preserve refl</a>

A simple but useful operation that we will make heavy use of is sometimes called **transport** (or "transport along an identity"). It is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[2](Prelude.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="4054" class="Keyword">module</a> <a id="hide-transport"></a><a id="4061" href="Prelude.Equality.html#4061" class="Module">hide-transport</a> <a id="4076" class="Symbol">{</a><a id="4077" href="Prelude.Equality.html#4077" class="Bound">𝓤</a> <a id="4079" href="Prelude.Equality.html#4079" class="Bound">𝓦</a> <a id="4081" class="Symbol">:</a> <a id="4083" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="4091" class="Symbol">}</a> <a id="4093" class="Keyword">where</a>

 <a id="hide-transport.𝑖𝑑"></a><a id="4101" href="Prelude.Equality.html#4101" class="Function">𝑖𝑑</a> <a id="4104" class="Symbol">:</a> <a id="4106" class="Symbol">{</a><a id="4107" href="Prelude.Equality.html#4107" class="Bound">𝓧</a> <a id="4109" class="Symbol">:</a> <a id="4111" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="4119" class="Symbol">}</a> <a id="4121" class="Symbol">(</a><a id="4122" href="Prelude.Equality.html#4122" class="Bound">X</a> <a id="4124" class="Symbol">:</a> <a id="4126" href="Prelude.Equality.html#4107" class="Bound">𝓧</a> <a id="4128" href="Universes.html#403" class="Function Operator">̇</a> <a id="4130" class="Symbol">)</a> <a id="4132" class="Symbol">→</a> <a id="4134" href="Prelude.Equality.html#4122" class="Bound">X</a> <a id="4136" class="Symbol">→</a> <a id="4138" href="Prelude.Equality.html#4122" class="Bound">X</a>
 <a id="4141" href="Prelude.Equality.html#4101" class="Function">𝑖𝑑</a> <a id="4144" href="Prelude.Equality.html#4144" class="Bound">X</a> <a id="4146" class="Symbol">=</a> <a id="4148" class="Symbol">λ</a> <a id="4150" href="Prelude.Equality.html#4150" class="Bound">x</a> <a id="4152" class="Symbol">→</a> <a id="4154" href="Prelude.Equality.html#4150" class="Bound">x</a>

 <a id="hide-transport.transport"></a><a id="4158" href="Prelude.Equality.html#4158" class="Function">transport</a> <a id="4168" class="Symbol">:</a> <a id="4170" class="Symbol">{</a><a id="4171" href="Prelude.Equality.html#4171" class="Bound">X</a> <a id="4173" class="Symbol">:</a> <a id="4175" href="Prelude.Equality.html#4077" class="Bound">𝓤</a> <a id="4177" href="Universes.html#403" class="Function Operator">̇</a> <a id="4179" class="Symbol">}</a> <a id="4181" class="Symbol">(</a><a id="4182" href="Prelude.Equality.html#4182" class="Bound">A</a> <a id="4184" class="Symbol">:</a> <a id="4186" href="Prelude.Equality.html#4171" class="Bound">X</a> <a id="4188" class="Symbol">→</a> <a id="4190" href="Prelude.Equality.html#4079" class="Bound">𝓦</a> <a id="4192" href="Universes.html#403" class="Function Operator">̇</a> <a id="4194" class="Symbol">)</a> <a id="4196" class="Symbol">{</a><a id="4197" href="Prelude.Equality.html#4197" class="Bound">x</a> <a id="4199" href="Prelude.Equality.html#4199" class="Bound">y</a> <a id="4201" class="Symbol">:</a> <a id="4203" href="Prelude.Equality.html#4171" class="Bound">X</a><a id="4204" class="Symbol">}</a> <a id="4206" class="Symbol">→</a> <a id="4208" href="Prelude.Equality.html#4197" class="Bound">x</a> <a id="4210" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="4212" href="Prelude.Equality.html#4199" class="Bound">y</a> <a id="4214" class="Symbol">→</a> <a id="4216" href="Prelude.Equality.html#4182" class="Bound">A</a> <a id="4218" href="Prelude.Equality.html#4197" class="Bound">x</a> <a id="4220" class="Symbol">→</a> <a id="4222" href="Prelude.Equality.html#4182" class="Bound">A</a> <a id="4224" href="Prelude.Equality.html#4199" class="Bound">y</a>
 <a id="4227" href="Prelude.Equality.html#4158" class="Function">transport</a> <a id="4237" href="Prelude.Equality.html#4237" class="Bound">A</a> <a id="4239" class="Symbol">(</a><a id="4240" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="4245" href="Prelude.Equality.html#4245" class="Bound">x</a><a id="4246" class="Symbol">)</a> <a id="4248" class="Symbol">=</a> <a id="4250" href="Prelude.Equality.html#4101" class="Function">𝑖𝑑</a> <a id="4253" class="Symbol">(</a><a id="4254" href="Prelude.Equality.html#4237" class="Bound">A</a> <a id="4256" href="Prelude.Equality.html#4245" class="Bound">x</a><a id="4257" class="Symbol">)</a>

<a id="4260" class="Keyword">open</a> <a id="4265" class="Keyword">import</a> <a id="4272" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="4281" class="Keyword">using</a> <a id="4287" class="Symbol">(</a><a id="4288" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="4290" class="Symbol">;</a> <a id="4292" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="4301" class="Symbol">)</a> <a id="4303" class="Keyword">public</a>

</pre>

As usual, we display `transport` in a hidden module and then imported the existing definition from [Type Topology][].<sup>[1](Preliminaries.Equality.html#fn1)</sup> See [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `x x' : X` of the domain, and an identity proof `p : x ≡ x'`, then we obtain a proof of `f x ≡ f x'` by simply applying the `ap` function like so, `ap f p : f x ≡ f x'`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="5286" class="Keyword">module</a> <a id="hide-ap"></a><a id="5293" href="Prelude.Equality.html#5293" class="Module">hide-ap</a>  <a id="5302" class="Symbol">{</a><a id="5303" href="Prelude.Equality.html#5303" class="Bound">𝓤</a> <a id="5305" href="Prelude.Equality.html#5305" class="Bound">𝓦</a> <a id="5307" class="Symbol">:</a> <a id="5309" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5317" class="Symbol">}</a> <a id="5319" class="Keyword">where</a>
 <a id="hide-ap.ap"></a><a id="5326" href="Prelude.Equality.html#5326" class="Function">ap</a> <a id="5329" class="Symbol">:</a> <a id="5331" class="Symbol">{</a><a id="5332" href="Prelude.Equality.html#5332" class="Bound">X</a> <a id="5334" class="Symbol">:</a> <a id="5336" href="Prelude.Equality.html#5303" class="Bound">𝓤</a> <a id="5338" href="Universes.html#403" class="Function Operator">̇</a> <a id="5340" class="Symbol">}</a> <a id="5342" class="Symbol">{</a><a id="5343" href="Prelude.Equality.html#5343" class="Bound">Y</a> <a id="5345" class="Symbol">:</a> <a id="5347" href="Universes.html#262" class="Generalizable">𝓥</a> <a id="5349" href="Universes.html#403" class="Function Operator">̇</a> <a id="5351" class="Symbol">}</a> <a id="5353" class="Symbol">(</a><a id="5354" href="Prelude.Equality.html#5354" class="Bound">f</a> <a id="5356" class="Symbol">:</a> <a id="5358" href="Prelude.Equality.html#5332" class="Bound">X</a> <a id="5360" class="Symbol">→</a> <a id="5362" href="Prelude.Equality.html#5343" class="Bound">Y</a><a id="5363" class="Symbol">)</a> <a id="5365" class="Symbol">{</a><a id="5366" href="Prelude.Equality.html#5366" class="Bound">x</a> <a id="5368" href="Prelude.Equality.html#5368" class="Bound">x&#39;</a> <a id="5371" class="Symbol">:</a> <a id="5373" href="Prelude.Equality.html#5332" class="Bound">X</a><a id="5374" class="Symbol">}</a> <a id="5376" class="Symbol">→</a> <a id="5378" href="Prelude.Equality.html#5366" class="Bound">x</a> <a id="5380" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5382" href="Prelude.Equality.html#5368" class="Bound">x&#39;</a> <a id="5385" class="Symbol">→</a> <a id="5387" href="Prelude.Equality.html#5354" class="Bound">f</a> <a id="5389" href="Prelude.Equality.html#5366" class="Bound">x</a> <a id="5391" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5393" href="Prelude.Equality.html#5354" class="Bound">f</a> <a id="5395" href="Prelude.Equality.html#5368" class="Bound">x&#39;</a>
 <a id="5399" href="Prelude.Equality.html#5326" class="Function">ap</a> <a id="5402" href="Prelude.Equality.html#5402" class="Bound">f</a> <a id="5404" class="Symbol">{</a><a id="5405" href="Prelude.Equality.html#5405" class="Bound">x</a><a id="5406" class="Symbol">}</a> <a id="5408" class="Symbol">{</a><a id="5409" href="Prelude.Equality.html#5409" class="Bound">x&#39;</a><a id="5411" class="Symbol">}</a> <a id="5413" href="Prelude.Equality.html#5413" class="Bound">p</a> <a id="5415" class="Symbol">=</a> <a id="5417" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="5427" class="Symbol">(λ</a> <a id="5430" href="Prelude.Equality.html#5430" class="Bound">-</a> <a id="5432" class="Symbol">→</a> <a id="5434" href="Prelude.Equality.html#5402" class="Bound">f</a> <a id="5436" href="Prelude.Equality.html#5405" class="Bound">x</a> <a id="5438" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5440" href="Prelude.Equality.html#5402" class="Bound">f</a> <a id="5442" href="Prelude.Equality.html#5430" class="Bound">-</a><a id="5443" class="Symbol">)</a> <a id="5445" href="Prelude.Equality.html#5413" class="Bound">p</a> <a id="5447" class="Symbol">(</a><a id="5448" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="5453" class="Symbol">(</a><a id="5454" href="Prelude.Equality.html#5402" class="Bound">f</a> <a id="5456" href="Prelude.Equality.html#5405" class="Bound">x</a><a id="5457" class="Symbol">))</a>

<a id="5461" class="Keyword">open</a> <a id="5466" class="Keyword">import</a> <a id="5473" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5482" class="Keyword">using</a> <a id="5488" class="Symbol">(</a><a id="5489" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="5491" class="Symbol">)</a> <a id="5493" class="Keyword">public</a>

</pre>

We now define some variations of `ap` that are sometimes useful.

<pre class="Agda">

<a id="ap-cong"></a><a id="5593" href="Prelude.Equality.html#5593" class="Function">ap-cong</a> <a id="5601" class="Symbol">:</a> <a id="5603" class="Symbol">{</a><a id="5604" href="Prelude.Equality.html#5604" class="Bound">𝓤</a> <a id="5606" href="Prelude.Equality.html#5606" class="Bound">𝓦</a> <a id="5608" class="Symbol">:</a> <a id="5610" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5618" class="Symbol">}{</a><a id="5620" href="Prelude.Equality.html#5620" class="Bound">A</a> <a id="5622" class="Symbol">:</a> <a id="5624" href="Prelude.Equality.html#5604" class="Bound">𝓤</a> <a id="5626" href="Universes.html#403" class="Function Operator">̇</a> <a id="5628" class="Symbol">}{</a><a id="5630" href="Prelude.Equality.html#5630" class="Bound">B</a> <a id="5632" class="Symbol">:</a> <a id="5634" href="Prelude.Equality.html#5606" class="Bound">𝓦</a> <a id="5636" href="Universes.html#403" class="Function Operator">̇</a> <a id="5638" class="Symbol">}{</a><a id="5640" href="Prelude.Equality.html#5640" class="Bound">f</a> <a id="5642" href="Prelude.Equality.html#5642" class="Bound">g</a> <a id="5644" class="Symbol">:</a> <a id="5646" href="Prelude.Equality.html#5620" class="Bound">A</a> <a id="5648" class="Symbol">→</a> <a id="5650" href="Prelude.Equality.html#5630" class="Bound">B</a><a id="5651" class="Symbol">}</a> <a id="5653" class="Symbol">{</a><a id="5654" href="Prelude.Equality.html#5654" class="Bound">a</a> <a id="5656" href="Prelude.Equality.html#5656" class="Bound">b</a> <a id="5658" class="Symbol">:</a> <a id="5660" href="Prelude.Equality.html#5620" class="Bound">A</a><a id="5661" class="Symbol">}</a>
 <a id="5664" class="Symbol">→</a>        <a id="5673" href="Prelude.Equality.html#5640" class="Bound">f</a> <a id="5675" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5677" href="Prelude.Equality.html#5642" class="Bound">g</a>  <a id="5680" class="Symbol">→</a>  <a id="5683" href="Prelude.Equality.html#5654" class="Bound">a</a> <a id="5685" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5687" href="Prelude.Equality.html#5656" class="Bound">b</a>
          <a id="5699" class="Comment">---------------</a>
 <a id="5716" class="Symbol">→</a>        <a id="5725" href="Prelude.Equality.html#5640" class="Bound">f</a> <a id="5727" href="Prelude.Equality.html#5654" class="Bound">a</a> <a id="5729" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="5731" href="Prelude.Equality.html#5642" class="Bound">g</a> <a id="5733" href="Prelude.Equality.html#5656" class="Bound">b</a>

<a id="5736" href="Prelude.Equality.html#5593" class="Function">ap-cong</a> <a id="5744" class="Symbol">(</a><a id="5745" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="5750" class="Symbol">_)</a> <a id="5753" class="Symbol">(</a><a id="5754" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="5759" class="Symbol">_)</a> <a id="5762" class="Symbol">=</a> <a id="5764" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="5769" class="Symbol">_</a>

</pre>

We sometimes need a version of this that works for [dependent types][], such as the following (which we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][], transcribed into MHE/UALib notation of course):

<pre class="Agda">

<a id="cong-app"></a><a id="6036" href="Prelude.Equality.html#6036" class="Function">cong-app</a> <a id="6045" class="Symbol">:</a> <a id="6047" class="Symbol">{</a><a id="6048" href="Prelude.Equality.html#6048" class="Bound">𝓤</a> <a id="6050" href="Prelude.Equality.html#6050" class="Bound">𝓦</a> <a id="6052" class="Symbol">:</a> <a id="6054" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6062" class="Symbol">}</a>
           <a id="6075" class="Symbol">{</a><a id="6076" href="Prelude.Equality.html#6076" class="Bound">A</a> <a id="6078" class="Symbol">:</a> <a id="6080" href="Prelude.Equality.html#6048" class="Bound">𝓤</a> <a id="6082" href="Universes.html#403" class="Function Operator">̇</a><a id="6083" class="Symbol">}</a> <a id="6085" class="Symbol">{</a><a id="6086" href="Prelude.Equality.html#6086" class="Bound">B</a> <a id="6088" class="Symbol">:</a> <a id="6090" href="Prelude.Equality.html#6076" class="Bound">A</a> <a id="6092" class="Symbol">→</a> <a id="6094" href="Prelude.Equality.html#6050" class="Bound">𝓦</a> <a id="6096" href="Universes.html#403" class="Function Operator">̇</a><a id="6097" class="Symbol">}</a>
           <a id="6110" class="Symbol">{</a><a id="6111" href="Prelude.Equality.html#6111" class="Bound">f</a> <a id="6113" href="Prelude.Equality.html#6113" class="Bound">g</a> <a id="6115" class="Symbol">:</a> <a id="6117" class="Symbol">(</a><a id="6118" href="Prelude.Equality.html#6118" class="Bound">a</a> <a id="6120" class="Symbol">:</a> <a id="6122" href="Prelude.Equality.html#6076" class="Bound">A</a><a id="6123" class="Symbol">)</a> <a id="6125" class="Symbol">→</a> <a id="6127" href="Prelude.Equality.html#6086" class="Bound">B</a> <a id="6129" href="Prelude.Equality.html#6118" class="Bound">a</a><a id="6130" class="Symbol">}</a>
 <a id="6133" class="Symbol">→</a>          <a id="6144" href="Prelude.Equality.html#6111" class="Bound">f</a> <a id="6146" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6148" href="Prelude.Equality.html#6113" class="Bound">g</a>   <a id="6152" class="Symbol">→</a>   <a id="6156" class="Symbol">(</a><a id="6157" href="Prelude.Equality.html#6157" class="Bound">a</a> <a id="6159" class="Symbol">:</a> <a id="6161" href="Prelude.Equality.html#6076" class="Bound">A</a><a id="6162" class="Symbol">)</a>
          <a id="6174" class="Comment">-----------------------</a>
 <a id="6199" class="Symbol">→</a>              <a id="6214" href="Prelude.Equality.html#6111" class="Bound">f</a> <a id="6216" href="Prelude.Equality.html#6157" class="Bound">a</a> <a id="6218" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6220" href="Prelude.Equality.html#6113" class="Bound">g</a> <a id="6222" href="Prelude.Equality.html#6157" class="Bound">a</a>

<a id="6225" href="Prelude.Equality.html#6036" class="Function">cong-app</a> <a id="6234" class="Symbol">(</a><a id="6235" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="6240" class="Symbol">_)</a> <a id="6243" href="Prelude.Equality.html#6243" class="Bound">a</a> <a id="6245" class="Symbol">=</a> <a id="6247" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="6252" class="Symbol">_</a>

</pre>




#### <a id="≡-intro-and-≡-elim-for-nondependent-pairs">≡-intro and ≡-elim for nondependent pairs</a>

We conclude the Equality module with some occasionally useful introduction and elimination rules for the equality relation on (nondependent) pair types.



<pre class="Agda">

<a id="6542" class="Keyword">open</a> <a id="6547" class="Keyword">import</a> <a id="6554" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="6563" class="Keyword">using</a> <a id="6569" class="Symbol">(</a><a id="6570" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="6572" class="Symbol">)</a> <a id="6574" class="Keyword">public</a>

<a id="≡-elim-left"></a><a id="6582" href="Prelude.Equality.html#6582" class="Function">≡-elim-left</a> <a id="6594" class="Symbol">:</a> <a id="6596" class="Symbol">{</a><a id="6597" href="Prelude.Equality.html#6597" class="Bound">𝓤</a> <a id="6599" href="Prelude.Equality.html#6599" class="Bound">𝓦</a> <a id="6601" class="Symbol">:</a> <a id="6603" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6611" class="Symbol">}</a>
              <a id="6627" class="Symbol">{</a><a id="6628" href="Prelude.Equality.html#6628" class="Bound">A₁</a> <a id="6631" href="Prelude.Equality.html#6631" class="Bound">A₂</a> <a id="6634" class="Symbol">:</a> <a id="6636" href="Prelude.Equality.html#6597" class="Bound">𝓤</a> <a id="6638" href="Universes.html#403" class="Function Operator">̇</a><a id="6639" class="Symbol">}</a> <a id="6641" class="Symbol">{</a><a id="6642" href="Prelude.Equality.html#6642" class="Bound">B₁</a> <a id="6645" href="Prelude.Equality.html#6645" class="Bound">B₂</a> <a id="6648" class="Symbol">:</a> <a id="6650" href="Prelude.Equality.html#6599" class="Bound">𝓦</a> <a id="6652" href="Universes.html#403" class="Function Operator">̇</a><a id="6653" class="Symbol">}</a>
 <a id="6656" class="Symbol">→</a>            <a id="6669" class="Symbol">(</a><a id="6670" href="Prelude.Equality.html#6628" class="Bound">A₁</a> <a id="6673" href="Prelude.Preliminaries.html#14518" class="InductiveConstructor Operator">,</a> <a id="6675" href="Prelude.Equality.html#6642" class="Bound">B₁</a><a id="6677" class="Symbol">)</a> <a id="6679" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6681" class="Symbol">(</a><a id="6682" href="Prelude.Equality.html#6631" class="Bound">A₂</a> <a id="6685" href="Prelude.Preliminaries.html#14518" class="InductiveConstructor Operator">,</a> <a id="6687" href="Prelude.Equality.html#6645" class="Bound">B₂</a><a id="6689" class="Symbol">)</a>
              <a id="6705" class="Comment">----------------------</a>
 <a id="6729" class="Symbol">→</a>                   <a id="6749" href="Prelude.Equality.html#6628" class="Bound">A₁</a> <a id="6752" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6754" href="Prelude.Equality.html#6631" class="Bound">A₂</a>

<a id="6758" href="Prelude.Equality.html#6582" class="Function">≡-elim-left</a> <a id="6770" href="Prelude.Equality.html#6770" class="Bound">e</a> <a id="6772" class="Symbol">=</a> <a id="6774" href="MGS-MLTT.html#6613" class="Function">ap</a> <a id="6777" href="MGS-MLTT.html#2942" class="Function">pr₁</a> <a id="6781" href="Prelude.Equality.html#6770" class="Bound">e</a>


<a id="≡-elim-right"></a><a id="6785" href="Prelude.Equality.html#6785" class="Function">≡-elim-right</a> <a id="6798" class="Symbol">:</a> <a id="6800" class="Symbol">{</a><a id="6801" href="Prelude.Equality.html#6801" class="Bound">𝓤</a> <a id="6803" href="Prelude.Equality.html#6803" class="Bound">𝓦</a> <a id="6805" class="Symbol">:</a> <a id="6807" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6815" class="Symbol">}</a>
               <a id="6832" class="Symbol">{</a><a id="6833" href="Prelude.Equality.html#6833" class="Bound">A₁</a> <a id="6836" href="Prelude.Equality.html#6836" class="Bound">A₂</a> <a id="6839" class="Symbol">:</a> <a id="6841" href="Prelude.Equality.html#6801" class="Bound">𝓤</a> <a id="6843" href="Universes.html#403" class="Function Operator">̇</a><a id="6844" class="Symbol">}{</a><a id="6846" href="Prelude.Equality.html#6846" class="Bound">B₁</a> <a id="6849" href="Prelude.Equality.html#6849" class="Bound">B₂</a> <a id="6852" class="Symbol">:</a> <a id="6854" href="Prelude.Equality.html#6803" class="Bound">𝓦</a> <a id="6856" href="Universes.html#403" class="Function Operator">̇</a><a id="6857" class="Symbol">}</a>
 <a id="6860" class="Symbol">→</a>             <a id="6874" class="Symbol">(</a><a id="6875" href="Prelude.Equality.html#6833" class="Bound">A₁</a> <a id="6878" href="Prelude.Preliminaries.html#14518" class="InductiveConstructor Operator">,</a> <a id="6880" href="Prelude.Equality.html#6846" class="Bound">B₁</a><a id="6882" class="Symbol">)</a> <a id="6884" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6886" class="Symbol">(</a><a id="6887" href="Prelude.Equality.html#6836" class="Bound">A₂</a> <a id="6890" href="Prelude.Preliminaries.html#14518" class="InductiveConstructor Operator">,</a> <a id="6892" href="Prelude.Equality.html#6849" class="Bound">B₂</a><a id="6894" class="Symbol">)</a>
               <a id="6911" class="Comment">-----------------------</a>
 <a id="6936" class="Symbol">→</a>                    <a id="6957" href="Prelude.Equality.html#6846" class="Bound">B₁</a> <a id="6960" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="6962" href="Prelude.Equality.html#6849" class="Bound">B₂</a>

<a id="6966" href="Prelude.Equality.html#6785" class="Function">≡-elim-right</a> <a id="6979" href="Prelude.Equality.html#6979" class="Bound">e</a> <a id="6981" class="Symbol">=</a> <a id="6983" href="MGS-MLTT.html#6613" class="Function">ap</a> <a id="6986" href="MGS-MLTT.html#3001" class="Function">pr₂</a> <a id="6990" href="Prelude.Equality.html#6979" class="Bound">e</a>


<a id="≡-×-intro"></a><a id="6994" href="Prelude.Equality.html#6994" class="Function">≡-×-intro</a> <a id="7004" class="Symbol">:</a> <a id="7006" class="Symbol">{</a><a id="7007" href="Prelude.Equality.html#7007" class="Bound">𝓤</a> <a id="7009" href="Prelude.Equality.html#7009" class="Bound">𝓦</a> <a id="7011" class="Symbol">:</a> <a id="7013" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="7021" class="Symbol">}</a>
            <a id="7035" class="Symbol">{</a><a id="7036" href="Prelude.Equality.html#7036" class="Bound">A₁</a> <a id="7039" href="Prelude.Equality.html#7039" class="Bound">A₂</a> <a id="7042" class="Symbol">:</a> <a id="7044" href="Prelude.Equality.html#7007" class="Bound">𝓤</a> <a id="7046" href="Universes.html#403" class="Function Operator">̇</a><a id="7047" class="Symbol">}</a> <a id="7049" class="Symbol">{</a><a id="7050" href="Prelude.Equality.html#7050" class="Bound">B₁</a> <a id="7053" href="Prelude.Equality.html#7053" class="Bound">B₂</a> <a id="7056" class="Symbol">:</a> <a id="7058" href="Prelude.Equality.html#7009" class="Bound">𝓦</a> <a id="7060" href="Universes.html#403" class="Function Operator">̇</a><a id="7061" class="Symbol">}</a>
 <a id="7064" class="Symbol">→</a>           <a id="7076" href="Prelude.Equality.html#7036" class="Bound">A₁</a> <a id="7079" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="7081" href="Prelude.Equality.html#7039" class="Bound">A₂</a>  <a id="7085" class="Symbol">→</a>  <a id="7088" href="Prelude.Equality.html#7050" class="Bound">B₁</a> <a id="7091" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="7093" href="Prelude.Equality.html#7053" class="Bound">B₂</a>
           <a id="7107" class="Comment">------------------------</a>
 <a id="7133" class="Symbol">→</a>          <a id="7144" class="Symbol">(</a><a id="7145" href="Prelude.Equality.html#7036" class="Bound">A₁</a> <a id="7148" href="Prelude.Preliminaries.html#14518" class="InductiveConstructor Operator">,</a> <a id="7150" href="Prelude.Equality.html#7050" class="Bound">B₁</a><a id="7152" class="Symbol">)</a> <a id="7154" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="7156" class="Symbol">(</a><a id="7157" href="Prelude.Equality.html#7039" class="Bound">A₂</a> <a id="7160" href="Prelude.Preliminaries.html#14518" class="InductiveConstructor Operator">,</a> <a id="7162" href="Prelude.Equality.html#7053" class="Bound">B₂</a><a id="7164" class="Symbol">)</a>

<a id="7167" href="Prelude.Equality.html#6994" class="Function">≡-×-intro</a> <a id="7177" class="Symbol">(</a><a id="7178" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="7183" class="Symbol">_</a> <a id="7185" class="Symbol">)</a> <a id="7187" class="Symbol">(</a><a id="7188" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="7193" class="Symbol">_</a> <a id="7195" class="Symbol">)</a> <a id="7197" class="Symbol">=</a> <a id="7199" class="Symbol">(</a><a id="7200" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="7205" class="Symbol">_</a> <a id="7207" class="Symbol">)</a>


<a id="≡-×-int"></a><a id="7211" href="Prelude.Equality.html#7211" class="Function">≡-×-int</a> <a id="7219" class="Symbol">:</a> <a id="7221" class="Symbol">{</a><a id="7222" href="Prelude.Equality.html#7222" class="Bound">𝓤</a> <a id="7224" href="Prelude.Equality.html#7224" class="Bound">𝓦</a> <a id="7226" class="Symbol">:</a> <a id="7228" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="7236" class="Symbol">}</a>
          <a id="7248" class="Symbol">{</a><a id="7249" href="Prelude.Equality.html#7249" class="Bound">A</a> <a id="7251" class="Symbol">:</a> <a id="7253" href="Prelude.Equality.html#7222" class="Bound">𝓤</a> <a id="7255" href="Universes.html#403" class="Function Operator">̇</a><a id="7256" class="Symbol">}</a> <a id="7258" class="Symbol">{</a><a id="7259" href="Prelude.Equality.html#7259" class="Bound">B</a> <a id="7261" class="Symbol">:</a> <a id="7263" href="Prelude.Equality.html#7224" class="Bound">𝓦</a> <a id="7265" href="Universes.html#403" class="Function Operator">̇</a><a id="7266" class="Symbol">}</a>
          <a id="7278" class="Symbol">(</a><a id="7279" href="Prelude.Equality.html#7279" class="Bound">a</a> <a id="7281" href="Prelude.Equality.html#7281" class="Bound">a&#39;</a> <a id="7284" class="Symbol">:</a> <a id="7286" href="Prelude.Equality.html#7249" class="Bound">A</a><a id="7287" class="Symbol">)(</a><a id="7289" href="Prelude.Equality.html#7289" class="Bound">b</a> <a id="7291" href="Prelude.Equality.html#7291" class="Bound">b&#39;</a> <a id="7294" class="Symbol">:</a> <a id="7296" href="Prelude.Equality.html#7259" class="Bound">B</a><a id="7297" class="Symbol">)</a>
 <a id="7300" class="Symbol">→</a>         <a id="7310" href="Prelude.Equality.html#7279" class="Bound">a</a> <a id="7312" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="7314" href="Prelude.Equality.html#7281" class="Bound">a&#39;</a>  <a id="7318" class="Symbol">→</a>  <a id="7321" href="Prelude.Equality.html#7289" class="Bound">b</a> <a id="7323" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="7325" href="Prelude.Equality.html#7291" class="Bound">b&#39;</a>
          <a id="7338" class="Comment">------------------------</a>
 <a id="7364" class="Symbol">→</a>         <a id="7374" class="Symbol">(</a><a id="7375" href="Prelude.Equality.html#7279" class="Bound">a</a> <a id="7377" href="Prelude.Preliminaries.html#14518" class="InductiveConstructor Operator">,</a> <a id="7379" href="Prelude.Equality.html#7289" class="Bound">b</a><a id="7380" class="Symbol">)</a> <a id="7382" href="Prelude.Equality.html#1231" class="Datatype Operator">≡</a> <a id="7384" class="Symbol">(</a><a id="7385" href="Prelude.Equality.html#7281" class="Bound">a&#39;</a> <a id="7388" href="Prelude.Preliminaries.html#14518" class="InductiveConstructor Operator">,</a> <a id="7390" href="Prelude.Equality.html#7291" class="Bound">b&#39;</a><a id="7392" class="Symbol">)</a>

<a id="7395" href="Prelude.Equality.html#7211" class="Function">≡-×-int</a> <a id="7403" href="Prelude.Equality.html#7403" class="Bound">a</a> <a id="7405" href="Prelude.Equality.html#7405" class="Bound">a&#39;</a> <a id="7408" href="Prelude.Equality.html#7408" class="Bound">b</a> <a id="7410" href="Prelude.Equality.html#7410" class="Bound">b&#39;</a> <a id="7413" class="Symbol">(</a><a id="7414" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="7419" class="Symbol">_</a> <a id="7421" class="Symbol">)</a> <a id="7423" class="Symbol">(</a><a id="7424" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="7429" class="Symbol">_</a> <a id="7431" class="Symbol">)</a> <a id="7433" class="Symbol">=</a> <a id="7435" class="Symbol">(</a><a id="7436" href="Prelude.Equality.html#1413" class="InductiveConstructor">refl</a> <a id="7441" class="Symbol">_</a> <a id="7443" class="Symbol">)</a>
</pre>

-------------------------------------

<sup>1</sup><span class="footnote" id="fn1">To hide code from the rest of the development, we enclose it in a named module.  In this case, we don't want the code inside the `hide-refl` module to conflict with the original definitions of these functions from Escardo's Type Topology library, which we import right after repeating their definitions.  As long as we don't invoke `open hide-refl`, the code inside the `hide-refl` model remains essentially hidden (for the purposes of resolving conflicts, though Agda *will* type-check the code). It may seem odd to both define `refl` ourselves only to immediately import the definition that we actually use. We do this in order to describe all or most of the types on which the [UALib][] depends, in a clear and self-contained way, while at the same time making sure that this cannot be misinterpreted as a claim to originality.</span>


<sup>2</sup><span class="footnote" id="fn2"> **Unicode Hints**. In [agda2-mode][] type `⁻¹` as `\^-\^1`, type `𝑖𝑑` as `\Mii\Mid`, and type `∙` as `\.`. In general, to get information about a given unicode character (e.g., how to type it) place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>



-------------------------------------


[← Prelude.Preliminaries ](Prelude.Preliminaries.html)
<span style="float:right;">[Prelude.Extensionality →](Prelude.Extensionality.html)</span>

{% include UALib.Links.md %}
