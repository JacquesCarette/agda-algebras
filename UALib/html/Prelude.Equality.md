---
layout: default
title : UALib.Prelude.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This is the [UALib.Prelude.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="276" class="Symbol">{-#</a> <a id="280" class="Keyword">OPTIONS</a> <a id="288" class="Pragma">--without-K</a> <a id="300" class="Pragma">--exact-split</a> <a id="314" class="Pragma">--safe</a> <a id="321" class="Symbol">#-}</a>

<a id="326" class="Keyword">module</a> <a id="333" href="Prelude.Equality.html" class="Module">Prelude.Equality</a> <a id="350" class="Keyword">where</a>

<a id="357" class="Keyword">open</a> <a id="362" class="Keyword">import</a> <a id="369" href="Prelude.Preliminaries.html" class="Module">Prelude.Preliminaries</a> <a id="391" class="Keyword">public</a>

</pre>

#### <a id="definitional-equality">Definitional equality</a>

Here we discuss what is probably the most important type in [MLTT][]. It is called *definitional equality*. This concept is easily understood, at least heuristically, with the following slogan:

*Definitional equality is the substitution-preserving equivalence relation generated by definitions.*

We will make this precise below, but first let us quote from a primary source. Per Martin-Löof offers the following definition (italics added):<sup>[1](Prelude.Equality.html#fn1)</sup>

"*Definitional equality* is defined to be the equivalence relation, that is, reflexive, symmetric and transitive relation, which is generated by the principles that a definiendum is always definitionally equal to its definiens and that definitional equality is preserved under substitution."<sup>[2](Prelude.Equality.html#fn2)

To be sure we understand what this means, let `:=` denote the relation with respect to which `x` is related to `y` (denoted `x := y`) if and only if `y` *is the definition of* `x`.  Then the definitional equality relation `≡` is the reflexive, symmetric, transitive, substitutive closure of `:=`. By *subsitutive closure* we mean closure under the following *substitution rule*.

\begin{prooftree}
\AxiomC{`\{A : 𝓤 ̇\}\{B : A → 𝓦 ̇\}\{x y : A\}`}
\AxiomC{`x ≡ y`}
\Rightlabel{(subst)}
\BinaryInfC{`B x ≡ B y`}
\end{prooftree}

The datatype we use to represent definitional equality is imported from the Identity-Type module of the [Type Topology][] library, but apart from superficial syntactic differences, it is equivalent to the identity type used in all other Agda libraries we know of.  We repeat the definition here for easy reference.

<pre class="Agda">

<a id="2142" class="Keyword">module</a> <a id="hide-refl"></a><a id="2149" href="Prelude.Equality.html#2149" class="Module">hide-refl</a> <a id="2159" class="Symbol">{</a><a id="2160" href="Prelude.Equality.html#2160" class="Bound">𝓤</a> <a id="2162" class="Symbol">:</a> <a id="2164" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2172" class="Symbol">}</a> <a id="2174" class="Keyword">where</a>

 <a id="2182" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="2187" href="Prelude.Equality.html#2187" class="Datatype Operator">_≡_</a> <a id="2191" class="Symbol">{</a><a id="2192" href="Prelude.Equality.html#2192" class="Bound">𝓤</a><a id="2193" class="Symbol">}</a> <a id="2195" class="Symbol">{</a><a id="2196" href="Prelude.Equality.html#2196" class="Bound">A</a> <a id="2198" class="Symbol">:</a> <a id="2200" href="Prelude.Equality.html#2192" class="Bound">𝓤</a> <a id="2202" href="Universes.html#403" class="Function Operator">̇</a> <a id="2204" class="Symbol">}</a> <a id="2206" class="Symbol">:</a> <a id="2208" href="Prelude.Equality.html#2196" class="Bound">A</a> <a id="2210" class="Symbol">→</a> <a id="2212" href="Prelude.Equality.html#2196" class="Bound">A</a> <a id="2214" class="Symbol">→</a> <a id="2216" href="Prelude.Equality.html#2192" class="Bound">𝓤</a> <a id="2218" href="Universes.html#403" class="Function Operator">̇</a> <a id="2220" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="2226" href="Prelude.Equality.html#2226" class="InductiveConstructor">refl</a> <a id="2231" class="Symbol">:</a> <a id="2233" class="Symbol">{</a><a id="2234" href="Prelude.Equality.html#2234" class="Bound">x</a> <a id="2236" class="Symbol">:</a> <a id="2238" href="Prelude.Equality.html#2196" class="Bound">A</a><a id="2239" class="Symbol">}</a> <a id="2241" class="Symbol">→</a> <a id="2243" href="Prelude.Equality.html#2234" class="Bound">x</a> <a id="2245" href="Prelude.Equality.html#2187" class="Datatype Operator">≡</a> <a id="2247" href="Prelude.Equality.html#2234" class="Bound">x</a>

<a id="2250" class="Keyword">open</a> <a id="2255" class="Keyword">import</a> <a id="2262" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="2276" class="Keyword">renaming</a> <a id="2285" class="Symbol">(</a><a id="2286" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="2290" class="Symbol">to</a> <a id="2293" class="Keyword">infix</a> <a id="2299" class="Number">0</a> <a id="_≡_"></a><a id="2301" href="Prelude.Equality.html#2301" class="Datatype Operator">_≡_</a><a id="2304" class="Symbol">)</a> <a id="2306" class="Keyword">public</a>

</pre>

Whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we invoke `refl`.  If we need to make explicit the implicit argument `x`, then we use `refl\{x = x\}`.

Of course `≡` is an equivalence relation and the formal proof of this fact is trivial. We don't need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

<pre class="Agda">

<a id="2778" class="Keyword">module</a> <a id="2785" href="Prelude.Equality.html#2785" class="Module">_</a>  <a id="2788" class="Symbol">{</a><a id="2789" href="Prelude.Equality.html#2789" class="Bound">𝓤</a> <a id="2791" class="Symbol">:</a> <a id="2793" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2801" class="Symbol">}{</a><a id="2803" href="Prelude.Equality.html#2803" class="Bound">A</a> <a id="2805" class="Symbol">:</a> <a id="2807" href="Prelude.Equality.html#2789" class="Bound">𝓤</a> <a id="2809" href="Universes.html#403" class="Function Operator">̇</a> <a id="2811" class="Symbol">}</a>  <a id="2814" class="Keyword">where</a>

 <a id="2822" href="Prelude.Equality.html#2822" class="Function">≡-symmetric</a> <a id="2834" class="Symbol">:</a> <a id="2836" class="Symbol">(</a><a id="2837" href="Prelude.Equality.html#2837" class="Bound">x</a> <a id="2839" href="Prelude.Equality.html#2839" class="Bound">y</a> <a id="2841" class="Symbol">:</a> <a id="2843" href="Prelude.Equality.html#2803" class="Bound">A</a><a id="2844" class="Symbol">)</a> <a id="2846" class="Symbol">→</a> <a id="2848" href="Prelude.Equality.html#2837" class="Bound">x</a> <a id="2850" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="2852" href="Prelude.Equality.html#2839" class="Bound">y</a> <a id="2854" class="Symbol">→</a> <a id="2856" href="Prelude.Equality.html#2839" class="Bound">y</a> <a id="2858" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="2860" href="Prelude.Equality.html#2837" class="Bound">x</a>
 <a id="2863" href="Prelude.Equality.html#2822" class="Function">≡-symmetric</a> <a id="2875" class="Symbol">_</a> <a id="2877" class="Symbol">_</a> <a id="2879" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2884" class="Symbol">=</a> <a id="2886" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="2893" href="Prelude.Equality.html#2893" class="Function">≡-sym</a> <a id="2899" class="Symbol">:</a> <a id="2901" class="Symbol">{</a><a id="2902" href="Prelude.Equality.html#2902" class="Bound">x</a> <a id="2904" href="Prelude.Equality.html#2904" class="Bound">y</a> <a id="2906" class="Symbol">:</a> <a id="2908" href="Prelude.Equality.html#2803" class="Bound">A</a><a id="2909" class="Symbol">}</a> <a id="2911" class="Symbol">→</a> <a id="2913" href="Prelude.Equality.html#2902" class="Bound">x</a> <a id="2915" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="2917" href="Prelude.Equality.html#2904" class="Bound">y</a> <a id="2919" class="Symbol">→</a> <a id="2921" href="Prelude.Equality.html#2904" class="Bound">y</a> <a id="2923" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="2925" href="Prelude.Equality.html#2902" class="Bound">x</a>
 <a id="2928" href="Prelude.Equality.html#2893" class="Function">≡-sym</a> <a id="2934" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2939" class="Symbol">=</a> <a id="2941" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="2948" href="Prelude.Equality.html#2948" class="Function">≡-transitive</a> <a id="2961" class="Symbol">:</a> <a id="2963" class="Symbol">(</a><a id="2964" href="Prelude.Equality.html#2964" class="Bound">x</a> <a id="2966" href="Prelude.Equality.html#2966" class="Bound">y</a> <a id="2968" href="Prelude.Equality.html#2968" class="Bound">z</a> <a id="2970" class="Symbol">:</a> <a id="2972" href="Prelude.Equality.html#2803" class="Bound">A</a><a id="2973" class="Symbol">)</a> <a id="2975" class="Symbol">→</a> <a id="2977" href="Prelude.Equality.html#2964" class="Bound">x</a> <a id="2979" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="2981" href="Prelude.Equality.html#2966" class="Bound">y</a> <a id="2983" class="Symbol">→</a> <a id="2985" href="Prelude.Equality.html#2966" class="Bound">y</a> <a id="2987" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="2989" href="Prelude.Equality.html#2968" class="Bound">z</a> <a id="2991" class="Symbol">→</a> <a id="2993" href="Prelude.Equality.html#2964" class="Bound">x</a> <a id="2995" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="2997" href="Prelude.Equality.html#2968" class="Bound">z</a>
 <a id="3000" href="Prelude.Equality.html#2948" class="Function">≡-transitive</a> <a id="3013" class="Symbol">_</a> <a id="3015" class="Symbol">_</a> <a id="3017" class="Symbol">_</a> <a id="3019" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3024" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3029" class="Symbol">=</a> <a id="3031" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3038" href="Prelude.Equality.html#3038" class="Function">≡-trans</a> <a id="3046" class="Symbol">:</a> <a id="3048" class="Symbol">{</a><a id="3049" href="Prelude.Equality.html#3049" class="Bound">x</a> <a id="3051" href="Prelude.Equality.html#3051" class="Bound">y</a> <a id="3053" href="Prelude.Equality.html#3053" class="Bound">z</a> <a id="3055" class="Symbol">:</a> <a id="3057" href="Prelude.Equality.html#2803" class="Bound">A</a><a id="3058" class="Symbol">}</a> <a id="3060" class="Symbol">→</a> <a id="3062" href="Prelude.Equality.html#3049" class="Bound">x</a> <a id="3064" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="3066" href="Prelude.Equality.html#3051" class="Bound">y</a> <a id="3068" class="Symbol">→</a> <a id="3070" href="Prelude.Equality.html#3051" class="Bound">y</a> <a id="3072" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="3074" href="Prelude.Equality.html#3053" class="Bound">z</a> <a id="3076" class="Symbol">→</a> <a id="3078" href="Prelude.Equality.html#3049" class="Bound">x</a> <a id="3080" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="3082" href="Prelude.Equality.html#3053" class="Bound">z</a>
 <a id="3085" href="Prelude.Equality.html#3038" class="Function">≡-trans</a> <a id="3093" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3098" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3103" class="Symbol">=</a> <a id="3105" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

The only difference between `≡-symmetric` and `≡-sym` (respectively, `≡-transitive` and `≡-trans`) is that the latter has fewer explicit arguments, which is sometimes convenient.

We prove that `≡` obeys the substitution rule (subst) in the next subsection (see the definition of `ap` below), but first we define some syntactic sugar that will make it easier to apply symmetry and transitivity of `≡` in proofs.\footnote{%
\textbf{Unicode Hints} (\agdamode): \texttt{\textbackslash{}\^{}-\textbackslash{}\^{}1} ↝ \af{⁻¹}; \texttt{\textbackslash{}Mii\textbackslash{}Mid} ↝ \af{𝑖𝑑}; \texttt{\textbackslash{}.}↝ \af{∙}. In general, for information about a character, place the cursor on the character and type \texttt{M-x\ describe-char} (or \texttt{M-x\ h\ d\ c}).}


Many proofs make abundant use of the symmetry of `_≡_`, and the following syntactic sugar can often improve the readability of such proofs.<sup>[3](Prelude.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="4085" class="Keyword">module</a> <a id="hide-sym-trans"></a><a id="4092" href="Prelude.Equality.html#4092" class="Module">hide-sym-trans</a> <a id="4107" class="Symbol">{</a><a id="4108" href="Prelude.Equality.html#4108" class="Bound">𝓤</a> <a id="4110" class="Symbol">:</a> <a id="4112" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="4120" class="Symbol">}</a> <a id="4122" class="Symbol">{</a><a id="4123" href="Prelude.Equality.html#4123" class="Bound">A</a> <a id="4125" class="Symbol">:</a> <a id="4127" href="Prelude.Equality.html#4108" class="Bound">𝓤</a> <a id="4129" href="Universes.html#403" class="Function Operator">̇</a> <a id="4131" class="Symbol">}</a> <a id="4133" class="Keyword">where</a>

 <a id="hide-sym-trans._⁻¹"></a><a id="4141" href="Prelude.Equality.html#4141" class="Function Operator">_⁻¹</a> <a id="4145" class="Symbol">:</a> <a id="4147" class="Symbol">{</a><a id="4148" href="Prelude.Equality.html#4148" class="Bound">x</a> <a id="4150" href="Prelude.Equality.html#4150" class="Bound">y</a> <a id="4152" class="Symbol">:</a> <a id="4154" href="Prelude.Equality.html#4123" class="Bound">A</a><a id="4155" class="Symbol">}</a> <a id="4157" class="Symbol">→</a> <a id="4159" href="Prelude.Equality.html#4148" class="Bound">x</a> <a id="4161" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="4163" href="Prelude.Equality.html#4150" class="Bound">y</a> <a id="4165" class="Symbol">→</a> <a id="4167" href="Prelude.Equality.html#4150" class="Bound">y</a> <a id="4169" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="4171" href="Prelude.Equality.html#4148" class="Bound">x</a>
 <a id="4174" href="Prelude.Equality.html#4174" class="Bound">p</a> <a id="4176" href="Prelude.Equality.html#4141" class="Function Operator">⁻¹</a> <a id="4179" class="Symbol">=</a> <a id="4181" href="Prelude.Equality.html#2893" class="Function">≡-sym</a> <a id="4187" href="Prelude.Equality.html#4174" class="Bound">p</a>

</pre>

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` .

Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.

<pre class="Agda">

 <a id="hide-sym-trans._∙_"></a><a id="4447" href="Prelude.Equality.html#4447" class="Function Operator">_∙_</a> <a id="4451" class="Symbol">:</a> <a id="4453" class="Symbol">{</a><a id="4454" href="Prelude.Equality.html#4454" class="Bound">x</a> <a id="4456" href="Prelude.Equality.html#4456" class="Bound">y</a> <a id="4458" href="Prelude.Equality.html#4458" class="Bound">z</a> <a id="4460" class="Symbol">:</a> <a id="4462" href="Prelude.Equality.html#4123" class="Bound">A</a><a id="4463" class="Symbol">}</a> <a id="4465" class="Symbol">→</a> <a id="4467" href="Prelude.Equality.html#4454" class="Bound">x</a> <a id="4469" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="4471" href="Prelude.Equality.html#4456" class="Bound">y</a> <a id="4473" class="Symbol">→</a> <a id="4475" href="Prelude.Equality.html#4456" class="Bound">y</a> <a id="4477" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="4479" href="Prelude.Equality.html#4458" class="Bound">z</a> <a id="4481" class="Symbol">→</a> <a id="4483" href="Prelude.Equality.html#4454" class="Bound">x</a> <a id="4485" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="4487" href="Prelude.Equality.html#4458" class="Bound">z</a>
 <a id="4490" href="Prelude.Equality.html#4490" class="Bound">p</a> <a id="4492" href="Prelude.Equality.html#4447" class="Function Operator">∙</a> <a id="4494" href="Prelude.Equality.html#4494" class="Bound">q</a> <a id="4496" class="Symbol">=</a> <a id="4498" href="Prelude.Equality.html#3038" class="Function">≡-trans</a> <a id="4506" href="Prelude.Equality.html#4490" class="Bound">p</a> <a id="4508" href="Prelude.Equality.html#4494" class="Bound">q</a>

</pre>

As usual, we import the original definitions from the [Type Topology][] library.

<pre class="Agda">

<a id="4619" class="Keyword">open</a> <a id="4624" class="Keyword">import</a> <a id="4631" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="4640" class="Keyword">using</a> <a id="4646" class="Symbol">(</a><a id="4647" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="4650" class="Symbol">;</a> <a id="4652" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="4655" class="Symbol">)</a> <a id="4657" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Prelude.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[2](Preliminaries.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="5350" class="Keyword">module</a> <a id="hide-transport"></a><a id="5357" href="Prelude.Equality.html#5357" class="Module">hide-transport</a> <a id="5372" class="Symbol">{</a><a id="5373" href="Prelude.Equality.html#5373" class="Bound">𝓤</a> <a id="5375" href="Prelude.Equality.html#5375" class="Bound">𝓦</a> <a id="5377" class="Symbol">:</a> <a id="5379" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5387" class="Symbol">}</a> <a id="5389" class="Keyword">where</a>

 <a id="hide-transport.𝑖𝑑"></a><a id="5397" href="Prelude.Equality.html#5397" class="Function">𝑖𝑑</a> <a id="5400" class="Symbol">:</a> <a id="5402" class="Symbol">{</a><a id="5403" href="Prelude.Equality.html#5403" class="Bound">𝓧</a> <a id="5405" class="Symbol">:</a> <a id="5407" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5415" class="Symbol">}</a> <a id="5417" class="Symbol">(</a><a id="5418" href="Prelude.Equality.html#5418" class="Bound">X</a> <a id="5420" class="Symbol">:</a> <a id="5422" href="Prelude.Equality.html#5403" class="Bound">𝓧</a> <a id="5424" href="Universes.html#403" class="Function Operator">̇</a> <a id="5426" class="Symbol">)</a> <a id="5428" class="Symbol">→</a> <a id="5430" href="Prelude.Equality.html#5418" class="Bound">X</a> <a id="5432" class="Symbol">→</a> <a id="5434" href="Prelude.Equality.html#5418" class="Bound">X</a>
 <a id="5437" href="Prelude.Equality.html#5397" class="Function">𝑖𝑑</a> <a id="5440" href="Prelude.Equality.html#5440" class="Bound">X</a> <a id="5442" class="Symbol">=</a> <a id="5444" class="Symbol">λ</a> <a id="5446" href="Prelude.Equality.html#5446" class="Bound">x</a> <a id="5448" class="Symbol">→</a> <a id="5450" href="Prelude.Equality.html#5446" class="Bound">x</a>

 <a id="hide-transport.transport"></a><a id="5454" href="Prelude.Equality.html#5454" class="Function">transport</a> <a id="5464" class="Symbol">:</a> <a id="5466" class="Symbol">{</a><a id="5467" href="Prelude.Equality.html#5467" class="Bound">A</a> <a id="5469" class="Symbol">:</a> <a id="5471" href="Prelude.Equality.html#5373" class="Bound">𝓤</a> <a id="5473" href="Universes.html#403" class="Function Operator">̇</a> <a id="5475" class="Symbol">}</a> <a id="5477" class="Symbol">(</a><a id="5478" href="Prelude.Equality.html#5478" class="Bound">B</a> <a id="5480" class="Symbol">:</a> <a id="5482" href="Prelude.Equality.html#5467" class="Bound">A</a> <a id="5484" class="Symbol">→</a> <a id="5486" href="Prelude.Equality.html#5375" class="Bound">𝓦</a> <a id="5488" href="Universes.html#403" class="Function Operator">̇</a> <a id="5490" class="Symbol">)</a> <a id="5492" class="Symbol">{</a><a id="5493" href="Prelude.Equality.html#5493" class="Bound">x</a> <a id="5495" href="Prelude.Equality.html#5495" class="Bound">y</a> <a id="5497" class="Symbol">:</a> <a id="5499" href="Prelude.Equality.html#5467" class="Bound">A</a><a id="5500" class="Symbol">}</a> <a id="5502" class="Symbol">→</a> <a id="5504" href="Prelude.Equality.html#5493" class="Bound">x</a> <a id="5506" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="5508" href="Prelude.Equality.html#5495" class="Bound">y</a> <a id="5510" class="Symbol">→</a> <a id="5512" href="Prelude.Equality.html#5478" class="Bound">B</a> <a id="5514" href="Prelude.Equality.html#5493" class="Bound">x</a> <a id="5516" class="Symbol">→</a> <a id="5518" href="Prelude.Equality.html#5478" class="Bound">B</a> <a id="5520" href="Prelude.Equality.html#5495" class="Bound">y</a>
 <a id="5523" href="Prelude.Equality.html#5454" class="Function">transport</a> <a id="5533" href="Prelude.Equality.html#5533" class="Bound">B</a> <a id="5535" class="Symbol">(</a><a id="5536" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5541" class="Symbol">{</a><a id="5542" class="Argument">x</a> <a id="5544" class="Symbol">=</a> <a id="5546" href="Prelude.Equality.html#5546" class="Bound">x</a><a id="5547" class="Symbol">})</a> <a id="5550" class="Symbol">=</a> <a id="5552" href="Prelude.Equality.html#5397" class="Function">𝑖𝑑</a> <a id="5555" class="Symbol">(</a><a id="5556" href="Prelude.Equality.html#5533" class="Bound">B</a> <a id="5558" href="Prelude.Equality.html#5546" class="Bound">x</a><a id="5559" class="Symbol">)</a>

<a id="5562" class="Keyword">open</a> <a id="5567" class="Keyword">import</a> <a id="5574" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5583" class="Keyword">using</a> <a id="5589" class="Symbol">(</a><a id="5590" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="5592" class="Symbol">;</a> <a id="5594" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="5603" class="Symbol">)</a> <a id="5605" class="Keyword">public</a>

</pre>

As usual, we display `transport` in a hidden module and then imported the existing definition from [Type Topology][]. 

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="6189" class="Keyword">module</a> <a id="hide-ap"></a><a id="6196" href="Prelude.Equality.html#6196" class="Module">hide-ap</a>  <a id="6205" class="Symbol">{</a><a id="6206" href="Prelude.Equality.html#6206" class="Bound">𝓤</a> <a id="6208" class="Symbol">:</a> <a id="6210" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6218" class="Symbol">}{</a><a id="6220" href="Prelude.Equality.html#6220" class="Bound">A</a> <a id="6222" class="Symbol">:</a> <a id="6224" href="Prelude.Equality.html#6206" class="Bound">𝓤</a> <a id="6226" href="Universes.html#403" class="Function Operator">̇</a><a id="6227" class="Symbol">}{</a><a id="6229" href="Prelude.Equality.html#6229" class="Bound">B</a> <a id="6231" class="Symbol">:</a> <a id="6233" href="Universes.html#262" class="Generalizable">𝓥</a> <a id="6235" href="Universes.html#403" class="Function Operator">̇</a><a id="6236" class="Symbol">}</a> <a id="6238" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="6246" href="Prelude.Equality.html#6246" class="Function">ap</a> <a id="6249" class="Symbol">:</a> <a id="6251" class="Symbol">(</a><a id="6252" href="Prelude.Equality.html#6252" class="Bound">f</a> <a id="6254" class="Symbol">:</a> <a id="6256" href="Prelude.Equality.html#6220" class="Bound">A</a> <a id="6258" class="Symbol">→</a> <a id="6260" href="Prelude.Equality.html#6229" class="Bound">B</a><a id="6261" class="Symbol">){</a><a id="6263" href="Prelude.Equality.html#6263" class="Bound">x</a> <a id="6265" href="Prelude.Equality.html#6265" class="Bound">y</a> <a id="6267" class="Symbol">:</a> <a id="6269" href="Prelude.Equality.html#6220" class="Bound">A</a><a id="6270" class="Symbol">}</a> <a id="6272" class="Symbol">→</a> <a id="6274" href="Prelude.Equality.html#6263" class="Bound">x</a> <a id="6276" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="6278" href="Prelude.Equality.html#6265" class="Bound">y</a> <a id="6280" class="Symbol">→</a> <a id="6282" href="Prelude.Equality.html#6252" class="Bound">f</a> <a id="6284" href="Prelude.Equality.html#6263" class="Bound">x</a> <a id="6286" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="6288" href="Prelude.Equality.html#6252" class="Bound">f</a> <a id="6290" href="Prelude.Equality.html#6265" class="Bound">y</a>
 <a id="6293" href="Prelude.Equality.html#6246" class="Function">ap</a> <a id="6296" href="Prelude.Equality.html#6296" class="Bound">f</a> <a id="6298" class="Symbol">{</a><a id="6299" href="Prelude.Equality.html#6299" class="Bound">x</a><a id="6300" class="Symbol">}</a> <a id="6302" href="Prelude.Equality.html#6302" class="Bound">p</a> <a id="6304" class="Symbol">=</a> <a id="6306" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="6316" class="Symbol">(λ</a> <a id="6319" href="Prelude.Equality.html#6319" class="Bound">-</a> <a id="6321" class="Symbol">→</a> <a id="6323" href="Prelude.Equality.html#6296" class="Bound">f</a> <a id="6325" href="Prelude.Equality.html#6299" class="Bound">x</a> <a id="6327" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="6329" href="Prelude.Equality.html#6296" class="Bound">f</a> <a id="6331" href="Prelude.Equality.html#6319" class="Bound">-</a><a id="6332" class="Symbol">)</a> <a id="6334" href="Prelude.Equality.html#6302" class="Bound">p</a> <a id="6336" class="Symbol">(</a><a id="6337" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6342" class="Symbol">{</a><a id="6343" class="Argument">x</a> <a id="6345" class="Symbol">=</a> <a id="6347" href="Prelude.Equality.html#6296" class="Bound">f</a> <a id="6349" href="Prelude.Equality.html#6299" class="Bound">x</a><a id="6350" class="Symbol">})</a>

<a id="6354" class="Keyword">open</a> <a id="6359" class="Keyword">import</a> <a id="6366" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="6375" class="Keyword">using</a> <a id="6381" class="Symbol">(</a><a id="6382" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="6384" class="Symbol">)</a> <a id="6386" class="Keyword">public</a>

</pre>

We now define some variations of `ap` that are sometimes useful.

<pre class="Agda">

<a id="6486" class="Keyword">module</a> <a id="6493" href="Prelude.Equality.html#6493" class="Module">_</a> <a id="6495" class="Symbol">{</a><a id="6496" href="Prelude.Equality.html#6496" class="Bound">𝓤</a> <a id="6498" href="Prelude.Equality.html#6498" class="Bound">𝓦</a> <a id="6500" class="Symbol">:</a> <a id="6502" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6510" class="Symbol">}{</a><a id="6512" href="Prelude.Equality.html#6512" class="Bound">A</a> <a id="6514" class="Symbol">:</a> <a id="6516" href="Prelude.Equality.html#6496" class="Bound">𝓤</a> <a id="6518" href="Universes.html#403" class="Function Operator">̇</a><a id="6519" class="Symbol">}</a> <a id="6521" class="Keyword">where</a>

 <a id="6529" href="Prelude.Equality.html#6529" class="Function">ap-cong</a> <a id="6537" class="Symbol">:</a> <a id="6539" class="Symbol">{</a><a id="6540" href="Prelude.Equality.html#6540" class="Bound">B</a> <a id="6542" class="Symbol">:</a> <a id="6544" href="Prelude.Equality.html#6498" class="Bound">𝓦</a> <a id="6546" href="Universes.html#403" class="Function Operator">̇</a><a id="6547" class="Symbol">}{</a><a id="6549" href="Prelude.Equality.html#6549" class="Bound">f</a> <a id="6551" href="Prelude.Equality.html#6551" class="Bound">g</a> <a id="6553" class="Symbol">:</a> <a id="6555" href="Prelude.Equality.html#6512" class="Bound">A</a> <a id="6557" class="Symbol">→</a> <a id="6559" href="Prelude.Equality.html#6540" class="Bound">B</a><a id="6560" class="Symbol">}{</a><a id="6562" href="Prelude.Equality.html#6562" class="Bound">a</a> <a id="6564" href="Prelude.Equality.html#6564" class="Bound">b</a> <a id="6566" class="Symbol">:</a> <a id="6568" href="Prelude.Equality.html#6512" class="Bound">A</a><a id="6569" class="Symbol">}</a> <a id="6571" class="Symbol">→</a> <a id="6573" href="Prelude.Equality.html#6549" class="Bound">f</a> <a id="6575" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="6577" href="Prelude.Equality.html#6551" class="Bound">g</a> <a id="6579" class="Symbol">→</a> <a id="6581" href="Prelude.Equality.html#6562" class="Bound">a</a> <a id="6583" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="6585" href="Prelude.Equality.html#6564" class="Bound">b</a> <a id="6587" class="Symbol">→</a> <a id="6589" href="Prelude.Equality.html#6549" class="Bound">f</a> <a id="6591" href="Prelude.Equality.html#6562" class="Bound">a</a> <a id="6593" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="6595" href="Prelude.Equality.html#6551" class="Bound">g</a> <a id="6597" href="Prelude.Equality.html#6564" class="Bound">b</a>
 <a id="6600" href="Prelude.Equality.html#6529" class="Function">ap-cong</a> <a id="6608" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6613" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6618" class="Symbol">=</a> <a id="6620" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

We sometimes need a version of this that works for [dependent types][], such as the following (which we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][], transcribed into MHE/UALib notation of course):

<pre class="Agda">

 <a id="6891" href="Prelude.Equality.html#6891" class="Function">cong-app</a> <a id="6900" class="Symbol">:</a> <a id="6902" class="Symbol">{</a><a id="6903" href="Prelude.Equality.html#6903" class="Bound">B</a> <a id="6905" class="Symbol">:</a> <a id="6907" href="Prelude.Equality.html#6512" class="Bound">A</a> <a id="6909" class="Symbol">→</a> <a id="6911" href="Prelude.Equality.html#6498" class="Bound">𝓦</a> <a id="6913" href="Universes.html#403" class="Function Operator">̇</a><a id="6914" class="Symbol">}{</a><a id="6916" href="Prelude.Equality.html#6916" class="Bound">f</a> <a id="6918" href="Prelude.Equality.html#6918" class="Bound">g</a> <a id="6920" class="Symbol">:</a> <a id="6922" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="6924" href="Prelude.Equality.html#6903" class="Bound">B</a><a id="6925" class="Symbol">}</a> <a id="6927" class="Symbol">→</a> <a id="6929" href="Prelude.Equality.html#6916" class="Bound">f</a> <a id="6931" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="6933" href="Prelude.Equality.html#6918" class="Bound">g</a> <a id="6935" class="Symbol">→</a> <a id="6937" class="Symbol">∀</a> <a id="6939" href="Prelude.Equality.html#6939" class="Bound">x</a> <a id="6941" class="Symbol">→</a> <a id="6943" href="Prelude.Equality.html#6916" class="Bound">f</a> <a id="6945" href="Prelude.Equality.html#6939" class="Bound">x</a> <a id="6947" href="Prelude.Equality.html#2301" class="Datatype Operator">≡</a> <a id="6949" href="Prelude.Equality.html#6918" class="Bound">g</a> <a id="6951" href="Prelude.Equality.html#6939" class="Bound">x</a>
 <a id="6954" href="Prelude.Equality.html#6891" class="Function">cong-app</a> <a id="6963" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6968" class="Symbol">_</a> <a id="6970" class="Symbol">=</a> <a id="6972" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>




-------------------------------------


<sup>1</sup><span class="footnote" id="fn1"> Per Martin-Löf, *An intuitionistic theory of types: predicative part*, Logic Colloquium '73 (Bristol, 1973), 73--118, Studies in Logic and the Foundations of Mathematics, Vol. 80, 1975.

<sup>2</sup><span class="footnote" id="fn2"> The *definiendum* is the left-hand side of a defining equation, the *definiens* is the right-hand side. For readers who have never generated an equivalence relation: the *reflexive closure* of `R ⊆ A × A `is the union of `R` and all pairs of the form `(a , a)`; the *symmetric closure* is the union of R and its inverse `\{(y , x) : (x , y) ∈ R\}`; we leave it to the reader to come up with the correct definition of transitive closure.

<sup>3</sup><span class="footnote" id="fn3"> **Unicode Hints**. In [agda2-mode][] type `⁻¹` as `\^-\^1`, type `𝑖𝑑` as `\Mii\Mid`, and type `∙` as `\.`. In general, to get information about a given unicode character (e.g., how to type it) place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>

<sup>4</sup><span class="footnote" id="fn4"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170). See also [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).<span>

<p></p>
<p></p>


[← Prelude.Preliminaries ](Prelude.Preliminaries.html)
<span style="float:right;">[Prelude.Extensionality →](Prelude.Extensionality.html)</span>

{% include UALib.Links.md %}


<!-- NO LONGER USED

#### <a id="≡-intro-and-≡-elim-for-nondependent-pairs">≡-intro and ≡-elim for nondependent pairs</a>

We conclude the Equality module with some occasionally useful introduction and elimination rules for the equality relation on (nondependent) pair types.

 ≡-elim-left : {A₁ A₂ : 𝓤 ̇}{B₁ B₂ : 𝓦 ̇} → (A₁ , B₁) ≡ (A₂ , B₂) → A₁ ≡ A₂
 ≡-elim-left e = ap fst e


 ≡-elim-right : {A₁ A₂ : 𝓤 ̇}{B₁ B₂ : 𝓦 ̇} → (A₁ , B₁) ≡ (A₂ , B₂) → B₁ ≡ B₂
 ≡-elim-right e = ap snd e


 ≡-×-intro : {A₁ A₂ : 𝓤 ̇} {B₁ B₂ : 𝓦 ̇} → A₁ ≡ A₂ → B₁ ≡ B₂ → (A₁ , B₁) ≡ (A₂ , B₂)
 ≡-×-intro refl refl = refl


 ≡-×-int : {A : 𝓤 ̇}{B : 𝓦 ̇}{a x : A}{b y : B} → a ≡ x → b ≡ y → (a , b) ≡ (x , y)
 ≡-×-int refl refl = refl

-->
