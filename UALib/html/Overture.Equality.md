---
layout: default
title : Overture.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This is the [Overture.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="266" class="Symbol">{-#</a> <a id="270" class="Keyword">OPTIONS</a> <a id="278" class="Pragma">--without-K</a> <a id="290" class="Pragma">--exact-split</a> <a id="304" class="Pragma">--safe</a> <a id="311" class="Symbol">#-}</a>

<a id="316" class="Keyword">module</a> <a id="323" href="Overture.Equality.html" class="Module">Overture.Equality</a> <a id="341" class="Keyword">where</a>

<a id="348" class="Keyword">open</a> <a id="353" class="Keyword">import</a> <a id="360" href="Overture.Preliminaries.html" class="Module">Overture.Preliminaries</a> <a id="383" class="Keyword">public</a>

</pre>

#### <a id="definitional-equality">Definitional equality</a>

Here we discuss what is probably the most important type in [MLTT][]. It is called *definitional equality*. This concept is easily understood, at least heuristically, with the following slogan:

*Definitional equality is the substitution-preserving equivalence relation generated by definitions.*

We will make this precise below, but first let us quote from a primary source.

In [An Intuitionistic Theory of Types: Predicative Part](https://www.sciencedirect.com/science/article/pii/S0049237X08719451), Per Martin-Löf offers the following definition (italics added):<sup>[1](Overture.Equality.html#fn1)</sup>

"*Definitional equality* is defined to be the equivalence relation, that is, reflexive, symmetric and transitive relation, which is generated by the principles that a definiendum is always definitionally equal to its definiens and that definitional equality is preserved under substitution."<sup>[2](Overture.Equality.html#fn2)

To be sure we understand what this means, let `:=` denote the relation with respect to which `x` is related to `y` (denoted `x := y`) if and only if `y` *is the definition of* `x`.  Then the definitional equality relation `≡` is the reflexive, symmetric, transitive, substitutive closure of `:=`. By *subsitutive closure* we mean closure under the following *substitution rule*.


```agda
    {A : 𝓤 ̇} {B : A → 𝓦 ̇} {x y : A}   x ≡ y
    ------------------------------------------ (subst)
                B x ≡ B y
```

The datatype we use to represent definitional equality is imported from the Identity-Type module of the [Type Topology][] library, but apart from superficial syntactic differences, it is equivalent to the standard *Paulin-Mohring style identity type* found in most other Agda libraries.  We repeat the definition here for easy reference.

<pre class="Agda">

<a id="2280" class="Keyword">module</a> <a id="hide-refl"></a><a id="2287" href="Overture.Equality.html#2287" class="Module">hide-refl</a> <a id="2297" class="Keyword">where</a>

 <a id="2305" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="2310" href="Overture.Equality.html#2310" class="Datatype Operator">_≡_</a> <a id="2314" class="Symbol">{</a><a id="2315" href="Overture.Equality.html#2315" class="Bound">A</a> <a id="2317" class="Symbol">:</a> <a id="2319" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2321" href="Universes.html#403" class="Function Operator">̇</a><a id="2322" class="Symbol">}</a> <a id="2324" class="Symbol">:</a> <a id="2326" href="Overture.Equality.html#2315" class="Bound">A</a> <a id="2328" class="Symbol">→</a> <a id="2330" href="Overture.Equality.html#2315" class="Bound">A</a> <a id="2332" class="Symbol">→</a> <a id="2334" href="Overture.Equality.html#2319" class="Bound">𝓤</a> <a id="2336" href="Universes.html#403" class="Function Operator">̇</a> <a id="2338" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="2344" href="Overture.Equality.html#2344" class="InductiveConstructor">refl</a> <a id="2349" class="Symbol">:</a> <a id="2351" class="Symbol">{</a><a id="2352" href="Overture.Equality.html#2352" class="Bound">x</a> <a id="2354" class="Symbol">:</a> <a id="2356" href="Overture.Equality.html#2315" class="Bound">A</a><a id="2357" class="Symbol">}</a> <a id="2359" class="Symbol">→</a> <a id="2361" href="Overture.Equality.html#2352" class="Bound">x</a> <a id="2363" href="Overture.Equality.html#2310" class="Datatype Operator">≡</a> <a id="2365" href="Overture.Equality.html#2352" class="Bound">x</a>

<a id="2368" class="Keyword">open</a> <a id="2373" class="Keyword">import</a> <a id="2380" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="2394" class="Keyword">renaming</a> <a id="2403" class="Symbol">(</a><a id="2404" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="2408" class="Symbol">to</a> <a id="2411" class="Keyword">infix</a> <a id="2417" class="Number">0</a> <a id="_≡_"></a><a id="2419" href="Overture.Equality.html#2419" class="Datatype Operator">_≡_</a><a id="2422" class="Symbol">)</a> <a id="2424" class="Keyword">public</a>

</pre>

Whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we invoke `refl`.  If we need to make explicit the implicit argument `x`, then we use `refl {x = x}`.

Of course `≡` is an equivalence relation and the formal proof of this fact is trivial. We don't need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

<pre class="Agda">

<a id="≡-sym"></a><a id="2895" href="Overture.Equality.html#2895" class="Function">≡-sym</a> <a id="2901" class="Symbol">:</a> <a id="2903" class="Symbol">{</a><a id="2904" href="Overture.Equality.html#2904" class="Bound">A</a> <a id="2906" class="Symbol">:</a> <a id="2908" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2910" href="Universes.html#403" class="Function Operator">̇</a><a id="2911" class="Symbol">}{</a><a id="2913" href="Overture.Equality.html#2913" class="Bound">x</a> <a id="2915" href="Overture.Equality.html#2915" class="Bound">y</a> <a id="2917" class="Symbol">:</a> <a id="2919" href="Overture.Equality.html#2904" class="Bound">A</a><a id="2920" class="Symbol">}</a> <a id="2922" class="Symbol">→</a> <a id="2924" href="Overture.Equality.html#2913" class="Bound">x</a> <a id="2926" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="2928" href="Overture.Equality.html#2915" class="Bound">y</a> <a id="2930" class="Symbol">→</a> <a id="2932" href="Overture.Equality.html#2915" class="Bound">y</a> <a id="2934" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="2936" href="Overture.Equality.html#2913" class="Bound">x</a>
<a id="2938" href="Overture.Equality.html#2895" class="Function">≡-sym</a> <a id="2944" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2949" class="Symbol">=</a> <a id="2951" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

<a id="≡-trans"></a><a id="2957" href="Overture.Equality.html#2957" class="Function">≡-trans</a> <a id="2965" class="Symbol">:</a> <a id="2967" class="Symbol">{</a><a id="2968" href="Overture.Equality.html#2968" class="Bound">A</a> <a id="2970" class="Symbol">:</a> <a id="2972" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2974" href="Universes.html#403" class="Function Operator">̇</a><a id="2975" class="Symbol">}{</a><a id="2977" href="Overture.Equality.html#2977" class="Bound">x</a> <a id="2979" href="Overture.Equality.html#2979" class="Bound">y</a> <a id="2981" href="Overture.Equality.html#2981" class="Bound">z</a> <a id="2983" class="Symbol">:</a> <a id="2985" href="Overture.Equality.html#2968" class="Bound">A</a><a id="2986" class="Symbol">}</a> <a id="2988" class="Symbol">→</a> <a id="2990" href="Overture.Equality.html#2977" class="Bound">x</a> <a id="2992" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="2994" href="Overture.Equality.html#2979" class="Bound">y</a> <a id="2996" class="Symbol">→</a> <a id="2998" href="Overture.Equality.html#2979" class="Bound">y</a> <a id="3000" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3002" href="Overture.Equality.html#2981" class="Bound">z</a> <a id="3004" class="Symbol">→</a> <a id="3006" href="Overture.Equality.html#2977" class="Bound">x</a> <a id="3008" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3010" href="Overture.Equality.html#2981" class="Bound">z</a>
<a id="3012" href="Overture.Equality.html#2957" class="Function">≡-trans</a> <a id="3020" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3025" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3030" class="Symbol">=</a> <a id="3032" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

We prove that `≡` obeys the substitution rule (subst) in the next subsection (see the definition of `ap` below), but first we define some syntactic sugar that will make it easier to apply symmetry and transitivity of `≡` in proofs.<sup>[3](Overture.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="3339" class="Keyword">module</a> <a id="hide-sym-trans"></a><a id="3346" href="Overture.Equality.html#3346" class="Module">hide-sym-trans</a> <a id="3361" class="Symbol">{</a><a id="3362" href="Overture.Equality.html#3362" class="Bound">A</a> <a id="3364" class="Symbol">:</a> <a id="3366" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="3368" href="Universes.html#403" class="Function Operator">̇</a><a id="3369" class="Symbol">}</a> <a id="3371" class="Keyword">where</a>

 <a id="hide-sym-trans._⁻¹"></a><a id="3379" href="Overture.Equality.html#3379" class="Function Operator">_⁻¹</a> <a id="3383" class="Symbol">:</a> <a id="3385" class="Symbol">{</a><a id="3386" href="Overture.Equality.html#3386" class="Bound">x</a> <a id="3388" href="Overture.Equality.html#3388" class="Bound">y</a> <a id="3390" class="Symbol">:</a> <a id="3392" href="Overture.Equality.html#3362" class="Bound">A</a><a id="3393" class="Symbol">}</a> <a id="3395" class="Symbol">→</a> <a id="3397" href="Overture.Equality.html#3386" class="Bound">x</a> <a id="3399" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3401" href="Overture.Equality.html#3388" class="Bound">y</a> <a id="3403" class="Symbol">→</a> <a id="3405" href="Overture.Equality.html#3388" class="Bound">y</a> <a id="3407" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3409" href="Overture.Equality.html#3386" class="Bound">x</a>
 <a id="3412" href="Overture.Equality.html#3412" class="Bound">p</a> <a id="3414" href="Overture.Equality.html#3379" class="Function Operator">⁻¹</a> <a id="3417" class="Symbol">=</a> <a id="3419" href="Overture.Equality.html#2895" class="Function">≡-sym</a> <a id="3425" href="Overture.Equality.html#3412" class="Bound">p</a>

</pre>

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` . Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.

<pre class="Agda">

 <a id="hide-sym-trans._∙_"></a><a id="3684" href="Overture.Equality.html#3684" class="Function Operator">_∙_</a> <a id="3688" class="Symbol">:</a> <a id="3690" class="Symbol">{</a><a id="3691" href="Overture.Equality.html#3691" class="Bound">x</a> <a id="3693" href="Overture.Equality.html#3693" class="Bound">y</a> <a id="3695" href="Overture.Equality.html#3695" class="Bound">z</a> <a id="3697" class="Symbol">:</a> <a id="3699" href="Overture.Equality.html#3362" class="Bound">A</a><a id="3700" class="Symbol">}</a> <a id="3702" class="Symbol">→</a> <a id="3704" href="Overture.Equality.html#3691" class="Bound">x</a> <a id="3706" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3708" href="Overture.Equality.html#3693" class="Bound">y</a> <a id="3710" class="Symbol">→</a> <a id="3712" href="Overture.Equality.html#3693" class="Bound">y</a> <a id="3714" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3716" href="Overture.Equality.html#3695" class="Bound">z</a> <a id="3718" class="Symbol">→</a> <a id="3720" href="Overture.Equality.html#3691" class="Bound">x</a> <a id="3722" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3724" href="Overture.Equality.html#3695" class="Bound">z</a>
 <a id="3727" href="Overture.Equality.html#3727" class="Bound">p</a> <a id="3729" href="Overture.Equality.html#3684" class="Function Operator">∙</a> <a id="3731" href="Overture.Equality.html#3731" class="Bound">q</a> <a id="3733" class="Symbol">=</a> <a id="3735" href="Overture.Equality.html#2957" class="Function">≡-trans</a> <a id="3743" href="Overture.Equality.html#3727" class="Bound">p</a> <a id="3745" href="Overture.Equality.html#3731" class="Bound">q</a>

</pre>

As usual, we import the original definitions from the [Type Topology][] library.

<pre class="Agda">

<a id="3856" class="Keyword">open</a> <a id="3861" class="Keyword">import</a> <a id="3868" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="3877" class="Keyword">using</a> <a id="3883" class="Symbol">(</a><a id="3884" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="3887" class="Symbol">;</a> <a id="3889" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="3892" class="Symbol">)</a> <a id="3894" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Overture.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[3](Preliminaries.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="4588" class="Keyword">module</a> <a id="hide-id-transport"></a><a id="4595" href="Overture.Equality.html#4595" class="Module">hide-id-transport</a> <a id="4613" class="Keyword">where</a>

 <a id="hide-id-transport.𝑖𝑑"></a><a id="4621" href="Overture.Equality.html#4621" class="Function">𝑖𝑑</a> <a id="4624" class="Symbol">:</a> <a id="4626" class="Symbol">(</a><a id="4627" href="Overture.Equality.html#4627" class="Bound">A</a> <a id="4629" class="Symbol">:</a> <a id="4631" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="4633" href="Universes.html#403" class="Function Operator">̇</a> <a id="4635" class="Symbol">)</a> <a id="4637" class="Symbol">→</a> <a id="4639" href="Overture.Equality.html#4627" class="Bound">A</a> <a id="4641" class="Symbol">→</a> <a id="4643" href="Overture.Equality.html#4627" class="Bound">A</a>
 <a id="4646" href="Overture.Equality.html#4621" class="Function">𝑖𝑑</a> <a id="4649" href="Overture.Equality.html#4649" class="Bound">A</a> <a id="4651" class="Symbol">=</a> <a id="4653" class="Symbol">λ</a> <a id="4655" href="Overture.Equality.html#4655" class="Bound">x</a> <a id="4657" class="Symbol">→</a> <a id="4659" href="Overture.Equality.html#4655" class="Bound">x</a>

 <a id="hide-id-transport.transport"></a><a id="4663" href="Overture.Equality.html#4663" class="Function">transport</a> <a id="4673" class="Symbol">:</a> <a id="4675" class="Symbol">{</a><a id="4676" href="Overture.Equality.html#4676" class="Bound">A</a> <a id="4678" class="Symbol">:</a> <a id="4680" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="4682" href="Universes.html#403" class="Function Operator">̇</a><a id="4683" class="Symbol">}(</a><a id="4685" href="Overture.Equality.html#4685" class="Bound">B</a> <a id="4687" class="Symbol">:</a> <a id="4689" href="Overture.Equality.html#4676" class="Bound">A</a> <a id="4691" class="Symbol">→</a> <a id="4693" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="4695" href="Universes.html#403" class="Function Operator">̇</a><a id="4696" class="Symbol">){</a><a id="4698" href="Overture.Equality.html#4698" class="Bound">x</a> <a id="4700" href="Overture.Equality.html#4700" class="Bound">y</a> <a id="4702" class="Symbol">:</a> <a id="4704" href="Overture.Equality.html#4676" class="Bound">A</a><a id="4705" class="Symbol">}</a> <a id="4707" class="Symbol">→</a> <a id="4709" href="Overture.Equality.html#4698" class="Bound">x</a> <a id="4711" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="4713" href="Overture.Equality.html#4700" class="Bound">y</a> <a id="4715" class="Symbol">→</a> <a id="4717" href="Overture.Equality.html#4685" class="Bound">B</a> <a id="4719" href="Overture.Equality.html#4698" class="Bound">x</a> <a id="4721" class="Symbol">→</a> <a id="4723" href="Overture.Equality.html#4685" class="Bound">B</a> <a id="4725" href="Overture.Equality.html#4700" class="Bound">y</a>
 <a id="4728" href="Overture.Equality.html#4663" class="Function">transport</a> <a id="4738" href="Overture.Equality.html#4738" class="Bound">B</a> <a id="4740" class="Symbol">(</a><a id="4741" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="4746" class="Symbol">{</a><a id="4747" class="Argument">x</a> <a id="4749" class="Symbol">=</a> <a id="4751" href="Overture.Equality.html#4751" class="Bound">x</a><a id="4752" class="Symbol">})</a> <a id="4755" class="Symbol">=</a> <a id="4757" href="Overture.Equality.html#4621" class="Function">𝑖𝑑</a> <a id="4760" class="Symbol">(</a><a id="4761" href="Overture.Equality.html#4738" class="Bound">B</a> <a id="4763" href="Overture.Equality.html#4751" class="Bound">x</a><a id="4764" class="Symbol">)</a>

<a id="4767" class="Keyword">open</a> <a id="4772" class="Keyword">import</a> <a id="4779" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="4788" class="Keyword">using</a> <a id="4794" class="Symbol">(</a><a id="4795" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="4797" class="Symbol">;</a> <a id="4799" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="4808" class="Symbol">)</a> <a id="4810" class="Keyword">public</a>

</pre>

As usual, we display definitions of existing types (here, `𝑖𝑑` and `transport`) in a hidden module and then imported their original definition from [Type Topology][].

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="5442" class="Keyword">module</a> <a id="hide-ap"></a><a id="5449" href="Overture.Equality.html#5449" class="Module">hide-ap</a> <a id="5457" class="Symbol">{</a><a id="5458" href="Overture.Equality.html#5458" class="Bound">A</a> <a id="5460" class="Symbol">:</a> <a id="5462" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="5464" href="Universes.html#403" class="Function Operator">̇</a><a id="5465" class="Symbol">}{</a><a id="5467" href="Overture.Equality.html#5467" class="Bound">B</a> <a id="5469" class="Symbol">:</a> <a id="5471" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="5473" href="Universes.html#403" class="Function Operator">̇</a><a id="5474" class="Symbol">}</a> <a id="5476" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="5484" href="Overture.Equality.html#5484" class="Function">ap</a> <a id="5487" class="Symbol">:</a> <a id="5489" class="Symbol">(</a><a id="5490" href="Overture.Equality.html#5490" class="Bound">f</a> <a id="5492" class="Symbol">:</a> <a id="5494" href="Overture.Equality.html#5458" class="Bound">A</a> <a id="5496" class="Symbol">→</a> <a id="5498" href="Overture.Equality.html#5467" class="Bound">B</a><a id="5499" class="Symbol">){</a><a id="5501" href="Overture.Equality.html#5501" class="Bound">x</a> <a id="5503" href="Overture.Equality.html#5503" class="Bound">y</a> <a id="5505" class="Symbol">:</a> <a id="5507" href="Overture.Equality.html#5458" class="Bound">A</a><a id="5508" class="Symbol">}</a> <a id="5510" class="Symbol">→</a> <a id="5512" href="Overture.Equality.html#5501" class="Bound">x</a> <a id="5514" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="5516" href="Overture.Equality.html#5503" class="Bound">y</a> <a id="5518" class="Symbol">→</a> <a id="5520" href="Overture.Equality.html#5490" class="Bound">f</a> <a id="5522" href="Overture.Equality.html#5501" class="Bound">x</a> <a id="5524" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="5526" href="Overture.Equality.html#5490" class="Bound">f</a> <a id="5528" href="Overture.Equality.html#5503" class="Bound">y</a>
 <a id="5531" href="Overture.Equality.html#5484" class="Function">ap</a> <a id="5534" href="Overture.Equality.html#5534" class="Bound">f</a> <a id="5536" class="Symbol">{</a><a id="5537" href="Overture.Equality.html#5537" class="Bound">x</a><a id="5538" class="Symbol">}</a> <a id="5540" href="Overture.Equality.html#5540" class="Bound">p</a> <a id="5542" class="Symbol">=</a> <a id="5544" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="5554" class="Symbol">(λ</a> <a id="5557" href="Overture.Equality.html#5557" class="Bound">-</a> <a id="5559" class="Symbol">→</a> <a id="5561" href="Overture.Equality.html#5534" class="Bound">f</a> <a id="5563" href="Overture.Equality.html#5537" class="Bound">x</a> <a id="5565" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="5567" href="Overture.Equality.html#5534" class="Bound">f</a> <a id="5569" href="Overture.Equality.html#5557" class="Bound">-</a><a id="5570" class="Symbol">)</a> <a id="5572" href="Overture.Equality.html#5540" class="Bound">p</a> <a id="5574" class="Symbol">(</a><a id="5575" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5580" class="Symbol">{</a><a id="5581" class="Argument">x</a> <a id="5583" class="Symbol">=</a> <a id="5585" href="Overture.Equality.html#5534" class="Bound">f</a> <a id="5587" href="Overture.Equality.html#5537" class="Bound">x</a><a id="5588" class="Symbol">})</a>

<a id="5592" class="Keyword">open</a> <a id="5597" class="Keyword">import</a> <a id="5604" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5613" class="Keyword">using</a> <a id="5619" class="Symbol">(</a><a id="5620" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="5622" class="Symbol">)</a> <a id="5624" class="Keyword">public</a>

</pre>

Here's a useful variation of `ap` that we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][] (transcribed into TypeTopology/UALib notation of course).

<pre class="Agda">

<a id="cong-app"></a><a id="5843" href="Overture.Equality.html#5843" class="Function">cong-app</a> <a id="5852" class="Symbol">:</a> <a id="5854" class="Symbol">{</a><a id="5855" href="Overture.Equality.html#5855" class="Bound">A</a> <a id="5857" class="Symbol">:</a> <a id="5859" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="5861" href="Universes.html#403" class="Function Operator">̇</a><a id="5862" class="Symbol">}{</a><a id="5864" href="Overture.Equality.html#5864" class="Bound">B</a> <a id="5866" class="Symbol">:</a> <a id="5868" href="Overture.Equality.html#5855" class="Bound">A</a> <a id="5870" class="Symbol">→</a> <a id="5872" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="5874" href="Universes.html#403" class="Function Operator">̇</a><a id="5875" class="Symbol">}{</a><a id="5877" href="Overture.Equality.html#5877" class="Bound">f</a> <a id="5879" href="Overture.Equality.html#5879" class="Bound">g</a> <a id="5881" class="Symbol">:</a> <a id="5883" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="5885" href="Overture.Equality.html#5864" class="Bound">B</a><a id="5886" class="Symbol">}</a> <a id="5888" class="Symbol">→</a> <a id="5890" href="Overture.Equality.html#5877" class="Bound">f</a> <a id="5892" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="5894" href="Overture.Equality.html#5879" class="Bound">g</a> <a id="5896" class="Symbol">→</a> <a id="5898" class="Symbol">∀</a> <a id="5900" href="Overture.Equality.html#5900" class="Bound">x</a> <a id="5902" class="Symbol">→</a> <a id="5904" href="Overture.Equality.html#5877" class="Bound">f</a> <a id="5906" href="Overture.Equality.html#5900" class="Bound">x</a> <a id="5908" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="5910" href="Overture.Equality.html#5879" class="Bound">g</a> <a id="5912" href="Overture.Equality.html#5900" class="Bound">x</a>
<a id="5914" href="Overture.Equality.html#5843" class="Function">cong-app</a> <a id="5923" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5928" class="Symbol">_</a> <a id="5930" class="Symbol">=</a> <a id="5932" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>





-------------------------------------


<sup>1</sup><span class="footnote" id="fn1"> Per Martin-Löf, *An intuitionistic theory of types: predicative part*, Logic Colloquium '73 (Bristol, 1973), 73--118, Studies in Logic and the Foundations of Mathematics, Vol. 80, 1975.</span>

<sup>2</sup><span class="footnote" id="fn2"> The *definiendum* is the left-hand side of a defining equation, the *definiens* is the right-hand side. For readers who have never generated an equivalence relation: the *reflexive closure* of `R ⊆ A × A `is the union of `R` and all pairs of the form `(a , a)`; the *symmetric closure* is the union of `R` and its inverse `{(y , x) : (x , y) ∈ R}`; we leave it to the reader to come up with the correct definition of transitive closure.</span>

<sup>3</sup><span class="footnote" id="fn3"> **Unicode Hints** ([agda2-mode][]). `\^-\^1 ↝ ⁻¹`; `\Mii\Mid ↝ 𝑖𝑑`; `\. ↝ ∙`. In general, for information about a character, place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>



<sup>4</sup><span class="footnote" id="fn4"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170). See also [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).</span>

<br>
<br>

[← Overture.Preliminaries ](Overture.Preliminaries.html)
<span style="float:right;">[Overture.FunExtensionality →](Overture.FunExtensionality.html)</span>

{% include UALib.Links.md %}


