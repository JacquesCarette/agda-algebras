---
layout: default
title : Overture.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This is the [Overture.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="266" class="Symbol">{-#</a> <a id="270" class="Keyword">OPTIONS</a> <a id="278" class="Pragma">--without-K</a> <a id="290" class="Pragma">--exact-split</a> <a id="304" class="Pragma">--safe</a> <a id="311" class="Symbol">#-}</a>

<a id="316" class="Keyword">module</a> <a id="323" href="Overture.Equality.html" class="Module">Overture.Equality</a> <a id="341" class="Keyword">where</a>

<a id="348" class="Keyword">open</a> <a id="353" class="Keyword">import</a> <a id="360" href="Overture.Preliminaries.html" class="Module">Overture.Preliminaries</a> <a id="383" class="Keyword">public</a>

</pre>

#### <a id="definitional-equality">Definitional equality</a>

Here we discuss what is probably the most important type in [MLTT][]. It is called *definitional equality*. This concept is easily understood, at least heuristically, with the following slogan:

*Definitional equality is the substitution-preserving equivalence relation generated by definitions.*

We will make this precise below, but first let us quote from a primary source.

In [An Intuitionistic Theory of Types: Predicative Part](https://www.sciencedirect.com/science/article/pii/S0049237X08719451), Per Martin-Löof offers the following definition (italics added):<sup>[1](Overture.Equality.html#fn1)</sup>

"*Definitional equality* is defined to be the equivalence relation, that is, reflexive, symmetric and transitive relation, which is generated by the principles that a definiendum is always definitionally equal to its definiens and that definitional equality is preserved under substitution."<sup>[2](Overture.Equality.html#fn2)

To be sure we understand what this means, let `:=` denote the relation with respect to which `x` is related to `y` (denoted `x := y`) if and only if `y` *is the definition of* `x`.  Then the definitional equality relation `≡` is the reflexive, symmetric, transitive, substitutive closure of `:=`. By *subsitutive closure* we mean closure under the following *substitution rule*.


```agda
    {A : 𝓤 ̇} {B : A → 𝓦 ̇} {x y : A}   x ≡ y
    ------------------------------------------
                B x ≡ B y
```

The datatype we use to represent definitional equality is imported from the Identity-Type module of the [Type Topology][] library, but apart from superficial syntactic differences, it is equivalent to the identity type used in all other Agda libraries we know of.  We repeat the definition here for easy reference.

<pre class="Agda">

<a id="2250" class="Keyword">module</a> <a id="hide-refl"></a><a id="2257" href="Overture.Equality.html#2257" class="Module">hide-refl</a> <a id="2267" class="Keyword">where</a>

 <a id="2275" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="2280" href="Overture.Equality.html#2280" class="Datatype Operator">_≡_</a> <a id="2284" class="Symbol">{</a><a id="2285" href="Overture.Equality.html#2285" class="Bound">A</a> <a id="2287" class="Symbol">:</a> <a id="2289" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2291" href="Universes.html#403" class="Function Operator">̇</a><a id="2292" class="Symbol">}</a> <a id="2294" class="Symbol">:</a> <a id="2296" href="Overture.Equality.html#2285" class="Bound">A</a> <a id="2298" class="Symbol">→</a> <a id="2300" href="Overture.Equality.html#2285" class="Bound">A</a> <a id="2302" class="Symbol">→</a> <a id="2304" href="Overture.Equality.html#2289" class="Bound">𝓤</a> <a id="2306" href="Universes.html#403" class="Function Operator">̇</a> <a id="2308" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="2314" href="Overture.Equality.html#2314" class="InductiveConstructor">refl</a> <a id="2319" class="Symbol">:</a> <a id="2321" class="Symbol">{</a><a id="2322" href="Overture.Equality.html#2322" class="Bound">x</a> <a id="2324" class="Symbol">:</a> <a id="2326" href="Overture.Equality.html#2285" class="Bound">A</a><a id="2327" class="Symbol">}</a> <a id="2329" class="Symbol">→</a> <a id="2331" href="Overture.Equality.html#2322" class="Bound">x</a> <a id="2333" href="Overture.Equality.html#2280" class="Datatype Operator">≡</a> <a id="2335" href="Overture.Equality.html#2322" class="Bound">x</a>

<a id="2338" class="Keyword">open</a> <a id="2343" class="Keyword">import</a> <a id="2350" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="2364" class="Keyword">renaming</a> <a id="2373" class="Symbol">(</a><a id="2374" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="2378" class="Symbol">to</a> <a id="2381" class="Keyword">infix</a> <a id="2387" class="Number">0</a> <a id="_≡_"></a><a id="2389" href="Overture.Equality.html#2389" class="Datatype Operator">_≡_</a><a id="2392" class="Symbol">)</a> <a id="2394" class="Keyword">public</a>

</pre>

Whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we invoke `refl`.  If we need to make explicit the implicit argument `x`, then we use `refl {x = x}`.

Of course `≡` is an equivalence relation and the formal proof of this fact is trivial. We don't need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

<pre class="Agda">

<a id="≡-symmetric"></a><a id="2865" href="Overture.Equality.html#2865" class="Function">≡-symmetric</a> <a id="2877" class="Symbol">:</a> <a id="2879" class="Symbol">{</a><a id="2880" href="Overture.Equality.html#2880" class="Bound">A</a> <a id="2882" class="Symbol">:</a> <a id="2884" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2886" href="Universes.html#403" class="Function Operator">̇</a><a id="2887" class="Symbol">}(</a><a id="2889" href="Overture.Equality.html#2889" class="Bound">x</a> <a id="2891" href="Overture.Equality.html#2891" class="Bound">y</a> <a id="2893" class="Symbol">:</a> <a id="2895" href="Overture.Equality.html#2880" class="Bound">A</a><a id="2896" class="Symbol">)</a> <a id="2898" class="Symbol">→</a> <a id="2900" href="Overture.Equality.html#2889" class="Bound">x</a> <a id="2902" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="2904" href="Overture.Equality.html#2891" class="Bound">y</a> <a id="2906" class="Symbol">→</a> <a id="2908" href="Overture.Equality.html#2891" class="Bound">y</a> <a id="2910" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="2912" href="Overture.Equality.html#2889" class="Bound">x</a>
<a id="2914" href="Overture.Equality.html#2865" class="Function">≡-symmetric</a> <a id="2926" class="Symbol">_</a> <a id="2928" class="Symbol">_</a> <a id="2930" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2935" class="Symbol">=</a> <a id="2937" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

<a id="≡-sym"></a><a id="2943" href="Overture.Equality.html#2943" class="Function">≡-sym</a> <a id="2949" class="Symbol">:</a> <a id="2951" class="Symbol">{</a><a id="2952" href="Overture.Equality.html#2952" class="Bound">A</a> <a id="2954" class="Symbol">:</a> <a id="2956" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2958" href="Universes.html#403" class="Function Operator">̇</a><a id="2959" class="Symbol">}{</a><a id="2961" href="Overture.Equality.html#2961" class="Bound">x</a> <a id="2963" href="Overture.Equality.html#2963" class="Bound">y</a> <a id="2965" class="Symbol">:</a> <a id="2967" href="Overture.Equality.html#2952" class="Bound">A</a><a id="2968" class="Symbol">}</a> <a id="2970" class="Symbol">→</a> <a id="2972" href="Overture.Equality.html#2961" class="Bound">x</a> <a id="2974" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="2976" href="Overture.Equality.html#2963" class="Bound">y</a> <a id="2978" class="Symbol">→</a> <a id="2980" href="Overture.Equality.html#2963" class="Bound">y</a> <a id="2982" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="2984" href="Overture.Equality.html#2961" class="Bound">x</a>
<a id="2986" href="Overture.Equality.html#2943" class="Function">≡-sym</a> <a id="2992" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="2997" class="Symbol">=</a> <a id="2999" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

<a id="≡-transitive"></a><a id="3005" href="Overture.Equality.html#3005" class="Function">≡-transitive</a> <a id="3018" class="Symbol">:</a> <a id="3020" class="Symbol">{</a><a id="3021" href="Overture.Equality.html#3021" class="Bound">A</a> <a id="3023" class="Symbol">:</a> <a id="3025" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="3027" href="Universes.html#403" class="Function Operator">̇</a><a id="3028" class="Symbol">}(</a><a id="3030" href="Overture.Equality.html#3030" class="Bound">x</a> <a id="3032" href="Overture.Equality.html#3032" class="Bound">y</a> <a id="3034" href="Overture.Equality.html#3034" class="Bound">z</a> <a id="3036" class="Symbol">:</a> <a id="3038" href="Overture.Equality.html#3021" class="Bound">A</a><a id="3039" class="Symbol">)</a> <a id="3041" class="Symbol">→</a> <a id="3043" href="Overture.Equality.html#3030" class="Bound">x</a> <a id="3045" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="3047" href="Overture.Equality.html#3032" class="Bound">y</a> <a id="3049" class="Symbol">→</a> <a id="3051" href="Overture.Equality.html#3032" class="Bound">y</a> <a id="3053" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="3055" href="Overture.Equality.html#3034" class="Bound">z</a> <a id="3057" class="Symbol">→</a> <a id="3059" href="Overture.Equality.html#3030" class="Bound">x</a> <a id="3061" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="3063" href="Overture.Equality.html#3034" class="Bound">z</a>
<a id="3065" href="Overture.Equality.html#3005" class="Function">≡-transitive</a> <a id="3078" class="Symbol">_</a> <a id="3080" class="Symbol">_</a> <a id="3082" class="Symbol">_</a> <a id="3084" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3089" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3094" class="Symbol">=</a> <a id="3096" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

<a id="≡-trans"></a><a id="3102" href="Overture.Equality.html#3102" class="Function">≡-trans</a> <a id="3110" class="Symbol">:</a> <a id="3112" class="Symbol">{</a><a id="3113" href="Overture.Equality.html#3113" class="Bound">A</a> <a id="3115" class="Symbol">:</a> <a id="3117" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="3119" href="Universes.html#403" class="Function Operator">̇</a><a id="3120" class="Symbol">}{</a><a id="3122" href="Overture.Equality.html#3122" class="Bound">x</a> <a id="3124" href="Overture.Equality.html#3124" class="Bound">y</a> <a id="3126" href="Overture.Equality.html#3126" class="Bound">z</a> <a id="3128" class="Symbol">:</a> <a id="3130" href="Overture.Equality.html#3113" class="Bound">A</a><a id="3131" class="Symbol">}</a> <a id="3133" class="Symbol">→</a> <a id="3135" href="Overture.Equality.html#3122" class="Bound">x</a> <a id="3137" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="3139" href="Overture.Equality.html#3124" class="Bound">y</a> <a id="3141" class="Symbol">→</a> <a id="3143" href="Overture.Equality.html#3124" class="Bound">y</a> <a id="3145" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="3147" href="Overture.Equality.html#3126" class="Bound">z</a> <a id="3149" class="Symbol">→</a> <a id="3151" href="Overture.Equality.html#3122" class="Bound">x</a> <a id="3153" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="3155" href="Overture.Equality.html#3126" class="Bound">z</a>
<a id="3157" href="Overture.Equality.html#3102" class="Function">≡-trans</a> <a id="3165" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3170" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3175" class="Symbol">=</a> <a id="3177" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

The only difference between `≡-symmetric` and `≡-sym` (respectively, `≡-transitive` and `≡-trans`) is that the latter has fewer explicit arguments, which is sometimes convenient.

We prove that `≡` obeys the substitution rule (subst) in the next subsection (see the definition of `ap` below), but first we define some syntactic sugar that will make it easier to apply symmetry and transitivity of `≡` in proofs.<sup>[3](Overture.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="3664" class="Keyword">module</a> <a id="hide-sym-trans"></a><a id="3671" href="Overture.Equality.html#3671" class="Module">hide-sym-trans</a> <a id="3686" class="Symbol">{</a><a id="3687" href="Overture.Equality.html#3687" class="Bound">A</a> <a id="3689" class="Symbol">:</a> <a id="3691" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="3693" href="Universes.html#403" class="Function Operator">̇</a><a id="3694" class="Symbol">}</a> <a id="3696" class="Keyword">where</a>

 <a id="hide-sym-trans._⁻¹"></a><a id="3704" href="Overture.Equality.html#3704" class="Function Operator">_⁻¹</a> <a id="3708" class="Symbol">:</a> <a id="3710" class="Symbol">{</a><a id="3711" href="Overture.Equality.html#3711" class="Bound">x</a> <a id="3713" href="Overture.Equality.html#3713" class="Bound">y</a> <a id="3715" class="Symbol">:</a> <a id="3717" href="Overture.Equality.html#3687" class="Bound">A</a><a id="3718" class="Symbol">}</a> <a id="3720" class="Symbol">→</a> <a id="3722" href="Overture.Equality.html#3711" class="Bound">x</a> <a id="3724" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="3726" href="Overture.Equality.html#3713" class="Bound">y</a> <a id="3728" class="Symbol">→</a> <a id="3730" href="Overture.Equality.html#3713" class="Bound">y</a> <a id="3732" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="3734" href="Overture.Equality.html#3711" class="Bound">x</a>
 <a id="3737" href="Overture.Equality.html#3737" class="Bound">p</a> <a id="3739" href="Overture.Equality.html#3704" class="Function Operator">⁻¹</a> <a id="3742" class="Symbol">=</a> <a id="3744" href="Overture.Equality.html#2943" class="Function">≡-sym</a> <a id="3750" href="Overture.Equality.html#3737" class="Bound">p</a>

</pre>

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` . Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.

<pre class="Agda">

 <a id="hide-sym-trans._∙_"></a><a id="4009" href="Overture.Equality.html#4009" class="Function Operator">_∙_</a> <a id="4013" class="Symbol">:</a> <a id="4015" class="Symbol">{</a><a id="4016" href="Overture.Equality.html#4016" class="Bound">x</a> <a id="4018" href="Overture.Equality.html#4018" class="Bound">y</a> <a id="4020" href="Overture.Equality.html#4020" class="Bound">z</a> <a id="4022" class="Symbol">:</a> <a id="4024" href="Overture.Equality.html#3687" class="Bound">A</a><a id="4025" class="Symbol">}</a> <a id="4027" class="Symbol">→</a> <a id="4029" href="Overture.Equality.html#4016" class="Bound">x</a> <a id="4031" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="4033" href="Overture.Equality.html#4018" class="Bound">y</a> <a id="4035" class="Symbol">→</a> <a id="4037" href="Overture.Equality.html#4018" class="Bound">y</a> <a id="4039" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="4041" href="Overture.Equality.html#4020" class="Bound">z</a> <a id="4043" class="Symbol">→</a> <a id="4045" href="Overture.Equality.html#4016" class="Bound">x</a> <a id="4047" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="4049" href="Overture.Equality.html#4020" class="Bound">z</a>
 <a id="4052" href="Overture.Equality.html#4052" class="Bound">p</a> <a id="4054" href="Overture.Equality.html#4009" class="Function Operator">∙</a> <a id="4056" href="Overture.Equality.html#4056" class="Bound">q</a> <a id="4058" class="Symbol">=</a> <a id="4060" href="Overture.Equality.html#3102" class="Function">≡-trans</a> <a id="4068" href="Overture.Equality.html#4052" class="Bound">p</a> <a id="4070" href="Overture.Equality.html#4056" class="Bound">q</a>

</pre>

As usual, we import the original definitions from the [Type Topology][] library.

<pre class="Agda">

<a id="4181" class="Keyword">open</a> <a id="4186" class="Keyword">import</a> <a id="4193" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="4202" class="Keyword">using</a> <a id="4208" class="Symbol">(</a><a id="4209" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="4212" class="Symbol">;</a> <a id="4214" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="4217" class="Symbol">)</a> <a id="4219" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Overture.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[2](Preliminaries.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="4913" class="Keyword">module</a> <a id="hide-id-transport"></a><a id="4920" href="Overture.Equality.html#4920" class="Module">hide-id-transport</a> <a id="4938" class="Keyword">where</a>

 <a id="hide-id-transport.𝑖𝑑"></a><a id="4946" href="Overture.Equality.html#4946" class="Function">𝑖𝑑</a> <a id="4949" class="Symbol">:</a> <a id="4951" class="Symbol">(</a><a id="4952" href="Overture.Equality.html#4952" class="Bound">A</a> <a id="4954" class="Symbol">:</a> <a id="4956" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="4958" href="Universes.html#403" class="Function Operator">̇</a> <a id="4960" class="Symbol">)</a> <a id="4962" class="Symbol">→</a> <a id="4964" href="Overture.Equality.html#4952" class="Bound">A</a> <a id="4966" class="Symbol">→</a> <a id="4968" href="Overture.Equality.html#4952" class="Bound">A</a>
 <a id="4971" href="Overture.Equality.html#4946" class="Function">𝑖𝑑</a> <a id="4974" href="Overture.Equality.html#4974" class="Bound">A</a> <a id="4976" class="Symbol">=</a> <a id="4978" class="Symbol">λ</a> <a id="4980" href="Overture.Equality.html#4980" class="Bound">x</a> <a id="4982" class="Symbol">→</a> <a id="4984" href="Overture.Equality.html#4980" class="Bound">x</a>

 <a id="hide-id-transport.transport"></a><a id="4988" href="Overture.Equality.html#4988" class="Function">transport</a> <a id="4998" class="Symbol">:</a> <a id="5000" class="Symbol">{</a><a id="5001" href="Overture.Equality.html#5001" class="Bound">A</a> <a id="5003" class="Symbol">:</a> <a id="5005" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="5007" href="Universes.html#403" class="Function Operator">̇</a><a id="5008" class="Symbol">}(</a><a id="5010" href="Overture.Equality.html#5010" class="Bound">B</a> <a id="5012" class="Symbol">:</a> <a id="5014" href="Overture.Equality.html#5001" class="Bound">A</a> <a id="5016" class="Symbol">→</a> <a id="5018" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="5020" href="Universes.html#403" class="Function Operator">̇</a><a id="5021" class="Symbol">){</a><a id="5023" href="Overture.Equality.html#5023" class="Bound">x</a> <a id="5025" href="Overture.Equality.html#5025" class="Bound">y</a> <a id="5027" class="Symbol">:</a> <a id="5029" href="Overture.Equality.html#5001" class="Bound">A</a><a id="5030" class="Symbol">}</a> <a id="5032" class="Symbol">→</a> <a id="5034" href="Overture.Equality.html#5023" class="Bound">x</a> <a id="5036" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="5038" href="Overture.Equality.html#5025" class="Bound">y</a> <a id="5040" class="Symbol">→</a> <a id="5042" href="Overture.Equality.html#5010" class="Bound">B</a> <a id="5044" href="Overture.Equality.html#5023" class="Bound">x</a> <a id="5046" class="Symbol">→</a> <a id="5048" href="Overture.Equality.html#5010" class="Bound">B</a> <a id="5050" href="Overture.Equality.html#5025" class="Bound">y</a>
 <a id="5053" href="Overture.Equality.html#4988" class="Function">transport</a> <a id="5063" href="Overture.Equality.html#5063" class="Bound">B</a> <a id="5065" class="Symbol">(</a><a id="5066" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5071" class="Symbol">{</a><a id="5072" class="Argument">x</a> <a id="5074" class="Symbol">=</a> <a id="5076" href="Overture.Equality.html#5076" class="Bound">x</a><a id="5077" class="Symbol">})</a> <a id="5080" class="Symbol">=</a> <a id="5082" href="Overture.Equality.html#4946" class="Function">𝑖𝑑</a> <a id="5085" class="Symbol">(</a><a id="5086" href="Overture.Equality.html#5063" class="Bound">B</a> <a id="5088" href="Overture.Equality.html#5076" class="Bound">x</a><a id="5089" class="Symbol">)</a>

<a id="5092" class="Keyword">open</a> <a id="5097" class="Keyword">import</a> <a id="5104" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5113" class="Keyword">using</a> <a id="5119" class="Symbol">(</a><a id="5120" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="5122" class="Symbol">;</a> <a id="5124" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="5133" class="Symbol">)</a> <a id="5135" class="Keyword">public</a>

</pre>

As usual, we display definitions of existing types (here, `𝑖𝑑` and `transport`) in a hidden module and then imported their original definition from [Type Topology][].

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="5767" class="Keyword">module</a> <a id="hide-ap"></a><a id="5774" href="Overture.Equality.html#5774" class="Module">hide-ap</a> <a id="5782" class="Symbol">{</a><a id="5783" href="Overture.Equality.html#5783" class="Bound">A</a> <a id="5785" class="Symbol">:</a> <a id="5787" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="5789" href="Universes.html#403" class="Function Operator">̇</a><a id="5790" class="Symbol">}{</a><a id="5792" href="Overture.Equality.html#5792" class="Bound">B</a> <a id="5794" class="Symbol">:</a> <a id="5796" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="5798" href="Universes.html#403" class="Function Operator">̇</a><a id="5799" class="Symbol">}</a> <a id="5801" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="5809" href="Overture.Equality.html#5809" class="Function">ap</a> <a id="5812" class="Symbol">:</a> <a id="5814" class="Symbol">(</a><a id="5815" href="Overture.Equality.html#5815" class="Bound">f</a> <a id="5817" class="Symbol">:</a> <a id="5819" href="Overture.Equality.html#5783" class="Bound">A</a> <a id="5821" class="Symbol">→</a> <a id="5823" href="Overture.Equality.html#5792" class="Bound">B</a><a id="5824" class="Symbol">){</a><a id="5826" href="Overture.Equality.html#5826" class="Bound">x</a> <a id="5828" href="Overture.Equality.html#5828" class="Bound">y</a> <a id="5830" class="Symbol">:</a> <a id="5832" href="Overture.Equality.html#5783" class="Bound">A</a><a id="5833" class="Symbol">}</a> <a id="5835" class="Symbol">→</a> <a id="5837" href="Overture.Equality.html#5826" class="Bound">x</a> <a id="5839" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="5841" href="Overture.Equality.html#5828" class="Bound">y</a> <a id="5843" class="Symbol">→</a> <a id="5845" href="Overture.Equality.html#5815" class="Bound">f</a> <a id="5847" href="Overture.Equality.html#5826" class="Bound">x</a> <a id="5849" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="5851" href="Overture.Equality.html#5815" class="Bound">f</a> <a id="5853" href="Overture.Equality.html#5828" class="Bound">y</a>
 <a id="5856" href="Overture.Equality.html#5809" class="Function">ap</a> <a id="5859" href="Overture.Equality.html#5859" class="Bound">f</a> <a id="5861" class="Symbol">{</a><a id="5862" href="Overture.Equality.html#5862" class="Bound">x</a><a id="5863" class="Symbol">}</a> <a id="5865" href="Overture.Equality.html#5865" class="Bound">p</a> <a id="5867" class="Symbol">=</a> <a id="5869" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="5879" class="Symbol">(λ</a> <a id="5882" href="Overture.Equality.html#5882" class="Bound">-</a> <a id="5884" class="Symbol">→</a> <a id="5886" href="Overture.Equality.html#5859" class="Bound">f</a> <a id="5888" href="Overture.Equality.html#5862" class="Bound">x</a> <a id="5890" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="5892" href="Overture.Equality.html#5859" class="Bound">f</a> <a id="5894" href="Overture.Equality.html#5882" class="Bound">-</a><a id="5895" class="Symbol">)</a> <a id="5897" href="Overture.Equality.html#5865" class="Bound">p</a> <a id="5899" class="Symbol">(</a><a id="5900" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5905" class="Symbol">{</a><a id="5906" class="Argument">x</a> <a id="5908" class="Symbol">=</a> <a id="5910" href="Overture.Equality.html#5859" class="Bound">f</a> <a id="5912" href="Overture.Equality.html#5862" class="Bound">x</a><a id="5913" class="Symbol">})</a>

<a id="5917" class="Keyword">open</a> <a id="5922" class="Keyword">import</a> <a id="5929" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5938" class="Keyword">using</a> <a id="5944" class="Symbol">(</a><a id="5945" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="5947" class="Symbol">)</a> <a id="5949" class="Keyword">public</a>

</pre>

Here's a useful variation of `ap` that we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][] (transcribed into TypeTopology/UALib notation of course).

<pre class="Agda">

<a id="cong-app"></a><a id="6168" href="Overture.Equality.html#6168" class="Function">cong-app</a> <a id="6177" class="Symbol">:</a> <a id="6179" class="Symbol">{</a><a id="6180" href="Overture.Equality.html#6180" class="Bound">A</a> <a id="6182" class="Symbol">:</a> <a id="6184" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="6186" href="Universes.html#403" class="Function Operator">̇</a><a id="6187" class="Symbol">}{</a><a id="6189" href="Overture.Equality.html#6189" class="Bound">B</a> <a id="6191" class="Symbol">:</a> <a id="6193" href="Overture.Equality.html#6180" class="Bound">A</a> <a id="6195" class="Symbol">→</a> <a id="6197" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="6199" href="Universes.html#403" class="Function Operator">̇</a><a id="6200" class="Symbol">}{</a><a id="6202" href="Overture.Equality.html#6202" class="Bound">f</a> <a id="6204" href="Overture.Equality.html#6204" class="Bound">g</a> <a id="6206" class="Symbol">:</a> <a id="6208" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="6210" href="Overture.Equality.html#6189" class="Bound">B</a><a id="6211" class="Symbol">}</a> <a id="6213" class="Symbol">→</a> <a id="6215" href="Overture.Equality.html#6202" class="Bound">f</a> <a id="6217" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="6219" href="Overture.Equality.html#6204" class="Bound">g</a> <a id="6221" class="Symbol">→</a> <a id="6223" class="Symbol">∀</a> <a id="6225" href="Overture.Equality.html#6225" class="Bound">x</a> <a id="6227" class="Symbol">→</a> <a id="6229" href="Overture.Equality.html#6202" class="Bound">f</a> <a id="6231" href="Overture.Equality.html#6225" class="Bound">x</a> <a id="6233" href="Overture.Equality.html#2389" class="Datatype Operator">≡</a> <a id="6235" href="Overture.Equality.html#6204" class="Bound">g</a> <a id="6237" href="Overture.Equality.html#6225" class="Bound">x</a>
<a id="6239" href="Overture.Equality.html#6168" class="Function">cong-app</a> <a id="6248" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6253" class="Symbol">_</a> <a id="6255" class="Symbol">=</a> <a id="6257" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>





-------------------------------------


<sup>1</sup><span class="footnote" id="fn1"> Per Martin-Löf, *An intuitionistic theory of types: predicative part*, Logic Colloquium '73 (Bristol, 1973), 73--118, Studies in Logic and the Foundations of Mathematics, Vol. 80, 1975.</span>

<sup>2</sup><span class="footnote" id="fn2"> The *definiendum* is the left-hand side of a defining equation, the *definiens* is the right-hand side. For readers who have never generated an equivalence relation: the *reflexive closure* of `R ⊆ A × A `is the union of `R` and all pairs of the form `(a , a)`; the *symmetric closure* is the union of `R` and its inverse `{(y , x) : (x , y) ∈ R}`; we leave it to the reader to come up with the correct definition of transitive closure.</span>

<sup>3</sup><span class="footnote" id="fn3"> **Unicode Hints** ([agda2-mode][]). `\^-\^1 ↝ ⁻¹`; `\Mii\Mid ↝ 𝑖𝑑`; `\. ↝ ∙`. In general, for information about a character, place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>



<sup>4</sup><span class="footnote" id="fn4"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170). See also [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).</span>

<br>
<br>

[← Overture.Preliminaries ](Overture.Preliminaries.html)
<span style="float:right;">[Overture.Extensionality →](Overture.Extensionality.html)</span>

{% include UALib.Links.md %}


