---
layout: default
title : Overture.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This is the [Overture.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="266" class="Symbol">{-#</a> <a id="270" class="Keyword">OPTIONS</a> <a id="278" class="Pragma">--without-K</a> <a id="290" class="Pragma">--exact-split</a> <a id="304" class="Pragma">--safe</a> <a id="311" class="Symbol">#-}</a>

<a id="316" class="Keyword">module</a> <a id="323" href="Overture.Equality.html" class="Module">Overture.Equality</a> <a id="341" class="Keyword">where</a>

<a id="348" class="Keyword">open</a> <a id="353" class="Keyword">import</a> <a id="360" href="Overture.Preliminaries.html" class="Module">Overture.Preliminaries</a> <a id="383" class="Keyword">public</a>

</pre>

#### <a id="definitional-equality">Definitional equality</a>

Here we discuss what is probably the most important type in [MLTT][]. It is called *definitional equality*. This concept is easily understood, at least heuristically, with the following slogan:

*Definitional equality is the substitution-preserving equivalence relation generated by definitions.*

We will make this precise below, but first let us quote from a primary source.

In [An Intuitionistic Theory of Types: Predicative Part](https://www.sciencedirect.com/science/article/pii/S0049237X08719451), Per Martin-Löof offers the following definition (italics added):<sup>[1](Overture.Equality.html#fn1)</sup>

"*Definitional equality* is defined to be the equivalence relation, that is, reflexive, symmetric and transitive relation, which is generated by the principles that a definiendum is always definitionally equal to its definiens and that definitional equality is preserved under substitution."<sup>[2](Overture.Equality.html#fn2)

To be sure we understand what this means, let `:=` denote the relation with respect to which `x` is related to `y` (denoted `x := y`) if and only if `y` *is the definition of* `x`.  Then the definitional equality relation `≡` is the reflexive, symmetric, transitive, substitutive closure of `:=`. By *subsitutive closure* we mean closure under the following *substitution rule*.

<!--
\begin{prooftree}
\AxiomC{`\{A : 𝓤 ̇\}\{B : A → 𝓦 ̇\}\{x y : A\}`}
\AxiomC{`x ≡ y`}
\Rightlabel{(subst)}
\BinaryInfC{`B x ≡ B y`}
\end{prooftree}
-->

```agda
    {A : 𝓤 ̇} {B : A → 𝓦 ̇} {x y : A}   x ≡ y
    ------------------------------------------
                B x ≡ B y
```

The datatype we use to represent definitional equality is imported from the Identity-Type module of the [Type Topology][] library, but apart from superficial syntactic differences, it is equivalent to the identity type used in all other Agda libraries we know of.  We repeat the definition here for easy reference.

<pre class="Agda">

<a id="2405" class="Keyword">module</a> <a id="hide-refl"></a><a id="2412" href="Overture.Equality.html#2412" class="Module">hide-refl</a> <a id="2422" class="Symbol">{</a><a id="2423" href="Overture.Equality.html#2423" class="Bound">𝓤</a> <a id="2425" class="Symbol">:</a> <a id="2427" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="2435" class="Symbol">}</a> <a id="2437" class="Keyword">where</a>

 <a id="2445" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="2450" href="Overture.Equality.html#2450" class="Datatype Operator">_≡_</a> <a id="2454" class="Symbol">{</a><a id="2455" href="Overture.Equality.html#2455" class="Bound">𝓤</a><a id="2456" class="Symbol">}</a> <a id="2458" class="Symbol">{</a><a id="2459" href="Overture.Equality.html#2459" class="Bound">A</a> <a id="2461" class="Symbol">:</a> <a id="2463" href="Overture.Equality.html#2455" class="Bound">𝓤</a> <a id="2465" href="Universes.html#403" class="Function Operator">̇</a> <a id="2467" class="Symbol">}</a> <a id="2469" class="Symbol">:</a> <a id="2471" href="Overture.Equality.html#2459" class="Bound">A</a> <a id="2473" class="Symbol">→</a> <a id="2475" href="Overture.Equality.html#2459" class="Bound">A</a> <a id="2477" class="Symbol">→</a> <a id="2479" href="Overture.Equality.html#2455" class="Bound">𝓤</a> <a id="2481" href="Universes.html#403" class="Function Operator">̇</a> <a id="2483" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="2489" href="Overture.Equality.html#2489" class="InductiveConstructor">refl</a> <a id="2494" class="Symbol">:</a> <a id="2496" class="Symbol">{</a><a id="2497" href="Overture.Equality.html#2497" class="Bound">x</a> <a id="2499" class="Symbol">:</a> <a id="2501" href="Overture.Equality.html#2459" class="Bound">A</a><a id="2502" class="Symbol">}</a> <a id="2504" class="Symbol">→</a> <a id="2506" href="Overture.Equality.html#2497" class="Bound">x</a> <a id="2508" href="Overture.Equality.html#2450" class="Datatype Operator">≡</a> <a id="2510" href="Overture.Equality.html#2497" class="Bound">x</a>

<a id="2513" class="Keyword">open</a> <a id="2518" class="Keyword">import</a> <a id="2525" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="2539" class="Keyword">renaming</a> <a id="2548" class="Symbol">(</a><a id="2549" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="2553" class="Symbol">to</a> <a id="2556" class="Keyword">infix</a> <a id="2562" class="Number">0</a> <a id="_≡_"></a><a id="2564" href="Overture.Equality.html#2564" class="Datatype Operator">_≡_</a><a id="2567" class="Symbol">)</a> <a id="2569" class="Keyword">public</a>

</pre>

Whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we invoke `refl`.  If we need to make explicit the implicit argument `x`, then we use `refl {x = x}`.

Of course `≡` is an equivalence relation and the formal proof of this fact is trivial. We don't need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

<pre class="Agda">

<a id="3040" class="Keyword">module</a> <a id="3047" href="Overture.Equality.html#3047" class="Module">_</a>  <a id="3050" class="Symbol">{</a><a id="3051" href="Overture.Equality.html#3051" class="Bound">𝓤</a> <a id="3053" class="Symbol">:</a> <a id="3055" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3063" class="Symbol">}{</a><a id="3065" href="Overture.Equality.html#3065" class="Bound">A</a> <a id="3067" class="Symbol">:</a> <a id="3069" href="Overture.Equality.html#3051" class="Bound">𝓤</a> <a id="3071" href="Universes.html#403" class="Function Operator">̇</a> <a id="3073" class="Symbol">}</a>  <a id="3076" class="Keyword">where</a>

 <a id="3084" href="Overture.Equality.html#3084" class="Function">≡-symmetric</a> <a id="3096" class="Symbol">:</a> <a id="3098" class="Symbol">(</a><a id="3099" href="Overture.Equality.html#3099" class="Bound">x</a> <a id="3101" href="Overture.Equality.html#3101" class="Bound">y</a> <a id="3103" class="Symbol">:</a> <a id="3105" href="Overture.Equality.html#3065" class="Bound">A</a><a id="3106" class="Symbol">)</a> <a id="3108" class="Symbol">→</a> <a id="3110" href="Overture.Equality.html#3099" class="Bound">x</a> <a id="3112" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3114" href="Overture.Equality.html#3101" class="Bound">y</a> <a id="3116" class="Symbol">→</a> <a id="3118" href="Overture.Equality.html#3101" class="Bound">y</a> <a id="3120" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3122" href="Overture.Equality.html#3099" class="Bound">x</a>
 <a id="3125" href="Overture.Equality.html#3084" class="Function">≡-symmetric</a> <a id="3137" class="Symbol">_</a> <a id="3139" class="Symbol">_</a> <a id="3141" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3146" class="Symbol">=</a> <a id="3148" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3155" href="Overture.Equality.html#3155" class="Function">≡-sym</a> <a id="3161" class="Symbol">:</a> <a id="3163" class="Symbol">{</a><a id="3164" href="Overture.Equality.html#3164" class="Bound">x</a> <a id="3166" href="Overture.Equality.html#3166" class="Bound">y</a> <a id="3168" class="Symbol">:</a> <a id="3170" href="Overture.Equality.html#3065" class="Bound">A</a><a id="3171" class="Symbol">}</a> <a id="3173" class="Symbol">→</a> <a id="3175" href="Overture.Equality.html#3164" class="Bound">x</a> <a id="3177" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3179" href="Overture.Equality.html#3166" class="Bound">y</a> <a id="3181" class="Symbol">→</a> <a id="3183" href="Overture.Equality.html#3166" class="Bound">y</a> <a id="3185" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3187" href="Overture.Equality.html#3164" class="Bound">x</a>
 <a id="3190" href="Overture.Equality.html#3155" class="Function">≡-sym</a> <a id="3196" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3201" class="Symbol">=</a> <a id="3203" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3210" href="Overture.Equality.html#3210" class="Function">≡-transitive</a> <a id="3223" class="Symbol">:</a> <a id="3225" class="Symbol">(</a><a id="3226" href="Overture.Equality.html#3226" class="Bound">x</a> <a id="3228" href="Overture.Equality.html#3228" class="Bound">y</a> <a id="3230" href="Overture.Equality.html#3230" class="Bound">z</a> <a id="3232" class="Symbol">:</a> <a id="3234" href="Overture.Equality.html#3065" class="Bound">A</a><a id="3235" class="Symbol">)</a> <a id="3237" class="Symbol">→</a> <a id="3239" href="Overture.Equality.html#3226" class="Bound">x</a> <a id="3241" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3243" href="Overture.Equality.html#3228" class="Bound">y</a> <a id="3245" class="Symbol">→</a> <a id="3247" href="Overture.Equality.html#3228" class="Bound">y</a> <a id="3249" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3251" href="Overture.Equality.html#3230" class="Bound">z</a> <a id="3253" class="Symbol">→</a> <a id="3255" href="Overture.Equality.html#3226" class="Bound">x</a> <a id="3257" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3259" href="Overture.Equality.html#3230" class="Bound">z</a>
 <a id="3262" href="Overture.Equality.html#3210" class="Function">≡-transitive</a> <a id="3275" class="Symbol">_</a> <a id="3277" class="Symbol">_</a> <a id="3279" class="Symbol">_</a> <a id="3281" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3286" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3291" class="Symbol">=</a> <a id="3293" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

 <a id="3300" href="Overture.Equality.html#3300" class="Function">≡-trans</a> <a id="3308" class="Symbol">:</a> <a id="3310" class="Symbol">{</a><a id="3311" href="Overture.Equality.html#3311" class="Bound">x</a> <a id="3313" href="Overture.Equality.html#3313" class="Bound">y</a> <a id="3315" href="Overture.Equality.html#3315" class="Bound">z</a> <a id="3317" class="Symbol">:</a> <a id="3319" href="Overture.Equality.html#3065" class="Bound">A</a><a id="3320" class="Symbol">}</a> <a id="3322" class="Symbol">→</a> <a id="3324" href="Overture.Equality.html#3311" class="Bound">x</a> <a id="3326" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3328" href="Overture.Equality.html#3313" class="Bound">y</a> <a id="3330" class="Symbol">→</a> <a id="3332" href="Overture.Equality.html#3313" class="Bound">y</a> <a id="3334" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3336" href="Overture.Equality.html#3315" class="Bound">z</a> <a id="3338" class="Symbol">→</a> <a id="3340" href="Overture.Equality.html#3311" class="Bound">x</a> <a id="3342" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3344" href="Overture.Equality.html#3315" class="Bound">z</a>
 <a id="3347" href="Overture.Equality.html#3300" class="Function">≡-trans</a> <a id="3355" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3360" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3365" class="Symbol">=</a> <a id="3367" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

The only difference between `≡-symmetric` and `≡-sym` (respectively, `≡-transitive` and `≡-trans`) is that the latter has fewer explicit arguments, which is sometimes convenient.

We prove that `≡` obeys the substitution rule (subst) in the next subsection (see the definition of `ap` below), but first we define some syntactic sugar that will make it easier to apply symmetry and transitivity of `≡` in proofs.<sup>[3](Overture.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="3854" class="Keyword">module</a> <a id="hide-sym-trans"></a><a id="3861" href="Overture.Equality.html#3861" class="Module">hide-sym-trans</a> <a id="3876" class="Symbol">{</a><a id="3877" href="Overture.Equality.html#3877" class="Bound">𝓤</a> <a id="3879" class="Symbol">:</a> <a id="3881" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="3889" class="Symbol">}</a> <a id="3891" class="Symbol">{</a><a id="3892" href="Overture.Equality.html#3892" class="Bound">A</a> <a id="3894" class="Symbol">:</a> <a id="3896" href="Overture.Equality.html#3877" class="Bound">𝓤</a> <a id="3898" href="Universes.html#403" class="Function Operator">̇</a> <a id="3900" class="Symbol">}</a> <a id="3902" class="Keyword">where</a>

 <a id="hide-sym-trans._⁻¹"></a><a id="3910" href="Overture.Equality.html#3910" class="Function Operator">_⁻¹</a> <a id="3914" class="Symbol">:</a> <a id="3916" class="Symbol">{</a><a id="3917" href="Overture.Equality.html#3917" class="Bound">x</a> <a id="3919" href="Overture.Equality.html#3919" class="Bound">y</a> <a id="3921" class="Symbol">:</a> <a id="3923" href="Overture.Equality.html#3892" class="Bound">A</a><a id="3924" class="Symbol">}</a> <a id="3926" class="Symbol">→</a> <a id="3928" href="Overture.Equality.html#3917" class="Bound">x</a> <a id="3930" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3932" href="Overture.Equality.html#3919" class="Bound">y</a> <a id="3934" class="Symbol">→</a> <a id="3936" href="Overture.Equality.html#3919" class="Bound">y</a> <a id="3938" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="3940" href="Overture.Equality.html#3917" class="Bound">x</a>
 <a id="3943" href="Overture.Equality.html#3943" class="Bound">p</a> <a id="3945" href="Overture.Equality.html#3910" class="Function Operator">⁻¹</a> <a id="3948" class="Symbol">=</a> <a id="3950" href="Overture.Equality.html#3155" class="Function">≡-sym</a> <a id="3956" href="Overture.Equality.html#3943" class="Bound">p</a>

</pre>

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` . Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.

<pre class="Agda">

 <a id="hide-sym-trans._∙_"></a><a id="4215" href="Overture.Equality.html#4215" class="Function Operator">_∙_</a> <a id="4219" class="Symbol">:</a> <a id="4221" class="Symbol">{</a><a id="4222" href="Overture.Equality.html#4222" class="Bound">x</a> <a id="4224" href="Overture.Equality.html#4224" class="Bound">y</a> <a id="4226" href="Overture.Equality.html#4226" class="Bound">z</a> <a id="4228" class="Symbol">:</a> <a id="4230" href="Overture.Equality.html#3892" class="Bound">A</a><a id="4231" class="Symbol">}</a> <a id="4233" class="Symbol">→</a> <a id="4235" href="Overture.Equality.html#4222" class="Bound">x</a> <a id="4237" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="4239" href="Overture.Equality.html#4224" class="Bound">y</a> <a id="4241" class="Symbol">→</a> <a id="4243" href="Overture.Equality.html#4224" class="Bound">y</a> <a id="4245" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="4247" href="Overture.Equality.html#4226" class="Bound">z</a> <a id="4249" class="Symbol">→</a> <a id="4251" href="Overture.Equality.html#4222" class="Bound">x</a> <a id="4253" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="4255" href="Overture.Equality.html#4226" class="Bound">z</a>
 <a id="4258" href="Overture.Equality.html#4258" class="Bound">p</a> <a id="4260" href="Overture.Equality.html#4215" class="Function Operator">∙</a> <a id="4262" href="Overture.Equality.html#4262" class="Bound">q</a> <a id="4264" class="Symbol">=</a> <a id="4266" href="Overture.Equality.html#3300" class="Function">≡-trans</a> <a id="4274" href="Overture.Equality.html#4258" class="Bound">p</a> <a id="4276" href="Overture.Equality.html#4262" class="Bound">q</a>

</pre>

As usual, we import the original definitions from the [Type Topology][] library.

<pre class="Agda">

<a id="4387" class="Keyword">open</a> <a id="4392" class="Keyword">import</a> <a id="4399" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="4408" class="Keyword">using</a> <a id="4414" class="Symbol">(</a><a id="4415" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="4418" class="Symbol">;</a> <a id="4420" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="4423" class="Symbol">)</a> <a id="4425" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Overture.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[2](Preliminaries.Equality.html#fn2)</sup>

<pre class="Agda">

<a id="5119" class="Keyword">module</a> <a id="hide-id-transport"></a><a id="5126" href="Overture.Equality.html#5126" class="Module">hide-id-transport</a> <a id="5144" class="Symbol">{</a><a id="5145" href="Overture.Equality.html#5145" class="Bound">𝓤</a> <a id="5147" href="Overture.Equality.html#5147" class="Bound">𝓦</a> <a id="5149" class="Symbol">:</a> <a id="5151" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5159" class="Symbol">}</a> <a id="5161" class="Keyword">where</a>

 <a id="hide-id-transport.𝑖𝑑"></a><a id="5169" href="Overture.Equality.html#5169" class="Function">𝑖𝑑</a> <a id="5172" class="Symbol">:</a> <a id="5174" class="Symbol">{</a><a id="5175" href="Overture.Equality.html#5175" class="Bound">𝓤</a> <a id="5177" class="Symbol">:</a> <a id="5179" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="5187" class="Symbol">}</a> <a id="5189" class="Symbol">(</a><a id="5190" href="Overture.Equality.html#5190" class="Bound">A</a> <a id="5192" class="Symbol">:</a> <a id="5194" href="Overture.Equality.html#5175" class="Bound">𝓤</a> <a id="5196" href="Universes.html#403" class="Function Operator">̇</a> <a id="5198" class="Symbol">)</a> <a id="5200" class="Symbol">→</a> <a id="5202" href="Overture.Equality.html#5190" class="Bound">A</a> <a id="5204" class="Symbol">→</a> <a id="5206" href="Overture.Equality.html#5190" class="Bound">A</a>
 <a id="5209" href="Overture.Equality.html#5169" class="Function">𝑖𝑑</a> <a id="5212" href="Overture.Equality.html#5212" class="Bound">A</a> <a id="5214" class="Symbol">=</a> <a id="5216" class="Symbol">λ</a> <a id="5218" href="Overture.Equality.html#5218" class="Bound">x</a> <a id="5220" class="Symbol">→</a> <a id="5222" href="Overture.Equality.html#5218" class="Bound">x</a>

 <a id="hide-id-transport.transport"></a><a id="5226" href="Overture.Equality.html#5226" class="Function">transport</a> <a id="5236" class="Symbol">:</a> <a id="5238" class="Symbol">{</a><a id="5239" href="Overture.Equality.html#5239" class="Bound">A</a> <a id="5241" class="Symbol">:</a> <a id="5243" href="Overture.Equality.html#5145" class="Bound">𝓤</a> <a id="5245" href="Universes.html#403" class="Function Operator">̇</a> <a id="5247" class="Symbol">}</a> <a id="5249" class="Symbol">(</a><a id="5250" href="Overture.Equality.html#5250" class="Bound">B</a> <a id="5252" class="Symbol">:</a> <a id="5254" href="Overture.Equality.html#5239" class="Bound">A</a> <a id="5256" class="Symbol">→</a> <a id="5258" href="Overture.Equality.html#5147" class="Bound">𝓦</a> <a id="5260" href="Universes.html#403" class="Function Operator">̇</a> <a id="5262" class="Symbol">)</a> <a id="5264" class="Symbol">{</a><a id="5265" href="Overture.Equality.html#5265" class="Bound">x</a> <a id="5267" href="Overture.Equality.html#5267" class="Bound">y</a> <a id="5269" class="Symbol">:</a> <a id="5271" href="Overture.Equality.html#5239" class="Bound">A</a><a id="5272" class="Symbol">}</a> <a id="5274" class="Symbol">→</a> <a id="5276" href="Overture.Equality.html#5265" class="Bound">x</a> <a id="5278" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="5280" href="Overture.Equality.html#5267" class="Bound">y</a> <a id="5282" class="Symbol">→</a> <a id="5284" href="Overture.Equality.html#5250" class="Bound">B</a> <a id="5286" href="Overture.Equality.html#5265" class="Bound">x</a> <a id="5288" class="Symbol">→</a> <a id="5290" href="Overture.Equality.html#5250" class="Bound">B</a> <a id="5292" href="Overture.Equality.html#5267" class="Bound">y</a>
 <a id="5295" href="Overture.Equality.html#5226" class="Function">transport</a> <a id="5305" href="Overture.Equality.html#5305" class="Bound">B</a> <a id="5307" class="Symbol">(</a><a id="5308" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5313" class="Symbol">{</a><a id="5314" class="Argument">x</a> <a id="5316" class="Symbol">=</a> <a id="5318" href="Overture.Equality.html#5318" class="Bound">x</a><a id="5319" class="Symbol">})</a> <a id="5322" class="Symbol">=</a> <a id="5324" href="Overture.Equality.html#5169" class="Function">𝑖𝑑</a> <a id="5327" class="Symbol">(</a><a id="5328" href="Overture.Equality.html#5305" class="Bound">B</a> <a id="5330" href="Overture.Equality.html#5318" class="Bound">x</a><a id="5331" class="Symbol">)</a>

<a id="5334" class="Keyword">open</a> <a id="5339" class="Keyword">import</a> <a id="5346" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5355" class="Keyword">using</a> <a id="5361" class="Symbol">(</a><a id="5362" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="5364" class="Symbol">;</a> <a id="5366" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="5375" class="Symbol">)</a> <a id="5377" class="Keyword">public</a>

</pre>

As usual, we display definitions of existing types (here, `𝑖𝑑` and `transport`) in a hidden module and then imported their original definition from [Type Topology][].

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="6009" class="Keyword">module</a> <a id="hide-ap"></a><a id="6016" href="Overture.Equality.html#6016" class="Module">hide-ap</a>  <a id="6025" class="Symbol">{</a><a id="6026" href="Overture.Equality.html#6026" class="Bound">𝓤</a> <a id="6028" href="Overture.Equality.html#6028" class="Bound">𝓦</a> <a id="6030" class="Symbol">:</a> <a id="6032" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6040" class="Symbol">}</a> <a id="6042" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="6050" href="Overture.Equality.html#6050" class="Function">ap</a> <a id="6053" class="Symbol">:</a> <a id="6055" class="Symbol">{</a><a id="6056" href="Overture.Equality.html#6056" class="Bound">A</a> <a id="6058" class="Symbol">:</a> <a id="6060" href="Overture.Equality.html#6026" class="Bound">𝓤</a> <a id="6062" href="Universes.html#403" class="Function Operator">̇</a><a id="6063" class="Symbol">}{</a><a id="6065" href="Overture.Equality.html#6065" class="Bound">B</a> <a id="6067" class="Symbol">:</a> <a id="6069" href="Overture.Equality.html#6028" class="Bound">𝓦</a> <a id="6071" href="Universes.html#403" class="Function Operator">̇</a><a id="6072" class="Symbol">}(</a><a id="6074" href="Overture.Equality.html#6074" class="Bound">f</a> <a id="6076" class="Symbol">:</a> <a id="6078" href="Overture.Equality.html#6056" class="Bound">A</a> <a id="6080" class="Symbol">→</a> <a id="6082" href="Overture.Equality.html#6065" class="Bound">B</a><a id="6083" class="Symbol">){</a><a id="6085" href="Overture.Equality.html#6085" class="Bound">x</a> <a id="6087" href="Overture.Equality.html#6087" class="Bound">y</a> <a id="6089" class="Symbol">:</a> <a id="6091" href="Overture.Equality.html#6056" class="Bound">A</a><a id="6092" class="Symbol">}</a> <a id="6094" class="Symbol">→</a> <a id="6096" href="Overture.Equality.html#6085" class="Bound">x</a> <a id="6098" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="6100" href="Overture.Equality.html#6087" class="Bound">y</a> <a id="6102" class="Symbol">→</a> <a id="6104" href="Overture.Equality.html#6074" class="Bound">f</a> <a id="6106" href="Overture.Equality.html#6085" class="Bound">x</a> <a id="6108" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="6110" href="Overture.Equality.html#6074" class="Bound">f</a> <a id="6112" href="Overture.Equality.html#6087" class="Bound">y</a>
 <a id="6115" href="Overture.Equality.html#6050" class="Function">ap</a> <a id="6118" href="Overture.Equality.html#6118" class="Bound">f</a> <a id="6120" class="Symbol">{</a><a id="6121" href="Overture.Equality.html#6121" class="Bound">x</a><a id="6122" class="Symbol">}</a> <a id="6124" href="Overture.Equality.html#6124" class="Bound">p</a> <a id="6126" class="Symbol">=</a> <a id="6128" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="6138" class="Symbol">(λ</a> <a id="6141" href="Overture.Equality.html#6141" class="Bound">-</a> <a id="6143" class="Symbol">→</a> <a id="6145" href="Overture.Equality.html#6118" class="Bound">f</a> <a id="6147" href="Overture.Equality.html#6121" class="Bound">x</a> <a id="6149" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="6151" href="Overture.Equality.html#6118" class="Bound">f</a> <a id="6153" href="Overture.Equality.html#6141" class="Bound">-</a><a id="6154" class="Symbol">)</a> <a id="6156" href="Overture.Equality.html#6124" class="Bound">p</a> <a id="6158" class="Symbol">(</a><a id="6159" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6164" class="Symbol">{</a><a id="6165" class="Argument">x</a> <a id="6167" class="Symbol">=</a> <a id="6169" href="Overture.Equality.html#6118" class="Bound">f</a> <a id="6171" href="Overture.Equality.html#6121" class="Bound">x</a><a id="6172" class="Symbol">})</a>

<a id="6176" class="Keyword">open</a> <a id="6181" class="Keyword">import</a> <a id="6188" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="6197" class="Keyword">using</a> <a id="6203" class="Symbol">(</a><a id="6204" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="6206" class="Symbol">)</a> <a id="6208" class="Keyword">public</a>

</pre>

Here's a useful variation of `ap` that we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][] (transcribed into TypeTopology/UALib notation of course).

<pre class="Agda">

<a id="6427" class="Keyword">module</a> <a id="6434" href="Overture.Equality.html#6434" class="Module">_</a> <a id="6436" class="Symbol">{</a><a id="6437" href="Overture.Equality.html#6437" class="Bound">𝓤</a> <a id="6439" href="Overture.Equality.html#6439" class="Bound">𝓦</a> <a id="6441" class="Symbol">:</a> <a id="6443" href="Agda.Primitive.html#423" class="Postulate">Universe</a><a id="6451" class="Symbol">}</a> <a id="6453" class="Keyword">where</a>

 <a id="6461" href="Overture.Equality.html#6461" class="Function">cong-app</a> <a id="6470" class="Symbol">:</a> <a id="6472" class="Symbol">{</a><a id="6473" href="Overture.Equality.html#6473" class="Bound">A</a> <a id="6475" class="Symbol">:</a> <a id="6477" href="Overture.Equality.html#6437" class="Bound">𝓤</a> <a id="6479" href="Universes.html#403" class="Function Operator">̇</a><a id="6480" class="Symbol">}{</a><a id="6482" href="Overture.Equality.html#6482" class="Bound">B</a> <a id="6484" class="Symbol">:</a> <a id="6486" href="Overture.Equality.html#6473" class="Bound">A</a> <a id="6488" class="Symbol">→</a> <a id="6490" href="Overture.Equality.html#6439" class="Bound">𝓦</a> <a id="6492" href="Universes.html#403" class="Function Operator">̇</a><a id="6493" class="Symbol">}{</a><a id="6495" href="Overture.Equality.html#6495" class="Bound">f</a> <a id="6497" href="Overture.Equality.html#6497" class="Bound">g</a> <a id="6499" class="Symbol">:</a> <a id="6501" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="6503" href="Overture.Equality.html#6482" class="Bound">B</a><a id="6504" class="Symbol">}</a> <a id="6506" class="Symbol">→</a> <a id="6508" href="Overture.Equality.html#6495" class="Bound">f</a> <a id="6510" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="6512" href="Overture.Equality.html#6497" class="Bound">g</a> <a id="6514" class="Symbol">→</a> <a id="6516" class="Symbol">∀</a> <a id="6518" href="Overture.Equality.html#6518" class="Bound">x</a> <a id="6520" class="Symbol">→</a> <a id="6522" href="Overture.Equality.html#6495" class="Bound">f</a> <a id="6524" href="Overture.Equality.html#6518" class="Bound">x</a> <a id="6526" href="Overture.Equality.html#2564" class="Datatype Operator">≡</a> <a id="6528" href="Overture.Equality.html#6497" class="Bound">g</a> <a id="6530" href="Overture.Equality.html#6518" class="Bound">x</a>
 <a id="6533" href="Overture.Equality.html#6461" class="Function">cong-app</a> <a id="6542" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6547" class="Symbol">_</a> <a id="6549" class="Symbol">=</a> <a id="6551" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>





-------------------------------------


<sup>1</sup><span class="footnote" id="fn1"> Per Martin-Löf, *An intuitionistic theory of types: predicative part*, Logic Colloquium '73 (Bristol, 1973), 73--118, Studies in Logic and the Foundations of Mathematics, Vol. 80, 1975.</span>

<sup>2</sup><span class="footnote" id="fn2"> The *definiendum* is the left-hand side of a defining equation, the *definiens* is the right-hand side. For readers who have never generated an equivalence relation: the *reflexive closure* of `R ⊆ A × A `is the union of `R` and all pairs of the form `(a , a)`; the *symmetric closure* is the union of `R` and its inverse `{(y , x) : (x , y) ∈ R}`; we leave it to the reader to come up with the correct definition of transitive closure.</span>

<sup>3</sup><span class="footnote" id="fn3"> **Unicode Hints** ([agda2-mode][]). `\^-\^1 ↝ ⁻¹`; `\Mii\Mid ↝ 𝑖𝑑`; `\. ↝ ∙`. In general, for information about a character, place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>



<sup>4</sup><span class="footnote" id="fn4"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170). See also [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).</span>

<br>
<br>

[← Overture.Preliminaries ](Overture.Preliminaries.html)
<span style="float:right;">[Overture.Extensionality →](Overture.Extensionality.html)</span>

{% include UALib.Links.md %}


