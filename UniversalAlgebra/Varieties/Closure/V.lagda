---
layout: default
title : Varieties.Closure.V module (The Agda Universal Algebra Library)
date : 2021-01-14
author: [the ualib/agda-algebras development team][]
---

### <a id="the-inductive-types-v">The Inductive Types V</a>

A class 𝒦 of 𝑆-algebras is called a **variety** if it is closed under each of the closure operators H, S, and P introduced elsewhere; the corresponding closure operator is often denoted 𝕍, but we will denote it by `V`.

We now define `V` as an inductive type which is hand-crafted to contain all the parts of H, S and P, under different names.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

open import Level using ( Level ; Lift )
open import Algebras.Basic

module Varieties.Closure.V {𝑆 : Signature 𝓞 𝓥} where

open import Axiom.Extensionality.Propositional renaming ( Extensionality to funext )
open import Agda.Primitive   using    ( _⊔_ ;  lsuc )
                             renaming ( Set to Type )
open import Data.Product     using    ( _,_ ; Σ-syntax )
open import Relation.Unary   using    ( Pred ; _∈_ ; _⊆_)

open import Overture.Preliminaries            using ( ∣_∣ ; ∥_∥ )
open import Algebras.Products               {𝑆 = 𝑆} using ( ov ; ⨅ )
open import Homomorphisms.HomomorphicImages {𝑆 = 𝑆} using ( HomImages ; _IsHomImageOf_ ; Lift-Alg-hom-image )
open import Homomorphisms.Isomorphisms      {𝑆 = 𝑆} using ( _≅_ ; Lift-Alg-associative ; Lift-≅ ; Lift-hom
                                                    ; Lift-Alg-⨅≅ ; ≅-sym ; Lift-Alg-iso )
open import Subalgebras.Subalgebras         {𝑆 = 𝑆} using ( _≤_ ; Lift-≤-Lift )


data V {α β : Level}(𝒦 : Pred(Algebra α 𝑆)(ov α)) : Pred(Algebra(α ⊔ β)𝑆)(ov(α ⊔ β))
 where
 vbase  : {𝑨 : Algebra α 𝑆} → 𝑨 ∈ 𝒦 → Lift-Alg 𝑨 β ∈ V 𝒦
 vlift  : {𝑨 : Algebra α 𝑆} → 𝑨 ∈ V{α}{α} 𝒦 → Lift-Alg 𝑨 β ∈ V 𝒦
 vliftw : {𝑨 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{β} 𝒦 → Lift-Alg 𝑨 (α ⊔ β) ∈ V 𝒦
 vhimg  : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{β} 𝒦 → ((𝑩 , _) : HomImages 𝑨) → 𝑩 ∈ V 𝒦
 vssubw : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{β} 𝒦 → 𝑩 ≤ 𝑨 → 𝑩 ∈ V 𝒦
 vprodu : {I : Type β}{𝒜 : I → Algebra α 𝑆} → (∀ i → (𝒜 i) ∈ V{α}{α} 𝒦) → ⨅ 𝒜 ∈ V 𝒦
 vprodw : {I : Type β}{𝒜 : I → Algebra _ 𝑆} → (∀ i → (𝒜 i) ∈ V{α}{β} 𝒦) → ⨅ 𝒜 ∈ V 𝒦
 visou  : {𝑨 : Algebra α 𝑆}{𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{α} 𝒦 → 𝑨 ≅ 𝑩 → 𝑩 ∈ V 𝒦
 visow  : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{β} 𝒦 → 𝑨 ≅ 𝑩 → 𝑩 ∈ V 𝒦

\end{code}

Thus, if 𝒦 is a class of 𝑆-algebras, then the **variety generated by** 𝒦 is denoted by `V 𝒦` and defined to be the smallest class that contains 𝒦 and is closed under `H`, `S`, and `P`.

With the closure operator V representing closure under HSP, we represent formally what it means to be a variety of algebras as follows.

\begin{code}

is-variety : {α : Level}(𝒱 : Pred (Algebra α 𝑆)(ov α)) → Type(ov α)
is-variety{α} 𝒱 = V{α}{α} 𝒱 ⊆ 𝒱

variety : (α : Level) → Type(lsuc (𝓞 ⊔ 𝓥 ⊔ (lsuc α)))
variety α = Σ[ 𝒱 ∈ (Pred (Algebra α 𝑆)(ov α)) ] is-variety 𝒱

\end{code}


#### <a id="V-is-closed-under-lift">V is closed under lift</a>

As mentioned earlier, a technical hurdle that must be overcome when formalizing proofs in Agda is the proper handling of universe levels. In particular, in the proof of the Birkhoff's theorem, for example, we will need to know that if an algebra 𝑨 belongs to the variety V 𝒦, then so does the lift of 𝑨.  Let us get the tedious proof of this technical lemma out of the way.

\begin{code}

open Level

module Vlift {α : Level} {fe₀ : funext (ov α) α}
             {fe₁ : funext ((ov α) ⊔ (lsuc (ov α))) (lsuc (ov α))}
             {fe₂ : funext (ov α) (ov α)}
             {𝒦 : Pred (Algebra α 𝑆)(ov α)} where

 VlA : {𝑨 : Algebra (ov α) 𝑆} → 𝑨 ∈ V{α}{ov α} 𝒦
  →    Lift-Alg 𝑨 (lsuc (ov α)) ∈ V{α}{lsuc (ov α)} 𝒦
 VlA (vbase{𝑨} x) = visow (vbase x) (Lift-Alg-associative 𝑨)
 VlA (vlift{𝑨} x) = visow (vlift x) (Lift-Alg-associative 𝑨)
 VlA (vliftw{𝑨} x) = visow (VlA x) (Lift-Alg-associative 𝑨)

 VlA (vhimg{𝑨}{𝑩} x hB) = vhimg {𝑩 = Lift-Alg 𝑩 (lsuc (ov α))} (VlA x) (lC , lChi)
  where
  lC : Algebra (lsuc (ov(α))) 𝑆
  lC = Lift-Alg ∣ hB ∣ (lsuc (ov(α)))
  lChi : lC IsHomImageOf _
  lChi = (Lift-Alg-hom-image (lsuc (ov(α))) {∣ hB ∣} (lsuc (ov(α))) ∥ hB ∥)

 VlA (vssubw{𝑨}{𝑩} x B≤A) = vssubw (VlA x) (Lift-≤-Lift  (lsuc (ov(α))) {𝑨}  (lsuc (ov(α))) B≤A)
 VlA (vprodu{I}{𝒜} x) = visow (vprodw vlA) (≅-sym B≅A)
  where
  𝑰 : Type (lsuc (ov α))
  𝑰 = Lift (lsuc (ov α)) I

  lA : 𝑰 → Algebra (lsuc (ov α)) 𝑆
  lA i = Lift-Alg (𝒜 (lower i)) (lsuc (ov α))

  vlA : ∀ i → (lA i) ∈ V{α}{lsuc (ov α)} 𝒦
  vlA i = vlift (x (lower i))

  iso-components : ∀ i → 𝒜 i ≅ lA (lift i)
  iso-components i = Lift-≅

  B≅A : Lift-Alg (⨅ 𝒜) (lsuc (ov α)) ≅ ⨅ lA
  B≅A = Lift-Alg-⨅≅  {fizw = fe₁}{fiu = fe₀} iso-components


 VlA (vprodw{I}{𝒜} x) = visow (vprodw vlA) (≅-sym B≅A)
  where
  𝑰 : Type (lsuc (ov α))
  𝑰 = Lift (lsuc (ov α)) I

  lA : 𝑰 → Algebra (lsuc (ov α)) 𝑆
  lA i = Lift-Alg (𝒜 (lower i)) (lsuc (ov α))

  vlA : ∀ i → (lA i) ∈ V{α}{lsuc (ov α)} 𝒦
  vlA i = VlA (x (lower i))

  iso-components : ∀ i → 𝒜 i ≅ lA (lift i)
  iso-components i = Lift-≅

  B≅A : Lift-Alg (⨅ 𝒜) (lsuc (ov α)) ≅ ⨅ lA
  B≅A = Lift-Alg-⨅≅ {fizw = fe₁}{fiu = fe₂} iso-components

 VlA (visou{𝑨}{𝑩} x A≅B) = visow (vlift x) (Lift-Alg-iso A≅B)
 VlA (visow{𝑨}{𝑩} x A≅B) = visow (VlA x) (Lift-Alg-iso A≅B)

\end{code}

--------------------------------------

{% include UALib.Links.md %}

--------------------------------------

[the ualib/agda-algebras development team]: https://github.com/ualib/agda-algebras#the-ualib-agda-algebras-development-team
