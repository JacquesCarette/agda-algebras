---
layout: default
title : Varieties.Closure.V module (The Agda Universal Algebra Library)
date : 2021-01-14
author: the agda-algebras development team
---

### <a id="the-inductive-types-v">The Inductive Types V</a>

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

open import Level using ( Level ; Lift )
open import Algebras.Basic


module Varieties.Closure.V {𝓞 𝓥 : Level} (𝑆 : Signature 𝓞 𝓥) where


open import Axiom.Extensionality.Propositional renaming ( Extensionality to funext )
open import Agda.Primitive   using    ( _⊔_ ;  lsuc )
                             renaming ( Set to Type )

open import Data.Product     using    ( _,_ ; Σ-syntax ; Σ ; _×_ )
                             renaming ( proj₁ to fst
                                      ; proj₂ to snd )

open import Relation.Unary   using    ( _∈_ ; Pred; _⊆_)


open import Overture.Preliminaries                 using ( _⁻¹ ; ∣_∣ ; ∥_∥ ; 𝑖𝑑 )
open import Overture.Inverses                      using ( IsSurjective )
open import Algebras.Products              {𝑆 = 𝑆} using ( ov ; ⨅ ; 𝔄 ; class-product )
open import Homomorphisms.Basic            {𝑆 = 𝑆} using ( hom )
open import Homomorphisms.HomomorphicImages{𝑆 = 𝑆} using ( HomImages ; IsHomImage ; Lift-alg-hom-image )
open import Homomorphisms.Isomorphisms     {𝑆 = 𝑆} using ( _≅_ ; Lift-alg-associative ; Lift-≅ ; Lift-hom
                                                         ; Lift-alg-⨅≅ ; ≅-sym ; Lift-alg-iso )
open import Subalgebras.Subalgebras        {𝑆 = 𝑆} using ( _≤_ ; _IsSubalgebraOfClass_ ; ≤-iso ; ≤-refl
                                                         ; Subalgebra ; ≤-TRANS-≅ ; ≤-trans ; Lift-≤-Lift )

\end{code}


#### <a id="varietal-closure">Varietal closure</a>

A class 𝒦 of 𝑆-algebras is called a **variety** if it is closed under each of the closure operators H, S, and P introduced elsewhere; the corresponding closure operator is often denoted 𝕍, but we will denote it by `V`.

We now define `V` as an inductive type which is hand-crafted to contain all the parts of H, S and P, under different names.

\begin{code}

data V {α β : Level}(𝒦 : Pred(Algebra α 𝑆)(ov α)) : Pred(Algebra(α ⊔ β)𝑆)(ov(α ⊔ β))
 where
 vbase  : {𝑨 : Algebra α 𝑆} → 𝑨 ∈ 𝒦 → Lift-alg 𝑨 β ∈ V 𝒦
 vlift  : {𝑨 : Algebra α 𝑆} → 𝑨 ∈ V{α}{α} 𝒦 → Lift-alg 𝑨 β ∈ V 𝒦
 vliftw : {𝑨 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{β} 𝒦 → Lift-alg 𝑨 (α ⊔ β) ∈ V 𝒦
 vhimg  : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{β} 𝒦 → ((𝑩 , _) : HomImages 𝑨) → 𝑩 ∈ V 𝒦
 vssubw : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{β} 𝒦 → 𝑩 ≤ 𝑨 → 𝑩 ∈ V 𝒦
 vprodu : {I : Type β}{𝒜 : I → Algebra α 𝑆} → (∀ i → (𝒜 i) ∈ V{α}{α} 𝒦) → ⨅ 𝒜 ∈ V 𝒦
 vprodw : {I : Type β}{𝒜 : I → Algebra _ 𝑆} → (∀ i → (𝒜 i) ∈ V{α}{β} 𝒦) → ⨅ 𝒜 ∈ V 𝒦
 visou  : {𝑨 : Algebra α 𝑆}{𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{α} 𝒦 → 𝑨 ≅ 𝑩 → 𝑩 ∈ V 𝒦
 visow  : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{α}{β} 𝒦 → 𝑨 ≅ 𝑩 → 𝑩 ∈ V 𝒦

\end{code}

Thus, if 𝒦 is a class of 𝑆-algebras, then the **variety generated by** 𝒦 is denoted by `V 𝒦` and defined to be the smallest class that contains 𝒦 and is closed under `H`, `S`, and `P`.

With the closure operator V representing closure under HSP, we represent formally what it means to be a variety of algebras as follows.

\begin{code}

is-variety : {α : Level}(𝒱 : Pred (Algebra α 𝑆)(ov α)) → Type(ov α)
is-variety{α} 𝒱 = V{α}{α} 𝒱 ⊆ 𝒱

variety : (α : Level) → Type(lsuc (𝓞 ⊔ 𝓥 ⊔ (lsuc α)))
variety α = Σ[ 𝒱 ∈ (Pred (Algebra α 𝑆)(ov α)) ] is-variety 𝒱

\end{code}


#### <a id="V-is-closed-under-lift">V is closed under lift</a>

As mentioned earlier, a technical hurdle that must be overcome when formalizing proofs in Agda is the proper handling of universe levels. In particular, in the proof of the Birkhoff's theorem, for example, we will need to know that if an algebra 𝑨 belongs to the variety V 𝒦, then so does the lift of 𝑨.  Let us get the tedious proof of this technical lemma out of the way.

\begin{code}

open Level


module Vlift {α : Level} {fe₀ : funext (ov α) α}
             {fe₁ : funext ((ov α) ⊔ (lsuc (ov α))) (lsuc (ov α))}
             {fe₂ : funext (ov α) (ov α)}
             {𝒦 : Pred (Algebra α 𝑆)(ov α)} where

 VlA : {𝑨 : Algebra (ov α) 𝑆} → 𝑨 ∈ V{α}{ov α} 𝒦
  →    Lift-alg 𝑨 (lsuc (ov α)) ∈ V{α}{lsuc (ov α)} 𝒦
 VlA (vbase{𝑨} x) = visow (vbase x) (Lift-alg-associative 𝑨)
 VlA (vlift{𝑨} x) = visow (vlift x) (Lift-alg-associative 𝑨)
 VlA (vliftw{𝑨} x) = visow (VlA x) (Lift-alg-associative 𝑨)

 VlA (vhimg{𝑨}{𝑩} x hB) = vhimg {𝑩 = Lift-alg 𝑩 (lsuc (ov α))} (VlA x) (lC , lChi)
  where
  lC : Algebra (lsuc (ov(α))) 𝑆
  lC = Lift-alg ∣ hB ∣ (lsuc (ov(α)))
  lChi : IsHomImage lC
  lChi = (Lift-alg-hom-image (lsuc (ov(α))) {∣ hB ∣} (lsuc (ov(α))) ∥ hB ∥)

 VlA (vssubw{𝑨}{𝑩} x B≤A) = vssubw (VlA x) (Lift-≤-Lift  (lsuc (ov(α))) {𝑨}  (lsuc (ov(α))) B≤A)
 VlA (vprodu{I}{𝒜} x) = visow (vprodw vlA) (≅-sym B≅A)
  where
  𝑰 : Type (lsuc (ov α))
  𝑰 = Lift (lsuc (ov α)) I

  lA : 𝑰 → Algebra (lsuc (ov α)) 𝑆
  lA i = Lift-alg (𝒜 (lower i)) (lsuc (ov α))

  vlA : ∀ i → (lA i) ∈ V{α}{lsuc (ov α)} 𝒦
  vlA i = vlift (x (lower i))

  iso-components : ∀ i → 𝒜 i ≅ lA (lift i)
  iso-components i = Lift-≅

  B≅A : Lift-alg (⨅ 𝒜) (lsuc (ov α)) ≅ ⨅ lA
  B≅A = Lift-alg-⨅≅  {fizw = fe₁}{fiu = fe₀} iso-components


 VlA (vprodw{I}{𝒜} x) = visow (vprodw vlA) (≅-sym B≅A)
  where
  𝑰 : Type (lsuc (ov α))
  𝑰 = Lift (lsuc (ov α)) I

  lA : 𝑰 → Algebra (lsuc (ov α)) 𝑆
  lA i = Lift-alg (𝒜 (lower i)) (lsuc (ov α))

  vlA : ∀ i → (lA i) ∈ V{α}{lsuc (ov α)} 𝒦
  vlA i = VlA (x (lower i))

  iso-components : ∀ i → 𝒜 i ≅ lA (lift i)
  iso-components i = Lift-≅

  B≅A : Lift-alg (⨅ 𝒜) (lsuc (ov α)) ≅ ⨅ lA
  B≅A = Lift-alg-⨅≅ {fizw = fe₁}{fiu = fe₂} iso-components

 VlA (visou{𝑨}{𝑩} x A≅B) = visow (vlift x) (Lift-alg-iso A≅B)
 VlA (visow{𝑨}{𝑩} x A≅B) = visow (VlA x) (Lift-alg-iso A≅B)

\end{code}


{% include UALib.Links.md %}
