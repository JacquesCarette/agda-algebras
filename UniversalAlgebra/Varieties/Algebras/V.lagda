---
layout: default
title : Varieties.Algebras.V module (The Agda Universal Algebra Library)
date : 2021-01-14
author: the agda-algebras development team
---

### <a id="the-inductive-types-v">The Inductive Types V</a>

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

-- Imports from Agda the Agda Standard Library
open import Agda.Builtin.Equality using (_≡_; refl)
open import Axiom.Extensionality.Propositional renaming (Extensionality to funext)
open import Data.Product using (_,_; Σ; _×_; Σ-syntax)
open import Function.Base  using (_∘_)
open import Level renaming (suc to lsuc; zero to lzero)
open import Relation.Binary.PropositionalEquality.Core using (cong; cong-app; module ≡-Reasoning)
open ≡-Reasoning
open import Relation.Unary using (⋂; _∈_; Pred; _⊆_)

-- Imports from the Agda Universal Algebra Library
open import Algebras.Basic
open import Overture.Inverses using (IsInjective)
open import Overture.Preliminaries
 using (Type; _∙_;_⁻¹; ∣_∣; ∥_∥; snd; fst)
open import Relations.Truncation using (hfunext)

module Varieties.Algebras.V {𝓞 𝓥 : Level} (𝑆 : Signature 𝓞 𝓥) where

open import Algebras.Products{𝑆 = 𝑆} using (ov; ⨅; 𝔄; class-product)
open import Homomorphisms.Basic{𝑆 = 𝑆} using (hom; 𝒾𝒹; ∘-hom; is-homomorphism)
open import Homomorphisms.HomomorphicImages{𝑆 = 𝑆} using (HomImages; Lift-alg-hom-image)
open import Homomorphisms.Isomorphisms{𝑆 = 𝑆} using (_≅_; ≅-sym; Lift-≅; ≅-trans; ≅-refl; Lift-alg-iso; ⨅≅; Lift-alg-associative; Lift-alg-⨅≅)
open import Subalgebras.Subalgebras{𝑆 = 𝑆} using (_≤_; _IsSubalgebraOfClass_; ≤-iso; ≤-refl; Subalgebra; ≤-TRANS-≅; ≤-trans; Lift-≤-Lift; ≤-Lift; _IsSubalgebraOf_)

\end{code}


#### <a id="varietal-closure">Varietal closure</a>

A class 𝒦 of 𝑆-algebras is called a **variety** if it is closed under each of the closure operators H, S, and P introduced elsewhere; the corresponding closure operator is often denoted 𝕍, but we will denote it by `V`.

We now define `V` as an inductive type which is hand-crafted to contain all the parts of H, S and P, under different names.

\begin{code}

data V {𝓤 𝓦 : Level}(𝒦 : Pred(Algebra 𝓤 𝑆)(ov 𝓤)) : Pred(Algebra(𝓤 ⊔ 𝓦)𝑆)(ov(𝓤 ⊔ 𝓦))
 where
 vbase  : {𝑨 : Algebra 𝓤 𝑆} → 𝑨 ∈ 𝒦 → Lift-alg 𝑨 𝓦 ∈ V 𝒦
 vlift  : {𝑨 : Algebra 𝓤 𝑆} → 𝑨 ∈ V{𝓤}{𝓤} 𝒦 → Lift-alg 𝑨 𝓦 ∈ V 𝒦
 vliftw : {𝑨 : Algebra _ 𝑆} → 𝑨 ∈ V{𝓤}{𝓦} 𝒦 → Lift-alg 𝑨 (𝓤 ⊔ 𝓦) ∈ V 𝒦
 vhimg  : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{𝓤}{𝓦} 𝒦 → ((𝑩 , _) : HomImages 𝑨) → 𝑩 ∈ V 𝒦
 vssub  : {𝑨 : Algebra 𝓤 𝑆}{𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{𝓤}{𝓤} 𝒦 → 𝑩 ≤ 𝑨 → 𝑩 ∈ V 𝒦
 vssubw : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{𝓤}{𝓦} 𝒦 → 𝑩 ≤ 𝑨 → 𝑩 ∈ V 𝒦
 vprodu : {I : Type 𝓦}{𝒜 : I → Algebra 𝓤 𝑆} → (∀ i → (𝒜 i) ∈ V{𝓤}{𝓤} 𝒦) → ⨅ 𝒜 ∈ V 𝒦
 vprodw : {I : Type 𝓦}{𝒜 : I → Algebra _ 𝑆} → (∀ i → (𝒜 i) ∈ V{𝓤}{𝓦} 𝒦) → ⨅ 𝒜 ∈ V 𝒦
 visou  : {𝑨 : Algebra 𝓤 𝑆}{𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{𝓤}{𝓤} 𝒦 → 𝑨 ≅ 𝑩 → 𝑩 ∈ V 𝒦
 visow  : {𝑨 𝑩 : Algebra _ 𝑆} → 𝑨 ∈ V{𝓤}{𝓦} 𝒦 → 𝑨 ≅ 𝑩 → 𝑩 ∈ V 𝒦

\end{code}

Thus, if 𝒦 is a class of 𝑆-algebras, then the **variety generated by** 𝒦 is denoted by `V 𝒦` and defined to be the smallest class that contains 𝒦 and is closed under `H`, `S`, and `P`.

With the closure operator V representing closure under HSP, we represent formally what it means to be a variety of algebras as follows.

\begin{code}

is-variety : {𝓤 : Level}(𝒱 : Pred (Algebra 𝓤 𝑆)(ov 𝓤)) → Type(ov 𝓤)
is-variety{𝓤} 𝒱 = V{𝓤}{𝓤} 𝒱 ⊆ 𝒱

variety : (𝓤 : Level) → Type(lsuc (𝓞 ⊔ 𝓥 ⊔ (lsuc 𝓤)))
variety 𝓤 = Σ[ 𝒱 ∈ (Pred (Algebra 𝓤 𝑆)(ov 𝓤)) ] is-variety 𝒱

\end{code}


#### <a id="V-is-closed-under-lift">V is closed under lift</a>

As mentioned earlier, a technical hurdle that must be overcome when formalizing proofs in Agda is the proper handling of universe levels. In particular, in the proof of the Birkhoff's theorem, for example, we will need to know that if an algebra 𝑨 belongs to the variety V 𝒦, then so does the lift of 𝑨.  Let us get the tedious proof of this technical lemma out of the way.

\begin{code}

open Lift

module Vlift {𝓤 : Level} {fe₀ : funext (ov 𝓤) 𝓤}
         {fe₁ : funext ((ov 𝓤) ⊔ (lsuc (ov 𝓤))) (lsuc (ov 𝓤))}
         {fe₂ : funext (ov 𝓤) (ov 𝓤)}
         {𝒦 : Pred (Algebra 𝓤 𝑆)(ov 𝓤)} where

 VlA : {𝑨 : Algebra (ov 𝓤) 𝑆} → 𝑨 ∈ V{𝓤}{ov 𝓤} 𝒦
  →    Lift-alg 𝑨 (lsuc (ov 𝓤)) ∈ V{𝓤}{lsuc (ov 𝓤)} 𝒦
 VlA (vbase{𝑨} x) = visow (vbase x) (Lift-alg-associative 𝑨)
 VlA (vlift{𝑨} x) = visow (vlift x) (Lift-alg-associative 𝑨)
 VlA (vliftw{𝑨} x) = visow (VlA x) (Lift-alg-associative 𝑨)

 VlA (vhimg{𝑨}{𝑩} x hB) =
  vhimg{𝑩 = Lift-alg 𝑩 (lsuc (ov 𝓤))}
   (VlA x) ((Lift-alg ∣ hB ∣ (lsuc (ov 𝓤))) , (Lift-alg-hom-image {𝑩 = ∣ hB ∣} ∥ hB ∥))

 VlA (vssub{𝑨}{𝑩} x B≤A) = vssubw (vlift{𝓦 = (lsuc (ov 𝓤))} x) (Lift-≤-Lift 𝑨 B≤A)
 VlA (vssubw{𝑨}{𝑩} x B≤A) = vssubw (VlA x) (Lift-≤-Lift 𝑨 B≤A)
 VlA (vprodu{I}{𝒜} x) = visow (vprodw vlA) (≅-sym B≅A)
  where
  𝑰 : Type (lsuc (ov 𝓤))
  𝑰 = Lift (lsuc (ov 𝓤)) I

  lA : 𝑰 → Algebra (lsuc (ov 𝓤)) 𝑆
  lA i = Lift-alg (𝒜 (lower i)) (lsuc (ov 𝓤))

  vlA : ∀ i → (lA i) ∈ V{𝓤}{lsuc (ov 𝓤)} 𝒦
  vlA i = vlift (x (lower i))

  iso-components : ∀ i → 𝒜 i ≅ lA (lift i)
  iso-components i = Lift-≅

  B≅A : Lift-alg (⨅ 𝒜) (lsuc (ov 𝓤)) ≅ ⨅ lA
  B≅A = Lift-alg-⨅≅  {fizw = fe₁}{fiu = fe₀} iso-components


 VlA (vprodw{I}{𝒜} x) = visow (vprodw vlA) (≅-sym B≅A)
  where
  𝑰 : Type (lsuc (ov 𝓤))
  𝑰 = Lift (lsuc (ov 𝓤)) I

  lA : 𝑰 → Algebra (lsuc (ov 𝓤)) 𝑆
  lA i = Lift-alg (𝒜 (lower i)) (lsuc (ov 𝓤))

  vlA : ∀ i → (lA i) ∈ V{𝓤}{lsuc (ov 𝓤)} 𝒦
  vlA i = VlA (x (lower i))

  iso-components : ∀ i → 𝒜 i ≅ lA (lift i)
  iso-components i = Lift-≅

  B≅A : Lift-alg (⨅ 𝒜) (lsuc (ov 𝓤)) ≅ ⨅ lA
  B≅A = Lift-alg-⨅≅ {fizw = fe₁}{fiu = fe₂} iso-components

 VlA (visou{𝑨}{𝑩} x A≅B) = visow (vlift x) (Lift-alg-iso A≅B)
 VlA (visow{𝑨}{𝑩} x A≅B) = visow (VlA x) (Lift-alg-iso A≅B)

\end{code}


{% include UALib.Links.md %}
