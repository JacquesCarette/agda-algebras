.. FILE      : subuniverses.agda
.. AUTHOR    : William DeMeo and Siva Somayyajula
.. DATE      : 20 Feb 2020
.. UPDATE    : 21 Jul 2020
.. COPYRIGHT : (c) 2020 William DeMeo


.. _subalgebras in agda:

=====================
Subalgebras in Agda
=====================

This chapter describes the `subuniverses module`_ of the `agda-ualib`_.

---------------------------------------------

Preliminaries
------------------

We define subuniverses and subalgebras and prove some basic facts about them in a module called ``subuniverses`` which resides in the ``subuniverses.lagda.rst`` file of the ``agda-ualib`` library.

The file starts, as usual, with a list of imports.

::

  {-# OPTIONS --without-K --exact-split --safe #-}

  open import prelude
  open import basic using (Signature; Algebra; Op; _̂_)
  open import relations using (transitive)
  open import homomorphisms using (hom; is-homomorphism; HomImage)
  open import terms using (Term; _̇_; generator; node; comm-hom-term)
  open import Relation.Unary using (⋂)

------------------------------------------------------

.. _types for subuniverses:

Types for subuniverses
------------------------

We begin the ``subuniverses`` module with a straightforward definition of the collection of subuniverses of an algebra A.  Since a subuniverse is a subset of the domain of A, it is defined as a predicate on ∣ A ∣.  Thus, the collection of subuniverses is a predicate on predicates on ∣ A ∣.

::

  module subuniverses {𝑆 : Signature 𝓞 𝓥} where

  Subuniverses : (𝑨 : Algebra 𝓤 𝑆)
   →             Pred (Pred ∣ 𝑨 ∣ 𝓣) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⊔ 𝓣)

  Subuniverses 𝑨 B =
   (f : ∣ 𝑆 ∣)(a : ∥ 𝑆 ∥ f → ∣ 𝑨 ∣) → Im a ⊆ B → (f ̂ 𝑨) a ∈ B

-------------------------------------

.. _obs 7 in agda:

Subuniverse generation
----------------------

Next we formalize the important theorem about subuniverse generation that we presented above in :numref:`Obs %s <obs 7>`.  Recall, if :math:`A = ⟨𝐴, …⟩` is an 𝑆-algebra, if :math:`∅ ≠ 𝐴₀ ⊆ 𝐴`, and if we define by recursion the sets :math:`A_{n+1} = Aₙ ∪ \{ f a : f ∈ F, a : ρ f → Aₙ \}`, then the subuniverse of A generated by 𝐴₀ is :math:`\mathrm{Sg}^A(A₀) = ⋃ₙ Aₙ`.

::

  record Subuniverse {𝑨 : Algebra 𝓤 𝑆} : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇ where
   constructor mksub
   field
     sset  : Pred ∣ 𝑨 ∣ 𝓤
     isSub : sset ∈ Subuniverses 𝑨

::

  module _
   {𝑨 : Algebra 𝓤 𝑆} where

::

   data Sg (X : Pred ∣ 𝑨 ∣ 𝓣) : Pred ∣ 𝑨 ∣ (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⊔ 𝓣) where
    var : ∀ {v} → v ∈ X → v ∈ Sg X
    app :  ( f : ∣ 𝑆 ∣ ) { a : ∥ 𝑆 ∥ f → ∣ 𝑨 ∣ }
     →       Im a ⊆ Sg X
            -----------------
     →       ∥ 𝑨 ∥ f a ∈ Sg X

   sgIsSub : (X : Pred ∣ 𝑨 ∣ 𝓤) → Sg X ∈ Subuniverses 𝑨
   sgIsSub _ f a α = app f α

   sgIsSmallest : {X : Pred ∣ 𝑨 ∣ 𝓡} {Y : Pred ∣ 𝑨 ∣ 𝓢}
    →             Y ∈ Subuniverses 𝑨
    →             X ⊆ Y
                 -----------------
    →              Sg X ⊆ Y

   -- By induction on x ∈ Sg X, show x ∈ Y
   sgIsSmallest _ X⊆Y (var v∈X) = X⊆Y v∈X

   sgIsSmallest {Y = Y} YIsSub X⊆Y (app f {a} ima⊆SgX) = app∈Y
    where
     -- First, show the args are in Y
     ima⊆Y : Im a ⊆ Y
     ima⊆Y i = sgIsSmallest YIsSub X⊆Y (ima⊆SgX i)

     --Since Y is a subuniverse of 𝑨, it contains the application
     app∈Y : ∥ 𝑨 ∥ f a ∈ Y          --           of f to said args.
     app∈Y = YIsSub f a ima⊆Y


.. _obs 6 in agda:

Closure under intersection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall from :numref:`Obs %s <obs 6>` that the intersection ⋂ᵢ 𝐴ᵢ of a collection {𝐴ᵢ ∣ 𝐴ᵢ ≤ 𝑨} of subuniverses of an algebra 𝑨 is again a subuniverse of 𝑨.  We formalize the statement and proof of this easy fact in Agda as follows.

::

  module _ {𝑨 : Algebra 𝓤 𝑆}{I : 𝓘 ̇}{𝒜 : I → Pred ∣ 𝑨 ∣ 𝓣} where

::

   sub-inter-is-sub : ((i : I) → 𝒜 i ∈ Subuniverses 𝑨)
    →                 ⋂ I 𝒜 ∈ Subuniverses 𝑨

   sub-inter-is-sub Ai-is-Sub f a ima⊆⋂A = α
    where
     α : (f ̂ 𝑨) a ∈ ⋂ I 𝒜
     α i = Ai-is-Sub i f a λ j → ima⊆⋂A j i



.. _obs 7.1 in agda:

Homomorphic images are subuniverses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this subsection we show that the image of an (extensional) homomorphism is a subuniverse.  (A version for intensional homomorphisms appears in :ref:`the intensional-hom-image module`, but the proof is essentially the same.) Before implementing the result formally in Agda, let us recall the steps of the informal proof.

Let 𝑓 be an operation symbol, let :math:`b : ρ f → ∣ B ∣` be a (ρ 𝑓)-tuple of elements of ∣ 𝑩 ∣, and assume the image ``Im 𝑏`` of 𝑏 belongs to the image ``Image ℎ`` of ℎ.  We must show that :math:`f^𝑩 b ∈ Image h`.  The assumption ``Im 𝑏 ⊆ Image ℎ`` implies that there is a (ρ 𝑓)-tuple :math:`𝑎 : ρ f → ∣ 𝑨 ∣`  such that ℎ ∘ 𝑎 = 𝑏.  Since ℎ is a homomorphism, we have :math:`f^𝑩 𝑏  = f^𝑩 (ℎ ∘ 𝑎) = ℎ (f^𝑨 𝑎) ∈` Image ℎ.

Finally, recall the definition of ``HomImage`` from the `homomorphisms module`_,

.. code-block:: agda

  HomImage : ∣ B ∣ → 𝓤 ̇
  HomImage = λ b → Image ∣ h ∣ ∋ b

We are now ready to formalize the proof the proof that homomorphic images are subuniverses.

::

  module _
   {𝑨 𝑩 : Algebra 𝓤 𝑆}
   (ϕ : hom 𝑨 𝑩) where

   hom-image-is-sub : {funext 𝓥 𝓤} → (HomImage{𝑨 = 𝑨} 𝑩 ϕ) ∈ Subuniverses 𝑩
   hom-image-is-sub {fe} f b b∈Imf =
    eq ((f ̂ 𝑩) b) ((f ̂ 𝑨) ar) γ
     where
      ar : ∥ 𝑆 ∥ f → ∣ 𝑨 ∣
      ar = λ x → Inv ∣ ϕ ∣ (b x) (b∈Imf x)

      ζ : ∣ ϕ ∣ ∘ ar ≡ b
      ζ = fe (λ x → InvIsInv ∣ ϕ ∣ (b x) (b∈Imf x))

      γ : (f ̂ 𝑩)  b
            ≡ ∣ ϕ ∣((f ̂ 𝑨)(λ x → Inv ∣ ϕ ∣ (b x)(b∈Imf x)))

      γ = (f ̂ 𝑩) b         ≡⟨ ap (f ̂ 𝑩) (ζ ⁻¹) ⟩
          (f ̂ 𝑩)(∣ ϕ ∣ ∘ ar) ≡⟨ ( ∥ ϕ ∥ f ar ) ⁻¹ ⟩
          ∣ ϕ ∣ ((f ̂ 𝑨) ar)    ∎

------------------------------------

.. _obs 12 in agda:

Generation with terms
------------------------------

Recall :numref:`Obs %s <obs 12>` presenting subuniverse generation using the images of terms: If 𝑌 is a subset of 𝐴, then :math:`\mathrm{Sg}^𝑨(Y) = \{t^𝑨 a : t ∈ T(X), a : X → Y\}`. To formalize this in Agda, we first prove that subuniverses are closed under the action of term operations.

::

  module _
   {X : 𝓤 ̇}
   {𝑨 𝑩 : Algebra 𝓤 𝑆}
   {B : Pred ∣ 𝑨 ∣ 𝓤}
   (Y : 𝓤 ̇) where

   sub-term-closed : B ∈ Subuniverses 𝑨
    →                (t : Term)(b : X → ∣ 𝑨 ∣)
    →                (∀ i → b i ∈ B)
                   ---------------------------
    →                ((t ̇ 𝑨) b) ∈ B

   sub-term-closed B≤A (generator x) b b∈B = b∈B x

   sub-term-closed B≤A (node f t) b b∈B =
     B≤A f (λ z → (t z ̇ 𝑨) b)
           (λ x → sub-term-closed B≤A (t x) b b∈B)

This proves :math:`\mathrm{Sg}^𝑨(Y) ⊇ \{ t^𝑨 a : t ∈ 𝑇(𝑋), a : 𝑋 → 𝑌 \}`.

Next we prove :math:`\mathrm{Sg}^𝑨(Y) ⊆ \{ t^𝑨 a : t ∈ 𝑇(𝑋), a : 𝑋 → 𝑌 \}` by the following steps:

  #. The image of 𝑌 under all terms, which we call `TermImage 𝑌`, is a subuniverse of 𝑨; i.e.,
     TermImage 𝑌 = :math:`\{ t^𝑨 a : t ∈ 𝑇(𝑋), a : 𝑋 → 𝑌 \} ≤ 𝑨`.
  #. 𝑌 ⊆ TermImage 𝑌 (obvious)
  #. :math:`\mathrm{Sg}^𝑨(Y)` is the smallest subuniverse containing 𝑌 (see `sgIsSmallest`) so :math:`\mathrm{Sg}^𝑨(Y)` ⊆ TermImage 𝑌.

(The last item was already proved above; see ``sgIsSmallest``.)

::

   data TermImage (Y : Pred ∣ 𝑨 ∣ 𝓤) : Pred ∣ 𝑨 ∣ (𝓞 ⊔ 𝓥 ⊔ 𝓤) where
    var : ∀ {y : ∣ 𝑨 ∣} → y ∈ Y → y ∈ TermImage Y
    app : (f : ∣ 𝑆 ∣) (t : ∥ 𝑆 ∥ f → ∣ 𝑨 ∣)
     →    (Im t ⊆ TermImage Y)  -- ∀ i  →  t i ∈ TermImage Y
         -------------------------------
     →    (∥ 𝑨 ∥ f t) ∈ TermImage Y

   --1. TermImage is a subuniverse
   TermImageIsSub : (Y : Pred ∣ 𝑨 ∣ 𝓤)
    →               TermImage Y ∈ Subuniverses 𝑨

   TermImageIsSub Y = λ f a x → app f a x

   --2. Y ⊆ TermImageY
   Y⊆TermImageY : (Y : Pred ∣ 𝑨 ∣ 𝓤)
    →             Y ⊆ TermImage Y

   Y⊆TermImageY Y {a} a∈Y = var a∈Y


Finally, we can prove the desired inclusion.

::

   SgY⊆TermImageY : (Y : Pred ∣ 𝑨 ∣ 𝓤) → Sg Y ⊆ TermImage Y
   SgY⊆TermImageY Y = sgIsSmallest (TermImageIsSub Y)
                                   (Y⊆TermImageY Y)

**Exercise**. Prove the following by generalizing the relation ≃ to predicates:

.. code-block:: agda

  SgY≃TermImageY : (Y : Pred ∣ 𝑨 ∣ k) → (TermImage Y) ≃ (Sg Y)
  SgY≃TermImageY {x} Y = ?

-----------------------------------------------------------------------------------

.. _types for subalgebras:

Types for subalgebras
---------------------

The next submodule is a generalization of MHE's implementation of subgroups. We consider the subalgebras of an single arbitrary(but fixed) algebra 𝑨.

::

  module _ {𝑨 : Algebra 𝓤 𝑆} (UV : Univalence) where

Following MHE's analogous development for groups and their subgroups (cf. `Subgroup' <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#372215>`_ ) we define the type of subalgebras as follows.

::

   Subalgebra : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇
   Subalgebra = Σ 𝑩 ꞉ (Algebra 𝓤 𝑆) ,
                   Σ h ꞉ (∣ 𝑩 ∣ → ∣ 𝑨 ∣) ,
                     is-embedding h × is-homomorphism 𝑩 𝑨 h


Next we present a module that generalizes `MHE's ambient module <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#subgroups-sip>`_ . It does for subuniverses what MHE does for subgroups.

Note that we introduce a new definition of the ``subuniverse`` type here.  In cotrast to our earlier definition of ``Subuniverses``, which uses a predicate on ``∣ 𝑨 ∣`` to represent the underlying set of the subuniverse, here we use the type ``𝓟 ∣ 𝑨 ∣``, the powerset of the universe of ``𝑨``.

::

   gfe : global-dfunext
   gfe = univalence-gives-global-dfunext UV

   op-closed : (∣ 𝑨 ∣ → 𝓦 ̇) → 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⊔ 𝓦 ̇
   op-closed B = (f : ∣ 𝑆 ∣)(a : ∥ 𝑆 ∥ f → ∣ 𝑨 ∣)
    → Im a ⊆ B → B (∥ 𝑨 ∥ f a)

   subuniverse : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇
   subuniverse = Σ B ꞉ (𝓟 ∣ 𝑨 ∣) , op-closed ( _∈₀ B)

   being-op-closed-is-subsingleton : (B : 𝓟 ∣ 𝑨 ∣)
    →           is-subsingleton (op-closed ( _∈₀ B ))
   being-op-closed-is-subsingleton B = Π-is-subsingleton gfe
    (λ f → Π-is-subsingleton gfe
     (λ a → Π-is-subsingleton gfe
      (λ _ → ∈-is-subsingleton B (∥ 𝑨 ∥ f a))))

   pr₁-is-embedding : is-embedding ∣_∣
   pr₁-is-embedding = pr₁-embedding being-op-closed-is-subsingleton

   --so equality of subalgebras is equality of their underlying
   --subsets in the powerset:
   ap-pr₁ : (B C : subuniverse) → B ≡ C → ∣ B ∣ ≡ ∣ C ∣
   ap-pr₁ B C = ap ∣_∣

   ap-pr₁-is-equiv : (B C : subuniverse) → is-equiv (ap-pr₁ B C)
   ap-pr₁-is-equiv =
    embedding-gives-ap-is-equiv ∣_∣ pr₁-is-embedding

   subuniverse-is-a-set : is-set subuniverse
   subuniverse-is-a-set B C = equiv-to-subsingleton
                             (ap-pr₁ B C , ap-pr₁-is-equiv B C)
                             (powersets-are-sets' UV ∣ B ∣ ∣ C ∣)

For a subuniverse B of 𝑨, we want to form a subalgebra 𝑩 = ⟨B, …⟩ of 𝑨 such that the operations of 𝑩 are those of 𝑨 restricted to B.

Here are some useful lemmas extracted from MHE's proof of `subgroup-equality`. The first is called `f` in MHE's proof.

::

   subuniverse-equality-gives-membership-equiv : (B C : subuniverse)
    →                                  B ≡ C
                        -----------------------------------
    →                   ( x : ∣ 𝑨 ∣ ) → (x ∈₀ ∣ B ∣) ⇔ (x ∈₀ ∣ C ∣)
   subuniverse-equality-gives-membership-equiv B C B≡C x =
    transport (λ - → x ∈₀ ∣ - ∣) B≡C ,
     transport (λ - → x ∈₀ ∣ - ∣ ) ( B≡C ⁻¹ )

The next lemma is called `h` in MHE's proof.

::

   membership-equiv-gives-carrier-equality : (B C : subuniverse)
    →          ((x : ∣ 𝑨 ∣) →  x ∈₀ ∣ B ∣  ⇔  x ∈₀ ∣ C ∣)
              -----------------------------------------
    →                       ∣ B ∣ ≡ ∣ C ∣
   membership-equiv-gives-carrier-equality B C φ =
    subset-extensionality' UV α β
     where
      α :  ∣ B ∣ ⊆₀ ∣ C ∣
      α x = lr-implication (φ x)

      β : ∣ C ∣ ⊆₀ ∣ B ∣
      β x = rl-implication (φ x)

The next lemma is called `g` in MHE's proof.

::

   membership-equiv-gives-subuniverse-equality : (B C : subuniverse)
    →            (( x : ∣ 𝑨 ∣ ) → x ∈₀ ∣ B ∣ ⇔ x ∈₀ ∣ C ∣)
                 ---------------------------------------
    →                          B ≡ C
   membership-equiv-gives-subuniverse-equality B C =
    inverse (ap-pr₁ B C)
    (ap-pr₁-is-equiv B C)
       ∘ (membership-equiv-gives-carrier-equality B C)

   membership-equiv-is-subsingleton : (B C : subuniverse)
    →    is-subsingleton (( x : ∣ 𝑨 ∣) → x ∈₀ ∣ B ∣ ⇔ x ∈₀ ∣ C ∣)
   membership-equiv-is-subsingleton B C =
    Π-is-subsingleton gfe
     (λ x → ×-is-subsingleton
      (Π-is-subsingleton gfe (λ _ → ∈-is-subsingleton ∣ C ∣ x ))
        (Π-is-subsingleton gfe (λ _ → ∈-is-subsingleton ∣ B ∣ x )))

So, two subuniverses are equal if and only if they have the same elements (cf. `subgroup-equality <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#371022>`_ ):

::

   subuniverse-equality : (B C : subuniverse)
    →    (B ≡ C)  ≃  ((x : ∣ 𝑨 ∣)  → (x ∈₀ ∣ B ∣) ⇔ (x ∈₀ ∣ C ∣))

   subuniverse-equality B C =
    logically-equivalent-subsingletons-are-equivalent _ _
      (subuniverse-is-a-set B C)
       (membership-equiv-is-subsingleton B C)
        (subuniverse-equality-gives-membership-equiv B C ,
          membership-equiv-gives-subuniverse-equality B C)

The converse of `membership-equiv-gives-carrier-equality` is obvious.

::

   carrier-equality-gives-membership-equiv : (B C : subuniverse)
    →                            ∣ B ∣ ≡ ∣ C ∣
                  ----------------------------------------
    →              (( x : ∣ 𝑨 ∣ ) → x ∈₀ ∣ B ∣ ⇔ x ∈₀ ∣ C ∣)
   carrier-equality-gives-membership-equiv B C (refl _) x = id , id

   --so we have...
   carrier-equiv : (B C : subuniverse)
    →   ((x : ∣ 𝑨 ∣) → x ∈₀ ∣ B ∣ ⇔ x ∈₀ ∣ C ∣) ≃ (∣ B ∣ ≡ ∣ C ∣)
   carrier-equiv B C =
    logically-equivalent-subsingletons-are-equivalent _ _
     (membership-equiv-is-subsingleton B C)
      (powersets-are-sets' UV ∣ B ∣ ∣ C ∣)
       (membership-equiv-gives-carrier-equality B C ,
         carrier-equality-gives-membership-equiv B C)

   -- ...which yields an alternative subuniverse equality lemma.
   subuniverse-equality' : (B C : subuniverse)
    →                      (B ≡ C) ≃ (∣ B ∣ ≡ ∣ C ∣)
   subuniverse-equality' B C =
    (subuniverse-equality B C) ● (carrier-equiv B C)

--------------------------------------------


Unicode Hints
---------------

Table of some special characters used in the `subuniverses module`_.

  +--------+------------------------------+
  | To get | Type                         |
  +--------+------------------------------+
  | 𝓘, 𝓣   | ``\MCI``, ``\MCT``           |
  +--------+------------------------------+
  | _⊧_≈_  | ``_\models_\~~_``            |
  +--------+------------------------------+
  | _⊧_≋_  | ``_\models_\~~~_``           |
  +--------+------------------------------+
  | ⊆      | ``\subseteq`` or ``\sub=``   |
  +--------+------------------------------+
  | ⋂      | ``\bigcap`` or ``\I``        |
  +--------+------------------------------+
  | ξ      | ``\xi``                      |
  +--------+------------------------------+

See :numref:`unicode hints` for a longer list of special symbols used in the agda-ualib_, or better yet, use these

  **Emacs commands providing information about special characters/input methods**:

    * ``M-x describe-char`` (or ``M-m h d c``) with the cursor on the character of interest

    * ``M-x describe-input-method`` (or ``C-h I``)

-------------------------

.. include:: hyperlink_references.rst



