.. FILE: subuniverses.agda
.. AUTHOR: William DeMeo and Siva Somayyajula
.. DATE: 20 Feb 2020
.. UPDATE: 17 Jun 2020

.. _types for subalgebras:

=====================
Types for Subalgebras
=====================

Preliminaries
------------------

We define subuniverses and subalgebras and prove some basic facts about them in a module called ``subuniverses`` which resides in the ``subuniverses.lagda.rst`` file of the ``agda-ualib`` library.

The file starts, as usual, with a list of imports.

::

   {-# OPTIONS --without-K --exact-split --safe #-} --allow-unsolved-metas #-}

   open import prelude
   open import basic using (Signature; Algebra; Op)
   open import relations using (transitive)
   open import homomorphisms using (HOM; Hom; hom; is-homomorphism)
   open import terms using (Term; _̇_; _̂_; generator; node; comm-hom-term)

   open import Relation.Unary using (⋂)


.. _subuniverses module:

The subuniverses module
------------------------

We begin the ``subuniverses`` module with a straightforward definition of the collection of subuniverses of an algebra 𝑨.  Since a subuniverse is a subset of the domain of 𝑨, it is defined as a predicate on ∣ 𝑨 ∣.  Thus, the collection of subuniverses is a predicate on predicates on ∣ 𝑨 ∣.

::

   module subuniverses {S : Signature 𝓞 𝓥} where

   Subuniverses : (𝑨 : Algebra 𝓤 S) → Pred (Pred ∣ 𝑨 ∣ 𝓣) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⊔ 𝓣)
   Subuniverses (A , Fᴬ) B = ( 𝓸 : ∣ S ∣ ) ( 𝒂 : ∥ S ∥ 𝓸 → A ) → Im 𝒂 ⊆ B → Fᴬ 𝓸 𝒂 ∈ B

Next we define a data type that represents the property of being a subuniverse. Note that, in order to keep ``𝑨`` at same universe level as ``Σ B , 𝐹``, we force ``B`` to live in the same universe.  We need to do this so that both ``𝑨`` and ``Σ B , 𝐹`` can be classified by the same predicate ``SClo``.

::

   data _is-supalgebra-of_ (𝑨 : Algebra 𝓤 S) : Pred (Algebra 𝓤 S) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺) where
    mem :   (B : Pred ∣ 𝑨 ∣ 𝓤)  ( 𝐹 : ( 𝓸 : ∣ S ∣ ) → Op ( ∥ S ∥ 𝓸 ) (Σ B) )
     →      ((𝓸 : ∣ S ∣) (𝒂 : ∥ S ∥ 𝓸 → Σ B)  →  ∣ 𝐹 𝓸 𝒂 ∣ ≡ ∥ 𝑨 ∥ 𝓸 (λ i → ∣ 𝒂 i ∣))
     →      𝑨 is-supalgebra-of (Σ B , 𝐹)

   _is-subalgebra-of_ : Algebra 𝓤 S → Algebra 𝓤 S → 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇
   𝑩 is-subalgebra-of 𝑨 = 𝑨 is-supalgebra-of 𝑩

   module _ {𝑨 : Algebra 𝓤 S} {B : Pred ∣ 𝑨 ∣ 𝓤}
    {𝐹 : (𝓸 : ∣ S ∣) → Op (∥ S ∥ 𝓸) (Σ B)}(B∈SubA : B ∈ Subuniverses 𝑨) where

    SubunivAlg : Algebra 𝓤 S
    SubunivAlg = Σ B , λ 𝓸 x → ∥ 𝑨 ∥ 𝓸 ( ∣_∣ ∘ x ) , B∈SubA 𝓸 ( ∣_∣ ∘ x ) (∥_∥ ∘ x)

    subuniv-to-subalg : SubunivAlg is-subalgebra-of 𝑨
    subuniv-to-subalg = mem B ∥ SubunivAlg ∥ λ 𝓸 𝒂 → (refl _)

.. _obs 7 agda:

Subuniverse generation
~~~~~~~~~~~~~~~~~~~~~~~~

Next we formalize the important theorem about subuniverse generation that we presented above in :numref:`Obs %s <obs 7>`.  Recall, if :math:`𝑨 = ⟨𝐴, …⟩` is an 𝑆-algebra, if :math:`∅ ≠ 𝐴₀ ⊆ 𝐴`, and if we define by recursion the sets :math:`A_{n+1} = Aₙ \cup \{ f a : f ∈ F, a : ρ f → Aₙ \}`, then the subuniverse of 𝑨 generated by 𝐴₀ is :math:`\mathrm{Sg}^𝑨(A₀) = ⋃ₙ Aₙ`.

::

   record Subuniverse {𝑨 : Algebra 𝓤 S} : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇ where
    constructor mksub
    field
      sset  : Pred ∣ 𝑨 ∣ 𝓤
      isSub : sset ∈ Subuniverses 𝑨

   module _ {𝑨 : Algebra 𝓤 S} where
    data Sg (X : Pred ∣ 𝑨 ∣ 𝓣) : Pred ∣ 𝑨 ∣ (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⊔ 𝓣) where
     var : ∀ {v} → v ∈ X → v ∈ Sg X
     app :  ( 𝓸 : ∣ S ∣ ) { 𝒂 : ∥ S ∥ 𝓸 → ∣ 𝑨 ∣ }
      →       Im 𝒂 ⊆ Sg X
             -----------------
      →       ∥ 𝑨 ∥ 𝓸 𝒂 ∈ Sg X

    sgIsSub : ( X : Pred ∣ 𝑨 ∣ 𝓤 ) → Sg X ∈ Subuniverses 𝑨
    sgIsSub _ 𝓸 𝒂 α = app 𝓸 α

    sgIsSmallest : { X : Pred ∣ 𝑨 ∣ 𝓡  } {Y : Pred ∣ 𝑨 ∣ 𝓢 }
     →             Y ∈ Subuniverses 𝑨
     →             X ⊆ Y
                  -----------------
     →              Sg X ⊆ Y
    -- By induction on x ∈ Sg X, show x ∈ Y
    sgIsSmallest _ X⊆Y (var v∈X) = X⊆Y v∈X
    sgIsSmallest {Y = Y} YIsSub X⊆Y (app 𝓸 {𝒂} im𝒂⊆SgX) = app∈Y where
     -- First, show the args are in Y
     im𝒂⊆Y : Im 𝒂 ⊆ Y
     im𝒂⊆Y i = sgIsSmallest YIsSub X⊆Y (im𝒂⊆SgX i)

     -- Since Y is a subuniverse of 𝑨, it contains the application of 𝓸 to said args
     app∈Y : ∥ 𝑨 ∥ 𝓸 𝒂 ∈ Y
     app∈Y = YIsSub 𝓸 𝒂 im𝒂⊆Y


Recall from :numref:`Obs %s <obs 6>` that the intersection ⋂ᵢ 𝐴ᵢ of a collection {𝐴ᵢ ∣ 𝐴ᵢ ≤ 𝑨} of subuniverses of an algebra 𝑨 is again a subuniverse of 𝑨.  We formalize the statement and proof of this easy fact in Agda as follows.

::

   module _ {𝑨 : Algebra 𝓤 S}  {I : 𝓘 ̇} {A : I → Pred ∣ 𝑨 ∣ 𝓣} where
    sub-inter-is-sub : ( (i : I) → A i ∈ Subuniverses 𝑨) → ⋂ I A ∈ Subuniverses 𝑨
    sub-inter-is-sub Ai-is-Sub 𝓸 𝒂 im𝒂⊆⋂A = α where
     α : ∥ 𝑨 ∥ 𝓸 𝒂 ∈ ⋂ I A      -- Suffices to show (i : I) → ⟦ A ⟧ 𝓸 𝒂 ∈ A i
     α i = Ai-is-Sub i 𝓸 𝒂 λ j → im𝒂⊆⋂A j i    -- Immediate from A i being a subuniverse

.. _hom images:

Homomorphic images 
~~~~~~~~~~~~~~~~~~~~~

Next we show that the image of an (extensional) homomorphism is a subuniverse.  (A version for intensional homs appears below, but the proof is essentially the same.)  We also construct the subalgebra whose universe is a homomorphic image.

::

   module _ {𝑨 𝑩 : Algebra 𝓤 S} (f : hom 𝑨 𝑩)  where
    HomImage : ∣ 𝑩 ∣ → 𝓤 ̇
    HomImage = λ b → Image ∣ f ∣ ∋ b

    hom-image : 𝓤 ̇
    hom-image = Σ (Image_∋_ ∣ f ∣)

    fres : ∣ 𝑨 ∣ → Σ (Image_∋_ ∣ f ∣)
    fres a = ∣ f ∣ a , im a

    hom-image-alg : Algebra 𝓤 S
    hom-image-alg = hom-image , ops-interp
     where
      𝒂 : {𝓸 : ∣ S ∣ } ( x : ∥ S ∥ 𝓸 → hom-image ) (y : ∥ S ∥ 𝓸)   →   ∣ 𝑨 ∣
      𝒂 x y = Inv ∣ f ∣  ∣ x y ∣ ∥ x y ∥

      ops-interp : ( 𝓸 : ∣ S ∣ ) → Op (∥ S ∥ 𝓸) hom-image
      ops-interp = λ 𝓸 x →( ∣ f ∣  ( ∥ 𝑨 ∥ 𝓸 (𝒂 x) ) , im ( ∥ 𝑨 ∥ 𝓸 (𝒂 x) ) )

We are about ready to formalize the easy fact that a homomorphic image is a subuniverse, but before doing so, let us go through the steps of the proof informally.  Let 𝓸 be an operation symbol, let :math:`𝒃 : ρ 𝓸 → ∣ 𝑩 ∣` be a (ρ 𝓸)-tuple of elements of ∣ 𝑩 ∣, and assume ∀ 𝑖, 𝒃(𝑖) ∈ Image 𝑓.  We must show :math:`𝓸^𝑩 𝒃 ∈ Image 𝑓`.  The assumption ∀ 𝑖,  𝒃(𝑖) ∈ Image 𝑓  implies that there is a (ρ 𝓸)-tuple :math:`𝒂 : ρ 𝓸 → ∣ 𝑨 ∣`  such that 𝒇 ∘ 𝒂 = 𝒃.  Since 𝑓 is a homomorphism, we have :math:`𝓸^𝑩 𝒃  = 𝓸^𝑩 (𝒇 ∘ 𝒂) = 𝑓 (𝓸^𝑨 𝒂) ∈` Image 𝑓.

We formalize the proof in Agda as follows.

::

    hom-image-is-sub : {funext 𝓥 𝓤} → HomImage ∈ Subuniverses 𝑩
    hom-image-is-sub {fe} 𝓸 𝒃 𝒃∈Imf =
     eq (∥ 𝑩 ∥ 𝓸 (λ x → 𝒃 x)) ( ∥ 𝑨 ∥ 𝓸 ar) γ
      where
       ar : ∥ S ∥ 𝓸 → ∣ 𝑨 ∣
       ar = λ x → Inv ∣ f ∣ (𝒃 x) (𝒃∈Imf x)

       ζ : (λ x → ∣ f ∣ (ar x)) ≡ (λ x → 𝒃 x)
       ζ = fe (λ x → InvIsInv ∣ f ∣ (𝒃 x) (𝒃∈Imf x) )

       γ : ∥ 𝑩 ∥ 𝓸 (λ x → 𝒃 x) ≡ ∣ f ∣ (∥ 𝑨 ∥ 𝓸 (λ x → Inv ∣ f ∣ (𝒃 x) (𝒃∈Imf x)))
       γ = ∥ 𝑩 ∥ 𝓸 (λ x → 𝒃 x)     ≡⟨ ap ( ∥ 𝑩 ∥ 𝓸 ) (ζ ⁻¹)  ⟩
           (∥ 𝑩 ∥ 𝓸)(∣ f ∣ ∘ ar)     ≡⟨ ( ∥ f ∥ 𝓸 ar ) ⁻¹ ⟩
           ∣ f ∣ (∥ 𝑨 ∥ 𝓸 ar)        ∎


.. _obs 12 agda:

Subuniverse generation with terms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall :numref:`Obs %s <obs 12>` presenting subuniverse generation using the images of terms: If 𝑌 is a subset of 𝐴, then :math:`\mathrm{Sg}^𝑨(Y) = \{t^𝑨 𝒂 : t ∈ T(X), 𝒂 : X → Y\}`.

*Proof*. Induction on the height of t shows that every subuniverse is closed under the action of t^𝑨. Thus the right-hand side is contained in the left. On the other hand, the right-hand side is a subuniverse that contains the elements of Y (take t = x₁), so it contains :math:`\mathrm{Sg}^𝑨(Y)`, as the latter is the smallest subuniverse containing Y. ☐

To prove Obs 2.11, we first prove that subuniverses are closed under the action of term operations.

::

   module _ {X : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ̇}{𝑨 𝑩 : Algebra 𝓤 S}{B : Pred ∣ 𝑨 ∣ 𝓤} (Y : 𝓤 ̇)  where

    sub-term-closed : B ∈ Subuniverses 𝑨
     →                (𝒕 : Term)(𝒃 : X → ∣ 𝑨 ∣)
     →                (∀ i → 𝒃 i ∈ B)
                    ---------------------------
     →                ((𝒕 ̇ 𝑨) 𝒃) ∈ B
    sub-term-closed B≤𝑨 (generator x) 𝒃 𝒃∈B = 𝒃∈B x
    sub-term-closed B≤𝑨 (node 𝓸 𝒕) 𝒃 𝒃∈B =
      B≤𝑨 𝓸 (λ z → (𝒕 z ̇ 𝑨) 𝒃) (λ x → sub-term-closed B≤𝑨 (𝒕 x) 𝒃 𝒃∈B)

This proves :math:`\mathrm{Sg}^𝑨(Y) ⊇ \{ t^𝑨 a : t ∈ T_σ(X_n), n ∈ ℕ, a: Fin(ρ t) \to Y \}`.

Next we prove :math:`\mathrm{Sg}^{𝑨}(Y) ⊆ \{t^𝑨 a : t ∈ T_σ(X_n), n ∈ ℕ, a: Fin(ρ t) \to Y\}` by the following steps:

  #. The image of Y under all terms, which we call `TermImage Y`, is a subuniverse of 𝑨; ie,
     `TermImage Y = ⋃{𝒕:Term} Image (𝒕 ̇ 𝑨) ≤ 𝑨`.
  #. `Y ⊆ TermImage Y` (obvious)
  #. :math:`\mathrm{Sg}^𝑨(Y)` is the smallest subuniverse containing Y (see `sgIsSmallest`) so :math:`\mathrm{Sg}^𝑨(Y) ⊆ TermImage Y`.

::

    data TermImage (Y : Pred ∣ 𝑨 ∣ 𝓤) : Pred ∣ 𝑨 ∣ (𝓞 ⊔ 𝓥 ⊔ 𝓤)  where
     var : ∀ {y : ∣ 𝑨 ∣} → y ∈ Y → y ∈ TermImage Y
     app : (𝓸 : ∣ S ∣) (𝒕 : ∥ S ∥ 𝓸 → ∣ 𝑨 ∣)
      →    (∀ i  →  𝒕 i ∈ TermImage Y)
          -------------------------------
      →    (∥ 𝑨 ∥ 𝓸 𝒕) ∈ TermImage Y

    --1. TermImage is a subuniverse
    TermImageIsSub : (Y : Pred ∣ 𝑨 ∣ 𝓤) → TermImage Y ∈ Subuniverses 𝑨
    TermImageIsSub Y  = λ 𝓸 𝒂 x → app 𝓸 𝒂 x

    --2. Y ⊆ TermImageY
    Y⊆TermImageY : (Y : Pred ∣ 𝑨 ∣ 𝓤) → Y ⊆ TermImage Y
    Y⊆TermImageY Y {a} a∈Y = var a∈Y

    -- 3. Sg^𝑨(Y) is the smallest subuniverse containing Y
    --    Proof: see `sgIsSmallest`

Finally, we can prove the desired inclusion.

::

    SgY⊆TermImageY : (Y : Pred ∣ 𝑨 ∣ 𝓤) → Sg Y ⊆ TermImage Y
    SgY⊆TermImageY Y = sgIsSmallest (TermImageIsSub Y) (Y⊆TermImageY Y)

Now we should be able to prove something like the following (if we could be bothered to generalize the relation ≃ to predicates):

.. code-block::

   SgY≃TermImageY : (Y : Pred ∣ 𝑨 ∣ k) ->  (TermImage Y) ≃ (Sg Y)
   SgY≃TermImageY {x} Y = ?

-----------------------------------------------------------------------------------


Subalgebras in Agda
---------------------

The next submodule is a generalization of MHE's implementation of subgroups. We consider the subalgebras of a given arbitrary "overalgebra" 𝑨.

**Ref**. This module generalizes MHE's `ambient` module. It does for subuniverses what MHE does for subgroups. cf.  https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#subgroups-sip )

::

   module _ {𝑨 : Algebra 𝓤 S} (𝓤★ : Univalence) where

    gfe : global-dfunext
    gfe = univalence-gives-global-dfunext 𝓤★

    op-closed : (∣ 𝑨 ∣ → 𝓦 ̇) → 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⊔ 𝓦 ̇
    op-closed B = (𝓸 : ∣ S ∣)(𝒂 : ∥ S ∥ 𝓸 → ∣ 𝑨 ∣)
     → ((i : ∥ S ∥ 𝓸) → B (𝒂 i)) → B (∥ 𝑨 ∥ 𝓸 𝒂)

    subuniverse : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇
    subuniverse = Σ B ꞉ (𝓟 ∣ 𝑨 ∣) , op-closed ( _∈₀ B)

    being-op-closed-is-subsingleton : (B : 𝓟 ∣ 𝑨 ∣) → is-subsingleton (op-closed ( _∈₀ B ))
    being-op-closed-is-subsingleton B =  Π-is-subsingleton gfe
     (λ 𝓸 → Π-is-subsingleton gfe (λ 𝒂 → Π-is-subsingleton gfe (λ _ → ∈-is-subsingleton B (∥ 𝑨 ∥ 𝓸 𝒂))))

    pr₁-is-embedding : is-embedding ∣_∣
    pr₁-is-embedding = pr₁-embedding being-op-closed-is-subsingleton

    --so equality of subalgebras is equality of their underlying subsets in the powerset:
    ap-pr₁ : (B C : subuniverse) → B ≡ C → ∣ B ∣ ≡ ∣ C ∣
    ap-pr₁ B C = ap ∣_∣

    ap-pr₁-is-equiv : (B C : subuniverse) → is-equiv (ap-pr₁ B C)
    ap-pr₁-is-equiv = embedding-gives-ap-is-equiv ∣_∣ pr₁-is-embedding

    subuniverse-is-a-set : is-set subuniverse
    subuniverse-is-a-set B C = equiv-to-subsingleton
                              (ap-pr₁ B C , ap-pr₁-is-equiv B C)
                              (powersets-are-sets' 𝓤★ ∣ B ∣  ∣ C ∣)

For a subuniverse 𝐵 of 𝑨, we want to form a subalgebra 𝑩 = ⟨𝐵, …⟩ of 𝑨 such that the operations of 𝑩 are those of 𝑨 restricted to 𝐵.

Here are some useful lemmas extracted from MHE's proof of `subgroup-equality`. The first is called `f` in MHE's proof.

::

    subuniverse-equality-gives-membership-equiv : (B C : subuniverse)
     →                                  B ≡ C
                         -----------------------------------
     →                   ( x : ∣ 𝑨 ∣ ) → (x ∈₀ ∣ B ∣) ⇔ (x ∈₀ ∣ C ∣)
    subuniverse-equality-gives-membership-equiv B C B≡C x =
     transport (λ - → x ∈₀ ∣ - ∣) B≡C , transport (λ - → x ∈₀ ∣ - ∣ ) ( B≡C ⁻¹ )

The next is called `h` in MHE's proof.

::

    membership-equiv-gives-carrier-equality :   (B C : subuniverse)
     →          ((x : ∣ 𝑨 ∣) →  x ∈₀ ∣ B ∣  ⇔  x ∈₀ ∣ C ∣)
               -----------------------------------------
     →                       ∣ B ∣ ≡ ∣ C ∣
    membership-equiv-gives-carrier-equality B C φ = subset-extensionality' 𝓤★ α β
     where
      α :  ∣ B ∣ ⊆₀ ∣ C ∣
      α x = lr-implication (φ x)

      β : ∣ C ∣ ⊆₀ ∣ B ∣
      β x = rl-implication (φ x)

The next is called lemma `g` in MHE's proof.

::

    membership-equiv-gives-subuniverse-equality : (B C : subuniverse)
     →            (( x : ∣ 𝑨 ∣ ) → x ∈₀ ∣ B ∣ ⇔ x ∈₀ ∣ C ∣)
                  ---------------------------------------
     →                          B ≡ C
    membership-equiv-gives-subuniverse-equality B C =
     inverse ( ap-pr₁ B C) (ap-pr₁-is-equiv B C) ∘ (membership-equiv-gives-carrier-equality B C)

    membership-equiv-is-subsingleton : (B C : subuniverse)
     →        is-subsingleton (( x : ∣ 𝑨 ∣) → x ∈₀ ∣ B ∣ ⇔ x ∈₀ ∣ C ∣)
    membership-equiv-is-subsingleton B C =
     Π-is-subsingleton gfe (λ x → ×-is-subsingleton
                             (Π-is-subsingleton gfe (λ _ → ∈-is-subsingleton ∣ C ∣ x ))
                             (Π-is-subsingleton gfe (λ _ → ∈-is-subsingleton ∣ B ∣ x ))
                           )

So, two subuniverses are equal if and only if they have the same elements (cf. `subgroup-equality <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#371022>`_ ):

::

    subuniverse-equality : (B C : subuniverse)
     →    (B ≡ C)  ≃  ((x : ∣ 𝑨 ∣)  → (x ∈₀ ∣ B ∣) ⇔ (x ∈₀ ∣ C ∣))

    subuniverse-equality B C =
     logically-equivalent-subsingletons-are-equivalent _ _
       (subuniverse-is-a-set B C) (membership-equiv-is-subsingleton B C)
       (subuniverse-equality-gives-membership-equiv B C ,
         membership-equiv-gives-subuniverse-equality B C)

The converse of `membership-equiv-gives-carrier-equality` is obvious.

::

    carrier-equality-gives-membership-equiv : (B C : subuniverse)
     →                            ∣ B ∣ ≡ ∣ C ∣
                   ----------------------------------------
     →              ( ( x : ∣ 𝑨 ∣ ) → x ∈₀ ∣ B ∣ ⇔ x ∈₀ ∣ C ∣ )
    carrier-equality-gives-membership-equiv B C (refl _) x = id , id

    --so we have...
    carrier-equiv : (B C : subuniverse)
     →     ((x : ∣ 𝑨 ∣) → x ∈₀ ∣ B ∣ ⇔ x ∈₀ ∣ C ∣)   ≃   (∣ B ∣ ≡ ∣ C ∣)
    carrier-equiv B C = logically-equivalent-subsingletons-are-equivalent _ _
     (membership-equiv-is-subsingleton B C) (powersets-are-sets' 𝓤★ ∣ B ∣ ∣ C ∣)
     (membership-equiv-gives-carrier-equality B C ,
        carrier-equality-gives-membership-equiv B C)

    -- ...which yields an alternative subuniverse equality lemma.
    subuniverse-equality' : (B C : subuniverse) → (B ≡ C)  ≃  (∣ B ∣ ≡ ∣ C ∣)
    subuniverse-equality' B C = (subuniverse-equality B C) ● (carrier-equiv B C)

Following MHE's analogous development for groups and their subgroups (cf. `Subgroup' <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#372215>`_ ) we now show that the type of subuniverses is equivalent to the following type, as an application of the subtype classifyer.

::

    Subalgebra : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇
    Subalgebra = Σ 𝑩 ꞉ (Algebra 𝓤 S) , Σ h ꞉ (∣ 𝑩 ∣ → ∣ 𝑨 ∣)
                                    , is-embedding h × is-homomorphism 𝑩 𝑨 h

..  -- module _ {X : 𝓤 ̇} (h : X → ∣ 𝑨 ∣ ) (hem : is-embedding h) where
    --   private
    --    h-lc : left-cancellable h
    --    h-lc = embeddings-are-lc h hem

    --   having-closed-fiber-is-subsingleton : is-subsingleton ( op-closed (fiber h) )
    --   having-closed-fiber-is-subsingleton = being-op-closed-is-subsingleton (λ x → (fiber h x , hem x) )

    --   at-most-one-homomorphic-structure : is-subsingleton (Σ 𝑩 ꞉ (algebra-on {𝓤} X) , (is-homomorphism  ∣ 𝑩 ∣  𝑨 h ) )
    --   at-most-one-homomorphic-structure = ?


----------------------------------------------------------------------------------------------

The intensional-hom-image module
---------------------------------

The image of an intensional HOM is a subuniverse. (N.B. the proof still requires function extensionality. Question: Is it necessary?)

::

   -- HOM image is subuniverse
   module intensional-hom-image {𝑨 𝑩 : Algebra 𝓤 S} (f : HOM 𝑨 𝑩)  where
    HOMImage : ∣ 𝑩 ∣ → 𝓤 ̇
    HOMImage = λ b → Image ∣ f ∣ ∋ b

    HOM-image : 𝓤 ̇
    HOM-image = Σ (Image_∋_ ∣ f ∣)

    fres' : ∣ 𝑨 ∣ → Σ (Image_∋_ ∣ f ∣)
    fres' a = ∣ f ∣ a , im a

    HOM-image-alg : Algebra 𝓤 S
    HOM-image-alg = HOM-image , ops-interp
     where
      𝒂 : {𝓸 : ∣ S ∣} (x : ∥ S ∥ 𝓸 → HOM-image) (y : ∥ S ∥ 𝓸)  →  ∣ 𝑨 ∣
      𝒂 x y = Inv ∣ f ∣  ∣ x y ∣ ∥ x y ∥

      ops-interp : ( 𝓸 : ∣ S ∣ ) → Op (∥ S ∥ 𝓸) HOM-image
      ops-interp = λ 𝓸 x →( ∣ f ∣  ( ∥ 𝑨 ∥ 𝓸 (𝒂 x) ) , im ( ∥ 𝑨 ∥ 𝓸 (𝒂 x) ) )

    HOM-image-is-sub : funext 𝓥 𝓤 → HOMImage ∈ Subuniverses 𝑩
    HOM-image-is-sub fe 𝓸 𝒃 𝒃∈Imf = eq (∥ 𝑩 ∥ 𝓸 𝒃) ( ∥ 𝑨 ∥ 𝓸 ar) γ
     where
      ar : ∥ S ∥ 𝓸 → ∣ 𝑨 ∣
      ar = λ x → Inv ∣ f ∣ (𝒃 x) (𝒃∈Imf x)

      ζ : (λ x → ∣ f ∣ (ar x)) ≡ (λ x → 𝒃 x)
      ζ = fe (λ x → InvIsInv ∣ f ∣ (𝒃 x) (𝒃∈Imf x) )

      γ : ∥ 𝑩 ∥ 𝓸 (λ x → 𝒃 x) ≡ ∣ f ∣ (∥ 𝑨 ∥ 𝓸 (λ x → Inv ∣ f ∣ (𝒃 x) (𝒃∈Imf x)))
      γ =   ∥ 𝑩 ∥ 𝓸 (λ x → 𝒃 x)       ≡⟨ ap ( ∥ 𝑩 ∥ 𝓸 ) ζ ⁻¹ ⟩
            ( ∥ 𝑩 ∥ 𝓸 ) ( ∣ f ∣ ∘ ar )     ≡⟨ intensionality ξ ar ⟩ -- ( ∥ f ∥ 𝓸 ar ) ⁻¹
             ∣ f ∣ ( ∥ 𝑨 ∥ 𝓸 ar )          ∎
       where
        τ :  (λ 𝓸 ar → ( ∥ 𝑩 ∥ 𝓸 ) ( ∣ f ∣ ∘ ar ))  ≡  ( λ 𝓸 ar → ∣ f ∣ ( ∥ 𝑨 ∥ 𝓸 ar ) )
        τ =  ( ∥ f ∥  )⁻¹
        ξ : (λ (ar  : ∥ S ∥ 𝓸 → ∣ 𝑨 ∣) → (∥ 𝑩 ∥ 𝓸)(∣ f ∣ ∘ ar))  ≡  (λ (ar : ∥ S ∥ 𝓸 → ∣ 𝑨 ∣) → ∣ f ∣ (∥ 𝑨 ∥ 𝓸 ar))
        ξ = dep-intensionality τ 𝓸

    finv' : {X : 𝓤 ̇ } (𝒃 : X → ∣ HOM-image-alg ∣ ) (x : X) → ∣ 𝑨 ∣
    finv' = λ 𝒃 x → Inv ∣ f ∣ ∣ 𝒃 x ∣ ∥ 𝒃 x ∥



--------------------------------------------------------------------------------------------------

Notes on homomorphic images and their types
--------------------------------------------

The homomorphic image of `f : Hom 𝑨 𝑩` is the image of `∣ 𝑨 ∣` under `f`, which, in "set-builder" notation, is simply `Im f = {f a : a ∈ ∣ 𝑨 ∣ }`.

As we have proved, `Im f` is a subuniverse of `𝑩`.

However, there is another means of representing the collection "H 𝑨" of all homomorphic images of 𝑨 without ever referring to codomain algebras (like 𝑩 above).

Here's how: by the first isomorphism theorem, for each `f : Hom 𝑨 𝑩`, there exists a congruence `θ` of `𝑨` (which is the kernel of `f`) that satisfies `𝑨 / θ ≅ Im f`.

Therefore, we have a handle on the collection `H 𝑨` of all homomorphic images of `𝑨` if we simply consider the collection `Con 𝑨` of all congruence relations of `𝑨`.  Indeed, by the above remark, we have

  `H 𝑨 = { 𝑨 / θ : θ ∈ Con 𝑨 }`.

So, we could define the following:

.. code-block::

   hom-closed : (𝓚 : Pred (Algebra (𝓤 ⁺) S) l) → Pred (Algebra 𝓤 S) _
    hom-closed 𝓚 = λ 𝑨 → (𝓚 (𝑨 / (∥𝟎∥ 𝑨)))
      →     (∃ θ : Congruence 𝑨) → (∃ 𝑪 : Algebra (𝓤 ⁺) S) → (𝓚 𝑪) × ((𝑨 / θ) ≅ 𝑪)

To get this to type check, we have an apparent problem, and we need a trick to resolve it. The class 𝓚 is a collection of algebras whose universes live at some level. (Above we use `𝓤 ⁺`.)

However, if `𝑨` is an algebra with `∣ 𝑨 ∣ : 𝓤 ̇`, then the quotient structure  (as it is now defined in Con.agda), has type `𝑨 / θ : 𝓤 ⁺ ̇`. So, in order for the class `𝓚` to contain both `𝑨` and all its quotients `𝑨 / θ` (i.e. all its homomorphic images), we need to somehow define a class of algebras that have different universe levels.

Can we define a data type with such "universe level polymorphism"?

Without that, we use a trick to get around the problem. Instead of assuming that `𝑨` itself belongs to `𝓚`, we could instead take the "quotient" `𝑨 / ∥𝟎∥` (which is isomorphic to `𝑨`) as belonging to `𝓚`.

This is a hack and, worse, it won't do for us. We need something inductive because we will also need that if `𝑪 ≅ 𝑨 / θ ∈ 𝓚`, then also `𝑪 / ψ ≅ (𝑨 / θ) / ψ ∈ 𝓚`.

So, if we want `𝓚` to be closed under all quotients, we cannot determine in advance the universe levels of the algebras that belong to `𝓚`.

We are trying to come up with a datatype for classes of algebras that has some sort of inductive notion of the universe levels involved.

It seems we may be testing the limits of Agda's universe level paradigm. Maybe we can invent a new type to solve the problem, or we may have to try to extend Agda's capabilities.

..
   record AlgebraClass (𝓤 : Universe) : 𝓤 ̇ where
    algebras : Pred (Algebra 𝓤 S) ( 𝓤 ⁺ )
    nextclass : AlgebraClass ( 𝓤 ⁺ )

   record AlgebraClass : Set _ where
    algebras : (ℓ : Level) -> Pred (Algebra ℓ S) (lsuc ℓ)

   module _ {S : Signature 𝓞 𝓥} where

    hom-closed : Pred (AlgebraClass lzero) _
    hom-closed 𝓚 = ∀ 𝑨 -> (algebras 𝓚) 𝑨 -- (𝓚 (𝑨 / (⟦𝟎⟧ 𝑨)))
     -> ∀ (θ : Congruence 𝑨) -> (∃ 𝑪 : Algebra lsuc ℓ S)
          ------------------------------
     ->     (𝓚 𝑪) × ((𝑨 / θ) ≅ 𝑪)


   module _  {S : Signature 𝓞 𝓥}  where
    open AlgebraClass

    data HomClo {ℓ : Level} (𝓚 : AlgebraClass) : Pred AlgebraClass _ where
     hombase : {𝑨 : Algebra ℓ S} → 𝑨 ∈ (algebras 𝓚) ℓ  → 𝑨 ∈ HomClo 𝓚
     homstep : {𝑨 : Algebra ℓ S} ->  𝑨 ∈ HomClo 𝓚
       ->     (∃ θ : Congruence 𝑨)
       ->     (𝑪 : Algebra (lsuc ℓ) S)
             ------------------------------
       ->     𝑪 ∈ (algebras (lsuc ℓ) 𝓚) × ((𝑨 / θ) ≅ 𝑪)




------------------

.. include:: hyperlink_references.rst



