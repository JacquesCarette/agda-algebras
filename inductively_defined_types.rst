.. include:: _static/math_macros.rst

.. _inductively-defined-types:

=========================
Inductively Defined Types
=========================

A primary motivation for this project was our observation that, on the one hand, many important constructs in universal algebra can be defined inductively, and on the other hand, type theory in general, and Lean in particular, offers excellent support for defining inductive types and powerful tactics for proving their properties.

These two facts suggest that there should be much to gain from implementing universal algebra in an expressive type system that offers powerful tools for proving theorems about inductively defined types.  Examples demonstrating how this vision manifests in Lean code are provided in :numref:`Sections %s <subuniverse-generation>`, :numref:`%s <clones-in-lean>` and :numref:`%s <terms-in-lean>`.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: ! subalgebra, ! subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean2:
.. _subuniverse-generation:

Subuniverse generation in Lean
-------------------------------

The Lean code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of (the ``dev_wjd`` branch of) the lean-ualib_ repository.

In :numref:`Section %s <subalgebras-in-lean1>`, we saw how :ref:`subalgebras <subalgebras>` can be implemented in Lean and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and implements the :ref:`subuniverse generation theorem <thm-1-14>`. 

First, we define an inductive type that represents the **subuniverse generated by a set**; cf. the informal language definition in given by :eq:`subalgebra-inductive` .

.. code-block:: lean

    import data.set  -- the set.lean file from mathlib
    definition op (β α) := (β → α) → α
    definition π {β α} (i) : op β α := λ a, a i
    structure signature := mk :: (F : Type*) (ρ : F → Type*)
    definition algebra_on (σ : signature) (α : Type*) := Π (f : σ.F), op (σ.ρ f) α   
    definition algebra (σ : signature) := sigma (algebra_on σ)
    instance alg_carrier (σ : signature) : has_coe_to_sort (algebra σ) := ⟨_, sigma.fst⟩
    instance alg_operations (σ : signature) : has_coe_to_fun (algebra σ) := ⟨_, sigma.snd⟩
 
    namespace subuniverse
      section sub
        parameters {σ : signature} {α : Type*} {I : Type*}
        def F := σ.F
        def ρ := σ.ρ 
        def Sub {𝔸: algebra σ} (B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸 f a) ∈ B₀
        def is_subalgebra (𝔸: algebra σ) (B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸 f ↑b
        def Sg (A : algebra_on σ α) (X : set α) : set α := ⋂₀ {U | Sub A U ∧ X ⊆ U}
        theorem Inter.intro {𝔸: algebra σ} {s: I → set 𝔸}: ∀ (x: 𝔸), (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) :=
        assume x h t ⟨j, (eq: t = s j)⟩, eq.symm ▸ h j
        theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: I → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h: x ∈ ⋂ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: I → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= 
        assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: F) (a: ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        show 𝔸 f a ∈ ⋂i, C i, from Inter.intro (𝔸 f a) (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))
        -- Fact 1. X is a subset of Sgᴬ(X) ----------------------------------------
        lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= 
        assume x (h: x ∈ X), 
          show x ∈ ⋂₀ {U | Sub U ∧ X ⊆ U}, from 
            assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}),  
            show x ∈ W, from 
              have h₂: Sub W ∧ X ⊆ W, from h₁, 
            h₂.right h
        -- Fact 2. A subuniverse that contains X also contains Sgᴬ X --
        lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}:
        ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
        assume R (h₁: Sub R) (h₂: X ⊆ R),
        show Sg X ⊆ R, from 
          assume x (h: x ∈ Sg X), show x ∈ R, from 
            h R (and.intro h₁ h₂)
        -- An alternative proof of Fact 2. ---------
        lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}:
        ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
        assume R (hc : Sub R ∧ X ⊆ R),
        have h₁: Sub R, from hc.left,
        have h₂: X ⊆ R, from hc.right,
        show Sg X ⊆ R, from 
          assume x (h: x ∈ Sg X), show x ∈ R, from 
            h R (and.intro h₁ h₂)
        -- Yet another derivation of Fact 2. ---------
        lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}:
        ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= 
        assume x (h₁: x ∈ Sg X) (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), 
        show x ∈ R, from h₁ R (and.intro h₂ h₃)
        -- Sgᴬ X is a subuniverse of A --------------------------
        lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= 
        assume (f: F) (a: ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), 
        show 𝔸 f a ∈ Sg X, from 
          assume W (h: Sub W ∧ X ⊆ W), show 𝔸 f a ∈ W, from 
            have h₁: Sg X ⊆ W, from 
              sInter_mem' W h,
            have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i),
            (h.left f a h')
    -- BEGIN
    inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
    | var (x : 𝔸) : x ∈ X → Y x
    | app (f : F) (a : ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸 f a)
    -- END  
      end sub
    end subuniverse

Next we prove that the type ``Y X`` is a subuniverse. Moreover, ``Y X`` is equal to :math:`\mathrm{Sg}^𝔸(X)`, which is another fact that we formalize and prove below.

.. code-block:: lean

    import data.set  -- the set.lean file from mathlib
    definition op (β α) := (β → α) → α
    definition π {β α} (i) : op β α := λ a, a i
    structure signature := mk :: (F : Type*) (ρ : F → Type*)
    definition algebra_on (σ : signature) (α : Type*) := Π (f : σ.F), op (σ.ρ f) α   
    definition algebra (σ : signature) := sigma (algebra_on σ)
    instance alg_carrier (σ : signature) : has_coe_to_sort (algebra σ) := ⟨_, sigma.fst⟩
    instance alg_operations (σ : signature) : has_coe_to_fun (algebra σ) := ⟨_, sigma.snd⟩
 
    namespace subuniverse
      section sub
        parameters {σ : signature} {α : Type*} {I : Type*}
        def F := σ.F
        def ρ := σ.ρ 
        def Sub {𝔸: algebra σ} (B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸 f a) ∈ B₀
        def is_subalgebra (𝔸: algebra σ) (B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸 f ↑b
        def Sg (A : algebra_on σ α) (X : set α) : set α := ⋂₀ {U | Sub A U ∧ X ⊆ U}
        theorem Inter.intro {𝔸: algebra σ} {s: I → set 𝔸}: ∀ (x: 𝔸), (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) :=
        assume x h t ⟨j, (eq: t = s j)⟩, eq.symm ▸ h j
        theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: I → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h: x ∈ ⋂ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: I → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= 
        assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: F) (a: ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        show 𝔸 f a ∈ ⋂i, C i, from Inter.intro (𝔸 f a) (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))
        lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:=                                   -- Fact 1.
        assume x (h: x ∈ X), 
          show x ∈ ⋂₀ {U | Sub U ∧ X ⊆ U}, from 
            assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}),  
            show x ∈ W, from 
              have h₂: Sub W ∧ X ⊆ W, from h₁, 
            h₂.right h
        lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}:                                                     -- Fact 2.
        ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
        assume R (h₁: Sub R) (h₂: X ⊆ R),
        show Sg X ⊆ R, from 
          assume x (h: x ∈ Sg X), show x ∈ R, from 
            h R (and.intro h₁ h₂)
        lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}:                               -- An alternative proof of Fact 2.
        ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
        assume R (hc : Sub R ∧ X ⊆ R),
        have h₁: Sub R, from hc.left,
        have h₂: X ⊆ R, from hc.right,
        show Sg X ⊆ R, from 
          assume x (h: x ∈ Sg X), show x ∈ R, from 
            h R (and.intro h₁ h₂)
        lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}:                          -- Yet another derivation of Fact 2.
        ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= 
        assume x (h₁: x ∈ Sg X) (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), 
        show x ∈ R, from h₁ R (and.intro h₂ h₃)
        lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):=               -- Sgᴬ X is a subuniverse of A
        assume (f: F) (a: ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), 
        show 𝔸 f a ∈ Sg X, from 
          assume W (h: Sub W ∧ X ⊆ W), show 𝔸 f a ∈ W, from 
            have h₁: Sg X ⊆ W, from 
              sInter_mem' W h,
            have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i),
            (h.left f a h')
        inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
        | var (x : 𝔸) : x ∈ X → Y x
        | app (f : F) (a : ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸 f a)

    -- BEGIN
    -- Y X is a subuniverse
    lemma Y_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Y X):= 
    assume f a (h: ∀ i, Y X (a i)), show Y X (𝔸 f a), from 
    Y.app f a h 

    -- Y A X is the subuniverse generated by X
    theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
    have h₀: X ⊆ Y X, from assume x (h: x ∈ X), 
      show x  ∈ Y X, from Y.var x h,
    have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), 
      show Y X (𝔸 f a), from Y.app f a h,
    have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
    have inc_r: Y X ⊆ Sg X, from assume a (h: a ∈ Y X), 
      show a ∈ Sg X, from
        have h₂: a ∈ Y X → a ∈ Sg X, from 
          Y.rec
          ( --base: a = x ∈ X
            assume x (hr₁: x ∈ X), 
            show x ∈ Sg X, from subset_X_of_SgX X hr₁ 
          )
          ( --inductive: a = A f b for some b with ∀ i, b i ∈ Sg X
            assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X),
            show 𝔸 f b ∈ Sg X, from SgX_is_Sub X f b hr₃ 
          ),
        h₂ h,
    set.subset.antisymm inc_l inc_r
    -- END  
      end sub
    end subuniverse

Finally, we prove that ``Y`` is the smallest subalgebra containing ``X``.

.. code-block:: lean

    import data.set  -- the set.lean file from mathlib
    definition op (β α) := (β → α) → α
    definition π {β α} (i) : op β α := λ a, a i
    structure signature := mk :: (F : Type*) (ρ : F → Type*)
    definition algebra_on (σ : signature) (α : Type*) := Π (f : σ.F), op (σ.ρ f) α   
    definition algebra (σ : signature) := sigma (algebra_on σ)
    instance alg_carrier (σ : signature) : has_coe_to_sort (algebra σ) := ⟨_, sigma.fst⟩
    instance alg_operations (σ : signature) : has_coe_to_fun (algebra σ) := ⟨_, sigma.snd⟩
 
    namespace subuniverse
      section sub
        parameters {σ : signature} {α : Type*} {I : Type*}
        def F := σ.F
        def ρ := σ.ρ 
        def Sub {𝔸: algebra σ} (B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸 f a) ∈ B₀
        def is_subalgebra (𝔸: algebra σ) (B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸 f ↑b
        def Sg (A : algebra_on σ α) (X : set α) : set α := ⋂₀ {U | Sub A U ∧ X ⊆ U}
        theorem Inter.intro {𝔸: algebra σ} {s: I → set 𝔸}: ∀ (x: 𝔸), (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) :=
        assume x h t ⟨j, (eq: t = s j)⟩, eq.symm ▸ h j
        theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: I → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h: x ∈ ⋂ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: I → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= 
        assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: F) (a: ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        show 𝔸 f a ∈ ⋂i, C i, from Inter.intro (𝔸 f a) (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))
        lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:=                                   -- Fact 1.
        assume x (h: x ∈ X), 
          show x ∈ ⋂₀ {U | Sub U ∧ X ⊆ U}, from 
            assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}),  
            show x ∈ W, from 
              have h₂: Sub W ∧ X ⊆ W, from h₁, 
            h₂.right h
        lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}:                                                     -- Fact 2.
        ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
        assume R (h₁: Sub R) (h₂: X ⊆ R),
        show Sg X ⊆ R, from 
          assume x (h: x ∈ Sg X), show x ∈ R, from 
            h R (and.intro h₁ h₂)
        lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}:                               -- An alternative proof of Fact 2.
        ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
        assume R (hc : Sub R ∧ X ⊆ R),
        have h₁: Sub R, from hc.left,
        have h₂: X ⊆ R, from hc.right,
        show Sg X ⊆ R, from 
          assume x (h: x ∈ Sg X), show x ∈ R, from 
            h R (and.intro h₁ h₂)
        lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}:                          -- Yet another derivation of Fact 2.
        ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= 
        assume x (h₁: x ∈ Sg X) (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), 
        show x ∈ R, from h₁ R (and.intro h₂ h₃)
        lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):=               -- Sgᴬ X is a subuniverse of A
        assume (f: F) (a: ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), 
        show 𝔸 f a ∈ Sg X, from 
          assume W (h: Sub W ∧ X ⊆ W), show 𝔸 f a ∈ W, from 
            have h₁: Sg X ⊆ W, from 
              sInter_mem' W h,
            have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i),
            (h.left f a h')
        inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
        | var (x : 𝔸) : x ∈ X → Y x
        | app (f : F) (a : ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸 f a)

        -- Y X is a subuniverse
        lemma Y_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Y X):= 
        assume f a (h: ∀ i, Y X (a i)), show Y X (𝔸 f a), from 
        Y.app f a h 
    
        -- Y A X is the subuniverse generated by X
        theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
        have h₀: X ⊆ Y X, from assume x (h: x ∈ X), 
          show x  ∈ Y X, from Y.var x h,
        have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), 
          show Y X (𝔸 f a), from Y.app f a h,
        have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
        have inc_r: Y X ⊆ Sg X, from assume a (h: a ∈ Y X), 
          show a ∈ Sg X, from
            have h₂: a ∈ Y X → a ∈ Sg X, from 
              Y.rec
              ( --base: a = x ∈ X
                assume x (hr₁: x ∈ X), 
                show x ∈ Sg X, from subset_X_of_SgX X hr₁ 
              )
              ( --inductive: a = A f b for some b with ∀ i, b i ∈ Sg X
                assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X),
                show 𝔸 f b ∈ Sg X, from SgX_is_Sub X f b hr₃ 
              ),
            h₂ h,
        set.subset.antisymm inc_l inc_r

    -- BEGIN
    definition index_of_sub_above_X {𝔸: algebra σ} 
    (X: set 𝔸) (C: I → set 𝔸): I → Prop:= 
    λ i, Sub (C i) ∧ X ⊆ (C i) 

    lemma sInter_mem_of_mem {𝔸: algebra σ} {X: set 𝔸} (x: 𝔸): 
    x ∈ Sg X ↔ ∀ {R: set 𝔸}, Sub R → X ⊆ R → x ∈ R:= 
    iff.intro
      (assume (h: x ∈ Sg X) (R: set 𝔸) (h₁: Sub R) (h₂: X ⊆ R), 
        show x ∈ R, from h R (and.intro h₁ h₂))
      (assume (h: ∀ {R: set 𝔸}, Sub R → X ⊆ R → x ∈ R), 
        show x ∈ Sg X, from h (SgX_is_Sub X) (subset_X_of_SgX X))

    -- Y is the smallest Sub containing X
    lemma Y_is_min_Sub {𝔸: algebra σ} (U X: set 𝔸): 
    Sub U → X ⊆ U → Y X ⊆ U:=
    assume (h₁: Sub U) (h₂ : X ⊆ U),
    assume (y: 𝔸)  (p: Y X y), show U y, from 
      have q: Y X y → Y X y → U y, from 
        Y.rec

        --base step: y = x ∈ X
        ( assume y (h: X y) (h': Y X y), h₂ h )

        --induction step: y = A f a for some a with ∀ i, a i ∈ Y
        ( assume f a,
          assume h₃: ∀ i, Y X (a i), 
          assume h₄: ∀ i, Y X (a i) → U (a i),
          assume h₅: Y X (𝔸 f a),
          have h₆: ∀ i, a i ∈ U, from 
            assume i, h₄ i (h₃ i), show U (𝔸 f a), from h₁ f a h₆ ),
      q p p

    -- END  
      end sub
    end subuniverse

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A ⊆ B → B ⊆ A → A = B`.

.. index:: recursor

We proved ``Y X ⊆ Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined.

The Lean keyword ``assume`` is syntactic sugar for ``λ``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: variables, word, term, free algebra, absolutely free, universal (for σ-algebras) 

.. _terms-in-lean:

Terms in Lean
-------------

The Lean code described in this section is in the source files ``free.lean`` and ``term.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`T(X)` of all terms of a given signature over a collection :math:`X` of variables.

.. include:: _static/free.lean.1.rst

The collection of terms over :math:`X`, along with the operations :math:`F^{𝕋(X)} := \{\mathsf{app} f ∣ f : F\}` forms an algebra in the signature :math:`σ = (F, ρ)`, which we denote and define by :math:`𝕋(X) = ⟨T(X), F^{𝕋(X)}⟩` .

Now, suppose :math:`𝔸 = ⟨A, F^𝔸⟩` is an algebra in the signature σ and :math:`h : X → A` is an arbitrary function.  We will show that :math:`h : X → A` has a unique *extension* (or *lift*) to a homomorphism from :math:`𝕋(X)` to 𝔸.

Since 𝔸 and :math:`h : X → A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`𝕋(X)` is **universal** for σ-algebras. Some authors say, ":math:`𝕋(X)` is **absolutely free** for σ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. include:: _static/free.lean.2.rst

If :math:`h : X → A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`𝕋(X)` is defined inductively as follows:

.. include:: _static/free.lean.3.rst

To prove that the term algebra is universal for σ-algebras, we show that the lift of an arbitrary function :math:`h : X → A` is a homomorphism and that this lift is unique.

.. include:: _static/free.lean.4.rst

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

The Lean code described in this section is in the source file ``clone.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_ Also, although we don't make it explicit below, all of the code in the first part of this section is contained inside a single block of the form 

.. code::

    namespace clone
      section clo 
        ... 
      end clo
    end clone

First, we define a structure that specifies the properties that a clone must have.  As defined in :numref:`Section %s <clones>`, in order to be a clone a collection must include all projections and be closed under general composition.

.. include:: _static/clone.lean.1.rst

Next we inductively define a clone of operations generated by a given collection ``X`` of "basic" operations.

.. include:: _static/clone.lean.2.rst

Finally, we check that the foregoing definition is indeed a clone and that it is the smallest clone containing the given collection of operations.

.. include:: _static/clone.lean.3.rst

---------------------------

.. rubric:: Footnotes

.. [1]
   As of this writing (9 June 2019), this documentation describes code residing on the dev_wjd_ branch of the ``lean-ualib`` repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.
   
.. _Lean: https://leanprover.github.io/

.. _`github.com/UniversalAlgebra/lean-ualib`: https://github.com/UniversalAlgebra/lean-ualib/

.. _lean-ualib: https://github.com/UniversalAlgebra/lean-ualib/

.. _dev_wjd: https://gitlab.com/ualib/lean-ualib/tree/dev_wjd

.. _master: https://gitlab.com/ualib/lean-ualib/tree/master

