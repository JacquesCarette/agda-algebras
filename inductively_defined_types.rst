.. highlight:: lean

.. include:: _static/math_macros.rst

.. _inductively-defined-types:

=========================
Inductively Defined Types
=========================

(`The chapter on inductive types <https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html>`_ in the `Theorem Proving in Lean`_ tutorial gives a nice presentation of this topic. We start our presentation by quoting four key points from the start of `that chapter <https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html>`_.)

#. "Lean's formal foundation includes basic types, ``Prop, Type 0, Type 1, ...``, and allows for the formation of :term:`dependent function types <dependent function type>`, ``Π x : α, β``."

#. "In Lean's library, every concrete type other than the universes and every type constructor other than ``Pi`` is an instance of a general family of type constructions known as *inductive types*."

#. "It is remarkable that it is possible to construct a substantial edifice of mathematics based on nothing more than the type universes, Pi types, and inductive types; everything else follows from those."

#. "Intuitively, an inductive type is built up from a specified list of constructors. In Lean, the syntax for specifying such a type is as follows:

   .. code-block:: text

       inductive foo : Sort u
       | constructor₁ : ... → foo
       | constructor₂ : ... → foo
       ...
       | constructorₙ : ... → foo

   The intuition is that each constructor specifies a way of building new objects of type ``foo``, possibly from previously constructed values. The type ``foo`` consists of nothing more than the objects that are constructed in this way."

------------------------------

.. _the-recursor:

The Recursor
------------

Each inductively defined type, say ``foo``, is accompanied by an elimination principle known as a **recursor** (denoted by ``foo.rec`` in Lean). This elimination principle is what makes the type "inductive"; it allows us to define a function on ``foo`` by assigning values for each of ``foo``'s constructors.

.. todo:: complete this section; include an example.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: ! subalgebra, ! subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean:

Subalgebras in Lean
-------------------

The Lean code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of the lean-ualib_ repository. [1]_

In :numref:`Section %s <subuniverses-in-lean>`, we saw how :ref:`subalgebras <subalgebras>` can be implemented in Lean and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and implements the :ref:`subuniverse generation theorem <thm-1-14>`. 

First, we define an inductive type that represents the **subuniverse generated by a set**; cf. the informal language definition in given by :eq:`subalgebra-inductive` .

::

  import data.set
  universes u v w
  namespace ualib
    definition op (γ: Type w) (α: Type u) := (γ → α) → α
    structure signature := mk :: (ℱ: Type v) (ρ: ℱ  → Type u)

    section algebra
      parameter σ: signature
      def algebra_on (α: Type u) := Π f, op (σ.ρ f) α
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := ⟨_, sigma.fst⟩
      instance alg_operations : has_coe_to_fun algebra := ⟨_, sigma.snd⟩
    end algebra

    section subuniverse
      parameters {α: Type u} {γ: Type w} {σ: signature}
      definition F := σ.ℱ
      definition ρ := σ.ρ
      def Sub {𝔸: algebra σ}(B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸.snd f a) ∈ B₀
      def is_subalgebra {𝔸: algebra σ}(B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸.snd f ↑b
      def Sg {𝔸: algebra σ}(X: set 𝔸): set 𝔸:= ⋂₀ {U | Sub U ∧ X ⊆ U}
      theorem Inter.intro {𝔸: algebra σ} {x: 𝔸} {s: γ → set 𝔸}: (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) := assume h, iff.elim_right set.mem_Inter h
      theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: γ → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h, iff.elim_left set.mem_Inter h
  
      lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: γ → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= assume h: (∀ i, Sub (C i)), assume (f: σ.ℱ) (a: σ.ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i), Inter.intro (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))

      lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= assume x (h: x ∈ X), 
      assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}), have h₂: Sub W ∧ X ⊆ W, from h₁, h₂.right h

      lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
      assume R (h₁: Sub R) (h₂: X ⊆ R), assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
      assume R (hc : Sub R ∧ X ⊆ R), have h₁: Sub R, from hc.left,
      have h₂: X ⊆ R, from hc.right, assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}: ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= assume x (h₁: x ∈ Sg X), assume (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), h₁ R (and.intro h₂ h₃)

      lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= assume f (a: σ.ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), assume W (h: Sub W ∧ X ⊆ W), have h₁: Sg X ⊆ W, from sInter_mem' W h,
      have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i), (h.left f a h')

      -- BEGIN
      inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
      | var (x: 𝔸): x ∈ X → Y x
      | app (f: σ.ℱ) (a: σ.ρ f → 𝔸): (∀ i, Y (a i)) → Y (𝔸.snd f a)
      -- END
  end subuniverse

Next we prove that the type ``Y X`` is a subuniverse. Moreover, ``Y X`` is equal to :math:`\mathrm{Sg}^𝔸(X)`, which is another fact that we formalize and prove below.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (γ: Type w) (α: Type u) := (γ → α) → α
    structure signature := mk :: (ℱ: Type v) (ρ: ℱ  → Type u)

    section algebra
      parameter σ: signature
      def algebra_on (α: Type u) := Π f, op (σ.ρ f) α
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := ⟨_, sigma.fst⟩
      instance alg_operations : has_coe_to_fun algebra := ⟨_, sigma.snd⟩
    end algebra

    section subuniverse
      parameters {α: Type u} {γ: Type w} {σ: signature}
      definition F := σ.ℱ
      definition ρ := σ.ρ

      def Sub {𝔸: algebra σ}(B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸.snd f a) ∈ B₀
      def is_subalgebra {𝔸: algebra σ}(B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸.snd f ↑b
      def Sg {𝔸: algebra σ}(X: set 𝔸): set 𝔸:= ⋂₀ {U | Sub U ∧ X ⊆ U}
      theorem Inter.intro {𝔸: algebra σ} {x: 𝔸} {s: γ → set 𝔸}: (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) := assume h, iff.elim_right set.mem_Inter h
      theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: γ → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h, iff.elim_left set.mem_Inter h
   
      lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: γ → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= assume h: (∀ i, Sub (C i)), assume (f: σ.ℱ) (a: σ.ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i), Inter.intro (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))

      lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= assume x (h: x ∈ X), 
      assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}), have h₂: Sub W ∧ X ⊆ W, from h₁, h₂.right h

      lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
      assume R (h₁: Sub R) (h₂: X ⊆ R), assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
      assume R (hc : Sub R ∧ X ⊆ R), have h₁: Sub R, from hc.left,
      have h₂: X ⊆ R, from hc.right, assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}: ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= assume x (h₁: x ∈ Sg X), assume (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), h₁ R (and.intro h₂ h₃)

      lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= assume f (a: σ.ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), assume W (h: Sub W ∧ X ⊆ W), have h₁: Sg X ⊆ W, from sInter_mem' W h,
      have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i), (h.left f a h')

      inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
      | var (x : 𝔸) : x ∈ X → Y x
      | app (f : σ.ℱ) (a : σ.ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸.snd f a)
      
    -- BEGIN
    -- Y X is a subuniverse
    lemma Y_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Y X):= 
    assume f a (h: ∀ i, Y X (a i)), show Y X (𝔸 f a), from 
    Y.app f a h 

    -- Y A X is the subuniverse generated by X
    theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
    have h₀: X ⊆ Y X, from assume x (h: x ∈ X), 
    show x  ∈ Y X, from Y.var x h,
    have h₁: Sub (Y X), from
      assume f a (h : ∀ x, Y X (a x)), 
      show Y X (𝔸 f a), from Y.app f a h,
        have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
        have inc_r: Y X ⊆ Sg X, from assume a (h: a ∈ Y X), 
      show a ∈ Sg X, from
        have h₂: a ∈ Y X → a ∈ Sg X, from 
          Y.rec
          -- base step: a = x ∈ X
            (
              assume x (hr₁: x ∈ X), 
              show x ∈ Sg X, from subset_X_of_SgX X hr₁
            )
          -- induct step: a = A f b for some b with ∀ i, b i ∈ Sg X
            (
              assume f b (hr₂: ∀ i, b i ∈ Y X),
              assume (hr₃: ∀ i, b i ∈ Sg X),
              show 𝔸 f b ∈ Sg X, from SgX_is_Sub X f b hr₃
            ),
          h₂ h,
          set.subset.antisymm inc_l inc_r
    -- END  
  end subuniverse

Finally, we prove that ``Y`` is the smallest subuniverse containing ``X``.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (γ: Type w) (α: Type u) := (γ → α) → α
    structure signature := mk :: (ℱ: Type v) (ρ: ℱ  → Type u)

    section algebra
      parameter σ: signature
      def algebra_on (α: Type u) := Π f, op (σ.ρ f) α
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := ⟨_, sigma.fst⟩
      instance alg_operations : has_coe_to_fun algebra := ⟨_, sigma.snd⟩
    end algebra

    section subuniverse
      parameters {α: Type u} {γ: Type w} {σ: signature}
      definition F := σ.ℱ
      definition ρ := σ.ρ
      def Sub {𝔸: algebra σ}(B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸.snd f a) ∈ B₀
      def is_subalgebra {𝔸: algebra σ}(B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸.snd f ↑b
      def Sg {𝔸: algebra σ}(X: set 𝔸): set 𝔸:= ⋂₀ {U | Sub U ∧ X ⊆ U}

      theorem Inter.intro {𝔸: algebra σ} {x: 𝔸} {s: γ → set 𝔸}: (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: γ → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h, iff.elim_left set.mem_Inter h
    
      lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: γ → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= assume h: (∀ i, Sub (C i)), assume (f: σ.ℱ) (a: σ.ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i), Inter.intro (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))

      lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= assume x (h: x ∈ X), 
      assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}), have h₂: Sub W ∧ X ⊆ W, from h₁, h₂.right h

      lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
      assume R (h₁: Sub R) (h₂: X ⊆ R), assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
      assume R (hc : Sub R ∧ X ⊆ R), have h₁: Sub R, from hc.left,
      have h₂: X ⊆ R, from hc.right, assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}: ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= assume x (h₁: x ∈ Sg X), assume (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), h₁ R (and.intro h₂ h₃)

      lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= assume f (a: σ.ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), assume W (h: Sub W ∧ X ⊆ W), have h₁: Sg X ⊆ W, from sInter_mem' W h,
      have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i), (h.left f a h')

      inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
      | var (x : 𝔸) : x ∈ X → Y x
      | app (f : σ.ℱ) (a : σ.ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸.snd f a)

      lemma Y_is_Sub {𝔸: algebra σ}(X: set 𝔸): Sub (Y X):= assume f a (h: ∀ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
      have h₀: X ⊆ Y X, from assume x (h: x ∈ X), Y.var x h,
      have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
      have inc_r: Y X ⊆ Sg X, from
        assume a (h: a ∈ Y X), have h₂: a ∈ Y X → a ∈ Sg X, from
        Y.rec
          (assume x (hr₁: x ∈ X), show x ∈ Sg X, from subset_X_of_SgX X hr₁)
          (assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X), show 𝔸.snd f b ∈ Sg X, from SgX_is_Sub X f b hr₃ ),
          h₂ h,
        set.subset.antisymm inc_l inc_r

    -- BEGIN
    -- Y is the smallest Sub containing X
    lemma Y_is_min_Sub {𝔸: algebra σ} (U X: set 𝔸): 
    Sub U → X ⊆ U → Y X ⊆ U:=
    assume (h₁: Sub U) (h₂ : X ⊆ U),
    assume (y: 𝔸) (p: Y X y), show U y, from 
      have q: Y X y → Y X y → U y, from 
        Y.rec

        --base step: y = x ∈ X
        ( assume y (h: X y) (h': Y X y), h₂ h )

        --induction step: y = A f a for some a with ∀ i, a i ∈ Y
        ( assume f a,
          assume h₃: ∀ i, Y X (a i), 
          assume h₄: ∀ i, Y X (a i) → U (a i),
          assume h₅: Y X (𝔸 f a),
          have h₆: ∀ i, a i ∈ U, from 
            assume i, h₄ i (h₃ i), show U (𝔸 f a), from h₁ f a h₆ ),
      q p p
    -- END  
    end sub
  end subuniverse

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A ⊆ B → B ⊆ A → A = B`.

.. index:: recursor

We proved ``Y X ⊆ Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined. (We will see many more examples of inductive proofs below.)

The Lean keyword ``assume`` is syntactic sugar for ``λ``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: variables, word, term, free algebra
.. index:: universal for; σ-algebras
.. index:: absolutely free for; σ-algebras

.. _terms-in-lean:

Terms in Lean
-------------

The Lean code described in this section is in the source files ``free.lean`` and ``term.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`T(X)` of all terms of a given signature over a collection :math:`X` of variables.

.. include:: _static/free.lean.1.rst

The collection of terms over :math:`X`, along with the operations :math:`F^{𝕋(X)} := \{\mathsf{app} f ∣ f : F\}` forms an algebra in the signature :math:`σ = (F, ρ)`, which we denote and define by :math:`𝕋(X) = ⟨T(X), F^{𝕋(X)}⟩` .

Now, suppose :math:`𝔸 = ⟨A, F^𝔸⟩` is an algebra in the signature σ and :math:`h : X → A` is an arbitrary function.  We will show that :math:`h : X → A` has a unique *extension* (or *lift*) to a homomorphism from :math:`𝕋(X)` to 𝔸.

Since 𝔸 and :math:`h : X → A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`𝕋(X)` is **universal for** σ-algebras. Some authors say, ":math:`𝕋(X)` is **absolutely free for** σ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. include:: _static/free.lean.2.rst

If :math:`h : X → A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`𝕋(X)` is defined inductively as follows:

.. include:: _static/free.lean.3.rst

To prove that the term algebra is universal for σ-algebras, we show that the lift of an arbitrary function :math:`h : X → A` is a homomorphism and that this lift is unique.

.. include:: _static/free.lean.4.rst

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

The Lean code described in this section is in the source file ``clone.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_ Also, although we don't make it explicit below, all of the code in the first part of this section is contained inside a single block of the form 

.. code::

    namespace clone
      section clo 
        ... 
      end clo
    end clone

First, we define a structure that specifies the properties that a clone must have.  As defined in :numref:`Section %s <clones>`, in order to be a clone a collection must include all projections and be closed under general composition.

.. include:: _static/clone.lean.1.rst

Next we define an inductive type that represents the clone generated by a given collection ``X`` of operations.

.. include:: _static/clone.lean.2.rst

Finally, we check that the foregoing definition is indeed a clone and that it is the smallest clone containing the given collection of operations.

.. include:: _static/clone.lean.3.rst

---------------------------

.. _basic-facts-in-lean:

Basic Facts in Lean
--------------------

In this section we show how to state and prove in Lean the basic facts of :numref:`basic-facts`.

.. index:: ! equalizer

Recall, the **equalizer** of the functions :math:`g` and :math:`h` is the set

.. math:: 𝖤(g,h) = \{ a : A ∣ g(a) = h(a) \}.

We begin by defining in Lean

#. the equalizer of two functions, ``E``,

#. a homomorphism, ``hom``, and 

#. the equalizer of two homomorphisms, ``E_hom``.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (γ: Type w) (α: Type u) := (γ → α) → α
    structure signature := mk :: (ℱ: Type v) (ρ: ℱ  → Type u)
  
    section algebra
      parameter σ: signature
      def algebra_on (α: Type u) := Π f, op (σ.ρ f) α
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := ⟨_, sigma.fst⟩
      instance alg_operations : has_coe_to_fun algebra := ⟨_, sigma.snd⟩
    end algebra

    section subuniverse
      parameters {α: Type u} {γ: Type w} {σ: signature}
      definition F := σ.ℱ 
      definition ρ := σ.ρ 
      def Sub {𝔸: algebra σ}(B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸.snd f a) ∈ B₀
      def is_subalgebra {𝔸: algebra σ}(B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸.snd f ↑b
      def Sg {𝔸: algebra σ}(X: set 𝔸): set 𝔸:= ⋂₀ {U | Sub U ∧ X ⊆ U}

      theorem Inter.intro {𝔸: algebra σ} {x: 𝔸} {s: γ → set 𝔸}: (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: γ → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: γ → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: σ.ℱ) (a: σ.ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        Inter.intro (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))

      lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= assume x (h: x ∈ X), 
      assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}), have h₂: Sub W ∧ X ⊆ W, from h₁, h₂.right h

      lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
      assume R (h₁: Sub R) (h₂: X ⊆ R), assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
      assume R (hc : Sub R ∧ X ⊆ R), have h₁: Sub R, from hc.left,
      have h₂: X ⊆ R, from hc.right, assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}: ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= assume x (h₁: x ∈ Sg X), assume (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), h₁ R (and.intro h₂ h₃)

      lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= assume f (a: σ.ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), assume W (h: Sub W ∧ X ⊆ W), have h₁: Sg X ⊆ W, from sInter_mem' W h,
      have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i), (h.left f a h')

      inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
      | var (x : 𝔸) : x ∈ X → Y x
      | app (f : σ.ℱ) (a : σ.ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸.snd f a)

      lemma Y_is_Sub {𝔸: algebra σ}(X: set 𝔸): Sub (Y X):= assume f a (h: ∀ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
      have h₀: X ⊆ Y X, from assume x (h: x ∈ X), Y.var x h,
      have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
      have inc_r: Y X ⊆ Sg X, from
        assume a (h: a ∈ Y X), have h₂: a ∈ Y X → a ∈ Sg X, from
        Y.rec
          (assume x (hr₁: x ∈ X), show x ∈ Sg X, from subset_X_of_SgX X hr₁)
          (assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X), show 𝔸.snd f b ∈ Sg X, from SgX_is_Sub X f b hr₃ ),
          h₂ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {𝔸: algebra σ} (U X: set 𝔸): Sub U → X ⊆ U → Y X ⊆ U:= assume (h₁: Sub U) (h₂ : X ⊆ U), assume (y: 𝔸)  (p: Y X y), have q: Y X y → Y X y → U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), h₂ h )
          ( assume f a (h₃: ∀ i, Y X (a i)) (h₄: ∀ i, Y X (a i) → U (a i)) (h₅: Y X (𝔸.snd f a)), have h₆: ∀ i, a i ∈ U, from
            assume i, h₄ i (h₃ i), h₁ f a h₆ ), q p p
    end subuniverse

    section homomorphism
      parameters {α: Type u} {γ: Type v}
      def homomorphic {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸 → 𝔹) := ∀ f a, h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
      def homomorphic_verbose {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸.fst → 𝔹.fst) := ∀ (f: σ.ℱ) (a : σ.ρ f → 𝔸.fst), h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
    end homomorphism

    def ker {α β: Type u} (f: α → β): α → α → Prop := λ a b, f a = f b

    -- BEGIN
    section basic_facts
      parameter {σ: signature}

      -- equalizer (of functions)
      def E {α β: Type u} (f g: α → β): set α := 
      λ (x: α), f x = g x 

      -- indicates whether g is a homomorphism  
      def hom {𝔸 𝔹: algebra σ} (g: 𝔸 → 𝔹): Prop :=
      ∀ f a, g (𝔸 f a) = 𝔹 f (g ∘ a)

      -- the set on which two homs agree
      def E_homs {𝔸 𝔹: algebra σ} (g h: 𝔸 → 𝔹)
      (hg: hom g) (hh: hom h): set 𝔸 := 
      λ (a: 𝔸), g a = h a 

    end basic_facts
    -- END

  end ualib

Recall the simple fact that composing two homomorphisms results in a homomorphism.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (γ: Type w) (α: Type u) := (γ → α) → α
    structure signature := mk :: (ℱ: Type v) (ρ: ℱ  → Type u)
  
    section algebra
      parameter σ: signature
      def algebra_on (α: Type u) := Π f, op (σ.ρ f) α
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := ⟨_, sigma.fst⟩
      instance alg_operations : has_coe_to_fun algebra := ⟨_, sigma.snd⟩
    end algebra

    section subuniverse
      parameters {α: Type u} {γ: Type w} {σ: signature}
      definition F := σ.ℱ 
      definition ρ := σ.ρ 
      def Sub {𝔸: algebra σ}(B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸.snd f a) ∈ B₀
      def is_subalgebra {𝔸: algebra σ}(B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸.snd f ↑b
      def Sg {𝔸: algebra σ}(X: set 𝔸): set 𝔸:= ⋂₀ {U | Sub U ∧ X ⊆ U}

      theorem Inter.intro {𝔸: algebra σ} {x: 𝔸} {s: γ → set 𝔸}: (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: γ → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: γ → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: σ.ℱ) (a: σ.ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        Inter.intro (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))

      lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= assume x (h: x ∈ X), 
      assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}), have h₂: Sub W ∧ X ⊆ W, from h₁, h₂.right h

      lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
      assume R (h₁: Sub R) (h₂: X ⊆ R), assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
      assume R (hc : Sub R ∧ X ⊆ R), have h₁: Sub R, from hc.left,
      have h₂: X ⊆ R, from hc.right, assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}: ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= assume x (h₁: x ∈ Sg X), assume (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), h₁ R (and.intro h₂ h₃)

      lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= assume f (a: σ.ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), assume W (h: Sub W ∧ X ⊆ W), have h₁: Sg X ⊆ W, from sInter_mem' W h,
      have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i), (h.left f a h')

      inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
      | var (x : 𝔸) : x ∈ X → Y x
      | app (f : σ.ℱ) (a : σ.ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸.snd f a)

      lemma Y_is_Sub {𝔸: algebra σ}(X: set 𝔸): Sub (Y X):= assume f a (h: ∀ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
      have h₀: X ⊆ Y X, from assume x (h: x ∈ X), Y.var x h,
      have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
      have inc_r: Y X ⊆ Sg X, from
        assume a (h: a ∈ Y X), have h₂: a ∈ Y X → a ∈ Sg X, from
        Y.rec
          (assume x (hr₁: x ∈ X), show x ∈ Sg X, from subset_X_of_SgX X hr₁)
          (assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X), show 𝔸.snd f b ∈ Sg X, from SgX_is_Sub X f b hr₃ ),
          h₂ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {𝔸: algebra σ} (U X: set 𝔸): Sub U → X ⊆ U → Y X ⊆ U:= assume (h₁: Sub U) (h₂ : X ⊆ U), assume (y: 𝔸)  (p: Y X y), have q: Y X y → Y X y → U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), h₂ h )
          ( assume f a (h₃: ∀ i, Y X (a i)) (h₄: ∀ i, Y X (a i) → U (a i)) (h₅: Y X (𝔸.snd f a)), have h₆: ∀ i, a i ∈ U, from
            assume i, h₄ i (h₃ i), h₁ f a h₆ ), q p p
    end subuniverse

    section homomorphism
      parameters {α: Type u} {γ: Type v}
      def homomorphic {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸 → 𝔹) := ∀ f a, h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
      def homomorphic_verbose {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸.fst → 𝔹.fst) := ∀ (f: σ.ℱ) (a : σ.ρ f → 𝔸.fst), h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
    end homomorphism

    def ker {α β: Type u} (f: α → β): α → α → Prop := λ a b, f a = f b

    section basic_facts
      parameter {σ: signature}
      def E {α β: Type u} (f g: α → β): set α := λ (x: α), f x = g x 
      def hom {𝔸 𝔹: algebra σ} (g: 𝔸 → 𝔹): Prop := ∀ f a, g (𝔸 f a) = 𝔹 f (g ∘ a)
      def E_homs {𝔸 𝔹: algebra σ} (g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h): set 𝔸 :=  λ (a: 𝔸), g a = h a 

    -- BEGIN
    -- 0. The composition of homs is a hom.
    lemma hom_comp_of_hom {𝔸 𝔹 ℂ: algebra σ}
    (g: 𝔸 → 𝔹) (h: 𝔹 → ℂ) (hg: hom g) (hh: hom h): hom (h ∘ g) :=
    assume f a, 
    show (h ∘ g)(𝔸 f a) = ℂ f (h ∘ g ∘ a), from 
      have h₃: (h ∘ g)(𝔸 f a) = h (g (𝔸 f a)), from  rfl,
      calc
        (h ∘ g)(𝔸 f a) = h ((𝔹 f) (g ∘ a)) : (h₁ f a) ▸ h₃ 
                   ... = (ℂ f) (h ∘ g ∘ a)  : h₂ f (g ∘ a)
    -- END
    end basic_facts
  end ualib

(As with the other numbered results appearing in this section, we include the statement and proof of the above fact inside the ``basic_facts`` section.)

Next we formally prove that the equalizer ``𝖤 g h`` of two homomorphisms ``g`` and ``h`` is a subuniverse of 𝔸 (cf. :numref:`Obs %s <obs-one>`).

::

  import data.set
  universes u v w
  namespace ualib
    definition op (γ: Type w) (α: Type u) := (γ → α) → α
    structure signature := mk :: (ℱ: Type v) (ρ: ℱ  → Type u)
  
    section algebra
      parameter σ: signature
      def algebra_on (α: Type u) := Π f, op (σ.ρ f) α
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := ⟨_, sigma.fst⟩
      instance alg_operations : has_coe_to_fun algebra := ⟨_, sigma.snd⟩
    end algebra

    section subuniverse
      parameters {α: Type u} {γ: Type w} {σ: signature}
      definition F := σ.ℱ 
      definition ρ := σ.ρ 
      def Sub {𝔸: algebra σ}(B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸.snd f a) ∈ B₀
      def is_subalgebra {𝔸: algebra σ}(B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸.snd f ↑b
      def Sg {𝔸: algebra σ}(X: set 𝔸): set 𝔸:= ⋂₀ {U | Sub U ∧ X ⊆ U}

      theorem Inter.intro {𝔸: algebra σ} {x: 𝔸} {s: γ → set 𝔸}: (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: γ → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: γ → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: σ.ℱ) (a: σ.ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        Inter.intro (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))

      lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= assume x (h: x ∈ X), 
      assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}), have h₂: Sub W ∧ X ⊆ W, from h₁, h₂.right h

      lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
      assume R (h₁: Sub R) (h₂: X ⊆ R), assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
      assume R (hc : Sub R ∧ X ⊆ R), have h₁: Sub R, from hc.left,
      have h₂: X ⊆ R, from hc.right, assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}: ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= assume x (h₁: x ∈ Sg X), assume (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), h₁ R (and.intro h₂ h₃)

      lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= assume f (a: σ.ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), assume W (h: Sub W ∧ X ⊆ W), have h₁: Sg X ⊆ W, from sInter_mem' W h,
      have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i), (h.left f a h')

      inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
      | var (x : 𝔸) : x ∈ X → Y x
      | app (f : σ.ℱ) (a : σ.ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸.snd f a)

      lemma Y_is_Sub {𝔸: algebra σ}(X: set 𝔸): Sub (Y X):= assume f a (h: ∀ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
      have h₀: X ⊆ Y X, from assume x (h: x ∈ X), Y.var x h,
      have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
      have inc_r: Y X ⊆ Sg X, from
        assume a (h: a ∈ Y X), have h₂: a ∈ Y X → a ∈ Sg X, from
        Y.rec
          (assume x (hr₁: x ∈ X), show x ∈ Sg X, from subset_X_of_SgX X hr₁)
          (assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X), show 𝔸.snd f b ∈ Sg X, from SgX_is_Sub X f b hr₃ ),
          h₂ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {𝔸: algebra σ} (U X: set 𝔸): Sub U → X ⊆ U → Y X ⊆ U:= assume (h₁: Sub U) (h₂ : X ⊆ U), assume (y: 𝔸)  (p: Y X y), have q: Y X y → Y X y → U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), h₂ h )
          ( assume f a (h₃: ∀ i, Y X (a i)) (h₄: ∀ i, Y X (a i) → U (a i)) (h₅: Y X (𝔸.snd f a)), have h₆: ∀ i, a i ∈ U, from
            assume i, h₄ i (h₃ i), h₁ f a h₆ ), q p p
    end subuniverse

    section homomorphism
      parameters {α: Type u} {γ: Type v}
      def homomorphic {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸 → 𝔹) := ∀ f a, h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
      def homomorphic_verbose {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸.fst → 𝔹.fst) := ∀ (f: σ.ℱ) (a : σ.ρ f → 𝔸.fst), h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
    end homomorphism

    def ker {α β: Type u} (f: α → β): α → α → Prop := λ a b, f a = f b

    section basic_facts
      parameter {σ: signature}
      def E {α β: Type u} (f g: α → β): set α := λ (x: α), f x = g x 
      def hom {𝔸 𝔹: algebra σ} (g: 𝔸 → 𝔹): Prop := ∀ f a, g (𝔸 f a) = 𝔹 f (g ∘ a)
      def E_homs {𝔸 𝔹: algebra σ} (g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h): set 𝔸 :=  λ (a: 𝔸), g a = h a 

      lemma hom_comp_of_hom {𝔸 𝔹 ℂ: algebra σ}(g: 𝔸 → 𝔹) (h: 𝔹 → ℂ) (hg: hom g) (hh: hom h): hom (h ∘ g) :=
    assume f a, show (h ∘ g)(𝔸 f a) = ℂ f (h ∘ g ∘ a), from 
      have h₃: (h ∘ g)(𝔸 f a) = h (g (𝔸 f a)), from  rfl,
      calc
        (h ∘ g)(𝔸 f a) = h ((𝔹 f) (g ∘ a)) : (h₁ f a) ▸ h₃ 
                   ... = (ℂ f) (h ∘ g ∘ a)  : h₂ f (g ∘ a)
    -- BEGIN
    -- 1. The equalizer of homs is a subuniverse.
    lemma Sub_E_homs {𝔸 𝔹: algebra σ}
    (g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h): 
    Sub (E_homs h g hh hg) := 
    assume f a (h₁: ∀ x, a x ∈ (E_homs h g hh hg)),
    show 𝔸 f a ∈ (E_homs h g hh hg),  from 
      have h₂: h ∘ a = g ∘ a, from funext h₁, 
      show h (𝔸 f a) = g (𝔸 f a), from 
        calc
          h (𝔸 f a) = 𝔹 f (h ∘ a) : hh f a
                ... = 𝔹 f (g ∘ a) : congr_arg (𝔹 f) h₂
                ... = g (𝔸 f a)   : eq.symm (hg f a)
    -- END
    end basic_facts
  end ualib
  
Recall (:numref:`Obs %s <obs-two>`) if two homomorphisms agree on a generating set, then they are equal.

More precisely, if a subset ``X`` is contained in the equalizer of two homomorphisms, then ``Sg X`` is also contained in the equalizer; thus, homomorphisms that agree on ``X`` also agree on ``Sg X``. Let us now state and prove this in Lean.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (γ: Type w) (α: Type u) := (γ → α) → α
    structure signature := mk :: (ℱ: Type v) (ρ: ℱ  → Type u)
  
    section algebra
      parameter σ: signature
      def algebra_on (α: Type u) := Π f, op (σ.ρ f) α
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := ⟨_, sigma.fst⟩
      instance alg_operations : has_coe_to_fun algebra := ⟨_, sigma.snd⟩
    end algebra

    section subuniverse
      parameters {α: Type u} {γ: Type w} {σ: signature}
      definition F := σ.ℱ 
      definition ρ := σ.ρ 
      def Sub {𝔸: algebra σ}(B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸.snd f a) ∈ B₀
      def is_subalgebra {𝔸: algebra σ}(B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸.snd f ↑b
      def Sg {𝔸: algebra σ}(X: set 𝔸): set 𝔸:= ⋂₀ {U | Sub U ∧ X ⊆ U}

      theorem Inter.intro {𝔸: algebra σ} {x: 𝔸} {s: γ → set 𝔸}: (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: γ → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: γ → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: σ.ℱ) (a: σ.ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        Inter.intro (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))

      lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= assume x (h: x ∈ X), 
      assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}), have h₂: Sub W ∧ X ⊆ W, from h₁, h₂.right h

      lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
      assume R (h₁: Sub R) (h₂: X ⊆ R), assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
      assume R (hc : Sub R ∧ X ⊆ R), have h₁: Sub R, from hc.left,
      have h₂: X ⊆ R, from hc.right, assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}: ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= assume x (h₁: x ∈ Sg X), assume (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), h₁ R (and.intro h₂ h₃)

      lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= assume f (a: σ.ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), assume W (h: Sub W ∧ X ⊆ W), have h₁: Sg X ⊆ W, from sInter_mem' W h,
      have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i), (h.left f a h')

      inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
      | var (x : 𝔸) : x ∈ X → Y x
      | app (f : σ.ℱ) (a : σ.ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸.snd f a)

      lemma Y_is_Sub {𝔸: algebra σ}(X: set 𝔸): Sub (Y X):= assume f a (h: ∀ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
      have h₀: X ⊆ Y X, from assume x (h: x ∈ X), Y.var x h,
      have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
      have inc_r: Y X ⊆ Sg X, from
        assume a (h: a ∈ Y X), have h₂: a ∈ Y X → a ∈ Sg X, from
        Y.rec
          (assume x (hr₁: x ∈ X), show x ∈ Sg X, from subset_X_of_SgX X hr₁)
          (assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X), show 𝔸.snd f b ∈ Sg X, from SgX_is_Sub X f b hr₃ ),
          h₂ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {𝔸: algebra σ} (U X: set 𝔸): Sub U → X ⊆ U → Y X ⊆ U:= assume (h₁: Sub U) (h₂ : X ⊆ U), assume (y: 𝔸)  (p: Y X y), have q: Y X y → Y X y → U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), h₂ h )
          ( assume f a (h₃: ∀ i, Y X (a i)) (h₄: ∀ i, Y X (a i) → U (a i)) (h₅: Y X (𝔸.snd f a)), have h₆: ∀ i, a i ∈ U, from
            assume i, h₄ i (h₃ i), h₁ f a h₆ ), q p p
    end subuniverse

    section homomorphism
      parameters {α: Type u} {γ: Type v}
      def homomorphic {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸 → 𝔹) := ∀ f a, h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
      def homomorphic_verbose {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸.fst → 𝔹.fst) := ∀ (f: σ.ℱ) (a : σ.ρ f → 𝔸.fst), h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
    end homomorphism

    def ker {α β: Type u} (f: α → β): α → α → Prop := λ a b, f a = f b

    section basic_facts
      parameter {σ: signature}
      def E {α β: Type u} (f g: α → β): set α := λ (x: α), f x = g x 
      def hom {𝔸 𝔹: algebra σ} (g: 𝔸 → 𝔹): Prop := ∀ f a, g (𝔸 f a) = 𝔹 f (g ∘ a)
      def E_homs {𝔸 𝔹: algebra σ} (g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h): set 𝔸 :=  λ (a: 𝔸), g a = h a 

      lemma hom_comp_of_hom {𝔸 𝔹 ℂ: algebra σ} (g: 𝔸 → 𝔹) (h₁: hom g) (h: 𝔹 → ℂ) (h₂: hom h): hom (h ∘ g) :=
      assume f a, show (h ∘ g)(𝔸 f a) = ℂ f (h ∘ g ∘ a), from 
        have h₃: (h ∘ g)(𝔸 f a) = h (g (𝔸 f a)), from  rfl,
        calc
          (h ∘ g)(𝔸 f a) = h ((𝔹 f) (g ∘ a)) : (h₁ f a) ▸ h₃ 
                     ... = (ℂ f) (h ∘ g ∘ a)  : h₂ f (g ∘ a)

      lemma Sub_E_homs {𝔸 𝔹: algebra σ}(g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h): Sub (E_homs g h hg hh) := 
      assume f a (h₁: ∀ x, a x ∈ (E_homs g h hg hh)),
      show 𝔸 f a ∈ (E_homs g h hg hh),  from 
        have h₂: g ∘ a = h ∘ a, from funext h₁, 
        show g (𝔸 f a) = h (𝔸 f a), from 
          calc
            g (𝔸 f a) = 𝔹 f (g ∘ a) : hg f a
                  ... = 𝔹 f (h ∘ a) : congr_arg (𝔹 f) h₂
                  ... = h (𝔸 f a)   : eq.symm (hh f a)

    -- BEGIN
    -- 2. If X ⊆ 𝔸, g and h are homs, and X ⊆ E g h,
    --    then Sg X ⊆ X.
    lemma hom_determined_on_gens {𝔸 𝔹: algebra σ}
    (g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h) (X: set 𝔸) : 
    X ⊆ E g h → Sg X ⊆ E g h := 
    -- Idea of the proof: we have
    --     1. X ⊆ E h g,
    --     2. Sub (E h g), i.e., E h g is a subalgebra
    --     3. and Sg X is the smallest subalgebra containing X
    -- Therefore, Sg X ⊆ E h g, which means h = g on Sg X.
    assume h₁: X ⊆ E g h, show Sg X ⊆ E g h, from 
      have h₃: Sub (E g h), from 
        (Sub_E_homs g h hg hh),
      sInter_mem (E g h) h₃ h₁
    -- END
    end basic_facts
  end ualib
  
Alternatively, we could have proved the last fact using the inductive nature of the definition of subalgebra generated by a set.

Indeed, recall the definition of ``Y`` above and the proof that ``Y X`` is equal to ``Sg X``; thus, properties of the subuniverse generated by the set ``X`` can be proved using the recursor of ``Y``.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (γ: Type w) (α: Type u) := (γ → α) → α
    structure signature := mk :: (ℱ: Type v) (ρ: ℱ  → Type u)
  
    section algebra
      parameter σ: signature
      def algebra_on (α: Type u) := Π f, op (σ.ρ f) α
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := ⟨_, sigma.fst⟩
      instance alg_operations : has_coe_to_fun algebra := ⟨_, sigma.snd⟩
    end algebra

    section subuniverse
      parameters {α: Type u} {γ: Type w} {σ: signature}
      definition F := σ.ℱ 
      definition ρ := σ.ρ 
      def Sub {𝔸: algebra σ}(B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸.snd f a) ∈ B₀
      def is_subalgebra {𝔸: algebra σ}(B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸.snd f ↑b
      def Sg {𝔸: algebra σ}(X: set 𝔸): set 𝔸:= ⋂₀ {U | Sub U ∧ X ⊆ U}

      theorem Inter.intro {𝔸: algebra σ} {x: 𝔸} {s: γ → set 𝔸}: (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: γ → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: γ → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: σ.ℱ) (a: σ.ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        Inter.intro (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))

      lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:= assume x (h: x ∈ X), 
      assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}), have h₂: Sub W ∧ X ⊆ W, from h₁, h₂.right h

      lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
      assume R (h₁: Sub R) (h₂: X ⊆ R), assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}: ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
      assume R (hc : Sub R ∧ X ⊆ R), have h₁: Sub R, from hc.left,
      have h₂: X ⊆ R, from hc.right, assume x (h: x ∈ Sg X), h R (and.intro h₁ h₂)

      lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}: ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= assume x (h₁: x ∈ Sg X), assume (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), h₁ R (and.intro h₂ h₃)

      lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):= assume f (a: σ.ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), assume W (h: Sub W ∧ X ⊆ W), have h₁: Sg X ⊆ W, from sInter_mem' W h,
      have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i), (h.left f a h')

      inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
      | var (x : 𝔸) : x ∈ X → Y x
      | app (f : σ.ℱ) (a : σ.ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸.snd f a)

      lemma Y_is_Sub {𝔸: algebra σ}(X: set 𝔸): Sub (Y X):= assume f a (h: ∀ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
      have h₀: X ⊆ Y X, from assume x (h: x ∈ X), Y.var x h,
      have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
      have inc_r: Y X ⊆ Sg X, from
        assume a (h: a ∈ Y X), have h₂: a ∈ Y X → a ∈ Sg X, from
        Y.rec
          (assume x (hr₁: x ∈ X), show x ∈ Sg X, from subset_X_of_SgX X hr₁)
          (assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X), show 𝔸.snd f b ∈ Sg X, from SgX_is_Sub X f b hr₃ ),
          h₂ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {𝔸: algebra σ} (U X: set 𝔸): Sub U → X ⊆ U → Y X ⊆ U:= assume (h₁: Sub U) (h₂ : X ⊆ U), assume (y: 𝔸)  (p: Y X y), have q: Y X y → Y X y → U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), h₂ h )
          ( assume f a (h₃: ∀ i, Y X (a i)) (h₄: ∀ i, Y X (a i) → U (a i)) (h₅: Y X (𝔸.snd f a)), have h₆: ∀ i, a i ∈ U, from
            assume i, h₄ i (h₃ i), h₁ f a h₆ ), q p p
    end subuniverse

    section homomorphism
      parameters {α: Type u} {γ: Type v}
      def homomorphic {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸 → 𝔹) := ∀ f a, h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
      def homomorphic_verbose {σ: signature} {𝔸 𝔹: algebra σ} (h: 𝔸.fst → 𝔹.fst) := ∀ (f: σ.ℱ) (a : σ.ρ f → 𝔸.fst), h (𝔸.snd f a) = 𝔹.snd f (h ∘ a)
    end homomorphism

    def ker {α β: Type u} (f: α → β): α → α → Prop := λ a b, f a = f b

    section basic_facts
      parameter {σ: signature}
      def E {α β: Type u} (f g: α → β): set α := λ (x: α), f x = g x 
      def hom {𝔸 𝔹: algebra σ} (g: 𝔸 → 𝔹): Prop := ∀ f a, g (𝔸 f a) = 𝔹 f (g ∘ a)
      def E_homs {𝔸 𝔹: algebra σ} (g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h): set 𝔸 :=  λ (a: 𝔸), g a = h a 

      lemma hom_comp_of_hom {𝔸 𝔹 ℂ: algebra σ} (g: 𝔸 → 𝔹) (h₁: hom g) (h: 𝔹 → ℂ) (h₂: hom h): hom (h ∘ g) :=
      assume f a, show (h ∘ g)(𝔸 f a) = ℂ f (h ∘ g ∘ a), from 
        have h₃: (h ∘ g)(𝔸 f a) = h (g (𝔸 f a)), from  rfl,
        calc
          (h ∘ g)(𝔸 f a) = h ((𝔹 f) (g ∘ a)) : (h₁ f a) ▸ h₃ 
                     ... = (ℂ f) (h ∘ g ∘ a)  : h₂ f (g ∘ a)

      lemma Sub_E_homs {𝔸 𝔹: algebra σ}(g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h): Sub (E_homs g h hg hh) := 
      assume f a (h₁: ∀ x, a x ∈ (E_homs g h hg hh)),
      show 𝔸 f a ∈ (E_homs g h hg hh),  from 
        have h₂: g ∘ a = h ∘ a, from funext h₁, 
        show g (𝔸 f a) = h (𝔸 f a), from 
          calc
            g (𝔸 f a) = 𝔹 f (g ∘ a) : hg f a
                  ... = 𝔹 f (h ∘ a) : congr_arg (𝔹 f) h₂
                  ... = h (𝔸 f a)   : eq.symm (hh f a)

      lemma hom_determined_on_gens {𝔸 𝔹: algebra σ}(g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h) (X: set 𝔸): X ⊆ E g h → Sg X ⊆ E g h :=
      assume h₁: X ⊆ E g h, show Sg X ⊆ E g h, from
        have h₃: Sub (E g h), from (Sub_E_homs g h hg hh),
        sInter_mem (E g h) h₃ h₁
    
    -- BEGIN
    -- 2. If X ⊆ 𝔸, g and h are homs, and X ⊆ E g h,
    --    then Sg X ⊆ X.
    lemma hom_determined_on_gens_rec {𝔸 𝔹: algebra σ}
    (g h: 𝔸 → 𝔹) (hg: hom g) (hh: hom h) (X: set 𝔸): 
    X ⊆ E g h → Sg X ⊆ E g h := 
    assume (h₀: X ⊆ E g h) (a: 𝔸) (h₁: a ∈ Sg X),
    show g a = h a, from
      have h₂: a ∈ Y X, from eq.subst (sg_inductive X) h₁,
      have h₃: ∀ x, x ∈ X → g x = h x, from
        assume x (h': x ∈ X), h₀ h',
      show g a = h a, from 
        Y.rec
          --base step: assume a ∈ X
          h₃
          --inductive step:
          -- assume a = 𝔸 f b for some b with ∀ i, b i ∈ Sg X
          (
            assume f b (h₄ : ∀ i, b i ∈ Y X),
            assume h₅ : ∀ i, g (b i) = h (b i),
            show g (𝔸 f b) = h (𝔸 f b), from 
              have h₆ : g ∘ b = h ∘ b, from funext h₅, 
              calc
                g (𝔸 f b) = (𝔹 f) (g ∘ b): hg f b
                      ... = (𝔹 f) (h ∘ b): congr_arg (𝔹 f) h₆    
                      ... = h (𝔸 f b)    : eq.symm (hh f b)
          ) h₂ 
    -- END
    end basic_facts
  end ualib

Before implementing :numref:`Obs %s <obs-four>` in Lean, we reiterate that we cannot do so constructively.  Here is a related passage from `Theorem Proving in Lean`_ that explains why.

  "The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces 'data' from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions as noncomputable to flag that fact... To summarize, then, on top of the underlying framework of universes, dependent function types, and inductive types, the standard library adds three additional components:

  #. the axiom of propositional extensionality
  #. a quotient construction, which implies function extensionality
  #. a choice principle, which produces data from an existential proposition.

  The first two of these block normalization within Lean, but are compatible with bytecode evaluation, whereas the third is not amenable to computational interpretation."
   
The upshot is that we cannot always use Lean's ``exists.elim`` to produce data.

.. todo:: insert Lean proof here

To see that :math:`k` is a homomorphism, assume there are :math:`m` operation symbols. Fix arbitrary :math:`0≤ i< m` and :math:`b: \underline{k_i} → B`.
   
Since :math:`g` is surjective, for each :math:`i: \underline{k_i}`, the subset :math:`g^{-1}\{b(i)\}⊆ A` is nonempty and is mapped by :math:`h` to a single point of :math:`C` (since :math:`\ker g ⊆ \ker h`.


-------------------------

.. rubric:: Footnotes

.. [1]
   As of this writing (9 June 2019), this documentation describes code residing on the william_ branch of the lean-ualib_ repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.
   
.. include:: hyperlink_references.rst
