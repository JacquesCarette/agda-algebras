.. highlight:: lean

.. include:: _static/math_macros.rst

.. _inductively-defined-types:

=========================
Inductively Defined Types
=========================

We briefly introduced inductively defined types in :numref:`inductive-types`.  Many more details can be found in the chapter on `Inductive Types`_ in :term:`TPIL`. 

The availability and utility of inductively defined types were among our primary original motivations for formalizing universal algebra in a language (like Lean) that supports such types. In the present chapter, we show how these types come into play in our formalization project.  

------------------------------

.. _the-recursor:

The Recursor
------------

Each inductively defined type, say ``foo``, is accompanied by an elimination principle known as a **recursor** (denoted by ``foo.rec`` in Lean). This elimination principle is what makes the type "inductive"; it allows us to define a function on ``foo`` by assigning values for each of ``foo``'s constructors.

.. todo:: complete this section; include an example.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: ! subalgebra, ! subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean:

Subalgebras in Lean
-------------------

The Lean code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of the lean-ualib_ repository. [1]_

In :numref:`Section %s <subuniverses-in-lean>`, we saw how :ref:`subalgebras <subalgebras>` can be implemented in Lean and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and implements the :ref:`subuniverse generation theorem <thm-1-14>`. 

First, we define an inductive type that represents the **subuniverse generated by a set**; cf. the informal language definition in given by :eq:`subalgebra-inductive` .

.. include:: _static/subuniverse.lean.2.rst

Next we prove that the type ``Y X`` is a subuniverse. Moreover, ``Y X`` is equal to :math:`\mathrm{Sg}^ùî∏(X)`, which is another fact that we formalize and prove below.

.. include:: _static/subuniverse.lean.3.rst

Finally, we prove that ``Y`` is the smallest subuniverse containing ``X``.

.. include:: _static/subuniverse.lean.4.rst

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A ‚äÜ B ‚Üí B ‚äÜ A ‚Üí A = B`.

.. index:: recursor

We proved ``Y X ‚äÜ Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined. (We will see many more examples of inductive proofs below.)

The Lean keyword ``assume`` is syntactic sugar for ``Œª``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: variables, word, term, free algebra
.. index:: universal for; œÉ-algebras
.. index:: absolutely free for; œÉ-algebras

.. _terms-in-lean:

Terms in Lean
-------------

The Lean code described in this section is in the source files ``free.lean`` and ``term.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`T(X)` of all terms of a given signature over a collection :math:`X` of variables.

.. include:: _static/free.lean.1.rst

The collection of terms over :math:`X`, along with the operations :math:`F^{ùïã(X)} := \{\mathsf{app} f ‚à£ f : F\}` forms an algebra in the signature :math:`œÉ = (F, œÅ)`, which we denote and define by :math:`ùïã(X) = ‚ü®T(X), F^{ùïã(X)}‚ü©` .

Now, suppose :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` is an algebra in the signature œÉ and :math:`h : X ‚Üí A` is an arbitrary function.  We will show that :math:`h : X ‚Üí A` has a unique *extension* (or *lift*) to a homomorphism from :math:`ùïã(X)` to ùî∏.

Since ùî∏ and :math:`h : X ‚Üí A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`ùïã(X)` is **universal for** œÉ-algebras. Some authors say, ":math:`ùïã(X)` is **absolutely free for** œÉ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. include:: _static/free.lean.2.rst

If :math:`h : X ‚Üí A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`ùïã(X)` is defined inductively as follows:

.. include:: _static/free.lean.3.rst

To prove that the term algebra is universal for œÉ-algebras, we show that the lift of an arbitrary function :math:`h : X ‚Üí A` is a homomorphism and that this lift is unique.

.. include:: _static/free.lean.4.rst

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

In this section we see how the clone concept, described above in :numref:`clones`, can be implemented in Lean.  We then formalize the proof of :numref:`Obs %s <obs-five>` which asserts that we can define *clone* inductively and that the inductive definition is equivalent to our initial definition.

(The Lean code described in this section is in the source file ``clone.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_ Also, although we don't make it explicit below, all of the code in the first part of this section is surrounded by the lines

.. code::

    namespace clone
      section clo 
        ... 
      end clo
    end clone

That is, the code belongs where the ellipses appear in the above block.)

First, we define a structure that specifies the properties that a clone must have.  As defined in :numref:`clones`, in order to be a clone a collection must include all projections and be closed under general composition.

.. include:: _static/clone.lean.1.rst

Next we define an inductive type that represents the clone generated by a given collection ``X`` of operations.

.. include:: _static/clone.lean.2.rst

Finally, we check that the foregoing definition is indeed a clone and that it is the smallest clone containing the given collection of operations.

.. include:: _static/clone.lean.3.rst

---------------------------

.. _basic-facts-in-lean:

Basic Facts in Lean
--------------------

In this section we show how to state and prove in Lean the basic facts of :numref:`basic-facts`.

.. index:: ! equalizer

Recall, the **equalizer** of the functions :math:`g` and :math:`h` is the set

.. math:: ùñ§(g,h) = \{ a : A ‚à£ g(a) = h(a) \}.

We begin by defining in Lean

#. the equalizer of two functions, ``E``,

#. a homomorphism, ``hom``, and 

#. the equalizer of two homomorphisms, ``E_hom``.

.. include:: _static/subuniverse.lean.1.rst

Composition of homomorphisms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall the simple fact that composing two homomorphisms results in a homomorphism.

.. include:: _static/homs.lean.1.rst

(As with the other numbered results appearing in this section, we include the statement and proof of the above fact inside the ``basic_facts`` section.)

Equalizer as subuniverse
~~~~~~~~~~~~~~~~~~~~~~~~

Next we formally prove that the equalizer ``ùñ§ g h`` of two homomorphisms ``g`` and ``h`` is a subuniverse of ùî∏ (cf. :numref:`Obs %s <obs-one>`).

.. include:: _static/homs.lean.2.rst

Homomorphisms that agree on a generating set
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall (:numref:`Obs %s <obs-two>`) if two homomorphisms agree on a generating set, then they are equal.

More precisely, if a subset ``X`` is contained in the equalizer of two homomorphisms, then ``Sg X`` is also contained in the equalizer; thus, homomorphisms that agree on ``X`` also agree on ``Sg X``. Let us now state and prove this in Lean.

.. include:: _static/homs.lean.3.rst

Alternatively, we could have proved the last fact using the inductive nature of the definition of subalgebra generated by a set.

Indeed, recall the definition of ``Y`` above and the proof that ``Y X`` is equal to ``Sg X``; thus, properties of the subuniverse generated by the set ``X`` can be proved using the recursor of ``Y``.

.. include:: _static/homs.lean.4.rst

Factoring homomorphisms
~~~~~~~~~~~~~~~~~~~~~~~

Before implementing in Lean the result on factoring homomorphisms (:numref:`Obs %s <obs-four>`), we reiterate that we cannot do so constructively.  Here is a related passage from `Theorem Proving in Lean`_ that explains why.

  "The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces 'data' from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions ``noncomputable`` to flag that fact... To summarize, then, on top of the underlying framework of universes, dependent function types, and inductive types, the standard library adds three additional components:

  #. the axiom of propositional extensionality
  #. a quotient construction, which implies function extensionality
  #. a choice principle, which produces data from an existential proposition.

  The first two of these block normalization within Lean, but are compatible with :term:`byte-code` evaluation, whereas the third is not amenable to computational interpretation."
   
The upshot is that we cannot always use Lean's ``exists.elim`` to produce data.

Nonetheless, we can use Lean's ``classical`` library and the ``noncomputable`` keyword to formalize proofs of nonconstructive results, like :numref:`Obs %s <obs-four>` on factoring homomorphisms.

.. index:: pair: epic; surjective
.. index:: pair: monic; injective
.. index:: bijective

First we define what it means for a function to be **epic** (or **surjective**), **monic** (or **injective**), and **bijective** (i.e., both epic and monic).

.. include:: _static/homs.lean.5.rst

.. index:: inverse, right inverse

Next, we define the (``noncomputable``) **inverse** and **right inverse** and then prove that an epic function has a right inverse.

(The following is also placed inside the ``basic_facts`` section, inside the ``ualib`` namespace.)

.. include:: _static/homs.lean.6.rst

Finally, we are ready to prove the homomorphism factorization lemma of :numref:`Obs %s <obs-four>`.

(Again, this belongs inside the ``basic_facts`` section.)

.. include:: _static/homs.lean.7.rst

-------------------------

.. rubric:: Footnotes

.. [1]
   As of this writing (9 June 2019), this documentation describes code residing on the william_ branch of the lean-ualib_ repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.
   
.. include:: hyperlink_references.rst
