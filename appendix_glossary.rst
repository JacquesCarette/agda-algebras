.. File: appendix_glossary.rst
.. Author: William DeMeo <williamdemeo@gmail.com>
.. Date: 11 Oct 2019
.. Updated: 30 Oct 2019
.. Updated: 27 Oct 2019
.. Copyright (c) 2019 William DeMeo (see the LICENSE file)

.. include:: _static/math_macros.rst

.. role:: code

.. highlight:: lean

.. _appendix-glossary:

Glossary
--------

.. _acronyms:

Acronyms
~~~~~~~~~

.. glossary::

    ATP
      | *n.* automated theorem prover
      | *v.* automated theorem proving

    CiC
      :term:`Calculus of Inductive Constructions`

    cod
      codomain

    dcpo
      :term:`directed-cocomplete poset`

    dom
      domain
    
    ETT
      :term:`extensional` :term:`intuitionistic type theory <TT>`.

    em
      :term:`law of the excluded middle`

    ER
      equality reflection

    ITP
      | *n.* interactive theorem prover (or proof assistant), e.g., :term:`Agda`, :term:`Coq`, :term:`Lean`, and :term:`NuPrl`
      | *v.* interactive theorem proving

    ITT
      :term:`intensional` :term:`intuitionistic type theory <TT>`.

    LSTL
      `Lean Standard Library`_
      
    ω-cpo
      :term:`ω-chain cocomplete poset`

    ran
      range

    TPIL
      the `Theorem Proving in Lean`_ tutorial

    TT
      (intuitionistic) :term:`type theory`

    UIP
      `Uniqueness of Identity Proofs <https://ncatlab.org/nlab/show/axiom+UIP>`_


.. _definitions:

Definitions
~~~~~~~~~~~~

.. glossary::

    abelian group
      A :term:`group` is called **abelian** just in case its binary operation is commutative; in that case we usually let :math:`0` (instead of :math:`e`) denote the *additive identity*, we let :math:`-` (instead of :math:`^{-1}`) denote the *additive inverse*, and we let :math:`+` (instead of :math:`⋅`) denote *binary addition*. Thus, an **abelian group** is a group :math:`⟨A, 0, -, +⟩` such that :math:`a+b = b+a` for all :math:`a, b ∈ A`.

    absolutely continuous measure
      Let :math:`μ` be a :term:`positive measure` on a :term:`σ-algebra` :math:`𝔐`, and let :math:`λ` be an arbitrary :term:`complex measure` on :math:`𝔐`. [1]_ 

      If :math:`∀ E ∈ 𝔐`, :math:`μ E = 0 \; ⟹ \; λ E = 0`, then we call :math:`λ` **absolutely continuous** with respect to :math:`μ`, and we write :math:`λ ≪ μ`.

    absolutely continuous function
      A real- or complex-valued function :math:`F` on :math:`ℝ` is called **absolutely continuous** on the interval :math:`[a,b] ⊆ ℝ`, denoted :math:`F ∈ AC[a,b]`, if for every :math:`ε > 0` there exists :math:`δ > 0` such that for each finite set :math:`\{(a_1, b_1), \dots, (a_N, b_N)\}` of disjoint intervals in :math:`[a,b]`, we have 

      .. math:: ∑_{i=1}^N (b_i-a_i) < δ \quad ⟹ \quad ∑_{i=1}^N |F(b_i)-F(a_i)| < ε.

    abstract category
      An **abstract category** is one whose objects are not sets or whose morphisms are not functions defined on sets. Our next example is somewhere in between. The objects are sets, but the morphisms are not necessarily *total* functions; that is, they may be defined on only a part of the source object.

    Agda
      An :term:`intensional`, :term:`predicative` :term:`ITP` supporting :term:`dependent types <dependent type>` and based on Martin Lof type theory; url: https://wiki.portal.chalmers.se/agda/pmwiki.php

    algebraic lattice
      a :term:`lattice` generated by its :term:`compact elements <compact element>`. 

    accumulation point
      See :term:`limit point`.
 
    additive
      Let :math:`𝔐 = \{M_λ: λ∈ Λ\}` be a collection of sets and let :math:`R` be a :term:`ring`.  An :math:`R`-valued function :math:`s: 𝔐 → R` defined on the collection :math:`𝔐` is called **additive** if for every subset :math:`Γ ⊆ Λ` such that :math:`\{M_γ : γ ∈ Γ\}` is a subcollection of *pairwise disjoint* subsets in :math:`𝔐`, we have

      .. math:: s \bigl( ⋃_{γ∈Γ}  M_γ \bigr) = ∑_{γ∈ Γ} s (M_γ).
      
    adjoint
      Suppose that :math:`X` and :math:`Y` are :term:`normed linear spaces <normed linear space>` and :math:`T ∈ 𝔅(X, Y)` (a :term:`bounded linear transformation`). The **adjoint** (or **transpose**) of :math:`T` is denoted by :math:`T^†: Y^∗ → X^∗` and defined for each :math:`f∈ Y^∗` by :math:`T^† f = f T`.
      
      It is not hard to show that :math:`T^† ∈ 𝔅(Y^∗, X^∗)` and :math:`\|T^†\| = \|T\|`.

    algebra
      See :term:`algebraic structure`.

    algebra of functions
      Let :math:`F` be a field and let :math:`F^X` denote the collection of all functions from :math:`X` to :math:`F`.  A subset :math:`𝔄 ⊆ F^X` of :math:`F`-valued functions on :math:`X` is called an **algebra** if it is closed under point-wise product.  That is, for all :math:`f, g ∈ 𝔄`, the function :math:`h = f ⋅ g` defined by :math:`h: x ↦ f(x) ⋅ g(x)` also belongs to :math:`𝔄`.

    algebra of sets
      Let :math:`X` be a nonempty set. An **algebra of sets** on :math:`X` is a nonempty collection :math:`𝔄` of subsets of :math:`X` that is closed under finite unions and complements. (Some authors call this a "field of sets.")

    algebraic structure
      An **algebraic structure** in the :term:`signature` :math:`σ = (F, ρ)` (or, :math:`σ`-**algebra**) is denoted by :math:`𝔸 = ⟨A, F^𝔸⟩` and consists of 

      #. :math:`A` := a set, called the *carrier* (or *universe*) of the algebra,
      #. :math:`F^𝔸 = \{ f^𝔸 ∣ f ∈ F, \ f^𝔸: (ρ f → A) → A \}` := a set of operations on :math:`A`, and
      #. a collection of identities satisfied by elements of :math:`A` and operations in :math:`F^𝔸`.

    antichain
      A subset :math:`A` of the preordered set :math:`X` is called an **antichain** if for all :math:`x, y ∈ A` we have :math:`x ≤ y` implies :math:`y ≤ x`.

    antisymmetric
      A binary relation :math:`R` on a set :math:`X` is called **antisymmetric** provided :math:`∀  x, y ∈ X \ (x \mathrel{R} y ∧ y\mathrel{R} x \ → \ x=y)`.

    arity
      Given a :term:`signature` :math:`σ = (F, ρ)`, each operation symbol :math:`f ∈ F` is assigned a value :math:`ρ f`, called the **arity** of :math:`f`. (Intuitively, the arity can be thought of as the "number of arguments" that :math:`f` takes as "input".)

    associative algebra
      If :math:`𝔸` is a :term:`bilinear algebra` with an associative product---:math:`(a ⋅ b) ⋅ c = a ⋅ (b ⋅ c)` for all :math:`a, b, c ∈ A`---then :math:`𝔸` is called an **associative algebra**.
      
      Thus an associative algebra over a field has both a :term:`vector space` :term:`reduct` and a :term:`ring` :term:`reduct`.
      
      An example of an associative algebra is the space of :term:`linear transformations <linear transformation>` (:term:`endomorphisms <endomorphism>`) of a vector space into itself.

    Baire category theorem
      No nonempty :term:`complete metric space` is of the :term:`first category`.

    Banach space
      A **Banach space** is a :term:`normed linear space` :math:`(X, \|\,⋅\,\|)` such that :math:`X` is :term:`complete <complete set>` in the metric defined by its norm. (That is, each Cauchy sequence in :math:`(X, \|\,⋅\,\|)` converges to a point in :math:`X`.)

    base
      Let :math:`(X, τ)` be a :term:`topological space` and let :math:`x ∈ X`. A collection :math:`ℬ_x` of :term:`neighborhoods <neighborhood>` of :math:`x` is called a **base for** :math:`τ` **at** :math:`x` provided for every neighborhood :math:`V` of :math:`x`, there exists :math:`B ∈ ℬ_x` such that :math:`B ⊆ V`. A collection :math:`ℬ` of open sets is called a **base for** :math:`τ` provided it contains a base for :math:`τ` at every point of :math:`X`.

    bilinear algebra
      Let :math:`𝔽= ⟨ F, 0, 1, -\, , +, ⋅⟩` be a field. An algebra :math:`𝔸 = ⟨ A, 0, -\, , +, ⋅, f_r⟩_{r∈ F}` is a **bilinear algebra** over :math:`𝔽` provided :math:`⟨A, 0, -, +, ⋅, f_r⟩_{r ∈ F}` is a :term:`vector space` over :math:`𝔽` and for all :math:`a, b, c ∈ A` and all :math:`r ∈ F`, we have

      .. math::   (a + b) ⋅ c &= (a ⋅ c) + (b ⋅ c)\\
                  c ⋅ (a + b) &= (c⋅ a) + (c⋅ b)\\
                   a⋅  f_r(b) &= f_r(a⋅ b) = f_r(a)⋅ b.

      If, in addition, :math:`(a ⋅ b) ⋅ c = a ⋅ (b ⋅ c)` for all :math:`a, b, c ∈ A`, then :math:`𝔸` is called an **associative algebra over** :math:`𝔽`. Thus an associative algebra over a field has both a vector space reduct and a ring reduct. An example of an associative algebra is the space of linear transformations (endomorphisms) of any vector space into itself.

    binary operation
      An operation :math:`f` on a set :math:`A` is called **binary** if the arity of :math:`f` is 2.  That is, :math:`f: A × A → A` (or, in curried form, :math:`f: A → A → A`).

    Borel function
      See :term:`Borel measurable function`.

    Borel measurable function
      If :math:`ℬ(X)` and :math:`ℬ(Y)` are :term:`Borel σ-algebras <Borel σ-algebra>` of :math:`X` and :math:`Y`, respectively, then a :math:`(ℬ(X), ℬ(Y))`-:term:`measurable function` is called a **Borel measurable function** (or just **Borel function**). Equivalently, :math:`f` is a Borel function iff :math:`f^{-1}(B) ∈ ℬ(X)` for every :math:`B∈ ℬ(Y)`.

    Boolean algebra homomorphism
      a :term:`lattice homomorphism` that also preserves complementation (but every lattice homomorphism between Boolean lattices automatically preserves complementation, so we may characterize the morphisms of this category more simply as the lattice homomorphisms).

      We call a function :math:`φ: ℝ^n → ℝ` **Borel measurable** (or a **Borel function** or just **Borel**) if it is :math:`(ℬ(ℝ) ⊗ \cdots ⊗ ℬ(ℝ))`-measurable, where the :math:`⊗`-:term:`product <product σ-algebra>` has :math:`n` factors.

    Borel measure
      A **Borel measure** is a :term:`measure` whose domain is a :term:`Borel σ-algebra`.

    Borel set
      The members of a :term:`Borel σ-algebra` are called **Borel sets**; included among them are the :term:`open sets <open set>`, :term:`closed sets <closed set>`, countable intersections of open sets, countable unions of closed sets, and so forth.

    Borel σ-algebra
      If :math:`X` is a :term:`metric <metric space>` or :term:`topological space`, then the :term:`σ-algebra` generated by the family of open sets in :math:`X` is called the **Borel σ-algebra** on :math:`X`, which we denote by :math:`ℬ(X)`.
      
    bounded linear functional
      Let :math:`X` be a :term:`normed linear space` over the :term:`field` :math:`F`.  A **bounded linear functional** on :math:`X` is a :term:`bounded linear transformation` with codomain :math:`F`.
      
      We denote by :math:`𝔅(X,F)` the collection of all bounded linear functionals on :math:`X`.

    bounded linear transformation
      Let :math:`X` and :math:`Y` be two :term:`normed linear spaces <normed linear space>`. A :term:`linear transformation` :math:`T: X → Y` is called **bounded** if there exists :math:`C > 0` such that

      .. math:: \|Tx\| ≤ C \|x\| \; \text{ for all } x ∈ X.
    
      We denote the space of all bounded linear transformations from :math:`X` to :math:`Y` by :math:`𝔅(X,Y)`.
      
    bounded set
      A set :math:`E` in a metric space is called **bounded** if it has finite diameter, :math:`\mathrm{diam} E < ∞`.

    bounded variation
      For :math:`f: [a, b] → ℝ` define

      .. math:: F(x) = \sup ∑_{i=1}^N |f(t_i)- f(t_{i-1})| \quad (a ≤ x ≤ b),

      where the supremum is taken over all :math:`N` and over all choices of :math:`\{t_i\}` such that :math:`a = t_0 < t_1 < \cdots < t_N = x`. If :math:`F(b)< ∞`, then we say :math:`f` is of **bounded variation** on :math:`[a,b]` and we write :math:`f∈ BV[a,b]`.

      If in addition :math:`f` is :term:`absolutely continuous <absolutely continuous function>` on :math:`[a,b]`, then the functions :math:`F`, :math:`F+ f`, and :math:`F - f` are nondecreasing and absolutely continuous on :math:`[a,b]`. (See :cite:`Rudin:1987` 7.19.) 

    Calculus of Inductive Constructions
      See https://en.wikipedia.org/wiki/Calculus_of_constructions.

    Cartesian product
      See :term:`product`.

    Cauchy sequence
      A sequence :math:`\{x_n\}` in a metric space :math:`(X, d)` is called a **Cauchy sequence** if for all :math:`\epsilon >0` there exists :math:`N>0` such that :math:`d(x_m, x_n) < \epsilon` for all :math:`n, m \geq N`.

    canonical normal form
      See the `ncatlab page on normal forms <https://ncatlab.org/nlab/show/normal+form>`_.

    category of categories
      has categories as objects and functors as morphisms.

    category of small categories
      See :term:`Cat`.

    Choice
      is short for the `Axiom of Choice <https://en.wikipedia.org/wiki/Axiom_of_choice>`_.

    characteristic function
      The characteristic function :math:`χ_A` of a subset :math:`A ⊆ X` is the function :math:`χ_A: X → \{0,1\}` that is 1 if and only if :math:`x ∈ A`; that is, :math:`χ_A(x) = 0` if :math:`x ∉ A` and :math:`χ_A(x) = 1` if :math:`x ∈ A`.

    chain
      Let :math:`⟨ X, ≤ ⟩` be a :term:`preordered <preorder>` set and :math:`C ⊆ X`. We call :math:`C` a **chain** of :math:`⟨ X, ≤ ⟩` if for all :math:`x, y ∈ C` either :math:`x ≤ y` or :math:`y ≤ x` holds.

    clone
      An **operational clone** (or just **clone**) on a nonempty set :math:`A` is a set of operations on :math:`A` that contains all :term:`projection operations <projection operation>` and is closed under :term:`general composition`.

    closed
      If :math:`𝖢` is a :term:`closure operator` on :math:`X`, then a subset :math:`A ⊆ X` is called **closed** with respect to :math:`𝖢` (or :math:`𝖢`-**closed**) provided :math:`𝖢(A) ⊆ A` (equivalently, :math:`𝖢(A) = A`).

      Here's an important example. Let :math:`σ = (F, ρ)` be a :term:`signature` and :math:`X` a set. Define for each :math:`A ⊆ X` the set :math:`𝖢(A) = \{f\, b ∣ f ∈ F, \, b: ρ f → A\}`.  Then :math:`𝖢` is a closure operator on :math:`X` and a subset :math:`A ⊆ X` is said to be "closed under the operations in :math:`F`" provided :math:`A` is :math:`𝖢`-closed.

    closed ball
      Let :math:`(X, d)` be a :term:`metric space`. If :math:`x ∈ X` and :math:`r > 0` are fixed, then the set denoted and defined by :math:`B̄ (x; r) = \{y ∈ X ∣ d(x,y) ≤ r\}` is called the **closed ball** with center :math:`x` and radius :math:`r`.

    closed set
      A subset of a :term:`metric <metric space>` or :term:`topological space` is **closed** if its complement is :term:`open <open set>`. (Hence the empty set and the whole universe are closed, finite unions of closed sets are closed, and arbitrary intersections of closed sets are closed.)

    closure
       If :math:`X` is a :term:`metric <metric space>` or :term:`topological space` then the **closure** of a subset :math:`E ⊆ X` is denoted by :math:`Ē` and defined to be the smallest :math:`closed` subset of :math:`X` containing :math:`E`.
       
       The closure :math:`Ē` exists since the collection :math:`Ω` of all closed subsets of :math:`X` which contain :math:`E` is not empty (since :math:`X ∈ Ω`), so define :math:`Ē` to be the intersection of all members of :math:`Ω`.

       Here is an alternative, equivalent definition. The **closure** of :math:`E` is the intersection of all :term:`closed` sets containing :math:`E`.

    closure operator
      Let :math:`X` be a set and let :math:`𝒫(X)` denote the collection of all subsets of :math:`X`. A **closure operator** on :math:`X` is a set function :math:`𝖢: 𝒫 (X) → 𝒫 (X)` satisfying the following conditions, for all :math:`A, B ∈ 𝒫 (X)`, 

      #. :math:`A ⊆ 𝖢(A)`,
      #. :math:`𝖢 ∘ 𝖢 = 𝖢`,
      #. :math:`A ⊆ B ⟹ 𝖢(A) ⊆ 𝖢(B)`.

    cocomplete
      See :term:`cocomplete poset`.

    cocomplete poset
      A :term:`poset` in which all joins exist is called **cocomplete**.

    codomain
      If :math:`f : A → B` is a function or relation from :math:`A` to :math:`B`, then :math:`B` is called the **codomain** of :math:`f`, denoted by 
      :math:`\cod f`.

    cofinite topology
      If :math:`X` is an infinite set, then :math:`\{V ∈ X ∣ V = ∅ \text{ or } V^c \text{ is finite}\}` is a topology on :math:`X`, called the **cofinite topology**.

    commutative diagram
      A **commutative diagram** is a diagram with the following property: for all objects :math:`C` and :math:`D`, all paths from :math:`C` to :math:`D` yield the same :term:`morphism`.

    commutative group
      See :term:`abelian group`.

    compact element
      an element :math:`x` of a lattice :math:`L` is called **compact** provided for all :math:`Y ⊆ L`, if :math:`x ≤ ⋁ Y`, then there exists a finite subset :math:`F ⊆ Y` such that :math:`x ≤ ⋁ F`.

    compact set
      If :math:`(X,d)` is a :term:`metric space`, then a subset :math:`E ⊆ X` is compact iff every open :term:`covering` reduces to a finite subcover.

      If :math:`(X,τ)` is a :term:`topological space` then a set :math:`A ⊆ X` is called **compact** if every open :term:`covering` :math:`\{V_i ∣ i ∈ I\} ⊆ τ` of :math:`A` has a finite subcover. That is, 

      .. math:: A ⊆ ⋃_{i∈ I} V_i \quad \text{ implies } \quad A ⊆ ⋃_{j=1}^n V_{i_j}

      for some finite subcollection :math:`\{V_{i_j} ∣ j = 1, \dots, n\} ⊆ \{V_i ∣ i∈ I\}`.

    complete
      A poset in which all meets exist is called **complete**.

    complete lattice
      a :term:`poset` whose universe is closed under arbitrary meets and joins.

    complete lattice homomorphism
      A **complete lattice homomorphism** is a function :math:`f: X → Y` that preserves complete meets and joins.

    complete measure
      A :term:`measure` :math:`μ` on a :term:`measurable space` :math:`(X, 𝔐)` is called **complete** if all subsets of sets of measure 0 are :term:`measurable <measurable set>` (and have measure 0). [2]_

    complete measure space
      If :math:`μ` is a :term:`complete measure` on the :term:`measurable space` :math:`(X, 𝔐)`, then :math:`(X, 𝔐, μ)` is called a **complete measure space**.

    complete metric space
      A :term:`metric space` :math:`(X, d)` is called **complete** if :math:`X` is :term:`complete <complete set>`; that is, each :term:`Cauchy sequence` in :math:`X` converges to a point of :math:`X`.

    complete poset
      A :term:`poset` in which all meets exist is called **complete**.

    complete set
      A subset :math:`C` of a (metric or topological) space :math:`X` is called **complete** if every :term:`Cauchy sequence` in :math:`C` converges to a point in :math:`C`.

    complex measure
      A **complex measure** on a :term:`measurable space` :math:`(X, 𝔐)` is a map :math:`ν: 𝔐 → ℂ` such that :math:`ν ∅ = 0`, and :math:`ν` is :term:`countably additive` over :math:`𝔐`, which means that
      
      .. math:: ν(⋃_j A_j) = ∑_j ν(A_j)
         :label: count-add
          
      whenever :math:`\{A_j\}` is a collection of disjoint sets in :math:`𝔐`.
      
      Moreover, the sum on the right-hand side of :eq:`count-add` converges absolutely.

      Notice, we do not allow a complex measure to take on infinite values. Thus, a :term:`positive measure` is a complex measure only if it is :term:`finite <finite measure>`.
      
    component    
      If :math:`α : F ⇒ G` is a :term:`natural transformation`, then the **component** of α at :math:`A` is the :term:`morphism` :math:`α_A : FA → GA`.

    composition of operations
      If :math:`f: (n → A) → A` is an :math:`n`-ary operation on the set :math:`A`, and if :math:`g: ∏_{(i:n)} ((k_i → A) → A)` is an :math:`n`-tuple of operations, then we define the **composition of** :math:`f` **with** :math:`g`, using the :term:`eval` and :term:`fork` operations, as follows:
   
      .. math:: f [g] := f\, (\mathbf{eval} \, \mathbf{fork}\, g): ∏_{(i:n)}(k_i → A) → A.
   
      Indeed, 
      
      .. math:: \mathbf{eval} \, \mathbf{fork} \, g: ∏_{(i:n)}(k_i → A) → (n → A)
      
      is the function that maps each :math:`a: ∏_{(i:n)}(k_i → A)` to :math:`∏_{(i:n)}\mathbf{eval} \,(g \, i, a\, i) = g ∘ a`, where for each :math:`(i:n)` :math:`(g ∘ a)(i) = (g i)(a i): A`.
      
      Thus, if :math:`a: ∏_{(i:n)}(k_i → A)`, then :math:`(\mathbf{eval} \, \mathbf{fork} \, g) (a)` has type :math:`n → A`, which is the domain type of :math:`f`.  Therefore, :math:`f \, (\mathbf{eval} \, \mathbf{fork}\, g)\, (a)` has type :math:`A`.

      For a slightly more general description of composition, see :numref:`greater-generality`.

    computable
      See https://pdfs.semanticscholar.org/1364/d8e8763891b84a9383b722d82294ae0a736b.pdf.

    concentrated
      If there is a set :math:`A ∈ 𝔐` such that for all :math:`E ∈ 𝔐` we have :math:`λ E = λ (A ∩ E)`, then we say that :math:`λ` is **concentrated** on :math:`A`.

    concrete category
      A **concrete category** is one whose objects are sets and whose :term:`morphisms <morphism>` are functions defined on these sets (possibly satisfying some other special properties).

    conjugate exponents
      If :math:`p` and :math:`q` are positive real numbers such that :math:`p+q = pq` (equivalently, :math:`(1/p) + (1/q) = 1`), then we call :math:`p` and :math:`q` a pair of **conjugate exponents**.

      It's clear that conjugate exponents satisfy :math:`1 < p, q < ∞` and that as :math:`p → 1`, :math:`q → ∞` and vice-versa. Thus, :math:`(1, ∞)` is also regarded as a pair of conjugate exponents.

    consecutive functions
      If :math:`f : A → B` and :math:`g : B → C`, then :math:`\cod f = \dom g` and we say that :math:`f` and :math:`g` are **consecutive functions**.

    constructive
      See https://plato.stanford.edu/entries/mathematics-constructive/ and https://en.wikipedia.org/wiki/Constructivism_(philosophy_of_mathematics) and https://en.wikipedia.org/wiki/Constructive_proof.

    continuous function
      Let :math:`(X, τ_1)` and :math:`(Y, τ_2)` be :term:`topological spaces <topological space>`. A function :math:`f: X → Y` is called **continuous** if :math:`f^{-1}(S) ∈ τ_1` for every :math:`S ∈ τ_2`.
  
      Let :math:`(X, |\;\;|_1)` and :math:`(Y, |\;\;|_2)` be :term:`metric spaces <metric space>`. A function :math:`f : X \to Y` is called **continuous** at the point :math:`x_0 ∈ X` if for all :math:`ε >0` there exists :math:`δ > 0` such that

      .. math::  |x - x_0|_1 < δ \, ⟹ \, |f(x) -f(x_0)|_2 < ε.

      A function :math:`f : X → Y` is called **continuous** in :math:`E ⊆ X` if it is continuous at every point of :math:`E`.
      
    contravariant powerset functor
      The **contravariant powerset functor** is a functor :math:`P^{\mathrm{op}}: \mathbf{Set} → \mathbf{Set}` such that for each :term:`morphism` :math:`g: B → A` the morphism :math:`P^{\mathrm{op}}g: 𝒫(A) → 𝒫(B)` is given by :math:`P^{\mathrm{op}} g (S) = \{b ∈ B : g(b) ∈ S\}` for each :math:`S ⊆ A`.

    coproduct
      Given two objects :math:`A` and :math:`B` a **coproduct** (or **sum**) of :math:`A` and :math:`B` is denoted by :math:`A+B` and defined to be an object with morphisms :math:`ι_1 : A → A + B` and :math:`ι_2 : B → A + B` such that for every object :math:`X` and all morphisms :math:`u : A → Y` and :math:`v : B → Y` there exists a unique morphism :math:`[u,v] : A+B → Y` such that :math:`[u,v] ∘ ι_1 = u` and :math:`[u,v] ∘ ι_2 = v`.

    Coq
      An :term:`intensional`, :term:`impredicative` :term:`ITP` supporting :term:`dependent types <dependent type>` and based on :term:`CiC`; url: http://coq.inria.fr
      
    countably additive
      Let :math:`𝒮 = \{S_λ: λ∈ Λ\}` be a collection of sets and let :math:`R` be a :term:`ring`.  A function :math:`s: 𝒮 → R` is called **countably additive** if for every *countable* subset :math:`Γ ⊆ Λ` such that :math:`\{S_γ : γ ∈ Γ\}` is a collection of *pairwise disjoint* subsets in :math:`𝒮`, we have
 
     .. math:: s \bigl( ⋃_{γ∈Γ}  A_γ \bigr) = ∑_{γ∈ Γ} s (A_γ).

    countably subadditive
      Let :math:`𝒮 = \{S_λ: λ∈ Λ\}` be a collection of sets and let :math:`R` be a :term:`ring`.  A function :math:`s: 𝒮 → R` is called **countably subadditive** if for every *countable* subset :math:`Γ ⊆ Λ` such that :math:`\{S_γ : γ ∈ Γ\}` is a collection of subsets in :math:`𝒮`, we have

    covariant powerset functor
      The **(covariant) powerset functor** is a functor :math:`P : \mathbf{Set} → \mathbf{Set}` such that for each :math:`f : A → B` the morphism :math:`Pf : PA → PB` is given by :math:`Pf(S) = \{f(x) : x ∈ S\}` for each :math:`S \subseteq A`.

    cover
      See :term:`covering`.

    covering
      In a metric or topological space :math:`X`, a **covering** of a subset :math:`E ⊆ X` is a collection of subsets :math:`\{V_α\}` of :math:`X` such that :math:`E ⊆ ⋃_α V_α`.  If, in addition, each :math:`V_α` is an open subset of :math:`X`, then we call :math:`\{V_α\}` an **open covering** of :math:`E`.


    Curry-Howard correspondence
      the correspondence between propositions and types, and proofs and programs; a proposition is identified with the type of its proofs, and a proof is a program of that type.
      
      (See also https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence.)

    currying
      See https://en.wikipedia.org/wiki/Currying.

    dense set
      A set :math:`G` is **dense** in :math:`X` if each :math:`x ∈ X` is a limit point of :math:`G`. Equivalently, the closure of :math:`G` contains :math:`X` (in symbols, :math:`X ⊆ Ḡ`.)

    dependent function type
      See :term:`Pi type`.

    dependent pair type
      See :term:`Sigma type`.

    dependent product type
      See :term:`Sigma type`.

    discrete topology
      If :math:`X` is a nonempty set, the powerset :math:`𝒫(X)` is a topology on :math:`X` and is called the **discrete topology**.
      
    diameter
      The **diameter** of a set :math:`E` in a metric space :math:`(X, d)` is denoted and defined by :math:`\mathrm{diam} E = \sup \{d(x, y) : x, y \in E\}`.
      
    dependent type
      A **dependent type** is actually a family of types indexed by some parameter. That is, a dependent type provides a *type schema*, which is a collection of types indexed by a set of values. For example, the type ``Fin n`` of finite sets of size ``n`` is a type that *depends* on the value ``n``.  More examples are in :numref:`dependent-types`_.
      
      (See also the `Dependent Types`_ section in the `TPL`_ tutorial.)

    directed set
      A subset :math:`D` of a :term:`preorder` is called **directed** if every finite subset of :math:`D` has an upper bound in :math:`D`. That is, if :math:`F ⊆ D` and :math:`F` is finite, then there exists :math:`d ∈ D` such that :math:`f ≤ d` for all :math:`f ∈ F`.

    directed-cocomplete preorder
      a :term:`preorder` for which the joins of all :term:`directed <directed set>` subsets exist. 
      
    directed-cocomplete poset
      an :term:`antisymmetric` :term:`directed-cocomplete preorder`.

    directed graph
      A **directed graph** is a :term:`relational structure` consisting of a vertex set :math:`V` (whose elements are called vertices) and an edge set :math:`E ⊆ V^2` (whose elements are called edges).

    division ring
      A :term:`ring` in which every non-zero element is a unit is called a **division ring**.

    domain
      If :math:`f : A → B` is a function or relation from :math:`A` to :math:`B`, then :math:`A` is called the **domain** of :math:`f`, denoted by :math:`\dom f`.

    dual
      If :math:`X` is a :term:`normed linear space` over the :term:`field` :math:`F`, then the collection :math:`𝔅(X,F)` of :term:`bounded linear functionals <bounded linear functional>` is called the **dual space** (or **dual**) of :math:`X`.

      If :math:`F` is complete, then :math:`𝔅(X,F)` is complete, hence a :term:`Banach space`.

    endofunctor
      A :term:`functor` that maps a category to itself is called an **endofunctor**.

    endomorphism
      A morphism :math:`f: 𝔸 → 𝔸` (i.e., :math:`\src f = \tar f`) is called an **endomorphism**.

    epimorphism
      A :term:`morphism` :math:`f: X → Y` is called an **epimorphism** if for every object :math:`Z` and pair :math:`g_1, g_2: Y → Z` of morphisms we have :math:`g_1 ∘ f = g_2 ∘ f` implies :math:`g_1 = g_2`. When :math:`f: X → Y` is an **epimorphism** we often say ":math:`f` is epi" and write :math:`f: X ↠ Y`.

    equivalence class
      If :math:`R` is an :term:`equivalence relation` on :math:`A`, then for each :math:`a ∈ A`, there is an **equivalence class** containing :math:`a`, which is denoted and defined by :math:`a/R = \{b ∈ A ∣ a \mathrel R b\}`.

    equivalence relation
      An **equivalence relation** is a :term:`symmetric` :term:`preorder`. The collection of all equivalence relations on :math:`X` is denoted by :math:`\mathrm{Eq}(X)`.

    equivalent categories
      Two categories :math:`\mathcal C` and :math:`\mathcal D` are called **equivalent categories** if there are functors :math:`F : \mathcal C →  \mathcal D` and :math:`G : \mathcal D → \mathcal C` together with natural isomorphisms :math:`ε : FG ≅ \mathrm{id}_{\mathcal D}`, and :math:`η : \mathrm{id}_{\mathcal C} ≅ GF`. We say that :math:`F` is an equivalence with an inverse equivalence :math:`G` and denote the equivalence by :math:`F : \mathcal C ≃ \mathcal D : G`.

    essentially surjective on objects
      A functor :math:`F : C → D` is called **essentially surjective on objects** if for every object :math:`D ∈ \mathcal D`, there is some :math:`A ∈ \mathcal C` such that :math:`F A` is isomorphic to :math:`D`.

    Euclidean norm
      For :math:`𝐱 = (x_1,\dots, x_n) ∈ ℝ^n` the **Euclidean norm** of :math:`𝐱` is denoted and defined by :math:`\|𝐱\|_2 = \left(∑_{i=1}^n x_i^2\right)^{1/2}`.

    Euclidean space
      For :math:`n∈ ℕ` the :term:`normed linear space` :math:`(ℝ^n, \|\,⋅\,\|_2)`, where :math:`\|\,⋅\,\|_2` is the :term:`Euclidean norm`, is called :math:`n`-dimensional **Euclidean space**.

    existential image functor
      the functor :math:`∃ f : P(A) → P(B)` defined by :math:`∃ f(X) = \{f(x) : x ∈  X\},` for :math:`X ∈ P(A)`.

    eval
      If :math:`A` and :math:`B` are types, then the **eval** (or **function application**) function on :math:`A` and :math:`B` is denoted by :math:`\mathbf{eval}: ((A → B) × A) → B` and defined by :math:`\mathbf{eval} (f, a) = f\, a`, for all :math:`f: A → B` and :math:`a: A`.

    evaluation functor
      The **evaluation functor** is the functor :math:`Ev : \mathcal C × \mathbf{Set}^{\mathcal C} → \mathbf{Set}`, which takes each pair :math:`(A, F) ∈ \mathcal C_{\mathrm{obj}} × \mathbf{Set}^{{\mathcal C}_{\mathrm{obj}}}` of objects to the set :math:`Ev(A, F) = FA`, and takes each pair :math:`(g, μ) ∈ \mathcal C_{\mathrm{obj}} × \mathbf{Set}^{\mathcal C_{\mathrm{mor}}}` of morphisms to a function on sets, namely, :math:`Ev(g, μ) = μ_{A'} ∘ F g = F' g ∘ μ_A`, where :math:`g ∈ \mathcal C(A, A')` and :math:`μ : F ⇒ F'`.

    evaluation natural transformation
      The **evaluation natural transformation** is denoted by :math:`eval^A : F_A →  \mathrm{id}_{\mathbf{Set}}` and defined by... (**Todo** complete definition)

    extensional
      An *extensional* definition of a term lists everything that qualifies as something to which that term refers.
      
      (See also :term:`function extensionality`.)

    faithful functor
      A functor :math:`F : \mathcal C → \mathcal D` is called **faithful** if for all objects :math:`A`, :math:`B` in :math:`\mathcal C_{\mathrm{obj}}`, the map :math:`\mathcal C(A, B) → \mathcal D(F A, F B)` is injective.
      
      (Note: A faithful functor need not be injective on morphisms.)

    field
      A **field** is a commutative :term:`division ring`.
      
    finite measure
      If :math:`(X, 𝔐, μ)` is a :term:`measure space`, then :math:`μ` is called a **finite measure** provided :math:`μ X < ∞`. 

    finite ordinals
      The category :math:`\mathrm{Ord}_{\mathrm{fin}}` of **finite ordinals** (also called the **simplex category** :math:`\Delta`) has :math:`\underline n = \{0, 1, \dots, n-1\}` for objects (for each :math:`n ∈ ℕ`) and :math:`f : \underline n → \underline m` :term:`monotone functions <monotone function>` for morphisms.

    finite set
      A set is called **finite** if it contains only a finite number of elements.

    first category
      A set :math:`G` is of the **first category** if it is a countable union of :term:`nowhere dense` sets.

    fork
      Let :math:`A` and :math:`D` be types and for each :math:`a: A`, let :math:`C_a` be a type. Then the (dependent) **fork function**, denoted
   
      .. math:: \mathbf{fork}: ∏_{a:A}(C_a → D) → ∏_{a:A} C_a → ∏_{a:A} (C_a → D) × C_a,
      
      is defined as follows: for all :math:`h: ∏_{a:A}(C_a → D)` and :math:`k: ∏_{a:A} C_a`,
      
      .. math:: \mathbf{fork}\, (h)(k): ∏_{a:A}((C_a → D) × C_a),

      and for each :math:`a:A`,

      .. math:: \mathbf{fork}\, (h)(k)(a) = (h\,a, k\,a): (C_a → D) × C_a.

      Thus, :math:`\mathbf{eval} \, \mathbf{fork}\, (h)(k)(a) = (h\, a)(k\, a)` is of type :math:`D`.

      (See also :numref:`general-composition`.)

    free algebra
      The **free algebra** in a :term:`variety` is the :term:`initial object` in a category whose objects are :term:`algebraic structures <algebraic structure>`.
      
      Precisely, if :math:`𝒱` is a :term:`variety` of :term:`algebras <algebraic structure>` and if :math:`X` is a set, then the **free algebra** generated by :math:`X` is denoted by :math:`𝔽(X)` and defined as follows: for every algebra :math:`𝔸 ∈ 𝒱` and every function :math:`f: X → A`, there exists a unique :term:`homomorphism` :math:`h: 𝔽(X) → 𝔸` such that :math:`∀ x ∈ X, h(x) = f(x)`.  We say that :math:`𝔽(X)` is "universal", or "has the :term:`universal mapping property`", for :math:`𝒱`

    free object
      See :term:`initial object`.

    free monoid
      The **free monoid** is the :term:`initial object` in a category of :term:`monoids <monoid>`.

    full embedding
      a :term:`fully faithful functor` that is injective on objects.

    full functor
      A functor :math:`F : \mathcal C → \mathcal D` is called **full** if for all objects :math:`A`, :math:`B` in :math:`\mathcal C`, the map :math:`\mathcal C(A, B) → \mathcal D(F A, F B)` is surjective.
      
      (N.B. A full functor need not be surjective on morphisms.)

    full subcategory
      If there exists a :term:`full embedding` :math:`F : \mathcal C → \mathcal D`, then :math:`\mathcal C` is called a **full subcategory** of :math:`\mathcal D`.

    fully faithful functor
      a functor that is both :term:`full <full functor>` and :term:`faithfull <faithful functor>`.

    function extensionality
      the principle that takes two functions :math:`f : X → Y` and :math:`g : X → Y` to be equal just in case :math:`f(x) = g(x)` holds for all :math:`x : X`; such functions are sometimes called "Leibniz equal."

      In Lean, one defines function extensionality for functions of (dependent) type :math:`Π(x:α), β x` as follows:

      .. code-block:: lean

         def equiv (f₁ f₂: Π x:α, β x): Prop := ∀ x, f₁ x = f₂ x

    function application
      See :term:`eval`.

    functional programming
      See https://en.wikipedia.org/wiki/Functional_programming.

    functor
      A **functor** :math:`F : \mathcal C → \mathcal D` consists of a function :math:`F_0` that maps objects of :math:`\mathcal C` to objects of :math:`\mathcal D` and a function :math:`F_1` that maps morphisms of :math:`\mathcal C` to morphisms of :math:`\mathcal D` such that :math:`F` preserves (co)domains of morphisms, identities, and compositions.

    functor category
      The **functor category** from :math:`\mathcal C` to :math:`\mathcal D` has functors :math:`F : \mathcal C → \mathcal D` as objects and natural transformations :math:`α : F ⇒ G` as morphisms.

    Galois connection
      See https://en.wikipedia.org/wiki/Galois_connection.

    Galois pair
      See https://en.wikipedia.org/wiki/Galois_connection.

    generalized element
      A :term:`morphism` :math:`h: X → A` is sometimes called a **generalized element** of :math:`A`. A morphism :math:`f` is mono when it is injective on the generalized elements of its domain.

    general composition
      See :term:`composition of operations`.

    global element
      See :term:`point`.

    graph morphism
      Let :math:`𝐆_1 =(V_1, E_1)` and :math:`𝐆_2 = (V_2, E_2)` be graphs. We say that a pair of functions :math:`f=(f_v,f_e)` is a **graph morphism** from :math:`𝐆_1` to :math:`𝐆_2` provided :math:`f_v : V_1 → V_2`, :math:`f_e : E_1 → E_2`, and for any edge :math:`e = (v_1,v_2) ∈ E_1` we have that we have :math:`f_e(e) = (f_v(v_1), f_v(v_2))`.

    group
      A **group** is a :term:`monoid` expanded with a unary operation :math:`^{-1}`, called *multiplicative inverse*, which satisfies :math:`∀ a ∈ A`, :math:`a ⋅ a^{-1} =  a^{-1} ⋅ a = e`.

    groupoid
      See :term:`magma`.

    Hausdorff space
      A :term:`topological space` :math:`(X, τ)` is called a **Hausdorff space** if the topology :term:`separates the points` of :math:`X`.  In other words, distinct points have some disjoint neighborhoods.

    height
      If :math:`w` is a term, then the **height** of :math:`w` is denoted by :math:`|w|` and defined to be the least :math:`n` such that :math:`w ∈ T_n`.

      If :math:`α` is a type, then we sometimes refer to the **height** of :math:`α`, by which we mean the *universe level* of :math:`α`
      
      (See the :ref:`appendix section on Lean's type hierarchy <leans-type-hierarchy>`.)

    Heyting algebra
      A **Heyting algebra** :math:`⟨L, ∧, ∨, ⊥, ⊤, →⟩` is a bounded :term:`lattice` with least and greatest elements ⊥ and ⊤, and a binary "implication" → that satisfies :math:`∀ a, b, c ∈ L, \ (c ∧ a ≤ b \ ⟺ \ c ≤ a → b)`.  Logically, this says a → b is the weakest proposition for which the modus ponens rule, :math:`\{a → b, a\} ⊢ b`, is sound. The class of Heyting algebras forms a variety that is finitely axiomatizable.
   
    Heyting algebra homomorphism
      a :term:`lattice homomorphism` that also preserves Heyting implications; that is, if :math:`x, x' ∈ X`, then :math:`f(x → x') = f(x) → f(x')`.
 
    Hilbert space
      A :term:`normed linear space` whose norm arises from an :term:`inner product` is called a **Hilbert space**.

    hom set
      Some authors require that :math:`\mathcal C(A,B)` always be a set and call :math:`\mathcal C(A,B)` the **hom set** from :math:`A` to :math:`B`.

    homeomorphic
      We call a pair :math:`X, Y` of :term:`topological spaces <topological space>` **homeomorphic** if there is a homeomorphism between them.

    homeomorphism
      A :term:`continuous function` from a :term:`topological space` :math:`X` to a topological space :math:`Y` is called a **homeomorphism** provided it is one-to-one and onto, and has a continuous inverse from :math:`Y` to :math:`X`.
   
      Clearly the inverse of a homeomorphism is a homeomorphism and the composition of homeomorphisms, when defined, is a homeomorphism.

    homomorphism
      See :term:`morphism`.

    idempotent
      An operation :math:`f: A^n → A` is called **idempotent** provided :math:`f(a, a, \dots, a) = a` for all :math:`a ∈ A`. That is, :math:`f` maps constant tuples to their constant image value.
      
      In other terms :math:`f: (ρ f → A) → A` is idempotent iff for each constant tuple :math:`a: ρ f → A`, say, :math:`∀ i<ρ f, \; a\, i = c`, we have :math:`f\, a = f(c, c, \dots, c) = c`.

    implication elimination
      See the `section on implication <https://leanprover.github.io/logic_and_proof/propositional_logic.html#implication>`_ in the `Logic and Proof`_ book.

    implicit arguments
      See sections `Implicit arguments`_ and `More on implicit arguments`_ of `TPL`_.

    impredicative
      A self-referencing definition is called **impredicative**. A definition is said to be impredicative if it invokes (mentions or quantifies over) the set being defined, or (more commonly) another set which contains the thing being defined.

    indiscrete topology
      If :math:`X` is a nonempty set, then :math:`\{∅, X\}` is a topology on :math:`X`, called the **trivial** (or **indiscrete**) **topology**.

    inductive set
      A subset :math:`I` of a :term:`preorder` :math:`X` is called **inductive** if :math:`⋁_X D ∈ I` for every directed subset :math:`D ⊆ X` contained in :math:`I`. That is, if :math:`D ⊆ I`, and if every finite subset of :math:`D` has an upper bound in :math:`D`, then :math:`D` as a least upper bound in :math:`I`.

    ∞-norm
      Let :math:`(X, 𝔐, μ)` be a :term:`measure space`.  The :math:`∞`-**norm relative to** :math:`μ` is defined for each real- or complex-valued function :math:`f` on :math:`X` by
    
      .. math:: \|f\|_∞ := \inf \{a∈ ℝ^∗ ∣ μ\{x : |f(x)| > a\} = 0\} = \inf \{a∈ ℝ^∗ ∣ |f(x)| ≤ a \text{ for } μ-\text{a.e. } x∈ X\},

      where :math:`ℝ^∗ = ℝ ∪ \{-∞, ∞\}` and :math:`\inf ∅ = ∞`.

    inductive type
      A type is called **inductive** or **inductively defined** if...
      
      (See also: :numref:`inductively-defined-types` and the :term:`definition of the recursor <recursor>`.)
      
    initial object
      An object :math:`0` in a category is called the **initial object**  (or **free object**) if for every object :math:`A` in the category there exists a unique morphism :math:`!_A: 0 → A`.
      
      The :term:`free algebra` in a :term:`variety` is a **free object** in a category whose objects are :term:`algebraic structures <algebraic structure>`.
     
    inner product 
      Let :math:`X` be a :term:`vector space` over the field :math:`F`.  An **inner product** on :math:`X` is a function :math:`⟨·,·⟩: X × X → F` satisfying the following conditions:

      #. :math:`⟨⋅,⋅⟩` is linear in the first variable; i.e., :math:`⟨α x + βy, z⟩ = α⟨x,z⟩ + β⟨y,z⟩` for all :math:`α, β ∈ F` and :math:`x, y, z ∈ X`;
      #. :math:`⟨⋅,⋅⟩` is symmetric; i.e., :math:`⟨x, y⟩ = ⟨y, x⟩` for all :math:`x, y ∈ X`; and
      #. :math:`⟨x, x⟩ ≥ 0` for each :math:`x∈ X` and :math:`⟨x, x⟩ = 0` if and only if :matH:`x = 0`.

    inner product space
      An **inner product space** is a vector space equipped with an :term:`inner product`.

    integrable
      A real- or complex-valued :math:`μ`-:term:`measurable function` :math:`f` is called :math:`μ`-**integrable** (or **integrable with respect to** :math:`μ`, or just **integrable**) over :math:`X` if :math:`∫_X |f| \, dμ < ∞`.  We let :math:`L_1(X, μ)` (or :math:`L_1(μ)`, or just :math:`L_1`) denote the collection of functions that are :math:`μ`-integrable over :math:`X`.

      When :math:`f∈ L_1(X, μ)` we define the :term:`integral` of :math:`f` over a measurable set :math:`E ⊆ X` by :math:`∫_E f\, dμ = ∫_E f^+\, dμ - ∫_E f^-\, dμ`.

    integral
      See :term:`Lebesgue integral`.

    interior
      If :math:`X` is a :term:`topological space` and :math:`A ⊆ X`, then the union of all :term:`open sets <open set>` contained in :math:`A` is called the **interior** of :math:`A`.

    intensional
      An **intensional** definition of a term specifies necessary and sufficient conditions that the term satisfies. In the case of nouns, this is equivalent to specifying all the properties that an object must have in order to be something to which the term refers.

    isometrically isomorphic
      Two :term:`Hilbert spaces <Hilbert space>` :math:`ℋ_1, ℋ_2` are called **isometrically isomorphic** if there exists a :term:`unitary operator` from :math:`ℋ_1` onto :math:`ℋ_2`.

      In other words, :math:`U: ℋ_1 ↠ ℋ_2` is a surjective :term:`isometry` from :math:`ℋ_1` to :math:`ℋ_2`.

    isometry
      Let :math:`(X, \|\,.\,\|_1)` and :math:`(Y, \|\,.\,\|_2)` be :term:`normed linear spaces <normed linear space>`.  A :term:`linear transformation` :math:`T: X → Y` is called an **isometry** if it preserves norms, that is, :math:`\|Tx\|_2 = \|x\|_1` holds for all :math:`x∈ X`.

    isomorphism
      A morphism :math:`f: A → B` is called an **isomorphism** if there exists a morphism :math:`g: A → B` such that :math:`g ∘ f= \mathrm{id}_A` and :math:`f ∘ g = \mathrm{id}_B`. We write :math:`f^{-1}` to denote :math:`g` when it exists.

    kernel
      By the **kernel** of a function :math:`f: A → B` we mean the binary relation on :math:`A` denoted and defined by :math:`\mathrm{ker} f := \{(a₁, a₂) : f a₁  = f a₂\}`.   

    Kleene closure
      See :term:`free monoid`.

    lambda calculus
      See https://en.wikipedia.org/wiki/Lambda_calculus.

    lattice
      a :term:`poset` whose universe is closed under all *finite* meets and joins is called a lattice.
     
    lattice homomorphism
      a function :math:`f: X → Y` preserving finite meets and joins.

    law of the excluded middle
      This is an axiom of classical logic asserting that for all propositions P either ¬ P or P holds.
      
      (See also the `LEM Section <https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html?highlight=reduction%20rule#the-law-of-the-excluded-middle>`_ of the :term:`TPIL`.)

    Lean
      An :term:`extensional`, :term:`impredicative` :term:`ITP` supporting :term:`dependent types <dependent type>` and based on :term:`CiC`; url: https://leanprover.github.io/.

    Lebesgue integrable
      A function that is :term:`integrable` with respect to :term:`Lebesgue measure` is called a **Lebesgue integrable** function.

    Lebesgue integral
      Let :math:`(X, 𝔐, μ)` be a :term:`measure space`.  If :math:`E ∈ 𝔐` and :math:`s: X → [0, ∞)` is a :term:`measurable <measurable function>` :term:`simple function` of the form :math:`s = ∑_{i=1}^n α_i χ_{A_i}`, where :math:`α_1, \dots, α_n ∈ ℝ` are the distinct values of :math:`s`, then we denote and define the **Lebesgue integral** of :math:`s` over :math:`E` as follows:
      
      .. math:: ∫_E s\, dμ := ∑_{i=1}^n α_i μ(A_i ∩ E),
      
      where we adopt the convention that :math:`0⋅∞ = 0` (in case, e.g., :math:`α_i = 0` and :math:`μ(A_i ∩ E) = ∞` for some :math:`1≤ i ≤ n`).
      
      If :math:`f: X → [0, ∞]` is a nonnegative extended real-valued measurable function and :math:`E∈ 𝔐`, then we denote and define the **Lebesgue integral** of :math:`f` over :math:`E` with respect to the measure :math:`μ` (or, the **integral** of :math:`f`) as follows:

      .. math:: ∫_E f\, dμ := \sup ∫_E s\, dμ,

      where the supremum is taken over all simple measurable functions :math:`s` such that :math:`0≤ s ≤ f`.

      If :math:`μ` is the only :term:`measure` in context, then we may write :math:`∫_E f` in place of :math:`∫_E f\, dμ`, and :math:`∫ f` in place of :math:`∫_X f`.

    Lebesgue measurable function
      Let :math:`E⊆ ℝ`.  A function :math:`f: E → ℝ` is called **Lebesgue measurable** provided :math:`f^{-1}(G)` is a :term:`Lebesgue measurable set` for every open set :math:`G ⊆ ℝ`.  Equivalently, :math:`f` is Lebesgue measurable iff the set :math:`f^{-1}((α, ∞))` is Lebesgue measurable for every :math:`α ∈ ℝ`.

    Lebesgue measurable set
      A set that is :term:`measurable <measurable set>` with respect to :term:`Lebesgue measure` is called a **Lebesgue measurable** set; that is, :math:`E⊆ ℝ` is Lebesgue measurable iff

      .. math:: m^∗ A = m^∗ (A ∩ E) + m^∗(A ∩ E^c)\; \text{ holds for all } A ⊆ R.

    Lebesgue measure
      Let :math:`ℓ` be the :term:`measure` defined on the :term:`semiring <semiring of sets>` :math:`S := \{[a, b) ∣ a, b ∈ ℝ\}` of bounded intervals by :math:`ℓ[a, b)= b-a` for all :math:`a ≤ b`. Let :math:`ℓ^∗: 𝒫(ℝ) → [0, ∞]` be the :term:`outer measure` generated by :math:`ℓ`.  That is, for :math:`E⊆ ℝ`,
      
      .. math:: ℓ^∗(E) := \inf \{∑_{n=1}^∞ m(I_n) ∣ \{I_n\} ⊆ S \text{ and } E ⊆ ⋃_{n=1}^∞ I_n\}
      
      The measure obtained by restricting :math:`ℓ^∗` to the :term:`measurable subsets <measurable set>` in :math:`𝒫(ℝ)` is called **Lebesgue measure**.
      
      Observe that the :math:`ℓ^∗`-:term:`measurable subsets <measurable set>` in :math:`𝒫(ℝ)` are those :math:`A∈ 𝒫(ℝ)` satisfying

      .. math:: ℓ^∗ E = ℓ^∗(E ∩ A) + ℓ^∗(E ∩ A^c)\; \text{ for all } E ⊆ ℝ.

    Lebesgue outer measure
      See :term:`Lebesgue measure`

    Lebesgue null set
      A **Lebesgue null set** is a set of :term:`Lebesgue measure` zero.

    Leibniz equal
      See :term:`function extensionality`.

    left module
      See :term:`module`.

    lift (n)
      See :term:`lifts (v)`

    lifts (v)
      For :math:`ρ ⊆ α × α`, and :math:`f: α → β`, we say that :math:`f` **lifts** to a function on the quotient :math:`α/ρ` provided the following implication holds for all :math:`x y: α`: if :math:`ρ x y` then :math:`f x = f y`.  The function to which :math:`f` lifts is called the **lift** of :math:`f`.

    limit point
      A point :math:`x` is called a **limit point** (or **accumulation point**) of a set :math:`A` in a topological space if :math:`A ∩ (V \ {x}) ≠ ∅` for every :term:`neighborhood` :math:`V` of :math:`x`.

    linear functional
      Let :math:`X` be a :term:`vector space` over the :term:`field` :math:`F`.  A **linear functional** on :math:`X` is a :term:`linear transformation` with :term:`codomain` :math:`F`.

    linear operator
      See :term:`linear transformation`.

    linear space
      See :term:`vector space`.

    linear transformation
      A **linear transformation** (or **linear operator**) is a :term:`morphism` in the category of :term:`vector spaces <vector space>`.

      Explicitly, if :math:`X` and :math:`Y` are :term:`vector spaces <vector space>` over the :term:`field` :math:`F`, then a **linear transformation** from :math:`X` to :math:`Y` is a function :math:`T: X → Y` that is "linear" in that it preserves the vector space operations (addition and scalar products); that is,
      
        #. :math:`∀ x, x' ∈ X`, :math:`T(x + x') = T\,x + T\,x'`.
        #. :math:`∀ α ∈ F`, :math:`∀ x ∈ X`, :math:`T(α x) = α T\,x`.

      (These conditions are equivalent to the single condition :math:`∀ α ∈ F`, :math:`∀ x, x' ∈ X`, :math:`T(α x + x') = α T\,x + T\,x'`.)

    Lipschitz condition
      A function :math:`f` satisfies a **Lipschitz condition** on an interval if there is a constant :math:`M` such that :math:`|f(x) - f(y)| ≤ M|x-y|` for all :math:`x`and :math:`y` in the interval.

    Lipschitz constant
      The number :math:`M` in the definition of :term:`Lipschitz condition` is called the **Lipschitz constant**.

    Lipschitz continuous
      A function is called **Lipschitz continuous** on an interval if it satisfies a :term:`Lipschitz condition` on that interval.

    locally compact
      A :term:`topological space` :math:`(X,τ)` is called **locally compact** if every point of :math:`X` has a neighborhood whose :term:`closure` is :term:`compact <compact set>`.

    locally small category
      A category :math:`\mathcal C` is **locally small** if for every pair :math:`A`, :math:`B` of objects in :math:`\mathcal C` the collection of morphisms from :math:`A` to :math:`B` is a set.

    logically equivalent
      Propositions :math:`P` and :math:`Q` are **logically equivalent** provided :math:`P` implies :math:`Q` and :math:`Q` implies :math:`P`.

    lower limit
      Let :math:`\{a_n\}` be a sequence in :math:`[-∞, ∞]`, and put :math:`b_k = \inf \{a_k, a_{k+1}, \dots\}` for :math:`k∈ ℕ` and :math:`β = \sup \{b_0, b_1, b_2, \dots \}`. We call :math:`β` the **lower limit** (or **limit inferior**) of :math:`\{a_n\}`, and write :math:`β = \liminf\limits_{n→ ∞} a_n`.  The :term:`upper limit`, :math:`\limsup\limits_{n→ \infty} a_n` is definied similarly.

      Observe that

        #. :math:`b_0 ≤  b_1 ≤ b_2 ≤ \cdots ≤ β` and :math:`b_k → β` as :math:`k→ ∞`;
        #. there is a subsequence :math:`\{a_{n_j}\}` of :math:`\{a_n\}` that converges to :math:`β` as :math:`j→ ∞` and :math:`β` is the smallest number with this property.
        #. :math:`\limsup\limits_{n→∞} a_n = -\liminf\limits_{n→∞} (- a_n)`.

      (See also the definition of :term:`upper limit` and the remarks following that definition.)

    magma
      An algebra with a single binary operation is called a **magma** (or **groupoid** or **binar**). The operation is usually denoted by :math:`+` or :math:`⋅`, and we write :math:`a+b` or :math:`a ⋅ b` (or just :math:`ab`) for the image of :math:`(a, b)` under this operation, which we call the *sum* or *product* of :math:`a` and :math:`b`, respectively.

    measurable function
      Let :math:`(X, 𝔐)` and :math:`(Y, 𝔑)` be measurable spaces. A function :math:`f: X → Y` is called :math:`(𝔐, 𝔑)`-**measurable** (or just **measurable**) if :math:`f^{-1}(N) ∈ 𝔐` for every :math:`N ∈ 𝔑`.

    measurable set
      If :math:`𝔐` is a :term:`σ-algebra` in :math:`X`, then the members of :math:`𝔐` are called the **measurable sets** in :math:`X`.

      If :math:`μ^∗` is an :term:`outer measure` on :math:`X`, a set :math:`A ⊆ X` is called :math:`μ^∗`-**measurable set** (or **measurable with respect to** :math:`μ^∗`, or just **measurable**) provided
      
      .. math:: μ^∗ E = μ^∗(E ∩ A) + μ^∗(E ∩ A^c)\; \text{ for all } E ⊆ X.

      Equivalently, :math:`A` is **measurable** iff
      
      .. math:: μ^∗ E ≥ μ^∗(E ∩ A) + μ^∗(E ∩ A^c)\; \text{ for all } E ⊆ X \text{ such that } μ^∗ E < ∞.

    measurable space
      If :math:`𝔐` is a :term:`σ-algebra` in :math:`X`, then :math:`(X, 𝔐)` (or just :math:`X`) is called a **measurable space**.

    measure
      A (positive) **measure** is a function :math:`μ: 𝔐 → [0, ∞]`, defined on a :math:`σ`-algebra :math:`𝔐`, which is :term:`countably additive`.

    measure space
      A **measure space** is a triple :math:`(X, 𝔐, μ)` where :math:`X` is a :term:`measurable space`, :math:`𝔐` is the :term:`σ-algebra` of :term:`measurable sets <measurable set>` in :math:`X`, and :math:`μ: 𝔐 → [0, ∞]` is a :term:`measure`.

    metric space
      A **metric space** is a pair :math:`(X, d)` where :math:`X` is a set and :math:`d: X × X → ℝ` is a **metric** (or **distance function**), that is, a function satisfying the following conditions for all :math:`x, y, z ∈ X`:

      #. :math:`d(x, y) ≥ 0`
      #. :math:`d(x,y) = 0` if and only if :math:`x = y`
      #. (symmetry) :math:`d(x, y) = d(y, x)` 
      #. (triangle inequality) :math:`d(x, z) ≤ d(x, y)+d(y, z)`.

    module
      Let :math:`R` be a :term:`ring` with unit. A **left unitary** :math:`R`-**module** (or simply :math:`R`-**module**) is an algebra :math:`⟨M, \{0, -, +\} ∪ \{f_r : r∈ R\}⟩` with an :term:`abelian group` :term:`reduct` :math:`⟨M, \{0, -, +\}⟩` and unary operations :math:`\{f_r : r ∈ R\}` that satisfy the following: :math:`∀ r, s ∈ R`, :math:`∀ x, y ∈ M`,

      #. :math:`f_r(x + y)  = f_r(x) + f_r(y)`
      #. :math:`f_{r+s}(x) = f_r(x) + f_s(x)`
      #. :math:`f_r(f_s(x)) = f_{rs}(x)`
      #. :math:`f_1(x) = x`.

    metaprogram
      a program whose purpose is to modify the behavior of other programs; :term:`proof tactics <proof tactic>` form an important class of metaprograms.

    modus ponens
      See :term:`implication elimination`.

    monoid
      If :math:`⟨M, ⋅⟩` is a :term:`semigroup` and if there exists :math:`e ∈ M` that is a multiplicative identity (i.e., :math:`∀ m ∈ M`, :math:`e ⋅ m = m = m ⋅ e`), then :math:`⟨M, \{e, ⋅\}⟩` is called a **monoid**.

    monoid homomorphism
      Given :term:`monoids <monoid>` :math:`𝐌_1 = (M_1, e_1, ⋆)` and :math:`𝐌_2 = (M_2, e_2, ∗)` we say that a function :math:`f : M_1 → M_2` is a **monoid homomorphism** from :math:`𝐌_1` to :math:`𝐌_2` provided :math:`f` preserves the :term:`nullary <nullary operation>` (identity) and :term:`binary operations <binary operation>`; that is, :math:`f(e_1) = e_2` and :math:`f (x ⋆ y) = f(x) ∗ f(y)` for all :math:`x, y ∈ M_1`.

    monomorphism
      A :term:`morphism` :math:`f: A → B` is called a **monomorphism** if for every object :math:`X` and every pair :math:`h, h' : X → A` of morphisms, :math:`f ∘ h = f ∘ h'` implies :math:`h = h'`. When :math:`f` is a monomorphism we often say :math:`f` is "mono" and write :math:`f: A ↣ B`.

    monotone function
      Given :term:`posets <poset>` :math:`⟨A, ≤ᴬ⟩` and :math:`(B, ≤ᴮ)` we say that a function :math:`f: A → B` is **monotone** from :math:`⟨A, ≤ᴬ⟩` to :math:`⟨B, ≤ᴮ ⟩` when for any :math:`x, y ∈ A` we have that :math:`x ≤ᴬ y` implies that :math:`f(x) ≤ᴮ f(y)`.
      
      (See also :term:`monotone increasing function`.)

    morphism
      If :math:`𝔸 = ⟨A, F^𝔸⟩` and :math:`𝔹 = ⟨B, F^𝔹⟩` are :term:`algebraic structures <algebraic structure>` in the :term:`signature` :math:`σ = (F, ρ)`, then a **morphism** (or **homomorphism**) :math:`h: 𝔸 → 𝔹` is a function from :math:`A` to :math:`B` that preserves (or commutes with) all operations; that is, for all :math:`f∈ F`, for all :math:`a_1, \dots, a_{ρ f} ∈ A`,

      .. math:: f^𝔹 (h\,a_1, \dots, h\,a_{ρ f}) = h f^𝔸(a_1, \dots, a_{ρ f}).
      
    middle linear map
      If :math:`B_r` and :math:`_rC` are modules over a ring :math:`R`, and :math:`A` is an abelian group, then a **middle linear** map from :math:`B × C` to :math:`A` is a function :math:`f: B × C → A` such that for all :math:`b, b_1, b_2 ∈ B` and :math:`c, c_1, c_2 ∈ C` and :math:`r ∈ R`:

      .. math:: f(b_1 + b_2, c) &= f(b_1,c) + f(b_2,c)\\
                f(b, c_1 + c_2) &= f(b,c_1) + f(b,c_2)\\
                       f(br, c) &= f(b,rc)

    module
      A **module** :math:`M` over a :term:`ring` :math:`R` is...

    monotone increasing function
      A real- or extended real-valued function :math:`f` deifned on :math:`ℝ` is called **monotone increasing** (or **monotonically increasing**) on the interval :math:`[a,b] ⊆ ℝ` if :math:`a≤ x < y ≤ b` implies :math:`f(x) ≤ f(y)`.
      
      (See also :term:`monotone function`.)

    multiplicative inverse
      Let :math:`𝔸 = ⟨ A, e, ∘, \dots ⟩` be an algebra in a signature with a nullary "identity" operation :math:`e: () → A` and a binary "multiplication" operation :math:`∘: A × A → A`. Then the element :math:`b ∈ A` is a **multiplicative inverse** of :math:`a ∈ A` provided :math:`a ∘ b = e = b ∘ a`.

    mutually singular
      Suppose :math:`λ_1` and :math:`λ_2` are measures on :math:`𝔐` and suppose there exists a pair of disjoint sets :math:`A` and :math:`B` such that :math:`λ_1` is :term:`concentrated` on :math:`A` and :math:`λ_2` is concentrated on :math:`B`. Then we say that :math:`λ_1` and :math:`λ_2` are **mutually singular** and we write :math:`λ_1 ⟂ λ_2`.

    natural isomorphism
      An isomorphism in a functor category is referred to as a **natural isomorphism**.
      
    natural transformation
      Given :term:`functors <functor>` :math:`F, G : \mathcal C → \mathcal D`, a **natural transformation** :math:`α : F ⇒ G` is a family :math:`\{α_A : A ∈ \mathcal C_{\mathrm{obj}}\}` of morphisms in :math:`\mathcal D` indexed by the objects of :math:`\mathcal C` such that, for each :math:`A ∈ \mathcal C_{\mathrm{obj}}`, the map :math:`\alpha_A` is a morphism from :math:`FA` to :math:`GA` satisfying the *naturality condition*, :math:`Gf ∘ α_A = α_B ∘ Ff`, for each :math:`f : A → B` in :math:`\mathcal C_{\mathrm{mor}}`. We shall write :math:`α : F ⇒ G : \mathcal C → \mathcal D` to indicate that α is a natural transformation from :math:`F` to :math:`G`, where :math:`F, G : \mathcal C → \mathcal D`.

    naturally isomorphic
      If there is a natural isomorphism between the functors :math:`F` and :math:`G`, then we call :math:`F` and :math:`G` **naturally isomorphic**.

    negative part
      The **negative part** of :math:`f: X → [-∞, ∞]` is the function that is denoted and defined for each :math:`x∈ X` by :math:`f^-(x) = \max\{-f(x),0\}`.
      
      Observe that :math:`f` is :term:`measurable <measurable function>` if and only if both the :term:`positive <positive part>` and negative parts of :math:`f` are measurable. Also, :math:`f^+, f^-: X → [0, ∞]`, :math:`f = f^+ - f^-`, and :math:`|f| = f^+ + f^-`.

    negligible
      A :term:`measurable set` is called **negligible** if it has measure 0.

    neighborhood
      A **neighborhood** of a point :math:`p` in a :term:`topological space` :math:`X` is a set :math:`A` in :math:`X` whose :term:`interior` contains :math:`p`; that is, :math:`p ∈ A^o`. [3]_

    nonnegative function
      A function :math:`f: X → ℝ` such that :math:`f(x) ≥ 0` for all :math:`x∈ ℝ` is called a **nonnegative function**.  We use the shorthand :math:`f ≥ 0` to denote that :math:`f` is a nonnegative function.

    norm
      Let :math:`X` be a :term:`vector space` over the :term:`field` :math:`F`, and let :math:`|\,⋅\,|: F → [0,∞)` be a :term:`valuation` on :math:`F`.  A **norm** on :math:`X` is a function :math:`\|\;\|: X → [0, ∞)` that satisfies the following conditions:

      #. :math:`\|x + y\| ≤ \|x\| + \|y\|`, for all :math:`x, y ∈ X`;
      #. :math:`\|α x\| = |α| \|x\|`, for all :math:`x ∈ X` and :math:`α ∈ F`;
      #. :math:`\|x\| = 0` if and only if :math:`x = 0`.

      Thus, a norm is a :term:`seminorm` satisfying: :math:`\|x\| = 0` only if :math:`x = 0`.

    normed linear space
      A **normed linear space** (or **normed vector space**) is a pair :math:`(X, \|\,⋅\,\|)` consisting of a :term:`vector space` :math:`X` and a :term:`norm` :math:`\|\,⋅\,\|` defined on :math:`X`.

    normed vector space
      See :term:`normed linear space`.

    nowhere dense
      A set :math:`G` is **nowhere dense** in :math:`X` if the :term:`closure` of :math:`G` contains no nonempty open subsets of :math:`X`. Equivalently, the :term:`interior` of the closure of :math:`G` is empty (in symbols, :math:`Ḡ^o = ∅`).

    nullary operation
      An operation :math:`f` on a set :math:`A` is called **nullary** if the arity of :math:`f` is 0; that is, :math:`f: () → A`; equialently, :math:`f` takes no arguments, so is simply a (constant) element of :math:`A`.

    NuPRL
      An :term:`extensional`, :term:`predicative` :term:`ITP` supporting :term:`dependent types <dependent type>` and based on Martin Lof type theory; url: http://www.nuprl.org/

    ω-chain
      Let :math:`⟨ X, ≤ ⟩` be a preordered set. An ω-**chain** is an enumerable :term:`chain`; that is, a :term:`chain` the elements that can be indexed by the natural numbers.

    ω-chain cocomplete
      A :term:`preorder` in which joins of all ω-chains exist is called ω-**chain cocomplete**.

    ω-chain cocomplete poset
      an :term:`antisymmetric` :term:`ω-chain cocomplete` :term:`preorder`.

    open ball
      Let :math:`(X, d)` be a :term:`metric space`. If :math:`x ∈ X` and :math:`r > 0` are fixed, then the set denoted and defined by :math:`B(x, r) = \{y ∈ X ∣ d(x,y) < r\}` is called the **open ball** with center :math:`x` and radius :math:`r`.

    open covering
      See :term:`covering`.

    open mapping
      Let :math:`X` and :math:`Y` be metric or topological spaces.  A set function :math:`T: 𝒫(X) → 𝒫(Y)` is called an **open mapping** if :math:`T(G)` is open in :math:`Y` for every open :math:`G ⊆ X`.

    open set
      A subset :math:`V` of a metric or topological space is called **open** if for every :math:`x ∈ V` there is an open ball contained in :math:`V` that contains :math:`x`.

      For a metric space :math:`(X,d)` this means that a set :math:`V` is open iff for every :math:`x ∈ V` there exists :math:`δ > 0` such that

      .. math:: B(x,δ) := \{y ∈ X ∣ d(x,y) < δ\} ⊆ V

      For a topological space :math:`(X, τ)` the open sets are the sets belonging to the topology :math:`τ`.

    operator norm
      If :math:`X` and :math:`Y` are :term:`normed linear spaces <normed linear space>`, then the space :math:`𝔅(X,Y)` of :term:`bounded linear transformations <bounded linear transformation>` is a :term:`vector space` and the function :math:`T ↦ \|T\|` defined by

      .. math:: \|T\| = \sup \{ \|Tx\| : \|x\| = 1 \}

      is a :term:`norm` on :math:`𝔅(X,Y)`, called the **operator norm**.

      There are other, equivalent ways to express the operator norm; e.g.,

      .. math:: \|T\| = \sup \{ \frac{\|Tx\|}{\|x\|} : x ≠ O\} = \inf \{ C : \|Tx\| ≤ C\|x\| \text{ for all } x\}.

    opposite category
      Given a category :math:`\mathcal C` the **opposite** (or **dual**) **category** :math:`\mathcal C^{\mathrm{op}}` has the same objects as :math:`\mathcal C` and whenever :math:`f: A → B` is a morphism in :math:`\mathcal C` we define :math:`f : B → A` to be a morphism in :math:`\mathcal C^{\mathrm{op}}`.

    orthogonal set
      Let :math:`(X, ⟨⋅, ⋅⟩)` be an :term:`inner product space`. A subset :math:`Q ⊆ X` is called **orthogonal** provided :math:`⟨ 𝐮, 𝐯 ⟩ = 0` for all :math:`𝐮 ≠ 𝐯` in :math:`Q`.
      
    orthonormal basis
      A maximal :term:`orthonormal set` in a :term:`Hilbert space` is known as an **orthonormal basis**. 

    orthonormal set
      Let :math:`(X, ⟨⋅, ⋅⟩)` be an :term:`inner product space`. An :term:`orthogonal set` :math:`U ⊆ X` is called **orthonormal** provided :math:`\|u\| = 1` for all :math:`𝐮 ∈ U`.
      
      In other terms, a subset :math:`Q ⊆ X` is called **orthonormal** provided for all :math:`𝐮, 𝐯 ∈ Q`,

      .. math:: ⟨ 𝐮, 𝐯 ⟩ = \begin{cases} 0,& 𝐮 ≠ 𝐯,\\
                                         1,& 𝐮 = 𝐯. \end{cases}

      Every inner product space has a maximal orthonormal set.

    outer measure
      An **outer measure** on a nonempty set :math:`X` is a function :math:`μ^∗: 𝒫(X) → [0, ∞]` that satisfies

      #. :math:`μ^∗ ∅ = 0`,
      #. :math:`μ^∗ A ≤ μ^∗ B` if :math:`A ⊆ B ⊆ X`,
      #. :math:`μ^∗\bigl(⋃_{i=1}^∞ A_i\bigr) ≤ ∑_{i=1}^∞ μ^∗ A_i` if :math:`A_i ⊆ X` for all :math:`1 ≤ i ≤ ∞`.

    parallel morphisms
      Morphisms :math:`f,g : A → B` are called **parallel morphisms** just in case :math:`\mathrm{src} f = \mathrm{src} g` and :math:`\mathrm{tar} f = \mathrm{tar} g`.
 
    partial function
      A **partial function** from :math:`A` to :math:`B` is a total function on some (potentially proper) subset :math:`\dom_f` of :math:`A`.

    partial order
      See :term:`partial order`.

    partial ordering
      A **partial ordering** (or "partial order") is an :term:`antisymmetric` :term:`preorder`.
      
    partially ordered set
      A **partially ordered set** (or "poset") :math:`⟨X, R⟩` is a set :math:`X` along with a :term:`partial ordering` :math:`R` defined on :math:`X`.

    Pi type
      The **Pi type** :math:`Π(x:A),B x`, also known as a **dependent function type**, is a dependent type that generalizes the type :math:`A → B`; it is a :term:`dependent type` because the codomain :math:`B x` depends on the value :math:`x`.
      
      (See also the `Dependent Types`_ section of the `TPL`_ tutorial.)

    point
      Given a category with an initial object :math:`\mathbf{1}` and another object :math:`A`, the morphisms with domain :math:`\mathbf{1}` and codomain :math:`A` are called the **points** or **global elements** of :math:`A`.

    pointwise limit
      Let :math:`f_n: X → [-∞, ∞]` for each :math:`n∈ ℕ`. If the limit :math:`f(x) = \lim_{n→∞} f_n(x)` exist at every :math:`x ∈ X`, then we call :math:`f: X → ℝ` the **pointwise limit** of the sequence :math:`\{f_n\}`. 

    polymorphic function
      a function that operates in the "same way" independently of the object parameter.

    polymorphic type
      (to do: fill in definition)

    poset
      A **poset** :math:`⟨X, ⊑⟩` consists of a set :math:`X` and an :term:`antisymmetric` :term:`preorder` :math:`⊑` on :math:`X`.

    positive measure
      See :term:`measure`.

    positive part
      The **positive part** of :math:`f: X → [-∞, ∞]` is the function that is denoted and defined for each :math:`x∈ X` by :math:`f^+(x) = \max\{f(x),0\}`.
      
      Observe that :math:`f` is :term:`measurable <measurable function>` if and only if both the positive and :term:`negative <negative part>` parts of :math:`f` are measurable. Also, :math:`f^+, f^-: X → [0, ∞]`, :math:`f = f^+ - f^-`, and :math:`|f| = f^+ + f^-`.
      
    powerset functor
      The **(covariant) powerset functor** is a :term:`functor` :math:`P: \mathbf{Set} → \mathbf{Set}` such that for each :term:`morphism` :math:`f: A → B` the morphism :math:`P f : 𝒫(A) → 𝒫(B)` is given by :math:`P f(S) = \{f(x): x ∈ S\}` for each :math:`S ⊆ A`.

    power set operator
      The **powerset operator** :math:`𝒫` maps a class :math:`X` to the class :math:`𝒫 (X)` of all subsets of :math:`X`.
 
    predicative
      The opposite of :term:`impredicative`, *predicative* refers to building stratified (or ramified) theories where quantification over lower levels results in variables of some new type, distinguished from the lower types that the variable ranges over.

    preorder
      A **preorder** on a set :math:`X` is a :term:`reflexive` and :term:`transitive` subset of :math:`X × X`.

    preserves
      See :term:`respects`.

    product
      Given two objects :math:`A` and :math:`B` a **product** of :math:`A` and :math:`B` is defined to be an object, :math:`A × B`, along with :term:`morphisms <morphism>` :math:`π_1: A × B → A` and :math:`π_2: A × B → B` such that for every object :math:`X` and all morphisms :math:`f: X → A` and :math:`g: X → B` there exists a unique morphism :math:`⟨f,g⟩: X → A × B` such that :math:`p_1 ∘ ⟨f,g⟩ = f` and :math:`p_2 ∘ ⟨f,g⟩ = g`.
      
    product σ-algebra
      Let :math:`(X, 𝔐, μ)` and :math:`(Y, 𝔑, ν)` be :term:`measure spaces <measure space>`. If we want to make the product :math:`X × Y` into a :term:`measurable space`, we naturally consider the :term:`σ-algebra` generated by the sets in :math:`𝔐 × 𝔑 = \{A × B ⊆ X × Y ∣ A ∈ 𝔐, B ∈ 𝔑\}`, and we *define* :math:`𝔐 ⊗ 𝔑 := σ(𝔐 × 𝔑)`; that is, :math:`𝔐 ⊗ 𝔑` is the :term:`σ-algebra` generated by :math:`𝔐 × 𝔑`.  [4]_
  
    product topology
      Let :math:`\{(X_λ, τ_λ)\}_{λ∈ Λ}` be a collection of :term:`topological spaces <topological space>` indexed by a set :math:`Λ`. The **product topology** on the :term:`Cartesian product` :math:`∏_{λ∈ Λ}X_λ` is the topology that has a :term:`base` consisting of sets of the form :math:`∏_{λ∈Λ}V_λ`, where :math:`V_λ ∈ τ_λ` and :math:`V_λ = X_λ` for all but finitely many :math:`λ`.

      Equivalently, the product topology is the weakest topology that makes all the projection maps :math:`π_λ(\mathbf x) = x_λ` continuous.  In other words, if :math:`Π` denotes the :term:`clone` of all projection operations on :math:`∏_{λ ∈ Λ} X_λ`, then the product topology is the :math:`Π`-topology.

    projection operation
      The :math:`i`**-th** :math:`k`**-ary projection operation on** :math:`A` is denoted by :math:`π^k_i: (k → A) → A` and defined for each :math:`k`-tuple :math:`a: k → A` by :math:`π^k_i \, a  = a\, i`.  

    projection operator
      If :math:`σ: k → n` is a :math:`k`-tuple of numbers in the set :math:`n = \{0, 1, \dots, n-1\}`, then we can compose an :math:`n`-tuple :math:`a ∈ ∏_{0≤i<n} A_i` with :math:`σ` yielding :math:`a ∘ σ ∈ ∏_{0≤i<k} A_{σ\, i}`.

      The result is a :math:`k`-tuple whose :math:`i`-th component is :math:`(a ∘ σ)(i) = a(σ(i))`.

      If :math:`σ` happens to be one-to-one, then we call the following a **projection operator**:

      .. math:: \Proj\, σ: ∏_{0≤i< n} A_i → ∏_{0≤i<k} A_{σ\, i};  \ \ a ↦ a ∘ σ.

      That is, for :math:`a ∈ ∏_{0≤i<n} A_i` we define :math:`\Proj\,σ\, a = a ∘ σ`.

    proof assistant
      See :term:`ITP`.

    proofs-as-programs
      In :term:`type theory`, constructing a proof of a proposition ``P`` is equivalent to constructing an inhabitant of the type to which ``P`` corresponds (under the :term:`propositions-as-types` correspondence). The construction of such a proof ``p: P`` is viewed as a program that computes ``p`` as output.
      
      (See also https://ncatlab.org/nlab/show/proofs+as+programs and :term:`Curry-Howard correspondence` and :term:`propositions-as-types`.)

    proof tactic    
      an automated procedure for constructing and manipulating proof terms.

    propositions-as-types
      In :term:`type theory`, the propositions-as-types correspondence says that propositions and types are essentially the same. A proposition, when viewed as a type, is identified with the collection (or type) of all its proofs, and a type is identified with the proposition that there exists something of that type.
      
      (See also https://ncatlab.org/nlab/show/propositions+as+types and :term:`Curry-Howard correspondence` and :term:`proofs-as-programs`.)

    proposition extensionality
      This axiom asserts that when two propositions imply one another, they are actually equal. This is consistent with set-theoretic interpretations in which any element ``a:Prop`` is either empty or the singleton set ``{*}``, for some distinguished element ``*``. The axiom has the effect that equivalent propositions can be substituted for one another in any context.
      
      (See also the `Proposition Extensionality <https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#propositional-extensionality>`_ section of the :term:`TPIL`.)

    quotient
      If :math:`R` is an :term:`equivalence relation` on :math:`A`, then the **quotient** of :math:`A` modulo :math:`R` is denoted by :math:`A/R` and is defined to be the collection :math:`\{ a/R ∣ a ∈ A \}` of :term:`equivalence classes <equivalence class>` of :math:`R`.

    record
      See :term:`structure`.

    recursor
      Each :term:`inductively defined type <inductive type>` ``T`` is accompanied by an elimination principle known as a **recursor** (denoted by ``T.rec`` in Lean). It is what makes the type "inductive" by allowing us to define a function on ``T`` by assigning values for each of ``T``'s constructors.
      
      (See also :numref:`inductively-defined-types`.)

    reduct
      Given two :term:`algebras <algebraic structure>` :math:`𝔸` and :math:`𝔹`, we say that :math:`𝔹` is a **reduct** of :math:`𝔸` if both algebras have the same universe and :math:`𝔹` can be obtained from :math:`𝔸` by removing  operations.

    reflexive
      A binary relation :math:`R` on a set :math:`X` is called **reflexive** provided :math:`∀ x ∈ X, \ x \mathrel{R} x`.

    relation
      Given sets :math:`A` and :math:`B`, a **relation** from :math:`A` to :math:`B` is a subset of :math:`A × B`.

    relational product
      Given relations :math:`R : A → B` and :math:`S : B → C` we denote and define the **relational product** (or **composition**) of :math:`S` and :math:`R` to be :math:`S ∘ R = \{(a,c) : (∃ b ∈ B) a \mathrel{R} b ∧ b \mathrel{S} c \}`.

    relational structure
      A relational structure :math:`𝔸 = ⟨A, ℛ⟩` is a set :math:`A` together with a collection :math:`ℛ` of relations on :math:`A`.

    relative topology
      If :math:`(X, τ)` is a :term:`topological space` and :math:`Y ⊆ X`, then :math:`τ_Y := \{V ∩ Y ∣ V ∈ τ\}` is a topology on :math:`Y`, called the **relative topology** induced by :math:`τ`.

    respects
      Given a function :math:`f: α → α`, we say that :math:`f` **respects** (or **preserves**) the binary relation :math:`R ⊆ α × α`, and we write :math:`f ⊧ R`, just in case :math:`∀ x, y :α \ (x \mathrel R y \ → \ f x \mathrel R f y)`.
        
      (The symbol ⊧ is produced by typing ``\models``.)

      If :math:`f: (β → α) → α` is a :math:`β`-ary operation on :math:`α`, we can extend the definition of ":math:`f` respects :math:`R`" in the obvious way.
      
      First, for every pair :math:`u : β → α` and :math:`v : β → α` (:math:`β`-tuples of :math:`α`), we say that :math:`(u, v)` "belongs to" :math:`R ⊆ α × α` provided
      
      .. math:: ∀ i: β \ ui \mathrel R vi
      
      Then we say :math:`f:  (β → α) → α` **respects** (or **preserves**) the binary relation :math:`R ⊆ α × α`, and we write :math:`f ⊧ R`, just in case :math:`∀ u, v, \ [(∀ i: β, \ u i \mathrel R v i) \ → \ f u \mathrel R f v]`.
        
    retraction
      todo: insert definition

    retract
      todo: insert definition

    right module
      A **right module** :math:`M` over a :term:`ring` :math:`R` is...

    ring
      An algebra :math:`⟨R, \{0, -, +, ⋅\}⟩` is called a **ring** just in case the following conditions hold:

      #. the reduct :math:`⟨R, \{0, -,+\}⟩` is an abelian group,
      #. the reduct :math:`⟨R, ⋅ ⟩` is a semigroup, and
      #. "multiplication" :math:`⋅` distributes over "addition" :math:`+`; that is, :math:`∀ a, b, c ∈ R`, :math:`a ⋅ (b+c) = a ⋅ b + a ⋅ c` and :math:`(a+b)⋅ c = a ⋅ c + b ⋅ c`.

    ring of sets
      A nonempty collection :math:`R` of subsets of a set :math:`X` is said to be a **ring** if :math:`A, B ∈ R` implies :math:`A ∪ B ∈ R` and :math:`A-B ∈ R`.

    ring with unity
      A **ring with unity** (or **unital ring**) is an algebra :math:`⟨R, \{0, 1, -, +, ⋅\}⟩` with a ring :term:`reduct` :math:`⟨R, \{0, -, +, ⋅\}⟩` and a *multiplicative identity* :math:`1 ∈ R`; that is :math:`∀ r ∈ R`, :math:`r ⋅ 1 = r = 1 ⋅ r`.

    second category
      A set :math:`G` is of the **second category** if it is not of the :term:`first category`.

    section
      For a set :math:`E ⊆ X × Y`, the **x-section** of :math:`E` at the point :math:`t` is defined as follows:

      .. math:: G_t = \{y ∈ ℝ: (x,y) ∈ E \text{ and } x=t\}.

    self-adjoint 
      A linear transformation of a :term:`Hilbert space` :math:`ℋ` to itself is called self-adjoint just in case :math:`∀ x, y ∈ ℋ, ⟨x, Ty⟩ = ⟨Tx, y⟩`.

    self-dual
      A normed linear space :math:`X` is called **self-dual** provided :math:`X ≅ X^∗`.
      
      A category :math:`𝒞` is called **self-dual** if :math:`𝒞^{\mathrm{op}} = 𝒞`.

    semigroup
      A :term:`magma` whose binary operation is associative is called a **semigroup**.  That is, a semigroup is a magma :math:`⟨A, ⋅⟩` whose binary operation satisfies :math:`∀ a, b, c ∈ A`, :math:`(a ⋅ b) ⋅ c = a ⋅ (b ⋅ c)`.

    seminorm
      Let :math:`X` be a :term:`vector space` over the :term:`field` :math:`F`.  A **seminorm** on :math:`X` is a function :math:`\|\;\|: X → [0, ∞)` that satisfies
      
      #. :math:`\|x + y\| ≤ \|x\| + \|y\|`, for all :math:`x, y ∈ X`;
      #. :math:`\|α x\| = |α| \|x\|`, for all :math:`x ∈ X` and :math:`α ∈ F`.

    semiring of sets
      A collection :math:`S` of subsets of a nonempty set :math:`X` is called a **semiring** if it satisfies the following properties:
      
      #. :math:`∅ ∈ S`;
      #. :math:`A, B ∈ S \; ⟹ \; A ∩ B ∈ S`;
      #. :math:`A, B ∈ S \; ⟹ \; ∃ C_1, \dots, C_n ∈ S`, :math:`A-B = ⋃_{i=1}^n C_i` and :math:`∀ i≠j, \,C_i ∩ C_j = ∅`.

    separable
      An infinite :term:`Hilbert space` is called **separable** if it has a countable :term:`orthonormal basis`.

    separates the points
      We say that a collection :math:`S` of subsets of :math:`X` **separates the points** of :math:`X` if for every pair :math:`p, q` of distinct points in :math:`X` there exist disjoint sets :math:`S_1, S_2∈ S` such that :math:`p ∈ S_1` and :math:`q∈ S_2`.

      Let :math:`F` be a field.  We say that a collection :math:`𝔄⊆ F^X` of :math:`F`-valued functions **separates the points** of :math:`X` if for every pair :math:`p, q` of distinct points in :math:`X` there exists :math:`f ∈ 𝔄` such that :math:`f(u) ≠ f (v)`. 
      
    σ-algebra
      A collection :math:`𝔐` of subsets of a nonempty set :math:`X` is called a **σ-algebra** if it satisfies the following conditions:
     
      #. :math:`X ∈ 𝔐`;
      #. if :math:`A ∈ 𝔐` then :math:`A^c:= X - A` of :math:`A` also belongs to :math:`𝔐`.
      #. if :math:`A_n ∈ 𝔐` for :math:`n ∈ ℕ`, then :math:`⋃_{n = 0}^∞ A_n ∈ 𝔐`.

      Equivalently, a **σ-algebra** of sets is an :term:`algebra of sets` that is closed under countable unions.
      
      (For the algebraic meaning of the term :math:`σ`-algebra, see the definition of :term:`algebraic structure`.)

    Sigma type
      The **Sigma type** :math:`Σ(x:A),B x`, also known as the **dependent pair type**, generalizes the Cartesian product :math:`A × B` by allowing the type :math:`B x` of the second argument of the ordered pair to depend on the value :math:`x` of the first.
      
      (See also the `Dependent Types`_ section of the `TPL`_ tutorial.)

    σ-finite measure
      If :math:`(X, 𝔐, μ)` is a :term:`measure space`, then :math:`μ` is a **σ-finite measure** provided :math:`X = ⋃_j E_j` for some :math:`E_j ∈ 𝔐` such that :math:`μ E_j < ∞` for all :math:`1≤ j < ∞`.
      
    signature
      a pair :math:`σ = (F, ρ)` consisting of a collection :math:`F` of operation symbols and an :term:`arity` function :math:`ρ : F → β` that maps each operation symbol to its arity; here, :math:`β` denotes the arity type.

    signed measure
      Let :math:`(X, 𝔐)` be a :term:`measurable space`. A **signed measure** on :math:`(X, 𝔐)` is a function :math:`ν: 𝔐 → [-∞, ∞]` such that
      
      #. :math:`ν ∅ = 0`;
      #. :math:`ν` assumes at most one of the values :math:`±∞`;
      #. :math:`ν` is countably additive.
      
      The last item means that
      
      .. math:: ν(⋃_j A_j) = ∑_j ν(A_j)
         :label: countably additive
          
      whenever :math:`\{A_j\}` is a collection of disjoint sets in :math:`𝔐`.
      
      Moreover, the sum on the right-hand side of :eq:`countably additive` converges absolutely if the left-hand side of :eq:`countably additive` is finite.

    simple function
      A complex- or real-valued function :math:`s` whose range consists of only finitely many points is called a **simple function**.

      Let :math:`s` be a simple function with domain :math:`X` and suppose :math:`α_1, \dots, α_n` is the set of distinct values of :math:`s`. If we set :math:`A_i = \{x\in X : s(x) = \alpha_i\}`, then clearly

      .. math:: s = ∑_{i=1}^n α_i χ_{A_i},
         :label: simple

      where :math:`χ_{A_i}` is the :term:`characteristic function` of the set :math:`A_i`.
      
      The definition of *simple function* assumes nothing about the sets :math:`A_i`; thus, a simple function is not necessarily measurable.

      Observe also that the function :math:`s` in :eq:`simple` is :term:`integrable` if and only if each :math:`A_i` has finite measure.

    simplex category
      See :term:`finite ordinals`.

    small category
      A category is called **small** if its collections of objects and morphisms are sets.

    source vertex
      Given a directed graph :math:`\mathbf G = (V,E)` and an edge :math:`e=(v_1,v_2) ∈ E`, we refer to :math:`v_1` as the **source vertex** of :math:`e`.

    step function
      A finite linear combination of characteristic functions of bounded intervals of :math:`ℝ` is called a **step function**.

    subadditive
      Let :math:`𝒮 = \{S_λ: λ∈ Λ\}` be a collection of sets and let :math:`R` be a :term:`ring`.  A function :math:`s: 𝒮 → R` is called **subadditive** if for every subset :math:`Γ ⊆ Λ` such that :math:`\{S_γ : γ ∈ Γ\}` is a collection of subsets in :math:`𝒮`, we have
      .. math:: s \bigl( ⋃_{γ∈Γ}  A_γ \bigr) ≤ ∑_{γ∈ Γ} s (A_γ).

    structure
      In Lean, a non-recursive inductive type that contains only one constructor is called a **structure**. In mathematics, a structure may refer to an :term:`algebraic structure` or a :term:`relational structure`.

    subalgebra
      Suppose :math:`𝔸 = ⟨A, F^𝔸⟩` is an algebra. If :math:`B ≠ ∅` is a :term:`subuniverse` of 𝔸, and if we let :math:`F^𝔹 = \{ f ↾ B : f ∈ F^𝔸 \}`, then :math:`𝔹 = ⟨ B, F^𝔹 ⟩` is an algebra, called a **subalgebra** of 𝔸.

    subdcpo
      If :math:`X` is a :term:`dcpo` then the subset :math:`A ⊆ X` is a **subdcpo** of :math:`X` if every directed subset :math:`D ⊆ A` satisfies :math:`⋁_X D ∈ A`.

    subuniverse
      Suppose :math:`𝔸 = ⟨A, F^𝔸⟩` is an algebra. If a subset :math:`B ⊆ A` is closed under :math:`F^𝔸`, then we call :math:`B` a **subuniverse** of :math:`𝔸`.

    symmetric
      A binary relation :math:`R` on a set :math:`X` is called **symmetric** provided :math:`∀ x, y ∈ X \ (x \mathrel{R} y \ → \ y \mathrel{R} x)`;

    target vertex
      Given a directed graph :math:`\mathbf G = (V,E)` and an edge :math:`e=(v_1,v_2)\in E`, we refer to :math:`v_2` as the **target vertex** of :math:`e`.

    terminal object
      An object :math:`\mathbf{1}` is called a **terminal** (or **bound**) **object** if for every object :math:`A` in the same category there exists a unique morphism :math:`⟨\ ⟩_A: A → \mathbf{1}`.

    ternary operation
      An operation :math:`f` on a set :math:`A` is called **ternary** if the arity of :math:`f` is 3; that is, :math:`f: A × A × A → A` (or, in curried form, :math:`f: A → A → A → A`).

    topology
      A **topology** :math:`τ` on a set :math:`X` is a collection of subsets of :math:`X` containing :math:`X` and the empty set, and is closed under finite intersections and arbitrary unions.  That is, :math:`τ` satisfies

      #. :math:`∅ ∈ τ` and :math:`X ∈ τ`;
      #. :math:`\{V_i ∣ i = 1, \dots, n\} ⊆ τ` implies :math:`⋂_{i=1}^n V_i ∈ τ`;
      #. :math:`\{V_α ∣ α ∈ A\} ⊆ τ` implies :math:`⋃_{α∈A} V_α ∈ τ`.

    topological space
      A **topological space** is a pair :math:`(X, τ)` where :math:`X` is a set and :math:`τ` is a :term:`topology` on :math:`X`.

    total function
      Given sets :math:`A` and :math:`B`, a **total function** :math:`f` from :math:`A` to :math:`B` is what we typically mean by a "function" from :math:`A` to :math:`B`.

    total order
      A **total order** relation :math:`R` on a set :math:`X` is a partial order on :math:`X` satisfying :math:`∀ x, y ∈ X \ (x ≤ y \ ⋁ \ y ≤ x)`.

    totally bounded
      A set :math:`E` in a metric space is called **totally bounded** if for every :math:`ε > 0` :math:`E` can be covered with finitely many balls of radius :math:`ε`.

    transitive
      A binary relation :math:`R` on a set :math:`X` is called **transitive** provided :math:`∀ x, y, z ∈ X \ (x \mathrel{R} y ∧ y \mathrel{R} z\ → \ x \mathrel{R} z)`.

    translation invariance
      Let :math:`(X, 𝔐)` be a :term:`measurable space`. Assume there is a binary operation defined on :math:`X`; e.g., addition :math:`+: X× X → X`. A :term:`measure` :math:`μ` on :math:`(X, 𝔐)` is called **translation invariant** provided :math:`μ(E + x) = μ E` holds for all :math:`E ∈ 𝔐` and all :math:`x∈  X`, where :math:`E+x := \{e+x ∣ e∈ E\}`.

    type class
      A **type class** is a family of types; each type in the family is called an :index:`instance` of the type class.  **N.B.** Lean will infer an implicit argument using the type class mechanism if we put the argument in square brackets (instead of curly braces) in the declaration.

    triangle inequality
      Let :math:`(X, \|\,⋅\,\|)` be a metric or normed space.  The inequality :math:`\|x + y\| ≤ \|x\| + \|y\|`, which holds for all :math:`x, y ∈ X` in a metric or normed space, is called the **triangle inequality**.  Equivalently (setting :math:`x = a-b` and :math:`y = b-c`), :math:`\|a - c\| ≤ \|a - b\| + \|b - c\|`.
 
    type theory
      **Type theory** internalizes the interpretation of intuitionistic logic proposed by Brouwer, Heyting, and Kolmogorov---the so-called BHK interpretation. The types in type theory play a similar role to that of sets in set theory but *functions definable in type theory are always computable*.

      Intuitionistic **type theory** extends the :term:`Curry-Howard correspondence` to predicate logic by introducing :term:`dependent types <dependent type>`. 
      
      (See also `ncatlab.org/type+theory <https://ncatlab.org/nlab/show/type+theory>`_.)

    unary operation
      An operation :math:`f` on a set :math:`A` is called **unary** if the arity of :math:`f` is 1; that is, :math:`f: A → A`.

    underlying set functor
      The **underlying set functor** of :math:`𝐌` is denoted by :math:`U(𝐌)`, or by :math:`|𝐌|`; it returns the *universe* of the structure :math:`𝐌`, and for each morphism :math:`f`, :math:`Uf` (or :math:`|f|`) is :math:`f` viewed simply as a function on sets.

    uniformly continuous
      Let :math:`(X, |\, |_X)` and :math:`(Y, |\, |_Y)` be :term:`metric spaces <metric space>`. A function :math:`f : X → Y` is called **uniformly continuous** in :math:`E ⊆ X` if

      .. math:: (∀ ε >0)\, (∃ δ >0)\, (∀ x, x_0 ∈ E) \, (|x - x_0| < δ \, ⟹ \, |f(x) -f(x_0)| < ε).

    unit
      If :math:`⟨R, \{0, 1, -, +, ⋅\}⟩` is a unital ring, an element :math:`r ∈ R` is called a **unit** if it has a multiplicative inverse, that is, there exists :math:`s ∈ R` with :math:`r ⋅ s = 1 = s ⋅ r`.  (We usually denote such an :math:`s` by :math:`r^{-1}`.)

    unital ring
      See :term:`ring with unity`.

    unitary operator
      A **unitary operator** (or **unitary map**) is an :term:`isomorphism` in the category of :term:`Hilbert spaces <Hilbert space>`.
      
      Explicitly, if :math:`ℋ_1` and :math:`ℋ_2` are :term:`Hilbert spaces <Hilbert space>` with :term:`inner products <inner product>` :math:`⟨\,.\,,\,.\,⟩_1` and :math:`⟨\,.\,,\,.\,⟩_2` (reps.), then a **unitary operator** from :math:`ℋ_1` to :math:`ℋ_2` is an invertible :term:`linear transformation` :math:`U: ℋ_1 → ℋ_2` that preserves inner products in the following sense:

      .. math:: ⟨U x, U y⟩_2 = ⟨x, y⟩_1 \; \text{ for all } x, y ∈ ℋ_1.

      By taking :math:`y = x`, we have :math:`\|U x\|_2 = \|x\|_1`.

    universal image functor
      the functor :math:`∀ f : P(A) → P(B)` defined by :math:`∀ f (X) = \{y ∈ B : f^{-1}(\{y\}) \subseteq  X\}`, for :math:`X ∈ P(A)`.

    universal mapping property
      Let :math:`η_A : A → |𝔸^*|` be the function that maps :math:`a ∈ A` to the "one-letter word" :math:`a ∈ A^*`. The :term:`functors <functor>` :math:`K (= \ ^∗)` and :math:`U (= |\ |)` are related by the **universal mapping property** of monoids, which says that for every :term:`monoid` :math:`𝐌` and every function :math:`f : A → U 𝐌` there exists a unique :term:`morphism` :math:`f̂ : KA → 𝐌` such that :math:`f = f̂ ∘ η`.

    universal property
      The **unique morphism property** of the :term:`initial object` in a category is what we refer to as a **universal property,** and we say that the :term:`free object` in a category :math:`𝒞` is "universal" for the category :math:`𝒞`.

    universe
      In :term:`type theory`, everything has a type---even a type has a type.  If ``α`` is a type, then ``α``'s type is ``Type u`` for some **universe** ``u``.  More accurately, the ``u`` here is actually a variable and whatever (natural number) value it takes on will be the universe *level* of the type ``α``.
   
      In universal algebra, the **universe** of an :term:`algebra <algebraic structure>` is the set on which an algebra is defined; e.g., the universe of the algebra :math:`𝔸 = ⟨A, F^𝔸⟩` is :math:`A`.  (N.B. we sometimes use the word **carrier** to mean universe in this sense, which can be helpful when we wish to avoid confusion with the universe levels in `type theory`_.)

    unique morphism property
      See :term:`universal property`.

    universe polymorphism
      We use an example to demonstrate this concept. Given a type ``α``, no matter to which type universe ``α`` belongs, we can form the type ``list α`` of lists of elements of type ``α``, and this type will have the same type universe as ``α``. In other terms, 
      
        ``α: Type u`` if and only if ``list α: Type u``.
        
      The Lean code for this example follows.

      :: 

        universes u v
        variables (α: Type u) (β: Type v)
        #check list      -- Type u_1 → Type u_1
        #check list α    -- Type u
        #check list β    -- Type v

      The variable ``u_1`` ranges over type levels.  As the output of the ``#check`` shows, ``list α`` has ``Type u`` because ``α`` has ``Type u``. Similarly for ``list β``. 
 
    upper limit
      Let :math:`\{a_n\}` be a sequence in :math:`[-∞, ∞]`, and put :math:`b_k = \sup \{a_k, a_{k+1}, \dots\}` for :math:`k∈ ℕ` and :math:`β = \inf \{b_0, b_1, b_2, \dots \}`. We call :math:`β` the **upper limit** (or **limit superior**) of :math:`\{a_n\}`, and write :math:`β = \limsup\limits_{n→ ∞} a_n`.  The :term:`lower limit`, :math:`\liminf\limits_{n→ \infty} a_n` is definied similarly.

      Observe that

        #. :math:`b_0 ≥  b_1 ≥ b_2 ≥ \cdots ≥ β` and :math:`b_k → β` as :math:`k→ ∞`;
        #. there is a subsequence :math:`\{a_{n_j}\}` of :math:`\{a_n\}` that converges to :math:`β` as :math:`j→ ∞` and :math:`β` is the largest number with this property.
        #. :math:`\liminf\limits_{n→∞} a_n = -\limsup\limits_{n→∞} (- a_n)`.

      Suppose :math:`\{f_n\}` is a sequence of extended real-valued functions on a set :math:`X`. Then :math:`\sup\limits_n f_n` and :math:`\limsup\limits_{n→∞}f_n` are the functions that are defined for each :math:`x∈ X` by
      
      .. math:: \left(\sup\limits_n f_n\right)(x) = \sup\limits_n (f_n(x)), \quad  \left(\limsup\limits_n f_n\right)(x) = \limsup\limits_n (f_n(x)).

    valuation
      The `absolute value`_ for real numbers can generalised to an arbitrary field by considering the four fundamental properties of absolute value. Thus, a real-valued function :math:`ν` on a field :math:`F` is called a **valuation** if it satisfies the following four axioms:

      #. :math:`ν(a)≥ 0` (non-negativity); 
      #. :math:`ν(a)=0 \; ⟺ \; a= \mathbf 0` (positive-definiteness); 	
      #. :math:`ν(ab)=ν(a)ν(b)` (multiplicativity);
      #. :math:`ν(a+b)≤ ν(a)+v(b)` (:term:`subadditivity <countably subadditive>`). 	

      Here :math:`\mathbf 0` denotes the additive identity element of :math:`F`. It follows from properties 2 and 3 that :math:`ν(1) = \mathbf 1`, where :math:`\mathbf 1` denotes the multiplicative identity element of :math:`F`. The real and complex absolute values are examples of valuations.

    variety
      A **variety** (or **equational class**) of structures in the language :math:`L` is one that can be axiomatized by a set of equations in :math:`L`.

    vector space
      If :math:`F` is a :term:`field`, then an :math:`F`-:term:`module` is called a **vector space** over :math:`F`.

--------------------------

.. rubric:: Footnotes

.. [1]
   The range of a complex measure is a subset of :math:`ℂ`, while a positive measure takes values in :math:`[0,∞]`. Thus the positive measures do not form a subclass of the complex measures.

.. [2]
   See Rudin :cite:`Rudin:1987` 1.35-6 for a nice discussion of the role played by sets of measure 0.  To summarize that discussion, it may happen that there is a set :math:`N ∈ 𝔐` of measure 0 that has a subset :math:`E ⊆ N` which is not a member of :math:`𝔐`.  Of course, we'd like all subsets of measure 0 to be measurable and have measure 0.  It turns out that in such cases we can extend :math:`𝔐` to include the offending subsets, assigning such subsets measure 0, and the resulting extension will remain a :math:`σ`-algebra.  In other words, we can always *complete* a measure space so that all subsets of negligible sets are measurable and negligible.

.. [3]
   The use of this term is not quite standardized; some (e.g., Rudin :cite:`Rudin:1987`) call any open set containing :math:`p` a "neighborhood of :math:`p`".

.. [4]
   This notation is not completely standard. In :cite:`Aliprantis:1998` (page 154) for example, :math:`𝔐 ⊗ 𝔑` denotes what we call :math:`𝔐 × 𝔑`, while :math:`σ(𝔐 ⊗ 𝔑)` denotes what we have labeled :math:`𝔐 ⊗ 𝔑`. At the opposite extreme, Rudin (in :cite:`Rudin:1987`) simply takes :math:`𝔐 × 𝔑` to be the :term:`σ-algebra` generated by the sets :math:`\{A × B ∣ A ∈ 𝔐, B ∈ 𝔑\}`.

----------------------

.. include:: hyperlink_references.rst
