.. include:: _static/math_macros.rst
.. highlight:: lean
.. role:: cat
.. role:: code

.. _algebras-in-lean:

================
Algebras in Lean
================

Most of the Lean_ code described in this section can be found in the files ``basic.lean`` residing in the ``src`` directory of the lean-ualib_ repository. [1]_

This section demonstrates the utility of dependent and inductive types by expressing some fundamental concepts of universal algebra in Lean.

In particular, we will formally represent each of the following:  *operation*, *algebra*, *subuniverse*, and *term algebra*.

Our formal representations of these concepts will be clear, concise, and computable. Moreover, we strive to develop a notation and syntax that will feel natural to working algebraists.

Our goal here is to demonstrate the power of Lean's type system for expressing mathematical concepts precisely and constructively, and to show that if we make careful design choices at the start of our development, then our formal theorems *and their proofs* can approximate the efficiency and readability of analogous informal presentations found in the mathematics literature.

.. index:: arity, operation
.. index:: airty type, operation symbol type
.. index:: ! type of; operation symbols
.. index:: ! type of; operations
.. index:: ! type of; arities
.. index:: ! type of; natural numbers

----------------------------------------

.. index:: pair: ‚Ñï; œâ
.. index:: pair: œâ; ùóáùñ∫ùóç

.. _operations-in-lean:

Operations in Lean
-------------------

Recall, the symbols ‚Ñï, œâ, and ``nat`` are synonymous and all denote the **type of natural numbers**.

We start with the **type of operation symbols**, which depends on our semantic notion of **arity**, also captured by a type.

Argument lists that are passed to operations are represented by tuples which are simply functions, say, of type ``Œ≤ ‚Üí Œ±``, where ``Œ≤`` is the **arity type** of the operation to which the tuple will be passed as an argument list.

Heuristically, it's fine to think of ``|Œ≤|`` as the "number" of arguments the operation takes, but the implementation is much more general than that. In particular, there is no reason to restrict the arity type to be a finite set, *a priori*.

An **operation** takes a tuple (or, list of "arguments") of type ``Œ≤ ‚Üí Œ±`` and returns an element of type ``Œ±``.  Here, ``Œ±`` is the type on which the operation is defined.

In the `lean-ualib`_, we declare types ``Œ±`` and ``Œ≤`` and then define the type of **Œ≤-ary operations on Œ±** to be ``(Œ≤ ‚Üí Œ±) ‚Üí Œ±``. We denote this type by ``op (Œ≤ Œ±)``.

Before getting to the implementation of the ``op`` type (which resides in the `basic.lean`_ file of the the `lean-ualib`_ library), we declare some Lean :term:`universes <universe>` that we will use throughout the library. (These appear at the top of almost every ``.lean`` files in `lean-ualib`_.)

.. include:: _static/basic.lean.1.rst

The code above is self-explanatory.  We merely declare a few universe "levels" in Lean's *type hierarchy* (:numref:`leans-type-hierarchy`), along with comments indicating the kind of types that we expect will reside in these universes.

(**N.B.** Most of the code listings below will take universe declarations for granted and will not mention them explicitly.) 

.. index:: ! projection operation

Now we define the type of operations and give a simple but important example of an operation of type ``op (Œ≤ Œ±)``---namely, the **Œ≤-ary projection on Œ±**.

.. include:: _static/basic.lean.2.rst

The operation ``œÄ i`` maps each ``Œ≤``-tuple of elements of type ``Œ±`` to its "value" at input ``i``.  For instance, if we have types ``Œ±`` and ``Œ≤``, and inhabitants ``i: Œ≤`` and ``a: Œ≤ ‚Üí Œ±``, then the command ``#check œÄ i a`` shows that the type of ``œÄ i a`` is ``Œ±``, as expected, since ``œÄ i a = a i``.

.. include:: _static/basic.lean.3.rst

The next two examples are a bit more concrete.

.. include:: _static/basic.lean.4.rst

----------------------------------------------------------

.. index:: ! signature, ! operation symbol, ! similarity type
.. index:: ! arity

.. _signatures-in-lean:

Signatures in Lean
------------------

A **signature** :math:`œÉ = (F, œÅ)` consists of

  + a set :math:`F` of **operation symbols**, and
  + a **similarity type** :math:`œÅ: F ‚Üí Œ≤`.
  
For each operation symbol :math:`f : F`, the value :math:`œÅ f` is the **arity** of :math:`f`.  This value has type :math:`Œ≤`, which is the **arity type**.

In classical universal algebra we typically assume that :math:`Œ≤ = ‚Ñï`, but for much of the basic theory this choice is inconsequential. [2]_

.. index:: ! type of; signatures
.. index:: ! arity function

We now implement a type of signatures and a type of operations in Lean_.

Define the **type of signatures** as a structure with two fields, the type ``‚Ñ±`` of operation symbols, and an **arity function** ``œÅ: ‚Ñ± ‚Üí Type w``, which takes each operation symbol ``f: œÉ.‚Ñ±`` to its arity ``œÅ f: Type w``.

.. include:: _static/basic.lean.5.rst

.. index:: type of; interpretations of operations
.. index:: keyword: section
.. index:: keyword: local notation

Later we will define the *type of interpretations of operations* on the :index:`carrier type` ``Œ±``.  For now, we note that by starting a new ``section`` we could define some parameters (such as a fixed signature ``œÉ``) that will be available throughout the section. [3]_


.. index:: pair: variety; equational class
.. index:: pair: algebra; algebraic structure
.. index:: carrier type

-------------------------------------------------------

.. _universal-algebras-in-lean:

Algebras in Lean
----------------

Classical universal algebra is the study of **varieties** (or **equational classes**) of algebraic structures.

Recall from :numref:`Section %s <algebraic-structures>`, an **algebraic structure** (or **algebra**) in the signature :math:`œÉ = (F, œÅ)` is denoted by :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` and consists of 

  + a set :math:`A`, called the **universe** (or **carrier**) of the algebra,
  + a set :math:`F^{ùî∏} = \{f^{ùî∏} ‚à£ f ‚àà F, f^{ùî∏} : (œÅ f ‚Üí A) ‚Üí A\}` of **operations** defined on :math:`A`, and
  + a collection of **identities** satisfied by the elements and operations of ùî∏.

Usually, the algebraic structures we study are **single-sorted**, meaning each structure has only one universe and that universe is of only a single type. Furthermore, in classical algebra, the universes are typically sets. We take the classical theory as our starting point, and although generalizations will eventually be incorporated into ``lean-ualib``, for now we content ourselves with developing and documenting an *accessible* implementation of the classical core of (single-sorted, set-based) universal algebra.

All functions are unary
~~~~~~~~~~~~~~~~~~~~~~~

When working informally, we typically denote an :math:`n`-ary operation by, say, :math:`f(x_0, x_1, \dots, x_{n-1})`, the arguments appearing as an :math:`n`-tuple, :math:`(x_0, x_1, \dots, x_{n-1})`.  However, when computing with functions (and even when not!) this is impractical for a number of reasons.

Functional programming languages like Lean_ are based on the :term:`lambda calculus`.  One reason for this is that there is only one kind of type (the function type); moreoever, every function is a *unary* function.  This has a major advantage for computing: our code need not depend on the arity of a given function.

Representing an :math:`n`-ary function by a unary function can be done in a number of essentially equivalent ways.  One is by :term:`currying`.  Another is by viewing the :math:`n`-tuple (e.g., passed to an :math:`n`-ary function) as a function.  We take the latter approach here (though we will have plenty of opportunities to curry later).

We explain how the correspondence between tuples and functions works using a simple example. [5]_ 

.. proof:example::

    Suppose :math:`A` is a set and :math:`f` is a :math:`œÅ f`-ary operation on :math:`A`. In this case, we often write :math:`f : A^{œÅf} ‚Üí A`.

    Let :math:`Œ≤` be the arity type. If :math:`Œ≤` happens to be ‚Ñï, then :math:`œÅ f = \{0, 1, \dots, œÅf-1\}` and a function :math:`g : œÅf ‚Üí A` is simply a :math:`œÅ f`-tuple of elements of :math:`A`. [6]_
    
    Conversely, for :math:`m : ‚Ñï`, an :math:`m`-tuple :math:`a = (a_0, a_1, \dots , a_{m-1}) : A^m` is (the graph of) the function :math:`a : m ‚Üí A`, defined for each :math:`i < m` by :math:`a\,i = a_i`. 
    
    If :math:`h : A ‚Üí B` and :math:`a : m ‚Üí A`, then :math:`h ‚àò a : m ‚Üí B` is the tuple whose :math:`i`-th value is :math:`(h ‚àò a) i = h\, a\, i = h a_i`, which has type :math:`B`.
    
    If :math:`g : A^m ‚Üí A` and :math:`a : m ‚Üí A`, then the value :math:`g\, a` has type :math:`A`.
    
    Putting it all together, if
    
      + :math:`f : (œÅf ‚Üí B) ‚Üí B` is a :math:`œÅ f`-ary operation on :math:`B`, 
      + :math:`a : œÅf ‚Üí A` is a :math:`œÅ f`-tuple on :math:`A`, and 
      + :math:`h : A ‚Üí B`,
    
    then :math:`h ‚àò a : œÅf ‚Üí B` and :math:`f (h ‚àò a) : B`.

.. index:: ! type of; interpretations of operations

The ``algebra_on`` type
~~~~~~~~~~~~~~~~~~~~~~~

Before defining a type of universal algebras, we first define a type called ``algebra_on`` which will be the **type of interpretations of operations** of a given signature. Our definition of ``algebra_on`` uses a :ref:`dependent function type <pi-type>` (or "Pi type").

Given a signature :math:`œÉ = (F, œÅ)` and a carrier type :math:`Œ±`, an inhabitant of ``algebra_on œÉ Œ±`` is determined by assigning an interpretation to each operation symbol :math:`f : F`.  Such an interpretation is a function of type :math:`(œÅ f ‚Üí Œ±) ‚Üí Œ±` (which *depends* on :math:`f`).

Thus, given a signature :math:`œÉ = (F, œÅ)`, the ``algebra_on Œ±`` type is

.. math:: \prod_{f : F} (œÅ f ‚Üí Œ±) ‚Üí Œ± = \prod_{f : F} \mathrm{op} \,(œÅ f)\, Œ±.

.. code-block:: lean

    def op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    def œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)

    -- BEGIN
    -- algebra_on is the type of algebras on a carrier type
    -- Œ± such that each symbol f is given an interpretation 
    -- as an operation on Œ± with arity œÅ f.
    definition algebra_on (œÉ : signature) (Œ± : Type*) := 
    Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   

      -- An inhabitant of algebra_on assigns to each op symbol 
      -- f : F of arity Œ≤ = œÉ.œÅ f, an interpretation of f, 
      -- that is, a function of type (Œ≤ ‚Üí Œ±) ‚Üí Œ±.
   -- END

.. index:: Pi type

Since the :ref:`dependent function type <pi-type>` or "Pi type" (denoted ``pi`` or ``Œ†`` in Lean_) is among one of the most important types in dependent type theory, let us pause pause for a moment to discuss it.

A **Pi type**, such as :math:`Œ†_{(x:A)} B x`, is also known as a *dependent function type* because it generalizes the function type :math:`A ‚Üí B` by allowing :math:`B x` (the type of the codomain) to depend on a *value* :math:`x : A` of the domain. (See :numref:`Section %s <dependent-types>` for more about dependent types.)
 
Here is how the type ``pi`` is defined in the Lean_ standard library.

.. todo:: check this!

.. code-block:: lean

    variables {Œ± : Type*} {œÄ : Œ± ‚Üí Type*}

    def pi (i : set Œ±) (s : Œ†a, set (œÄ a)) : set (Œ†a, œÄ a) := 
    { f | ‚àÄ a ‚àà i, f a ‚àà s a }

.. (See also :numref:`Appendix Section %s <pi-type>`, for a more technical description of Leans ``pi`` type.)

.. index:: ! type of; universal algebras
.. index:: type of; dependent pairs

.. _the-algebra-type:

The ``algebra`` type
~~~~~~~~~~~~~~~~~~~~~

Finally, let us define the **type of universal algebras** in Lean.

A :index:`universal algebra` :math:`ùî∏ = ‚ü®A,F^ùî∏‚ü©` is a pair consisting of a :index:`carrier` (or :index:`universe`) :math:`A` along with an set :math:`F^ùî∏` of :index:`operations` (i.e., interpretations of the operation symbols in :math:`F`).

Also, our definition should caption the concept of an algebraic structure of any choice of signature. Thus, the type of :math:`‚ü®A,F^ùî∏‚ü©` *depends* on the choice of signature :math:`œÉ = (F, œÅ)`, so it is natural to encode the type of algebras as a :term:`dependent pair <Sigma type>`.

.. code-block:: lean

   def op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   def œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   def algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   

   -- BEGIN
   -- algebra is the type of algebras consisting of a pair: 
   -- a carrier type Œ±, along with an algebra_on Œ± 
   definition algebra (œÉ : signature) := sigma (algebra_on œÉ)
  
     -- The Lean syntax sigma (algebra_on œÉ) denotes the 
     -- dependent pair type, ‚àë (Œ± : Type*) (algebra_on œÉ Œ±).
   -- END

An algebra pairs a carrier with an interpretation of the op symbols.

.. index:: type of; dependent pairs

The type ``sigma`` is the so called :term:`Sigma type`, which is also known as a :term:`dependent pair type`, or :term:`dependent product type`. It is one of the most important types in (dependent) :term:`type theory`, so let's pause for a moment to discuss it.

A **Sigma type** :math:`Œ£_(x:A), B x` is also known as a **dependent pair type** because it generalizes the Cartesian product :math:`A √ó B` by allowing the type :math:`B x` of the second component to depend on the *value* :math:`x` of the first.

Here is how the type ``sigma`` is defined in the Lean_ standard library.

.. code-block:: lean

   structure sigma {Œ± : Type u} (Œ≤ : Œ± ‚Üí Type v) :=
   mk :: (fst : Œ±) (snd : Œ≤ fst)

Sigma is the appropriate type for the ``algebra`` type since an algebra consists of a universe (of type Œ±), along with operations on that universe, and the type of each operation is dependent on the universe type Œ±.

.. index:: keyword: has_coe_to_sort
.. index:: keyword: has_coe_to_fun
.. index:: coercion


Syntactic sugar and coercions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lean_ has a nifty :index:`coercion` feature which we use for the following purpose: if ``A`` is an algebra, Lean_ will try to determine the correct type of the symbol A---either the algebra itself or the universe of the algebra---depending on the context (just as we would when working informally!).

The next bit of code shows how the ``has_coe_to_sort`` and ``has_coe_to_fun`` coercion directives direct Lean_ to yield either the universe of the algebra or the whole algebra, as appropriate for the given context.

.. code-block:: lean

    def op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    def œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
    def algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
    def algebra (œÉ : signature) := sigma (algebra_on œÉ)
 
    -- BEGIN
    -- coercion to universe of œÉ
    -- (essentially the forgetful functor)
    instance alg_carrier (œÉ : signature) : 
    has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
 
    -- coercion to operations of œÉ 
    instance alg_operations (œÉ : signature) : 
    has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
    -- END

Using coercions allows us to identify certain objects which, though not identical, are typically conflated in informal mathematics. In the next section we use coercions to our advantage in a concrete example, but see also `Coercions`_ for a simpler example and for the definitions of ``has_coe_to_sort`` and ``has_coe_to_fun`` in the Lean_ library.

-----------------------------------------------

.. _subalgebras-in-lean:

Subalgebras in Lean
---------------------

The code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of (the ``william`` branch of) the lean-ualib_ repository. 

We will cover subalgebra generation in Lean_, using inductive types, in :numref:`subuniverses-in-lean`.  In the present section we show how to use Lean_ to formally define a subalgebra and test whether a subset is a subuniverse.

We start by importing the definitions described above so that we have signatures and algebras available. We will also need to import the set.lean_ file from the mathlib_ library.  We satisfy these requirements as follows:
 
.. code-block::

   import basic     -- the basic.lean file from lean-ualib
   import data.set  -- the set.lean file from mathlib

Next, we open a ``namespace`` to collect definitions and results related to subuniverses and subalgebras.  This is done using the ``namespace`` directive. We also start a ``section`` so we can fix a signature along with some syntactic sugar. 

.. code-block:: lean

    def op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    def œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
    def algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
    def algebra (œÉ : signature) := sigma (algebra_on œÉ)
    instance alg_carrier (œÉ : signature) : has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
    instance alg_operations (œÉ : signature) : has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
 
    -- BEGIN
    namespace subuniverse
      section sub
 
        parameter {œÉ : signature}
        parameter {Œ± : Type*}
        parameter {I : Type*}
        definition F := œÉ.F
        definition œÅ := œÉ.œÅ 
    
      end sub
    end subuniverse
    -- END

 Although we won't make it explicit, the remainder of this section assumes all Lean_ code (apart from that being imported from another file) is part of the ``subuniverse`` namespace; that is, it occurs inside a block of the form

.. code-block:: lean

   namespace subuniverse

     -- all subuniverse code goes here --

   end subuniverse

We now implement the definition of **subuniverse**. Specifically, we say what it means for a given set ``B‚ÇÄ`` (comprised of elements of the carrier type of an algebra ``A``) to be closed under the operations of ``A``.

.. code-block:: lean

    def op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    def œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
    def algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
    def algebra (œÉ : signature) := sigma (algebra_on œÉ)
    instance alg_carrier (œÉ : signature) : has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
    instance alg_operations (œÉ : signature) : has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameter {œÉ : signature} {Œ± : Type*} {I : Type*}
        definition F := œÉ.F
        definition œÅ := œÉ.œÅ 
        -- BEGIN
        -- subuniverse -----------------------------------
        definition Sub {ùî∏: algebra œÉ} (B‚ÇÄ: set ùî∏): Prop:=
        ‚àÄ (f: F) (a: œÅ f ‚Üí ùî∏), (‚àÄ x, a x ‚àà B‚ÇÄ) ‚Üí (ùî∏ f a) ‚àà B‚ÇÄ
         
        -- ùî∏ f a ‚àà B‚ÇÄ  is syntactic sugar for  B‚ÇÄ (ùî∏ f a).
        -- END
      end sub
    end subuniverse

Notice that we use ``A f`` to denote what, in the informal syntax, is usually denoted by :math:`f^ùî∏`. So, although our Lean_ syntax doesn't match the informal syntax exactly, it is arguably just as elegant, and adapting to it should not overburden the user.

We also want a means of testing whether an algebra defined on a subset :math:`B‚ÇÄ ‚äÜ A` is a subalgebra of ùî∏. (Of course, this is equivalent to testing whether :math:`B‚ÇÄ` is a subuniverse of ùî∏.)

.. code-block:: lean

    def op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    def œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
    def algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
    def algebra (œÉ : signature) := sigma (algebra_on œÉ)
    instance alg_carrier (œÉ : signature) : has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
    instance alg_operations (œÉ : signature) : has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameter {œÉ : signature} {Œ± : Type*} {I : Type*}
        def F := œÉ.F
        def œÅ := œÉ.œÅ 
        def Sub {ùî∏: algebra œÉ} (B‚ÇÄ: set ùî∏): Prop:= ‚àÄ (f: F) (a: œÅ f ‚Üí ùî∏), (‚àÄ x, a x ‚àà B‚ÇÄ) ‚Üí (ùî∏ f a) ‚àà B‚ÇÄ
        -- BEGIN
        -- is subalgebra? -----------------------
        definition is_subalgebra (ùî∏: algebra œÉ) 
        (B‚ÇÄ: set ùî∏) (ùîπ: algebra_on œÉ B‚ÇÄ): Prop:= 
        ‚àÄ f b, ‚Üë(ùîπ f b) = ùî∏ f ‚Üëb
        -- END
      end sub
    end subuniverse

Next, we codify the definition of the subuniverse generated by a set that we saw in :eq:`SgDef` of :numref:`subuniverses`.

.. code-block:: lean

    def op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    def œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
    def algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
    def algebra (œÉ : signature) := sigma (algebra_on œÉ)
    instance alg_carrier (œÉ : signature) : has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
    instance alg_operations (œÉ : signature) : has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameters {œÉ : signature} {Œ± : Type*} {I : Type*}
        def F := œÉ.F
        def œÅ := œÉ.œÅ 
        def Sub {ùî∏: algebra œÉ} (B‚ÇÄ: set ùî∏): Prop:= ‚àÄ (f: F) (a: œÅ f ‚Üí ùî∏), (‚àÄ x, a x ‚àà B‚ÇÄ) ‚Üí (ùî∏ f a) ‚àà B‚ÇÄ
        def is_subalgebra (ùî∏: algebra œÉ) (B‚ÇÄ: set ùî∏) (ùîπ: algebra_on œÉ B‚ÇÄ): Prop:= ‚àÄ f b, ‚Üë(ùîπ f b) = ùî∏ f ‚Üëb
        -- BEGIN
        -- subuniverse generated by X ----------------------
        definition Sg(A: algebra_on œÉ Œ±) (X: set Œ±): set Œ±:= 
        ‚ãÇ‚ÇÄ {U | Sub A U ‚àß X ‚äÜ U}
        -- END
     end
   end subuniverse
   
We now formally prove that the intersection of two subuniverses is a subuniverse.  For this we will need "introduction" and "elimination" rules for the intersection operation ``Inter`` defined in the mathlib_. [7]_  (Naturally, mathlib_ allows us to use the notation ``‚ãÇ`` in place of ``Inter``.)

(See also :numref:`Section %s <intersection-and-union>`, for a more technical description of the intersection operation coercions ``‚ãÇ‚ÇÄ`` in Lean.)

.. code-block:: lean

    def op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    def œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
    def algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
    def algebra (œÉ : signature) := sigma (algebra_on œÉ)
    instance alg_carrier (œÉ : signature) : has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
    instance alg_operations (œÉ : signature) : has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameters {œÉ : signature} {Œ± : Type*} {I : Type*}
        def F := œÉ.F
        def œÅ := œÉ.œÅ 
        def Sub {ùî∏: algebra œÉ} (B‚ÇÄ: set ùî∏): Prop:= ‚àÄ (f: F) (a: œÅ f ‚Üí ùî∏), (‚àÄ x, a x ‚àà B‚ÇÄ) ‚Üí (ùî∏ f a) ‚àà B‚ÇÄ
        def is_subalgebra (ùî∏: algebra œÉ) (B‚ÇÄ: set ùî∏) (ùîπ: algebra_on œÉ B‚ÇÄ): Prop:= ‚àÄ f b, ‚Üë(ùîπ f b) = ùî∏ f ‚Üëb
        def Sg (A : algebra_on œÉ Œ±) (X : set Œ±) : set Œ± := ‚ãÇ‚ÇÄ {U | Sub A U ‚àß X ‚äÜ U}
        -- BEGIN
        -- intersection introduction ---------------------
        theorem Inter.intro {ùî∏: algebra œÉ} {s: I ‚Üí set ùî∏}: 
        ‚àÄ (x: ùî∏), (‚àÄ i, x ‚àà s i) ‚Üí (x ‚àà ‚ãÇ i, s i) :=
        assume x h t ‚ü®j, (eq: t = s j)‚ü©, eq.symm ‚ñ∏ h j

        -- intersection elimination -----------------------------
        theorem Inter.elim {ùî∏: algebra œÉ} {x: ùî∏} {C: I ‚Üí set ùî∏}: 
        (x ‚àà ‚ãÇ i, C i) ‚Üí  (‚àÄ i, x ‚àà C i):= 
        assume h: x ‚àà ‚ãÇ i, C i, by simp at h; apply h
        -- END
     end
   end subuniverse

Now we are ready to prove that the easy but important fact that intersections of subuniverses are subuniverses.

.. code-block:: lean

    definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
    definition algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
    definition algebra (œÉ : signature) := sigma (algebra_on œÉ)
    instance alg_carrier (œÉ : signature) : has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
    instance alg_operations (œÉ : signature) : has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameter {œÉ : signature} {Œ± : Type*} {I : Type*}
        def F := œÉ.F
        def œÅ := œÉ.œÅ 
        def Sub {ùî∏: algebra œÉ} (B‚ÇÄ: set ùî∏): Prop:= ‚àÄ (f: F) (a: œÅ f ‚Üí ùî∏), (‚àÄ x, a x ‚àà B‚ÇÄ) ‚Üí (ùî∏ f a) ‚àà B‚ÇÄ
        def is_subalgebra (ùî∏: algebra œÉ) (B‚ÇÄ: set ùî∏) (ùîπ: algebra_on œÉ B‚ÇÄ): Prop:= ‚àÄ f b, ‚Üë(ùîπ f b) = ùî∏ f ‚Üëb
        def Sg (A : algebra_on œÉ Œ±) (X : set Œ±) : set Œ± := ‚ãÇ‚ÇÄ {U | Sub A U ‚àß X ‚äÜ U}
        theorem Inter.intro {ùî∏: algebra œÉ} {s: I ‚Üí set ùî∏}: ‚àÄ (x: ùî∏), (‚àÄ i, x ‚àà s i) ‚Üí (x ‚àà ‚ãÇ i, s i) :=
        assume x h t ‚ü®j, (eq: t = s j)‚ü©, eq.symm ‚ñ∏ h j
        theorem Inter.elim {ùî∏: algebra œÉ} {x: ùî∏} {C: I ‚Üí set ùî∏}: (x ‚àà ‚ãÇ i, C i) ‚Üí  (‚àÄ i, x ‚àà C i):= assume h: x ‚àà ‚ãÇ i, C i, by simp at h; apply h
        -- BEGIN
        -- Intersection of subuniverses is a subuniverse ---------
        lemma sub_of_sub_inter_sub {ùî∏: algebra œÉ} (C: I ‚Üí set ùî∏): 
        (‚àÄ i, Sub (C i)) ‚Üí Sub (‚ãÇi, C i):= 
        assume h: (‚àÄ i, Sub (C i)), show Sub (‚ãÇi, C i), from
        assume (f: F) (a: œÅ f ‚Üí ùî∏) (h‚ÇÅ: ‚àÄ x, a x ‚àà ‚ãÇi, C i),
        show ùî∏ f a ‚àà ‚ãÇi, C i, from 
          Inter.intro (ùî∏ f a)
          (Œª j, (h j) f a (Œª x, Inter.elim (h‚ÇÅ x) j))
        -- END
      end
    end subuniverse

Here, ``‚ãÇ‚ÇÄ`` is notation for ``sInter (S : set (set Œ±)) : set Œ± := Inf S``, and ``Inf S`` is defined as follows:

``Inf := Œªs, {a | ‚àÄ t ‚àà s, a ‚àà t }``

So, if ``S : set (set Œ±)`` (i.e., a collection of sets of type ``Œ±``), then ``Inf S`` is the intersection of the sets in ``S``.

(See also :numref:`Appendix Section %s <intersection-and-union>`, for a more technical description of the intersection operation coercions ``‚ãÇ‚ÇÄ`` in Lean.)

Next we formalize three obvious facts and their proofs:

  #. ``X`` is a subset of :math:`\Sg^ùî∏ (X)`, 
  #. every subuniverse containing ``X`` also contains :math:`\Sg^ùî∏ (X)`, and 
  #. :math:`\Sg^ùî∏ (X)` is a subuniverse.

(We will give three alternative, but similar, proofs of the second.)

.. code-block:: lean

    definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
    definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
    structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
    definition algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
    definition algebra (œÉ : signature) := sigma (algebra_on œÉ)
    instance alg_carrier (œÉ : signature) : has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
    instance alg_operations (œÉ : signature) : has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameter {œÉ : signature} {Œ± : Type*} {I : Type*}
        def F := œÉ.F
        def œÅ := œÉ.œÅ 
        def Sub {ùî∏: algebra œÉ} (B‚ÇÄ: set ùî∏): Prop:= ‚àÄ (f: F) (a: œÅ f ‚Üí ùî∏), (‚àÄ x, a x ‚àà B‚ÇÄ) ‚Üí (ùî∏ f a) ‚àà B‚ÇÄ
        def is_subalgebra (ùî∏: algebra œÉ) (B‚ÇÄ: set ùî∏) (ùîπ: algebra_on œÉ B‚ÇÄ): Prop:= ‚àÄ f b, ‚Üë(ùîπ f b) = ùî∏ f ‚Üëb
        def Sg (A : algebra_on œÉ Œ±) (X : set Œ±) : set Œ± := ‚ãÇ‚ÇÄ {U | Sub A U ‚àß X ‚äÜ U}
        theorem Inter.intro {ùî∏: algebra œÉ} {s: I ‚Üí set ùî∏}: ‚àÄ (x: ùî∏), (‚àÄ i, x ‚àà s i) ‚Üí (x ‚àà ‚ãÇ i, s i) :=
        assume x h t ‚ü®j, (eq: t = s j)‚ü©, eq.symm ‚ñ∏ h j
        theorem Inter.elim {ùî∏: algebra œÉ} {x: ùî∏} {C: I ‚Üí set ùî∏}: (x ‚àà ‚ãÇ i, C i) ‚Üí  (‚àÄ i, x ‚àà C i):= assume h: x ‚àà ‚ãÇ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {ùî∏: algebra œÉ} (C: I ‚Üí set ùî∏): (‚àÄ i, Sub (C i)) ‚Üí Sub (‚ãÇi, C i):= 
        assume h: (‚àÄ i, Sub (C i)), show Sub (‚ãÇi, C i), from
        assume (f: F) (a: œÅ f ‚Üí ùî∏) (h‚ÇÅ: ‚àÄ x, a x ‚àà ‚ãÇi, C i),
        show ùî∏ f a ‚àà ‚ãÇi, C i, from Inter.intro (ùî∏ f a) (Œª j, (h j) f a (Œª x, Inter.elim (h‚ÇÅ x) j))

        -- BEGIN
        -- Fact 1. X is a subset of Sg·¥¨(X) -------------------
        lemma subset_X_of_SgX {ùî∏: algebra œÉ} (X : set ùî∏): X ‚äÜ Sg X:= 
        assume x (h: x ‚àà X), 
          show x ‚àà ‚ãÇ‚ÇÄ {U | Sub U ‚àß X ‚äÜ U}, from 
            assume W (h‚ÇÅ: W ‚àà {U | Sub U ‚àß X ‚äÜ U}),  
            show x ‚àà W, from 
              have h‚ÇÇ: Sub W ‚àß X ‚äÜ W, from h‚ÇÅ, 
            h‚ÇÇ.right h
    
        -- Fact 2. A subuniverse that contains X also contains Sg·¥¨ X --
        lemma sInter_mem {ùî∏: algebra œÉ} {X: set ùî∏}:
        ‚àÄ R, Sub R ‚Üí X ‚äÜ R ‚Üí (Sg X ‚äÜ R) := 
        assume R (h‚ÇÅ: Sub R) (h‚ÇÇ: X ‚äÜ R),
        show Sg X ‚äÜ R, from 
          assume x (h: x ‚àà Sg X), show x ‚àà R, from 
            h R (and.intro h‚ÇÅ h‚ÇÇ)

        -- An alternative proof of Fact 2. ---------
        lemma sInter_mem' {ùî∏: algebra œÉ} {X: set ùî∏}:
        ‚àÄ R, Sub R ‚àß X ‚äÜ R ‚Üí (Sg X ‚äÜ R):= 
        assume R (hc : Sub R ‚àß X ‚äÜ R),
        have h‚ÇÅ: Sub R, from hc.left,
        have h‚ÇÇ: X ‚äÜ R, from hc.right,
        show Sg X ‚äÜ R, from 
          assume x (h: x ‚àà Sg X), show x ‚àà R, from 
            h R (and.intro h‚ÇÅ h‚ÇÇ)
    
        -- Yet another derivation of Fact 2. ---------
        lemma sInter_mem'' {ùî∏: algebra œÉ} {X: set ùî∏}:
        ‚àÄ x, x ‚àà Sg X ‚Üí ‚àÄ R, Sub R ‚Üí X ‚äÜ R ‚Üí x ‚àà R:= 
        assume x (h‚ÇÅ: x ‚àà Sg X) (R: set ùî∏) (h‚ÇÇ: Sub R) (h‚ÇÉ: X ‚äÜ R), 
        show x ‚àà R, from h‚ÇÅ R (and.intro h‚ÇÇ h‚ÇÉ)
    
        -- Sg·¥¨ X is a subuniverse of A --------------------------
        lemma SgX_is_Sub {ùî∏: algebra œÉ} (X: set ùî∏): Sub (Sg X):= 
        assume (f: F) (a: œÅ f ‚Üí ùî∏) (h‚ÇÄ: ‚àÄ i, a i ‚àà Sg X), 
        show ùî∏ f a ‚àà Sg X, from 
          assume W (h: Sub W ‚àß X ‚äÜ W), show ùî∏ f a ‚àà W, from 
            have h‚ÇÅ: Sg X ‚äÜ W, from 
              sInter_mem' W h,
            have h': ‚àÄ i, a i ‚àà W, from assume i, h‚ÇÅ (h‚ÇÄ i),
            (h.left f a h')
        -- END


----------------------------------------------------------------

.. index:: homomorphism

.. _homomorphisms-in-lean:

Homomorphisms in Lean
---------------------

Using the types defined in the last section, it's not hard to represent the assertion that a function :math:`h : A ‚Üí B` is a `homomorphism <homomorphisms>`_.

We could clean this up a bit by fixing the signature œÉ and algebras ùî∏ and ùîπ in advance, the definition looks a bit cleaner.

.. code-block:: lean

   import data.set
   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª f, f i
   variables (Œ± : Type*) (Œ≤ : Type*) (i : Œ≤) (f : Œ≤ ‚Üí Œ±) 
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   section
     parameter (œÉ : signature)
     local notation `F` := œÉ.F
     local notation `œÅ` := œÉ.œÅ 
     definition algebra_on (Œ± : Type*) := Œ† (f : F), op (œÅ f) Œ±   
     definition algebra := sigma algebra_on
     instance alg_carrier : has_coe_to_sort algebra := ‚ü®_, sigma.fst‚ü©
     instance alg_operations : has_coe_to_fun algebra := ‚ü®_, sigma.snd‚ü©
   end

   -- BEGIN
   variables {œÉ: signature} {A: algebra œÉ} {B: algebra œÉ}

   definition homomorphic (h: A ‚Üí B) :=
   ‚àÄ f a, h (A f a) = B f (h ‚àò a)
   -- END

Comparing this with a common informal language definition of a homomorphism, which is typically something similar to :math:`‚àÄ f \ ‚àÄ a \ h (f^ùî∏ (a)) = f^ùîπ (h ‚àò a)`, we expect working algebraists to find the ``lean-ualib`` syntax quite readable.

Alternatively, we could define ``homomorphic`` so that the signature and algebras are not specified in advance, but instead passed in as arguments. This is demonstrated below, along with a third alternative that makes the types explicit which can sometimes be instructive.

.. code-block:: lean

   import data.set
   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª f, f i
   variables (Œ± : Type*) (Œ≤ : Type*) (i : Œ≤) (f : Œ≤ ‚Üí Œ±) 
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   section
     parameter (œÉ : signature)
     local notation `F` := œÉ.F
     local notation `œÅ` := œÉ.œÅ 
     definition algebra_on (Œ± : Type*) := Œ† (f : F), op (œÅ f) Œ±   
     definition algebra := sigma algebra_on
     instance alg_carrier : has_coe_to_sort algebra := ‚ü®_, sigma.fst‚ü©
     instance alg_operations : has_coe_to_fun algebra := ‚ü®_, sigma.snd‚ü©
   end

   -- BEGIN
   def homomorphic_with_args 
   {œÉ : signature} {A : algebra œÉ} {B : algebra œÉ} 
   (h : A ‚Üí B) := ‚àÄ f a, h (A f a) = B f (h ‚àò a)

   def homomorphic_explicit (h : A ‚Üí B) := 
   ‚àÄ (f : œÉ.F) (a : œÉ.œÅ f ‚Üí A.fst), h (A f a) = B f (h ‚àò a)
   -- END


-------------------------------

.. highlight:: lean

.. include:: _static/math_macros.rst

.. _basic-facts-in-lean:

Basic Facts in Lean
--------------------

In this section we show how to state and prove in Lean the basic facts that we first encountered in :numref:`Chapter %s <basic-facts>`.

.. index:: ! equalizer

Recall, the **equalizer** of the functions :math:`g` and :math:`h` is the set

.. math:: ùñ§(g,h) = \{ a : A ‚à£ g(a) = h(a) \}.

We begin by defining in Lean

#. the equalizer of two functions, ``E``,

#. a homomorphism, ``hom``, and 

#. the equalizer of two homomorphisms, ``E_hom``.

.. include:: _static/subuniverse.lean.1.rst

.. _composition-of-homomorphisms:

Composition of homomorphisms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall the simple fact that composing two homomorphisms results in a homomorphism.

.. include:: _static/homs.lean.1.rst

(As with the other numbered results appearing in this section, we include the statement and proof of the above fact inside the ``basic_facts`` section.)

.. _equalizer-as-subuniverse:

Equalizer as subuniverse
~~~~~~~~~~~~~~~~~~~~~~~~

Next we formally prove that the equalizer ``ùñ§ g h`` of two homomorphisms ``g`` and ``h`` is a subuniverse of ùî∏ (cf. :numref:`Obs %s <obs-one>`).

.. include:: _static/homs.lean.2.rst

.. _homomorphisms-that-agree-on-a-generating-set:

Homomorphisms that agree on a generating set
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall (:numref:`Obs %s <obs-two>`) if two homomorphisms agree on a generating set, then they are equal.

More precisely, if a subset ``X`` is contained in the equalizer of two homomorphisms, then ``Sg X`` is also contained in the equalizer; thus, homomorphisms that agree on ``X`` also agree on ``Sg X``. Let us now state and prove this in Lean.

.. include:: _static/homs.lean.3.rst

Alternatively, we could have proved the last fact using the inductive nature of the definition of subalgebra generated by a set.

Indeed, recall the definition of ``Y`` above and the proof that ``Y X`` is equal to ``Sg X``; thus, properties of the subuniverse generated by the set ``X`` can be proved using the recursor of ``Y``.

.. include:: _static/homs.lean.4.rst

.. _factoring-homomorphisms:

Factoring homomorphisms
~~~~~~~~~~~~~~~~~~~~~~~

Before implementing in Lean the result on factoring homomorphisms (:numref:`Obs %s <obs-four>`), we reiterate that we cannot do so constructively.  Here is a related passage from `Theorem Proving in Lean`_ that explains why.

  "The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces 'data' from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions ``noncomputable`` to flag that fact... To summarize, then, on top of the underlying framework of universes, dependent function types, and inductive types, the standard library adds three additional components:

  #. the axiom of propositional extensionality
  #. a quotient construction, which implies function extensionality
  #. a choice principle, which produces data from an existential proposition.

  The first two of these block normalization within Lean, but are compatible with :term:`byte-code` evaluation, whereas the third is not amenable to computational interpretation."
   
The upshot is that we cannot always use Lean's ``exists.elim`` to produce data.

Nonetheless, we can use Lean's ``classical`` library and the ``noncomputable`` keyword to formalize proofs of nonconstructive results, like :numref:`Obs %s <obs-four>` on factoring homomorphisms.

.. index:: pair: epic; surjective
.. index:: pair: monic; injective
.. index:: bijective

First we define what it means for a function to be **epic** (or **surjective**), **monic** (or **injective**), and **bijective** (i.e., both epic and monic).

.. include:: _static/homs.lean.5.rst

.. index:: inverse, right inverse

Next, we define the (``noncomputable``) **inverse** and **right inverse** and then prove that an epic function has a right inverse.

(The following is also placed inside the ``basic_facts`` section, inside the ``ualib`` namespace.)

.. include:: _static/homs.lean.6.rst

Finally, we are ready to prove the homomorphism factorization lemma of :numref:`Obs %s <obs-four>`.

(Again, this belongs inside the ``basic_facts`` section.)

.. include:: _static/homs.lean.7.rst

-------------------


.. rubric:: Footnotes

.. [1]
   As of this writing (9 June 2019), this documentation describes code residing in (the william_ branch of) the `lean-ualib`_ repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.
   
.. [2]
   We will see very soon that when implementing general operations (e.g., in Lean) it is unnecessary to commit in advance to a specific arity type :math:`N`. An exception is the *quotient algebra type* since, unless we restrict ourselves to finitary operations, lifting a basic operation to a quotient requires some form of choice.

.. [3]
   The  ``section`` command allows us to open a section throughout which our signature ``œÉ`` will be available; ``section`` ends when a matching instance of the keyword ``end`` appears.

.. [5]
   For a more general and detailed treatment of this topic, see :numref:`Section %s <tuple-functors>`.

.. [6]
   Technically, this assumes we identify :math:`g` with its graph, which is fairly common practice. We will try to identify any situations in which the conflation of a function with its graph might cause problems.

.. [7]
   In Gentzen style natural deduction, which is the logical system on which Lean_ is based, "introduction" and "elimination" rules are two fundamental types of rules of deduction.  The *introduction rule for conjunction*, for example, specifies how one *forms* a conjunction in the course of a natural deduction proof, while the *elimination rule for conjunction* specifies how one *uses* a conjunction in a natural deduction proof.
   
.. include:: hyperlink_references.rst
