.. include:: _static/math_macros.rst

.. role:: cat
.. role:: code

.. _algebras-in-lean:

================
Algebras in Lean
================

This section demonstrates the utility of dependent and inductive types by expressing some fundamental concepts of universal algebra in Lean.

In particular, we will formally represent each of the following:  *operation*, *algebra*, *subuniverse*, and *term algebra*.

Our formal representations of these concepts will be clear, concise, and computable. Moreover, we strive to develop a notation and syntax that will feel natural to working algebraists.

Our goal here is to demonstrate the power of Lean's type system for expressing mathematical concepts precisely and constructively, and to show that if we make careful design choices at the start of our development, then our formal theorems *and their proofs* can approximate the efficiency and readability of analogous informal presentations found in the mathematics literature.

Most of the Lean code described in this section can be found in the files ``basic.lean`` and ``subuniverse.lean`` which reside in the ``src`` directory of the lean-ualib_ repository.

.. index:: arity, operation
.. index:: airty type, operation symbol type
.. index:: type of; operation symbols
.. index:: type of; arities
.. index:: type of; natural numbers

----------------------------------------

.. _operations-in-lean:

Operations in Lean
-------------------

Recall, the symbols ‚Ñï, œâ, and ``nat`` are synonymous and all denote the **type of natural numbers**.

We start with the **type of operation symbols**, which depends on our semantic notion of **arity**, also captured by a type.

Argument lists that are passed to operations are represented by tuples which are simply functions, say, of type Œ≤ ‚Üí Œ±, where Œ≤ is the **arity type** of the operation to which the tuple will be passed as an argument list.

Heuristically, it's fine to think of | Œ≤ | as the "number" of arguments the operation takes, but the implementation is much more general than that. In particular, there is no reason to restrict the arity type to be a finite set, *a priori*.

.. index:: ! type of; operations

An **operation** takes a tuple (or, list of "arguments") of type Œ≤ ‚Üí Œ± and returns an element of type Œ±.  Here, Œ± is the type on which the operation is defined.

In the lean-ualib_, given types Œ± and Œ≤, we define the type of **Œ≤-ary operations on Œ±** to be (Œ≤ ‚Üí Œ±) ‚Üí Œ±, and we denote this type by ``op (Œ≤ Œ±)``.

.. code-block:: lean

   -- operation type
   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±

.. index:: ! projection function

A simple but important example of an operation of type ``op (Œ≤ Œ±)`` is the **Œ≤-ary projection on Œ±**, which is defined as follows:

.. code-block:: lean

   -- operation type
   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±

   -- BEGIN
   -- Example Operation (Projection)
   -- Get i-th element of a given tuple ``a``.
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
   -- END

For clarity, it is sometimes helpful to make the types explicit, so we repeat the definition of the Œ≤-ary projection on Œ±, this time showing the types.

.. code-block:: lean

   -- operation type
   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±

   -- BEGIN
   -- (same example but with types shown explicitly)
   definition œÄ {Œ≤ Œ±} (i : Œ≤) : op Œ≤ Œ± := Œª (a : Œ≤ ‚Üí Œ±), a i
   -- END

The operation ``œÄ i`` maps a given tuple ``a: Œ≤ ‚Üí Œ±`` to its "value" ``a i`` at input ``i``.

For instance, if we have types ``Œ±`` and ``Œ≤``, and inhabitants ``i: Œ≤`` and ``a: Œ≤ ‚Üí Œ±``, then the command ``#check œÄ i a`` shows that the type of ``œÄ i a`` is ``Œ±``, as expected, since ``œÄ i a = a i``.

.. code-block:: lean

   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i

   -- BEGIN
   section Example_operation_projection
     parameters (Œ± : Type*) (Œ≤ : Type*) (i : Œ≤) (a : Œ≤ ‚Üí Œ±) 
     #check œÄ i a
   end Example_operation_projection
   -- END

Here are a couple of examples that are a bit more concrete.

.. code-block:: lean

   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i

   -- BEGIN
   -- Example: the tuple p1 = (1, 2, 3, ...).
   definition p1 : ‚Ñï ‚Üí ‚Ñï := Œª n, n+1

   -- What's the 3rd projection of p1?
   #eval œÄ 3 p1                         -- answer: 4

   -- Example: the constant tuple sevens = (7, 7, 7, ...)
   definition sevens : ‚Ñï ‚Üí ‚Ñï := Œª n, 7

   -- What's the 3rd projection of sevens?
   #eval œÄ 3 sevens                      -- answer: 7
   -- END

.. index:: ! signature, ! operation symbol, ! similarity type
.. index:: ! arity

----------------------------------------------------------

.. _signatures-in-lean:

Signatures in Lean
------------------

A **signature** :math:`œÉ = (F, œÅ)` consists of

  + a set :math:`F` of **operation symbols**, and
  + a **similarity type** :math:`œÅ: F ‚Üí Œ≤`.
  
For each operation symbol :math:`f : F`, the value :math:`œÅ f` is the **arity** of :math:`f`.  This value has type :math:`Œ≤`, which is the **arity type**.

In classical universal algebra we typically assume that :math:`Œ≤ = ‚Ñï`, but for much of the basic theory this choice is inconsequential. [1]_

.. index:: ! type of; signatures
.. index:: ! type of; operations
.. index:: ! arity function

We now implement a type of signatures and a type of operations in Lean_.  In the process we compare and contrast the formal and the informal presentations of these concepts.

Define the **type of signatures** as a structure with two fields, the type ``F`` of operation symbols, and an **arity function** ``œÅ : F ‚Üí Type*``, which takes each operation symbol ``f`` to its arity ``œÅ f``.

.. code-block:: lean

   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i

   -- BEGIN
   -- signature type
   -- F : a set of operation symbols
   -- œÅ : returns the arity of a given operation symbol
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   -- END

.. index:: ! type of; interpretations of operations
.. index:: keyword: section
.. index:: keyword: local notation

In the next section, we define the **type of interpretations of operations** on the :index:`carrier type` ``Œ±``.  Before proceeding, however, we note that by starting a new ``section`` we could define some parameters (such as a fixed signature ``œÉ``) that will be available throughout the section. [2]_

.. code-block:: lean

   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   -- BEGIN
   section
     parameter (œÉ : signature)
     local notation `F` := œÉ.F
     local notation `œÅ` := œÉ.œÅ 
   end
    -- END

This enables us to define some ``local notation``, so that we can write ``f : F`` (instead of ``f : œÉ.F``) to indicate that the operation symbol ``f`` has type ``F``; similarly, for the arity of ``f``, we can write ``œÅ f`` (instead of ``œÉ.œÅ f``). This syntactic sugar results in Lean syntax that matches that of informal algebra almost exactly. [3]_ 

.. index:: pair: variety; equational class
.. index:: triple: algebra; structure; universal algebra
.. index:: carrier type

-------------------------------------------------------

.. _universal-algebras-in-lean:

Algebras in Lean
----------------

Classical universal algebra is the study of **varieties** (or **equational classes**) of algebraic structures.

A **universal algebra** (also known as an **algebraic structure**) is denoted by :math:`ùêÄ = ‚ü®A, F^{ùêÄ}‚ü©` and consists of 

  + a set :math:`A`, called the **universe** (or **carrier**) of the algebra,
  + a set :math:`F^{ùêÄ} = \{f^{ùêÄ} ‚à£ f ‚àà F, f^{ùêÄ} : (œÅf ‚Üí A) ‚Üí A\}` of **operations** defined on :math:`A`, and
  + a collection of **identities** satisfied by the elements and operations of ùêÄ.

Usually, the algebraic structures we study are **single-sorted**, meaning each structure has only one universe and that universe is of only a single type. Furthermore, in classical algebra, the universes are typically sets.

Some of the renewed interest in universal algebra has focused on representations of algebras in categories other than :math:`\mathbf{Set}`, such as **multisorted** algebras and higher-type algebras, etc. (:cite:`MR2757312`, :cite:`MR3003214`, :cite:`Finster:2018`, :cite:`Gepner:2018`, :cite:`MR1173632`). These are natural generalizations that will eventually be incorporated into ``lean-ualib``, but for now we content ourselves with developing and documenting an *accessible* implementation of the classical core of (single-sorted, set-based) universal algebra.

One arity to rule them all!
~~~~~~~~~~~~~~~~~~~~~~~~~~~

When working informally, we typically denote an :math:`n`-ary operation by, say, :math:`f(x_0, x_1, \dots, x_{n-1})`, the arguments appearing as an :math:`n`-tuple, :math:`(x_0, x_1, \dots, x_{n-1})`.  However, when computing with functions (and even when not!) this is impractical for a number of reasons.

Functional programming languages like Lean_ are based on the :term:`lambda calculus`.  One reason for this is that there is only one kind of type (the function type); moreoever, every function is a *unary* function.  This has a major advantage for computing: our code need not depend on the arity of a given function.

Representing an :math:`n`-ary function by a unary function can be done in a number of essentially equivalent ways.  One is by :term:`currying`.  Another is by viewing the :math:`n`-tuple (e.g., passed to an :math:`n`-ary function) as a function.  We take the latter approach here (though we will have plenty of opportunities to curry later).

So, let us review how the correspondence between tuples and functions works by way of an example. [4]_ Suppose :math:`A` is a set and :math:`f` is a :math:`œÅ f`-ary operation on :math:`A`. In this case, we often write :math:`f : A^{œÅf} ‚Üí A`.

Let :math:`Œ≤` be the arity type. If :math:`Œ≤` happens to be ‚Ñï, then :math:`œÅ f = \{0, 1, \dots, œÅf-1\}` and a function :math:`g : œÅf ‚Üí A` is simply a :math:`œÅ f`-tuple of elements of :math:`A`. [5]_

Conversely, for :math:`m : ‚Ñï`, an :math:`m`-tuple :math:`a = (a_0, a_1, \dots , a_{m-1}) : A^m` is (the graph of) the function :math:`a : m ‚Üí A`, defined for each :math:`i < m` by :math:`a\,i = a_i`. 

If :math:`h : A ‚Üí B` and :math:`a : m ‚Üí A`, then :math:`h ‚àò a : m ‚Üí B` is the tuple whose :math:`i`-th value is :math:`(h ‚àò a) i = h\, a\, i = h a_i`, which has type :math:`B`.

If :math:`g : A^m ‚Üí A` and :math:`a : m ‚Üí A`, then the value :math:`g\, a` has type :math:`A`.

Putting it all together, if

  + :math:`f : (œÅf ‚Üí B) ‚Üí B` is a :math:`œÅ f`-ary operation on :math:`B`, 
  + :math:`a : œÅf ‚Üí A` is a :math:`œÅ f`-tuple on :math:`A`, and 
  + :math:`h : A ‚Üí B`,

then :math:`h ‚àò a : œÅf ‚Üí B` and :math:`f (h ‚àò a) : B`.

.. index:: type of; interpretations of operations

The ``algebra_on`` type
~~~~~~~~~~~~~~~~~~~~~~~

Before defining a type of universal algebras, we first define a type called ``algebra_on`` which will be the **type of interpretations of operations** of a given signature. Our definition of ``algebra_on`` uses a :ref:`dependent function type <pi-type>` (or "Pi type").

Given a signature :math:`œÉ = (F, œÅ)` and a carrier type :math:`Œ±`, an inhabitant of ``algebra_on œÉ Œ±`` is determined by assigning an interpretation to each operation symbol :math:`f : F`.  Such an interpretation is a function of type :math:`(œÅ f ‚Üí Œ±) ‚Üí Œ±` (which *depends* on :math:`f`).

Thus, given a signature :math:`œÉ = (F, œÅ)`, the ``algebra_on Œ±`` type is

.. math:: \prod_{f : F} (œÅ f ‚Üí Œ±) ‚Üí Œ± = \prod_{f : F} \mathrm{op} \,(œÅ f)\, Œ±.

.. code-block:: lean

   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)

   -- BEGIN
   -- algebra_on type
   -- Define interpretations of operations on carrier type Œ±
   definition algebra_on (œÉ : signature) (Œ± : Type*) := 
   Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   

      -- This is called `algebra_on` since an algebra is fully
      -- specified by its (Cayley) operation tables. An inhabitant 
      -- of `algebra_on` assigns to each op symbol f : F, of 
      -- arity `Œ≤ = S.œÅ f`, an interpretation of f, that is, 
      -- a function of type (Œ≤ ‚Üí Œ±) ‚Üí Œ±.
   -- END

.. index:: Pi type

Since the :ref:`dependent function type <pi-type>` or "Pi type" (denoted ``pi`` or ``Œ†`` in Lean_) is among one of the most important types in dependent type theory, let us pause pause for a moment to discuss it.

The **Pi type** :math:`Œ†_(x:A), B x` is called a *dependent function type* because it generalizes the function type :math:`A ‚Üí B` by allowing the type :math:`B x` of the codomain to depend on the *value* :math:`x : A` of the domain. (See :numref:`Section %s <dependent-types>` for more about dependent types.)
 
Here is how the type ``pi`` is defined in the Lean_ standard library.

.. todo:: check this!

.. code-block:: lean

    variables {Œ± : Type*} {œÄ : Œ± ‚Üí Type*}

    def pi (i : set Œ±) (s : Œ†a, set (œÄ a)) : set (Œ†a, œÄ a) := 
    { f | ‚àÄ a ‚àà i, f a ‚àà s a }

.. (See also :numref:`Appendix Section %s <pi-type>`, for a more technical description of Leans ``pi`` type.)

.. index:: type of; universal algebras

The (universal) ``algebra`` type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally, let us define the **type of universal algebras** in Lean.

A :index:`universal algebra` :math:`ùêÄ = ‚ü®A,F^ùêÄ‚ü©` is a pair consisting of a :index:`carrier` (or :index:`universe`) :math:`A` along with an set :math:`F^ùêÄ` of :index:`operations` (i.e., interpretations of the operation symbols in :math:`F`).

Also, we should have the concept of an algebraic structures of any given signature. Thus, the type of :math:`‚ü®A,F^ùêÄ‚ü©` depends on the choice of signature :math:`œÉ = (F, œÅ)`, so it is natural to encode the type of algebras as a :index:`dependent pair`, or :index:`Sigma type`.

.. code-block:: lean

   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   definition algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   

   -- BEGIN
   -- algebra type
   -- pairs a carrier with an interpretation of op symbols
   definition algebra (œÉ : signature) := sigma (algebra_on œÉ)

   -- sigma is the "dependent pair" type: ‚ü®Œ±, Œ≤ Œ±‚ü© 
   -- which is appropriate here since an algebra consists of 
   -- a universe (of type Œ±), and operations on that universe,
   -- the type of the operations depends on the universe type.
   -- END

An algebra pairs a carrier with an interpretation of the op symbols.

.. index:: Sigma type

The type ``sigma`` is the Sigma type, which is also known as a :ref:`dependent pair <sigma-type>` (i.e., dependent product). It is one of the most important types in dependent type theory, so let's pause for a moment to discuss it.

The Sigma type :math:`Œ£_(x:A), B x` is called a *dependent pair type* because it generalizes the Cartesian product :math:`A √ó B` by allowing the type :math:`B x` of the second component to depend on the *value* :math:`x` of the first.

Here is how the type ``sigma`` is defined in the Lean_ standard library.

.. code-block:: lean

   structure sigma {Œ± : Type u} (Œ≤ : Œ± ‚Üí Type v) :=
   mk :: (fst : Œ±) (snd : Œ≤ fst)

Sigma is the appropriate type for the ``algebra`` type since an algebra consists of a universe (of type Œ±), along with operations on that universe, and the type of each operation is dependent on the universe type Œ±.

Syntactic sugar and coersions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lean_ has a nifty :index:`coersion` feature which we use for the following purpose: if ``A`` is an algebra, Lean_ will try to determine the correct type of the symbol A---either the algebra itself or the universe of the algebra---depending on the context (just as we would when working informally!).

The next bit of code shows how the ``has_coe_to_sort`` and ``has_coe_to_fun`` coersion directives direct Lean_ to yield either the universe of the algebra or the whole algebra, as appropriate for the given context.

.. code-block:: lean

   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª a, a i
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   definition algebra_on (œÉ : signature) (Œ± : Type*) := Œ† (f : œÉ.F), op (œÉ.œÅ f) Œ±   
   definition algebra (œÉ : signature) := sigma (algebra_on œÉ)

   -- BEGIN
   instance alg_carrier (œÉ : signature) : has_coe_to_sort (algebra œÉ) := ‚ü®_, sigma.fst‚ü©
   instance alg_operations (œÉ : signature) : has_coe_to_fun (algebra œÉ) := ‚ü®_, sigma.snd‚ü©
   -- END

.. index:: keyword: has_coe_to_sort
.. index:: keyword: has_coe_to_fun
.. index:: coersion

.. The last two lines are tagged with ``has_coe_to_sort`` and ``has_coe_to_fun``, respectively, because here we are using a very nice feature of Lean called **coercions**.

Using coercions allows us to identify certain objects which, though not identical, are normally conflated in informal mathematics. 

For instance, the standard notation for the interpretation of the operation symbol :math:`f` in the algebra :math:`ùêÄ = ‚ü®A, F^ùêÄ‚ü©` is :math:`f^ùêÄ`. In our Lean implementation, we use ``A f`` to denote :math:`f^ùêÄ`. Although this syntax doesn't match the informal syntax exactly, it seems equally elegant and adapting to it should not overburden the user.

See :numref:`Section %s <coercion>` for a simple example and the precise definitions of ``has_coe_to_sort`` and ``has_coe_to_fun`` in the Lean_ library.

-----------------------------------------------

.. index:: homomorphism

.. _homomorphisms-in-lean:

Homomorphisms in Lean
---------------------

Using the types defined in the last section, it's not hard to represent the assertion that a function :math:`h : A ‚Üí B` is a :ref:`homomorphism <homomorphisms>`.

We could clean this up a bit by fixing the signature œÉ and algebras ùêÄ and ùêÅ in advance, the definition looks a bit cleaner.

.. code-block:: lean

   import data.set
   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª f, f i
   variables (Œ± : Type*) (Œ≤ : Type*) (i : Œ≤) (f : Œ≤ ‚Üí Œ±) 
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   section
     parameter (œÉ : signature)
     local notation `F` := œÉ.F
     local notation `œÅ` := œÉ.œÅ 
     definition algebra_on (Œ± : Type*) := Œ† (f : F), op (œÅ f) Œ±   
     definition algebra := sigma algebra_on
     instance alg_carrier : has_coe_to_sort algebra := ‚ü®_, sigma.fst‚ü©
     instance alg_operations : has_coe_to_fun algebra := ‚ü®_, sigma.snd‚ü©
   end

   -- BEGIN
   variables {œÉ : signature} {A : algebra œÉ} {B : algebra œÉ}

   definition homomorphic (h : A ‚Üí B) := ‚àÄ f a, h (A f a) = B f (h ‚àò a)
   -- END

Comparing this with a common informal language definition of a homomorphism, which is typically something similar to :math:`‚àÄ f \ ‚àÄ a \ h (f^ùêÄ (a)) = f^ùêÅ (h ‚àò a)`, we expect working algebraists to find the ``lean-ualib`` syntax quite readable.

Alternatively, we could define ``homomorphic`` so that the signature and algebras are not specified in advance, but instead passed in as arguments. This is demonstrated below, along with a third alternative that makes the types explicit which can sometimes be instructive.

.. code-block:: lean

   import data.set
   definition op (Œ≤ Œ±) := (Œ≤ ‚Üí Œ±) ‚Üí Œ±
   definition œÄ {Œ≤ Œ±} (i) : op Œ≤ Œ± := Œª f, f i
   variables (Œ± : Type*) (Œ≤ : Type*) (i : Œ≤) (f : Œ≤ ‚Üí Œ±) 
   structure signature := mk :: (F : Type*) (œÅ : F ‚Üí Type*)
   section
     parameter (œÉ : signature)
     local notation `F` := œÉ.F
     local notation `œÅ` := œÉ.œÅ 
     definition algebra_on (Œ± : Type*) := Œ† (f : F), op (œÅ f) Œ±   
     definition algebra := sigma algebra_on
     instance alg_carrier : has_coe_to_sort algebra := ‚ü®_, sigma.fst‚ü©
     instance alg_operations : has_coe_to_fun algebra := ‚ü®_, sigma.snd‚ü©
   end

   -- BEGIN
   def homomorphic_with_args 
   {œÉ : signature} {A : algebra œÉ} {B : algebra œÉ} 
   (h : A ‚Üí B) := ‚àÄ f a, h (A f a) = B f (h ‚àò a)

   def homomorphic_explicit (h : A ‚Üí B) := 
   ‚àÄ (f : œÉ.F) (a : œÉ.œÅ f ‚Üí A.fst), h (A f a) = B f (h ‚àò a)
   -- END

--------------------------------------------------------------

.. rubric:: Footnotes

.. [1]
   As we will see when implementing general operations in Lean, it is unnecessary to commit in advance to a specific arity type :math:`N`. An exception is the *quotient algebra type* since, unless we restrict ourselves to finitary operations, lifting a basic operation to a quotient requires some form of choice.

.. [2]
   The  ``section`` command allows us to open a section throughout which our signature ``œÉ`` will be available; ``section`` ends when the keyword ``end`` appears.

.. [3]
   The only exception is that in type theory we make *typing judgments*, denoted by ``:``, rather than set membership judgments, denoted by ``‚àà``.

.. [4]
   For a more general and detailed treatment of this topic, see :numref:`Section %s <tuple-functors>`.

.. [5]
   Technically, this assumes we identify :math:`g` with its graph, which is fairly common practice. We will try to identify any situations in which the conflation of a function with its graph might cause problems.

.. _Lean: https://leanprover.github.io/

.. _`github.com/UniversalAlgebra/lean-ualib`: https://github.com/UniversalAlgebra/lean-ualib/

.. _lean-ualib: https://github.com/UniversalAlgebra/lean-ualib/

