.. File: free.lagda.rst
.. Author: William DeMeo  <williamdemeo@gmail.com>
.. Date: 25 Dec 2019
.. Updated: 29 Jan 2020
.. Note: This was used for the second part of my talk at JMM Special Session.
.. Copyright (c) 2019 William DeMeo

.. _Datatypes for Terms:

Datatypes for Terms 
======================

(The code described in this chapter resides in ``free.agda``.)

As usual, we begin by setting some options and importing a few things from the Agda std lib (as well as our definitions from the ``basic.agda`` file).

.. code-block:: agda
		
    {-# OPTIONS --without-K --exact-split #-}

    open import Level
    open import basic 
    open algebra
    open signature

    module free {S : signature}{X : Set} where

    open import preliminaries  using (_‚äé_ ; ‚àÄ-extensionality; ‚àë)
    open import Function using (_‚àò_)
    open import Relation.Unary
    open import Relation.Binary hiding (Total)
    import Relation.Binary.PropositionalEquality as Eq
    open Eq using (_‚â°_; refl; cong; sym)
    open Eq.‚â°-Reasoning
    import Relation.Binary.EqReasoning as EqR

--------------------------------------------

Terms
-------

We define the inductive family of terms in ``signature S`` as follows: 


.. code-block:: agda

    data Term : Set where

      generator : X -> Term

      node : ‚àÄ (ùì∏ : ‚ü® S ‚ü©‚Çí)
        ->   (Fin (‚ü® S ‚ü©‚Çê ùì∏) -> Term)
            -------------------------
	->    Term


-----------------------------------------------

The term algebra
-----------------

Here is a datatype for the term algebra in ``signature S``.

.. code-block:: agda
		
    open Term

    free : algebra S

    free = record { ‚ü¶_‚üß·µ§ = Term ; _‚ü¶_‚üß = node }


-----------------------------------------------

The universal property
-----------------------------------

We now come to our first proof.

We wish to show that the term algebra is **aboslutely free**.

That is, we must show

1. every ``h : X -> ‚ü¶ A ‚üß·µ§`` lifts to a hom from ``free`` to ``A``;

2. the induced hom is unique.


Here is the Agda code proving these facts.

1.
   a. Every map  ``(X -> A)``  "lifts".

      .. code-block:: agda
		
          free-lift : {A : algebra  S}
	              (h : X -> ‚ü¶ A ‚üß·µ§)
                    ---------------------
            ->        ‚ü¶ free ‚üß·µ§ -> ‚ü¶ A ‚üß·µ§

          free-lift h (generator x) = h x

          free-lift {A} h (node ùì∏ args) =
	    (A ‚ü¶ ùì∏ ‚üß) Œª{i -> free-lift {A} h (args i)}


   b. The lift is a hom.

      .. code-block:: agda
		
          open Hom

          lift-hom : {A : algebra S}
	             (h : X -> ‚ü¶ A ‚üß·µ§)
                    ------------------
	    ->        Hom free A

          lift-hom {A} h =
            record
              {
              ‚ü¶_‚üß‚Çï = free-lift {A} h;
              homo = Œª args -> refl
              }


2. The lift to  ``(free -> A)``  is unique.

   We need `function extensionality`_ for this, which we import from our ``preliminaries.agda`` file (see the agda-ualib_ gitlab repository).

   .. code-block:: agda

       free-unique : {A : algebra S}
         ->    ( f g : Hom free A )
         ->    ( ‚àÄ x  ->  ‚ü¶ f ‚üß‚Çï (generator x) ‚â° ‚ü¶ g ‚üß‚Çï (generator x) )
         ->    (t : Term)
              ---------------------------
         ->    ‚ü¶ f ‚üß‚Çï t ‚â° ‚ü¶ g ‚üß‚Çï t

       free-unique {A} f g p (generator x) = p x

       free-unique {A} f g p (node ùì∏ args) =
          begin
            ‚ü¶ f ‚üß‚Çï (node ùì∏ args)
          ‚â°‚ü® homo f args  ‚ü©
            (A ‚ü¶ ùì∏ ‚üß) (Œª i -> ‚ü¶ f ‚üß‚Çï (args i))
          ‚â°‚ü® cong ((A ‚ü¶_‚üß)_) (‚àÄ-extensionality (induct f g p args)) ‚ü©
            (A ‚ü¶ ùì∏ ‚üß) (Œª i -> ‚ü¶ g ‚üß‚Çï (args i))
          ‚â°‚ü® sym (homo g args) ‚ü©
            ‚ü¶ g ‚üß‚Çï (node ùì∏ args)
          ‚àé
          where
           induct : {A : algebra S}
             ->     (f g : Hom free A)
             ->     (‚àÄ x -> ‚ü¶ f ‚üß‚Çï (generator x) ‚â° ‚ü¶ g ‚üß‚Çï (generator x))
             ->     (args : Fin (‚ü® S ‚ü©‚Çê ùì∏) ‚Üí Term)
             ->     (i : Fin (‚ü® S ‚ü©‚Çê ùì∏))
                   --------------------------------------- (IH)
             ->     ‚ü¶ f ‚üß‚Çï (args i) ‚â° ‚ü¶ g ‚üß‚Çï (args i)
           induct f' g' h' args' i' = free-unique f' g' h' (args' i')


   Now that we have seen exactly where and how induction is used, let's clean up the proof by inserting the induction step within the angle brackets inside the calculational proof.

   .. code-block:: agda

       free-unique : {A : algebra S}
         ->    ( f g : Hom free A )
         ->    ( ‚àÄ x  ->  ‚ü¶ f ‚üß‚Çï (generator x) ‚â° ‚ü¶ g ‚üß‚Çï (generator x) )
         ->    (t : Term)
              ---------------------------
         ->    ‚ü¶ f ‚üß‚Çï t ‚â° ‚ü¶ g ‚üß‚Çï t

       free-unique {A} f g p (generator x) = p x

       free-unique {A} f g p (node ùì∏ args) =
          begin
	    ‚ü¶ f ‚üß‚Çï (node ùì∏ args)
	  ‚â°‚ü® homo f args  ‚ü©
	    (A ‚ü¶ ùì∏ ‚üß) (Œª i -> ‚ü¶ f ‚üß‚Çï (args i))
	  ‚â°‚ü® cong ((A ‚ü¶_‚üß)_)
	     ( ‚àÄ-extensionality Œª i -> free-unique f g p (args i) ) ‚ü©
	    (A ‚ü¶ ùì∏ ‚üß) (Œª i -> ‚ü¶ g ‚üß‚Çï (args i))
	  ‚â°‚ü® sym (homo g args) ‚ü©
	    ‚ü¶ g ‚üß‚Çï (node ùì∏ args)
	  ‚àé


----------------------------

Essential arity
------------------

The definition of arity of an operation or term is a bit nuanced as the next example demonstrates.

.. proof:example:: arity of a term

   Suppose ùëì is a binary term, and ùëù and ùëû are ternary terms.

   What is the arity of the following term?

   .. math:: ùë°(ùë¢, ùë£, ùë§, ùë•, ùë¶, ùëß) = ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))
     :label: arity1

   On the face of it, it seems safe to say that ùë° has arity 6, since it is expressible as a function
   of 6 variables.

   But what if we decided to throw in some useless (or "dummy") variables, like so,

   .. math:: t'(ùë¢', ùë£', ùë¢, ùë£, ùë§, ùë•, ùë¶, ùëß, ùëß') = ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))?
     :label: arity2

   And what happens if :math:`ùëù(ùë•, ùë¶, ùëß) = ùëß`, so that ùëù depends on just one of its arguments? Then we could replace it with :math:`ùëù'(ùëß) = ùëù(ùë•, ùë¶, ùëß)`, and ùë° could be expressed as,

   .. math:: ùë°''(ùë¢, ùë£, ùë§, ùë•, ùëß) = ùëì(ùëù'(ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))).
     :label: arity3
	     
   The respective arities of :math:`ùë°, ùë°'` and :math:`ùë°''` are 6, 9, and 5, yet :eq:`arity1`--:eq:`arity3` merely give three different ways to present the term :math:`ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))`.
   
As the example demonstrates, the notion of arity of a term is not uniquely defined (modulo equivalence of terms). As such, it is sometimes useful to speak of the **essential arity** of a term, which is defined to be the minimum number of variables required to express that term; it should be clear that this is equal to the number of arguments with respect to which the term is not constant.

.. proof:example:: essential arity of a term

   It is impossible to know the essential arity of a term until we know that of each of its subterms.

   Picking up where we left off in the previous example, suppose ùëì depends on both of its arguments and :math:`ùëû(ùë¢, ùë£, ùë§) = ùëì(ùë£, ùë§)`. Then ùë° is expressible as

   .. math:: s(ùë£, ùë§, ùë•, ùëß) = ùëì(ùëù'(ùëß), ùëì(ùë§, ùë•), ùëì(ùë£, ùë§))

   and we finally see the lower bound on the number of variables required to express ùë°, namely 4.  Therefore, ùë° has essential arity 4.


------------------------------------------------------------------

Interpretation of terms
-----------------------

.. ùêÄ = ‚ü®ùê¥,...‚ü© be an algebra
   
.. proof:definition:: cf. 4.31 of Bergman

   Let ùëø be an infinite set (of variables), and let ùë® = ‚ü®ùê¥,...‚ü© be an algebra of signature :math:`S`.

   .. , and let ùëê : œâ ‚Üí ùëø be an injective function. (We might call ùëê a "choice function" or "indexing function".)

   If :math:`t` is a :math:`(œÅ t)`-ary term symbol in the signature :math:`S`, and if we select a :math:`(œÅ t)`-tuple of variables, say :math:`x : (œÅ t) ‚Üí X`, then the term associated with the symbols :math:`t` and :math:`x` is :math:`t(x)`.

   The **interpretation** of :math:`t(x)` in ùë®, often denoted by :math:`t^ùë®(x)`, is the :math:`(œÅ t)`-ary operation on :math:`A` defined by recursion on the structure of :math:`t`, as follows:

     #. if :math:`t(x)` is simply the variable :math:`x i ‚àà X`, and if ùëé is a :math:`(œÅ t)`-tuple of :math:`A`, then :math:`t^ùë®(a) = a i`; that is, :math:`t^ùë®(a)` is the projection of the input tuple onto its :math:`i`-th coordinate.

     #. if :math:`t = ùì∏ ùëì`, where ùì∏ is a basic operation symbol with interpretation :math:`ùì∏^ùë®` in ùë® and :math:`ùëì : (œÅ ùì∏) ‚Üí` Term is a (œÅ ùì∏)-tuple of terms, each with interpretation :math:`(ùëì i)^ùë®`, then :math:`t^ùë®(ùëì)` is :math:`ùì∏^ùë® \bigl( Œª (i : œÅ ùì∏) . (ùëì i)^ùë®\bigr)`.


Let's translate this definition into the Agda syntax developed above.

#. If ``t x`` is a variable, say, ``x i : X``, then we define ``(t ÃÇ A) : (Fin ‚ü® S ‚ü©‚Çê tFin ‚ü¶ A ‚üß·µ§ -> ‚ü¶ A ‚üß·µ§`` for each ``a : ‚ü¶ A ‚üß·µ§`` by ``(t ÃÇ A) a = a``.

#. If ``t = ùì∏ ùêü``, where ``ùì∏ : ‚ü® S ‚ü©‚Çí`` is a basic operation symbol with interpretation ``A ‚ü¶ ùì∏ ‚üß`` in ùö®, and if ``ùêü : Fin ‚ü® S ‚ü©‚Çê ùì∏ -> Term`` is a ``(‚ü® S ‚ü©‚Çê ùì∏)``-tuple of terms with interpretations ``(ùêü i) ÃÇ A`` for each ``i : ‚ü® S ‚ü©‚Çê ùì∏``, then we define

   ``(t ÃÇ A) = (ùì∏ ùêü) ÃÇ A = (A ‚ü¶ ùì∏ ‚üß) Œª{i -> (ùêü i) ÃÇ A}``

Here's how we could implement this in Agda.


.. code-block:: agda

    _ÃÇ_ : Term -> (A : algebra S) -> (X -> ‚ü¶ A ‚üß·µ§) -> ‚ü¶ A ‚üß·µ§

    ((generator x) ÃÇ A) tup = tup x

    ((node ùì∏ args) ÃÇ A) tup = (A ‚ü¶ ùì∏ ‚üß) Œª{i -> (args i ÃÇ A) tup }


Recall (:cite:`Bergman:2012` Theorem 4.32),

.. proof:theorem::

   Let ùî∏ and ùîπbe algebras of signature :math:`S`. The following hold:

     #. For every :math:`n`-ary term :math:`t` and homomorphism :math:`g : A \to B`, we have

	.. math:: g(t·¥¨(a‚ÇÅ,...,a‚Çô)) = t·¥Æ(g(a‚ÇÅ),...,g(a‚Çô)).

     #. For every term :math:`t ‚àà T(X)` and every :math:`Œ∏ ‚àà Con()`, we have

	.. math:: a Œ∏ b \implies t(a) Œ∏ t(b).

     #. For every subset :math:`Y` of :math:`A`, we have

       .. math:: \mathrm{Sg}(Y) = \{ t(a‚ÇÅ,\dots ,a‚Çô) : t ‚àà T(X‚Çô), n < œâ, \text{ and } a·µ¢ ‚àà Y, for i ‚â§ n\}.

Rewriting the three assertions in Agda syntax, 

     #. For every ``n``-ary term ``t`` and homomorphism ``g : hom A B``, we have

	  ``‚ü¶ g ‚üß‚Çï ((t ÃÇ A) a)  ‚â° (t ÃÇ B)(‚ü¶ g ‚üß‚Çï ‚àò a)``

	for each ``n``-tuple ``a``.

     #. For every term ``t ‚àà T(X)`` and congruence ``Œ∏ ‚àà con A``, we have

	  ``‚ü¶ Œ∏ ‚üß·µ£ a b => ‚ü¶ Œ∏ ‚üß·µ£ t(a) t(b)``.

     #. For every subset ``Y`` of ``A``, we have

	  ``Sg(Y) = {(t ÃÇ A) a : t ‚àà T(X‚Çô), n < œâ, a·µ¢ ‚àà Y (‚àÄ i ‚â§ n)}``.

Let's prove the first of the assertions in Agda.

**Claim**. Homomorphisms commute with terms.

   .. code-block:: agda

      comm-hom-term : {A B : algebra S}
        ->            (g : Hom A B) -> (t : Term)
	->            (tup : X -> ‚ü¶ A ‚üß·µ§)
               ----------------------------------------------
	->       ‚ü¶ g ‚üß‚Çï ((t ÃÇ A) tup) ‚â° (t ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup)

      comm-hom-term g (generator x) tup = refl

      comm-hom-term {A} {B} g (node ùì∏ args) tup =  

      -- Goal: ‚ü¶ g ‚üß‚Çï ((A ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ A) tup })) ‚â°
      --  (B ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ B) ((Œª {.x} ‚Üí ‚ü¶ g ‚üß‚Çï) ‚àò tup) })

        begin

	  ‚ü¶ g ‚üß‚Çï ((A ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ A) tup }))

	‚â°‚ü® homo g (Œª { i ‚Üí (args i ÃÇ A) tup }) ‚ü©

	  (B ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí ‚ü¶ g ‚üß‚Çï ((args i ÃÇ A) tup) })

	‚â°‚ü® cong ((B ‚ü¶_‚üß)_) (‚àÄ-extensionality (induct g tup args)) ‚ü©

	  (B ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup)})

	‚àé

	where

	  induct : {A B : algebra S}
	    ->     (g : Hom A B)
            ->     (tup : X -> ‚ü¶ A ‚üß·µ§)
            ->     (args : ‚ü® S ‚ü©‚Çê ùì∏ ‚Üí Term)
            ->     (i : ‚ü® S ‚ü©‚Çê ùì∏)
               ---------------------------------------------------------
            ->    ‚ü¶ g ‚üß‚Çï ((args i ÃÇ A) tup) ‚â° (args i ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup)

	  induct g' tup' args' i' = comm-hom-term g' (args' i') tup' 


   Now that we have seen exactly where and how induction is used, let's clean up the proof by inserting the induction step within the angle brackets inside the calculational proof.

.. code-block:: agda

   comm-hom-term : {A B : algebra S}
     ->    (g : hom A B) -> (t : Term)
     ->    (tup : X -> ‚ü¶ A ‚üß·µ§)
          ------------------------------
     ->     ‚ü¶ g ‚üß‚Çï ((t ÃÇ A) tup) ‚â° (t ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup)

   comm-hom-term g (generator x) tup = refl
   comm-hom-term {A} {B} g (node ùì∏ args) tup =  
   -- Goal: ‚ü¶ g ‚üß‚Çï ((A ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ A) tup })) ‚â°
   --       (B ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ B) ((Œª {.x} ‚Üí ‚ü¶ g ‚üß‚Çï) ‚àò tup) })
     begin
       ‚ü¶ g ‚üß‚Çï ((A ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ A) tup }))
     ‚â°‚ü® homo g ( Œª i ‚Üí (args i ÃÇ A) tup )‚ü©
       (B ‚ü¶ ùì∏ ‚üß) ( Œª i ‚Üí ‚ü¶ g ‚üß‚Çï ((args i ÃÇ A) tup) )
     ‚â°‚ü® cong ((B ‚ü¶_‚üß)_)
        ( ‚àÄ-extensionality  Œª i -> comm-hom-term g (args i) tup  ) ‚ü©
       (B ‚ü¶ ùì∏ ‚üß) ( Œª i ‚Üí (args i ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup) )
     ‚àé

-----------------------------------------------

.. include:: hyperlink_references.rst

