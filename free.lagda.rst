.. File: free.lagda.rst
.. Author: William DeMeo  <williamdemeo@gmail.com>
.. Date: 25 Dec 2019
.. Updated: 29 Jan 2020
.. Note: This was used for the second part of my talk at JMM Special Session.
.. Copyright (c) 2019 William DeMeo

.. _Datatypes for Terms:

Datatypes for Terms 
======================

(The code described in this chapter resides in ``free.agda``.)

As usual, we begin by setting some options and importing a few things from the Agda std lib (as well as our definitions from the ``basic.agda`` file).

.. code-block:: agda
		
    {-# OPTIONS --without-K --exact-split #-}

    open import Level
    open import basic 
    open algebra
    open signature

    module free {S : signature}{X : Set} where

    open import preliminaries  using (_‚äé_ ; ‚àÄ-extensionality; ‚àë)
    open import Function using (_‚àò_)
    open import Relation.Unary
    open import Relation.Binary hiding (Total)
    import Relation.Binary.PropositionalEquality as Eq
    open Eq using (_‚â°_; refl; cong; sym)
    open Eq.‚â°-Reasoning
    import Relation.Binary.EqReasoning as EqR

--------------------------------------------

Terms
-------

We define the inductive family of terms in ``signature S`` as follows: 


.. code-block:: agda

    data Term : Set where

      generator : X -> Term

      node : ‚àÄ (ùì∏ : ‚ü® S ‚ü©‚Çí)
        ->   (Fin (‚ü® S ‚ü©‚Çê ùì∏) -> Term)
            -------------------------
	->    Term


-----------------------------------------------

The term algebra
-----------------

Here is a datatype for the term algebra in ``signature S``.

.. code-block:: agda
		
    open Term

    free : algebra S

    free = record { ‚ü¶_‚üß·µ§ = Term ; _‚ü¶_‚üß = node }


-----------------------------------------------

The universal property
-----------------------------------

We now come to our first proof.

We wish to show that the term algebra is **aboslutely free**.

That is, we must show

1. every ``h : X -> ‚ü¶ A ‚üß·µ§`` lifts to a hom from ``free`` to ``A``;

2. the induced hom is unique.


Here is the Agda code proving these facts.

1.
   a. Every map  ``(X -> A)``  "lifts".

      .. code-block:: agda
		
          free-lift : {A : algebra  S}
	              (h : X -> ‚ü¶ A ‚üß·µ§)
                    ---------------------
            ->        ‚ü¶ free ‚üß·µ§ -> ‚ü¶ A ‚üß·µ§

          free-lift h (generator x) = h x

          free-lift {A} h (node ùì∏ args) =
	    (A ‚ü¶ ùì∏ ‚üß) Œª{i -> free-lift {A} h (args i)}


   b. The lift is a hom.

      .. code-block:: agda
		
          open Hom

          lift-hom : {A : algebra S}
	             (h : X -> ‚ü¶ A ‚üß·µ§)
                    ------------------
	    ->        Hom free A

          lift-hom {A} h =
            record
              {
              ‚ü¶_‚üß‚Çï = free-lift {A} h;
              homo = Œª args -> refl
              }


2. The lift to  ``(free -> A)``  is unique.

   We need `function extensionality`_ for this, which we import from our ``preliminaries.agda`` file (see the agda-ualib_ gitlab repository).

   .. code-block:: agda

       free-unique : {A : algebra S}
         ->    ( f g : Hom free A )
         ->    ( ‚àÄ x  ->  ‚ü¶ f ‚üß‚Çï (generator x) ‚â° ‚ü¶ g ‚üß‚Çï (generator x) )
         ->    (t : Term)
              ---------------------------
         ->    ‚ü¶ f ‚üß‚Çï t ‚â° ‚ü¶ g ‚üß‚Çï t

       free-unique {A} f g p (generator x) = p x

       free-unique {A} f g p (node ùì∏ args) =
          begin
            ‚ü¶ f ‚üß‚Çï (node ùì∏ args)
          ‚â°‚ü® homo f args  ‚ü©
            (A ‚ü¶ ùì∏ ‚üß) (Œª i -> ‚ü¶ f ‚üß‚Çï (args i))
          ‚â°‚ü® cong ((A ‚ü¶_‚üß)_) (‚àÄ-extensionality (induct f g p args)) ‚ü©
            (A ‚ü¶ ùì∏ ‚üß) (Œª i -> ‚ü¶ g ‚üß‚Çï (args i))
          ‚â°‚ü® sym (homo g args) ‚ü©
            ‚ü¶ g ‚üß‚Çï (node ùì∏ args)
          ‚àé
          where
           induct : {A : algebra S}
             ->     (f g : Hom free A)
             ->     (‚àÄ x -> ‚ü¶ f ‚üß‚Çï (generator x) ‚â° ‚ü¶ g ‚üß‚Çï (generator x))
             ->     (args : Fin (‚ü® S ‚ü©‚Çê ùì∏) ‚Üí Term)
             ->     (i : Fin (‚ü® S ‚ü©‚Çê ùì∏))
                   --------------------------------------- (IH)
             ->     ‚ü¶ f ‚üß‚Çï (args i) ‚â° ‚ü¶ g ‚üß‚Çï (args i)
           induct f' g' h' args' i' = free-unique f' g' h' (args' i')


   Now that we have seen exactly where and how induction is used, let's clean up the proof by inserting the induction step within the angle brackets inside the calculational proof.

   .. code-block:: agda

       free-unique : {A : algebra S}
         ->    ( f g : Hom free A )
         ->    ( ‚àÄ x  ->  ‚ü¶ f ‚üß‚Çï (generator x) ‚â° ‚ü¶ g ‚üß‚Çï (generator x) )
         ->    (t : Term)
              ---------------------------
         ->    ‚ü¶ f ‚üß‚Çï t ‚â° ‚ü¶ g ‚üß‚Çï t

       free-unique {A} f g p (generator x) = p x

       free-unique {A} f g p (node ùì∏ args) =
          begin
	    ‚ü¶ f ‚üß‚Çï (node ùì∏ args)
	  ‚â°‚ü® homo f args  ‚ü©
	    (A ‚ü¶ ùì∏ ‚üß) (Œª i -> ‚ü¶ f ‚üß‚Çï (args i))
	  ‚â°‚ü® cong ((A ‚ü¶_‚üß)_)
	     ( ‚àÄ-extensionality Œª i -> free-unique f g p (args i) ) ‚ü©
	    (A ‚ü¶ ùì∏ ‚üß) (Œª i -> ‚ü¶ g ‚üß‚Çï (args i))
	  ‚â°‚ü® sym (homo g args) ‚ü©
	    ‚ü¶ g ‚üß‚Çï (node ùì∏ args)
	  ‚àé


----------------------------

Interpretation of a term
-------------------------

**TODO** This section needs to be rewritten.

Given a set ``X`` and an algebra ``ùêÄ = ‚ü®A,...‚ü©``, we call a function ``ctx : X ‚Üí A`` a **context**.

.. proof:definition:: cf. 4.31 of Bergman

   Let  and ùêÄ be an algebra of signature :math:`S`.

   Let :math:`t` be an :math:`(œÅ t)`-ary term of signature :math:`S`.

   The **interpretation** of :math:`t` in ùêÄ---often denoted in the literature by :math:`t^ùö®`---is the :math:`(œÅ t)`-ary operation on :math:`A` defined by recursion on the structure of :math:`t`, as follows:

     #. if :math:`t` is the variable :math:`x ‚àà X`, then in the context ``ctx`` we take :math:`t^ùö®` to be the projection onto the coordinate containing ``ctx x``.

     #. if :math:`t = ùì∏ ùêü`, where ùì∏ is a basic operation symbol with interpretation :math:`ùì∏^ùö®` in ùö® and :math:`ùêü : (œÅ ùì∏) ‚Üí` Term is a (œÅ ùì∏)-tuple of terms, each with interpretation :math:`(ùêü i)^ùö®`, then we take :math:`t^ùêÄ(ùêü)` to be :math:`ùì∏^ùêÄ \bigl( Œª \{ (i : œÅ ùì∏) . (ùêü i)^ùêÄ\}\bigr)`.


Let's translate this definition into the Agda syntax developed above.

#. If ``t`` is a variable, say, ``x : X``, then we define ``(t ÃÇ A) : ‚ü¶ A ‚üß·µ§ -> ‚ü¶ A ‚üß·µ§`` for each ``a : ‚ü¶ A ‚üß·µ§`` by ``(t ÃÇ A) a = a``.

#. If ``t = ùì∏ ùêü``, where ``ùì∏ : ‚ü® S ‚ü©‚Çí`` is a basic operation symbol with interpretation ``A ‚ü¶ ùì∏ ‚üß`` in ùö®, and if ``ùêü : ‚ü® S ‚ü©‚Çê ùì∏ -> Term`` is a ``(‚ü® S ‚ü©‚Çê ùì∏)``-tuple of terms with interpretations ``(ùêü i) ÃÇ A`` for each ``i : ‚ü® S ‚ü©‚Çê ùì∏``, then we define

   ``(t ÃÇ A) = (ùì∏ ùêü) ÃÇ A = (A ‚ü¶ ùì∏ ‚üß) Œª{i -> (ùêü i) ÃÇ A}``

Here's how we could implement this in Agda.


.. code-block:: agda

    _ÃÇ_ : Term -> (A : algebra S) -> (X -> ‚ü¶ A ‚üß·µ§) -> ‚ü¶ A ‚üß·µ§

    ((generator x) ÃÇ A) tup = tup x

    ((node ùì∏ args) ÃÇ A) tup = (A ‚ü¶ ùì∏ ‚üß) Œª{i -> (args i ÃÇ A) tup }


Recall (:cite:`Bergman:2012` Theorem 4.32),

.. proof:theorem::

   Let ùî∏ and ùîπbe algebras of signature :math:`S`. The following hold:

     #. For every :math:`n`-ary term :math:`t` and homomorphism :math:`g : A \to B`, we have

	.. math:: g(t·¥¨(a‚ÇÅ,...,a‚Çô)) = t·¥Æ(g(a‚ÇÅ),...,g(a‚Çô)).

     #. For every term :math:`t ‚àà T(X)` and every :math:`Œ∏ ‚àà Con()`, we have

	.. math:: a Œ∏ b \implies t(a) Œ∏ t(b).

     #. For every subset :math:`Y` of :math:`A`, we have

       .. math:: \mathrm{Sg}(Y) = \{ t(a‚ÇÅ,\dots ,a‚Çô) : t ‚àà T(X‚Çô), n < œâ, \text{ and } a·µ¢ ‚àà Y, for i ‚â§ n\}.

Rewriting the three assertions in Agda syntax, 

     #. For every ``n``-ary term ``t`` and homomorphism ``g : hom A B``, we have

	  ``‚ü¶ g ‚üß‚Çï ((t ÃÇ A) a)  ‚â° (t ÃÇ B)(‚ü¶ g ‚üß‚Çï ‚àò a)``

	for each ``n``-tuple ``a``.

     #. For every term ``t ‚àà T(X)`` and congruence ``Œ∏ ‚àà con A``, we have

	  ``‚ü¶ Œ∏ ‚üß·µ£ a b => ‚ü¶ Œ∏ ‚üß·µ£ t(a) t(b)``.

     #. For every subset ``Y`` of ``A``, we have

	  ``Sg(Y) = {(t ÃÇ A) a : t ‚àà T(X‚Çô), n < œâ, a·µ¢ ‚àà Y (‚àÄ i ‚â§ n)}``.

Let's prove the first of the assertions in Agda.

**Claim**. Homomorphisms commute with terms.

   .. code-block:: agda

      comm-hom-term : {A B : algebra S}
        ->            (g : Hom A B) -> (t : Term)
	->            (tup : X -> ‚ü¶ A ‚üß·µ§)
               ----------------------------------------------
	->       ‚ü¶ g ‚üß‚Çï ((t ÃÇ A) tup) ‚â° (t ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup)

      comm-hom-term g (generator x) tup = refl

      comm-hom-term {A} {B} g (node ùì∏ args) tup =  

      -- Goal: ‚ü¶ g ‚üß‚Çï ((A ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ A) tup })) ‚â°
      --  (B ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ B) ((Œª {.x} ‚Üí ‚ü¶ g ‚üß‚Çï) ‚àò tup) })

        begin

	  ‚ü¶ g ‚üß‚Çï ((A ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ A) tup }))

	‚â°‚ü® homo g (Œª { i ‚Üí (args i ÃÇ A) tup }) ‚ü©

	  (B ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí ‚ü¶ g ‚üß‚Çï ((args i ÃÇ A) tup) })

	‚â°‚ü® cong ((B ‚ü¶_‚üß)_) (‚àÄ-extensionality (induct g tup args)) ‚ü©

	  (B ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup)})

	‚àé

	where

	  induct : {A B : algebra S}
	    ->     (g : Hom A B)
            ->     (tup : X -> ‚ü¶ A ‚üß·µ§)
            ->     (args : ‚ü® S ‚ü©‚Çê ùì∏ ‚Üí Term)
            ->     (i : ‚ü® S ‚ü©‚Çê ùì∏)
               ---------------------------------------------------------
            ->    ‚ü¶ g ‚üß‚Çï ((args i ÃÇ A) tup) ‚â° (args i ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup)

	  induct g' tup' args' i' = comm-hom-term g' (args' i') tup' 


   Now that we have seen exactly where and how induction is used, let's clean up the proof by inserting the induction step within the angle brackets inside the calculational proof.

.. code-block:: agda

   comm-hom-term : {A B : algebra S}
     ->    (g : hom A B) -> (t : Term)
     ->    (tup : X -> ‚ü¶ A ‚üß·µ§)
          ------------------------------
     ->     ‚ü¶ g ‚üß‚Çï ((t ÃÇ A) tup) ‚â° (t ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup)

   comm-hom-term g (generator x) tup = refl
   comm-hom-term {A} {B} g (node ùì∏ args) tup =  
   -- Goal: ‚ü¶ g ‚üß‚Çï ((A ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ A) tup })) ‚â°
   --       (B ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ B) ((Œª {.x} ‚Üí ‚ü¶ g ‚üß‚Çï) ‚àò tup) })
     begin
       ‚ü¶ g ‚üß‚Çï ((A ‚ü¶ ùì∏ ‚üß) (Œª { i ‚Üí (args i ÃÇ A) tup }))
     ‚â°‚ü® homo g ( Œª i ‚Üí (args i ÃÇ A) tup )‚ü©
       (B ‚ü¶ ùì∏ ‚üß) ( Œª i ‚Üí ‚ü¶ g ‚üß‚Çï ((args i ÃÇ A) tup) )
     ‚â°‚ü® cong ((B ‚ü¶_‚üß)_)
        ( ‚àÄ-extensionality  Œª i -> comm-hom-term g (args i) tup  ) ‚ü©
       (B ‚ü¶ ùì∏ ‚üß) ( Œª i ‚Üí (args i ÃÇ B) (‚ü¶ g ‚üß‚Çï ‚àò tup) )
     ‚àé

-----------------------------------------------

.. include:: hyperlink_references.rst

