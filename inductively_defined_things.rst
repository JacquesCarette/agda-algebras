.. include:: _static/math_macros.rst

.. _inductively-defined-things:

==========================
Inductively Defined Things
==========================

.. index:: ! subuniverse, ! subalgebra

.. _subalgebras:

Subalgebras
-----------

Two important concepts in universal algebra are **subuniverse** and **subalgebra**.

Our Lean implementation of subuniverse will illustrate one of the underlying themes that motivates our work. Indeed, we demonstrate the power of **inductively defined types**, which are essential for working with infinite objects in a constructive and computable way, and for proving (by induction) properties of these objects. 

.. A **subuniverse** of an algebra :math:`𝐀 = ⟨A, F^𝐀⟩` is a subset :math:`B ⊆ A` that is closed under the operations in :math:`F^𝐀`.

Suppose :math:`𝐀 = ⟨ A, F^𝐀 ⟩` is an algebra. Recall, the (nonempty) set :math:`A` is called the **universe** of 𝐀.

If a subset :math:`B ⊆ A` is *closed* under all operations in :math:`F^𝐀`, we call :math:`B` a **subuniverse** of :math:`A`. By closed under all operations we mean the following: for each :math:`f∈ F^𝐀` and for all :math:`b_0, \dots, b_{ρf-1} ∈ B` we have :math:`f(b_0, \dots, b_{ρ f-1}) ∈ B`, 

If :math:`B ≠ ∅` is a subuniverse of 𝐀, and if we let :math:`F^𝐁 = \{ f ↾ B : f ∈ F^𝐀 \}`, then :math:`𝐁 = ⟨ B, F^𝐁 ⟩` is an algebra, called a **subalgebra** of 𝐀.

Equivalently, if :math:`B ≠ ∅` is a subuniverse of 𝐀 and :math:`F^{𝐁|_A} = \{f^𝐀|_B ∣ f ∈ F\}` is the set of basic operations of 𝐀 restricted to the set :math:`B`, then :math:`𝐁 = ⟨B, F^{𝐁|_A}⟩` is a **subalgebra** of 𝐀.

Conversely, all subalgebras are of this form.

If 𝐁 is a subalgebra of 𝐀, we denote this fact by :math:`𝐁 ≤ 𝐀`.

Similarly, we write :math:`B ≤ A` if :math:`B` is a subuniverse of :math:`A`. Note that universe of an algebra is not allowed to be empty. However, the empty set is a subuniverse.

**Fact**. If :math:`𝐀_i ≤ 𝐀`, :math:`i ∈ I`, then :math:`⋂_{i∈ I} A_i` is a subuniverse.

.. index:: subuniverse generated by a set

Denote by :math:`𝖲 𝐀` the collection of all subalgebras of 𝐀.  

If 𝐀 is an algebra and :math:`X ⊆ A` a subset of the universe of 𝐀, then the **subuniverse of** 𝐀 **generated by** :math:`X`, denoted :math:`\operatorname{Sg}^𝐀 (X)` or :math:`⟨X⟩`, is the smallest subuniverse of 𝐀 containing the set :math:`X`.  Equivalently, 

.. math:: \mathrm{Sg}^{𝐀}(X)  =  ⋂ \{ U ∈ 𝖲 𝐀 ∣ X ⊆ U \}.
  :label: SgDef

.. To give an exhibition of the efficiency and ease with which we can formalize basic but important mathematical concepts in Lean_, we now present a fundamental theorem about subalgebra generation, first in the informal language, and then formally :ref:`below <subalgebras-in-lean>`.

.. Notice that the added complexity of the Lean implementation of this theorem is not significant, and the proof seems quite readable (especially when compared to the syntax used by other interactive theorem provers).  

The following is a recursive definition of the subuniverse generated by a set. (See :cite:`Bergman:2012`, Thm. 1.14.)

.. _thm-1-14:

.. proof:theorem:: Subuniverse generation

   Let :math:`𝐀 = ⟨A, F^{𝐀}⟩`  be  an  algebra in the signature :math:`σ = (F, ρ)` and let :math:`X ⊆ A`.

   Define, by recursion on :math:`n`, the sets :math:`X_n` as follows:

   .. math:: X_0  &=  X \\
          X_{n+1} &=  X_n ∪ \{ f a  ∣ f ∈ F, \ a ∈ X_n^{ρf}\}.
      :label: subalgebra-inductive

   Then  :math:`\mathrm{Sg}^{𝐀}(X) = ⋃ X_n`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Let :math:`Y = ⋃_{n < ω} X_n`. Clearly :math:`X_n ⊆ Y ⊆ A`, for every :math:`n < ω`. In particular :math:`X = X_0 ⊆ Y`.

      Let us show that :math:`Y` is a subuniverse of 𝐀.
   
      Let :math:`f` be a basic :math:`k`-ary operation and :math:`a ∈ Y^k`.
    
      From the construction of :math:`Y`, there is an :math:`n < ω` such that :math:`∀ i,\ a,\ i ∈ X_n`.
    
      From its definition, :math:`f a ∈ X_{n+1} ⊆ Y`.
    
      Thus :math:`Y` is a subuniverse of 𝐀 containing :math:`X`.
    
      By :eq:`SgDef`, :math:`\mathrm{Sg}^{𝐀}(X) ⊆ Y`.
    
      For the opposite inclusion, it is enough to check, by induction on :math:`n`, that :math:`X_n ⊆ \mathrm{Sg}^{𝐀}(X)`.
    
      By definition, :math:`X_0 = X ⊆ \mathrm{Sg}^{𝐀}(X)`.
      
      Assume :math:`X_n ⊆ \mathrm{Sg}^𝐀(X)`.  We show :math:`X_{n+1} ⊆ \mathrm{Sg}^𝐀(X)`.
      
      If :math:`b ∈ X_{n+1} - X_n`, then :math:`b = f a` for a basic :math:`k`-ary operation :math:`f` and some :math:`a ∈ X_n^k`.
      
      But :math:`∀ i, \ a i ∈ \mathrm{Sg}^𝐀(X)` and since this latter object is a subuniverse, :math:`b ∈ \mathrm{Sg}^𝐀(X)` as well.
    
      Therefore, :math:`X_{n+1} ⊆ \mathrm{Sg}^𝐀(X)`, as desired.

The argument in the proof of :numref:`Theorem %s <thm-1-14>` is of a type that one encounters frequently throughout algebra. It has two parts.

  #. Some set :math:`Y` is shown to be a subuniverse of 𝐀 that contains :math:`X`.

  #. Every subuniverse containing :math:`X` is shown to contain :math:`Y` as well.

  #. One concludes that :math:`Y = \mathrm{Sg}^𝐀 (X)`.

Subdirect products
------------------

If :math:`k, n ∈ ℕ`, if :math:`A = (A_0, A_1, \dots, A_{n-1})` is a list of sets, and if :math:`σ : k → n` is a :math:`k`-tuple, then a relation :math:`R` over :math:`A` with scope :math:`σ` is a subset of the Cartesian product :math:`A_{σ(0)} × A_{σ(1)} × \cdots × A_{σ(k-1)}`.

Let :math:`F` be a set of operation symbols and for each :math:`i<n` let :math:`𝐀_i = ⟨ A_i, F ⟩` be an algebra of type :math:`F`. If :math:`𝐀 = ∏_{i<n}𝐀_i` is the product of these algebras, then a relation :math:`R` over :math:`𝐀` with scope :math:`σ` is called **compatible with** 𝐀 if it is closed under the basic operations in
:math:`F`. In other words, :math:`R` is compatible if the induced algebra :math:`𝐑 = ⟨ R, F ⟩` is a subalgebra of :math:`\prod_{j<k} 𝐀_{σ(j)}`.

If :math:`R` is compatible with the product algebra and if the projection of :math:`R` onto each factor is surjective, then :math:`𝐑` is called a **subdirect product** of the algebras in the list :math:`(𝐀_{σ(0)}, 𝐀_{σ(1)}, \dots, 𝐀_{σ(k-1)})`; we denote this situation by writing :math:`𝐑 ≤_{\mathrm{sd}} \prod_{j< k} 𝐀_{σ(j)}` [1]_ 

.. index:: ! clone

.. _clones:

Clones
------

A **clone** on a nonempty set :math:`A` is a set of operations on :math:`A` that contains the projection operations and is closed under :ref:`general composition <general-composition>`. 

.. todo:: complete this section

.. index:: ! Taylor term, ! term

.. _terms-and-free-algebras:

Terms and free algebras
-----------------------

.. For a nonempty set :math:`A`, we let :math:`𝖮_A` denote the set of all finitary operations on :math:`A`. That is, :math:`𝖮_A = ⋃_{n∈ ℕ} A^{A^n}` on :math:`A` is a subset of :math:`𝖮_A` that contains all projection operations and is closed under the (partial) operation of :ref:`general composition <general-composition>`.

If :math:`𝐀 = ⟨ A, F^𝐀 ⟩` denotes the algebra with universe :math:`A` and set of basic operations :math:`F`, then :math:`\operatorname{Clo} (𝐀)` denotes the clone generated by :math:`F`, which is also known as the **clone of term operations** of :math:`𝐀`.

Walter Taylor proved in :cite:`MR0434928` that a variety, :math:`𝕍`, satisfies some nontrivial idempotent Malcev condition if and only if it satisfies one of the following form: for some :math:`n`, 𝕍 has an idempotent :math:`n`-ary term  :math:`t` such that for each :math:`i < n` there is an identity of the form 

.. math:: t(∗, \cdots, ∗, x, ∗, \cdots, ∗) ≈ t(∗, \cdots, ∗, y, ∗, \cdots, ∗)

true in 𝕍 where distinct variables :math:`x` and :math:`y` appear in the :math:`i`-th position on either side of the identity.  Such a term :math:`t` is now commonly
called a **Taylor term**. 

.. The clone of *polynomials} of $\alg A$, denoted by $\Pol \alg A$, is the clone generated by the basic operations of $\alg A$ and the constant unary maps on $A$.

.. The set of  :math:`n`-ary members of $\Pol \alg A$ is sometimes denoted by $\Pol_n \alg A$. The smallest clone on a set $A$ is the set of all projections 

.. $\Proj A := \{\pi^n_i \mid 0\leq i < n < \omega\}$, defined as follows: for $0\leq i < n < \omega$, if $a \colon n \to A$, then $\pi^n_i a = a\, i$.
 
.. .. [9] Lean's built-in sigma type is defined as follows: :math:`structure sigma {α : Type u} (β : α → Type v) := mk :: (fst : α) (snd : β fst)`

Fix a signature :math:`σ = (F, ρ)`, let :math:`X` be a set of **variables** and assume :math:`X ∩ F = ∅`.

For every :math:`n < ω`, let  :math:`F_n = ρ^{-1} \{n\}` be the set of :math:`𝗇`-ary operation symbols.

By a **word** on :math:`X ∪ F` we mean a nonempty, finite sequence of members of :math:`X ∪ T`.

We denote the concatenation of sequences by simple juxtaposition. We define, by recursion on :math:`n`, the sets :math:`T_n` of words on :math:`X ∪ F` by

.. math::      T_0 &= X ∪ F_0;\\
           T_{n+1} &= T_n ∪ \{ f s ∣ f ∈  F, \ s : ρf → T_n \}. 

Define the set of **terms in the signature** σ **over** :math:`X` by :math:`T_ρ(X) = ⋃_{n < ω}T_n`.

The definition of :math:`T_ρ (X)` is recursive, indicating that *the set of terms in a signature can be implemented in Lean using an inductive type*.

We will confirm this in the next subsection, but before doing so, we impose an algebraic structure on :math:`T_ρ(X)`, and then state and prove some basic but important facts about this algebra. These will be formalized in the next section, giving us another chance to compare informal language proofs to their formal Lean counterparts and to show off inductively defined types in Lean.

If :math:`w` is a term, let :math:`|w|` be the least :math:`n` such that :math:`w ∈ T_n`, called the *height* of :math:`w`. [2]_ The height is a useful index for recursion and induction.

Notice that the set :math:`T_ρ (X)` is nonempty iff either :math:`X` or :math:`F_0` is nonempty. As long as :math:`T_ρ (X)` is nonempty, we can impose upon this set an algebraic structure, as follows:

For every basic operation symbol :math:`f ∈ F` let :math:`f^{𝐓_ρ (X)}` be the operation on :math:`𝐓_ρ (X)` that maps each tuple :math:`𝐚 : ρf → T_ρ (X)` to the formal term :math:`f 𝐚`.

We define :math:`𝐓_ρ (X)` to be the algebra with universe :math:`T_ρ (X)` and with basic operations :math:`\{f^{𝐓_ρ (X)} | f ∈ F\}`. [3]_

Indeed, Part (2) of :ref:`Theorem 4.21 <thm-4-21>` below asserts that :math:`𝐓_ρ (X)` is *universal for* \sigma-algebras.

To prove this, we need the following basic lemma, which states that a homomorphism is uniquely determined by its restriction to a generating set. (See also :cite:`Bergman:2012`, Ex. 1.16.6.)

.. _ex_1-16-6-brief:

.. proof:lemma:: Homomorphisms are determined on generating sets

   Let :math:`f` and :math:`g` be homomorphisms from 𝐀 to 𝐁. If :math:`X ⊆ A` and :math:`X` generates 𝐀 and :math:`f|_X = g|_X`, then :math:`f = g`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Suppose the subset :math:`X ⊆ A` generates 𝐀 and suppose :math:`f|_X = g|_X`. Fix an arbitrary element :math:`a ∈ A`.

      We show :math:`f(a) = g(a)`. Since :math:`X` generates 𝐀, there exists a (say, :math:`n`-ary) term :math:`t` and a tuple :math:`(x_1, \dots, x_n) ∈ X^n` such that :math:`a = t^{𝐀}(x_1, \dots, x_n)`. Therefore,

      .. math:: f(a) = f(t^{𝐀}(x_1, \dots, x_n)) &= t^{𝐁}(f(x_1), \dots, f(x_n)) \\
                                    &= t^{𝐁}(g(x_1), \dots, g(x_n)) = g(t^{𝐀}(x_1, \dots, x_n)) = g(a).

Here is another useful theorem. (See also :cite:`Bergman:2012`, Thm. 4.21.) 

.. _thm-4-21:

.. proof:theorem:: The term algebra is absolutely free

   Let :math:`σ = (F, ρ)` be a signature.

   #. :math:`𝐓_ρ (X)` is generated by X.
   #. For every σ-algebra 𝐀 and every function :math:`h : X → A` there is a unique homomorphism :math:`g : 𝐓_ρ (X) → 𝐀` such that :math:`g|_X = h`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      The definition of :math:`𝐓_ρ (X)` exactly parallels the construction in :ref:`Theorem 1.14 <thm-1-14>`. That accounts for (1).

      For (2), define :math:`g(t)` by induction on :math:`ρt`. Suppose :math:`ρt = 0`. Then :math:`t ∈ X ∪ F`.
      
      If :math:`t ∈ X` then define :math:`g(t) = h(t)`. For :math:`t ∉ X`, :math:`g(t) = t^{𝐀}`.
      
      Note that since 𝐀 is an \sigma-algebra and 𝗍 is a nullary operation symbol, :math:`t^{𝐀}` is defined.
    
      For the inductive step, let :math:`|t| = n + 1`. Then :math:`t = f(s_1, \dots, s_k)` for some :math:`f ∈ F_k` and :math:`s_1, \dots, s_k` each of height at most :math:`n`.
      
      We define :math:`g(t) = f^{𝐀}(g(s_1), \dots, g(s_k))`.
      
      By its very definition, 𝗀 is a homomorphism.
      
      Finally, the uniqueness of 𝗀 follows from :ref:`Lemma 1.16 <ex_1-16-6-brief>`. 


.. todo:: complete this section (include material on free algebras)

.. _basic-facts:

Basic Facts
-----------

Throughout this section,

+ :math:`𝐀 = ⟨A, F^𝐀⟩, \ 𝐁 = ⟨B, F^𝐁⟩, \ 𝐂 = ⟨C, F^𝐂⟩\ ` are algebras of the same signature :math:`σ = (F, ρ)`, and

+ :math:`g, h : \hom(𝐀, 𝐁)` are homomorphism from 𝐀 to 𝐁;

.. index:: ! equalizer

The **equalizer** of :math:`g` and :math:`h` is the set

.. math:: 𝖤(g,h) = \{ a : A ∣ g(a) = h(a) \}.

Here is a list of basic observations that we will need later. We will reference the first observation in the list as :ref:`Obs 1 <obs-one>`, etc. [4]_

.. _obs-one:

.. proof:observation::

   :math:`𝖤(g,h)` is a subuniverse of 𝐀.

   .. container:: toggle
 
      .. container:: header
 
         *Proof.*

      Fix arbitrary :math:`f ∈ F` and :math:`a : ρf → 𝖤(g,h)`.

      We show that :math:`g (f^𝐀 ∘ a) = h (f^𝐀 ∘ a)`, as this shows that :math:`𝖤(g, h)` is closed under the operation :math:`f^𝐀` of :math:`𝐀`.

      But this is trivial since, by definition of homomorphism, we have

      .. math:: (g ∘ f^𝐀)(ι_i a) = (f^𝐁 ∘ F g)(ι_i a) = (f^𝐁 ∘ F h)(ι_i a) = (h ∘ f^𝐀)(ι_i a).

.. _obs-two:

.. proof:observation::

   If the set :math:`X ⊆ A` generates 𝐀 and :math:`g|_X = h|_X`, then :math:`g = h`.

   .. container:: toggle
    
      .. container:: header
  
         *Proof*.

      Suppose the subset :math:`X ⊆ A` generates :math:`⟨A, f^𝐀⟩` and suppose :math:`g|_X = h|_X`.
 
      Fix an arbitrary :math:`a : A`. We show :math:`g(a) = h(a)`.
 
      Since :math:`X` generates 𝐀, there exists a term :math:`t` and a tuple :math:`x : ρt → X` of generators such that :math:`a = t^𝐀 x`.
 
      Therefore, since :math:`F g = F h` on :math:`X`, we have
    
      .. math:: g(a) = g(tᴬ x) = (tᴮ ∘ F g)(x) = (tᴮ ∘ F h)(x) = h(tᴬ x) = h(a).

.. _obs-three:

.. proof:observation::

   If :math:`A, B` are finite and :math:`X` generates 𝐀, then :math:`|\hom(𝐀, 𝐁)| ≤ |B|^{|X|}`.

   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      By :ref:`Obs 2 <obs-two>`, a homomorphism is uniquely determined by its restriction to a generating set.

      If :math:`X` generates 𝐀, then since there are exactly :math:`|B|^{|X|}` functions from :math:`X` to :math:`B` we have :math:`|\hom(𝐀, 𝐁)| ≤ |B|^{|X|}`.
    
.. _obs-four:

.. proof:observation::

   If :math:`g : \epi (𝐀, 𝐁)` and :math:`h : \hom (𝐀, 𝐂)` satisfy :math:`\ker g ⊆ \ker h`, then

   .. math:: ∃ k ∈ \hom(𝐁, 𝐂)\ . \ h = k ∘ g.
    
   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      We define :math:`k ∈ \hom(𝐁, 𝐂)` constructively, as follows:

      Fix :math:`b : B`.

      Since :math:`g` is surjective, the set :math:`g^{-1}\{b\} ⊆ A` is nonempty, and since :math:`\ker g ⊆ \ker h`, we see that every element of :math:`g^{-1}\{b\}` is mapped by :math:`h` to a single element of :math:`C`.

      Label this element :math:`c_b`. That is, :math:`h(a) = c_b`, for all :math:`a : g^{-1}\{b\}`.
   
      We define :math:`k(b) = c_b`. Since :math:`b` was arbitrary, :math:`k` is defined on all of :math:`B` in this way.
   
      Now it's easy to see that :math:`k g = h` by construction.
   
      Indeed, for each :math:`a ∈ A`, we have :math:`a ∈ g^{-1}\{g(a)\}`, so :math:`k(g(a)) = h(a)` by definition.
   
      To see that :math:`k` is a homomorphism, let there be :math:`m` operation symbols and let :math:`0≤ i< m` be arbitrary.
   
      Fix :math:`b : \underline{k_i} → B`.
   
      Since :math:`g` is surjective, for each :math:`i : \underline{k_i}`, the subset :math:`g^{-1}\{b(i)\}⊆ A` is nonempty and is mapped by :math:`h` to a single point of :math:`C` (since :math:`\ker g ⊆ \ker h`.
   
      Label this point :math:`c_i` and define :math:`c : \underline{k_i} → C` by :math:`c(i) = c_i`.
   
      We want to show :math:`(f^C ∘ F k) (b) = (k ∘ f^B)(b).`
   
      The left hand side is :math:`f^C c`, which is equal to :math:`(h ∘ fᴬ)(a)` for some :math:`a : \underline{k_i} → A`, since :math:`h` is a homomorphism.
   
      Therefore,
   
      .. math:: (f^C ∘ F k) (b) = (h ∘ f^A) (a) = (k ∘ g ∘ f^A)(a) = (k ∘ f^B ∘ F g)(a) = (k ∘ f^B)(b).

.. _obs-five:

.. proof:observation::

   Let :math:`S = (F, ρ)` be a signature each :math:`f ∈ F` an :math:`(ρf)`-ary operation symbol.
 
    Define :math:`F_0 := \operatorname{Proj}(A)` and for all :math:`n > 0` in :math:`ω` let
 
    .. math:: F_{n+1} := F_n ∪ \{ f g ∣ f ∈ F, g : ρf → (F_n ∩ (ρg → A)) \}.
 
    Then :math:`\mathrm{Clo}^{𝐀}(F) = ⋃_n F_n`.
 
.. _obs-six:

.. proof:observation::

   Let :math:`f` be a similarity type.
 
    (a) :math:`𝐓_ρ (X)` is generated by :math:`X`.
 
    (b) For every algebra :math:`𝐀 = ⟨A, F⟩` of type :math:`ρ` and every function :math:`h : X → A` there is a unique homomorphism :math:`g : 𝐓_ρ (X) → ⟨A, fᴬ⟩` such that :math:`g|_X = h`.
 
   .. container:: toggle
    
      .. container:: header
     
         *Proof*.
     
      The definition of :math:`𝐓_ρ (X)` exactly parallels the construction in Theorem 1.14 :cite:`Bergman:2012`. That accounts for the first item.
     
      For b, define :math:`g(t)` by induction on :math:`|t|`.
     
      Suppose :math:`|t| = 0`.  Then :math:`t ∈ X ∪ \mathcal F_0`.
     
      If :math:`t ∈ X` then define :math:`g(t) = h(t)`. For :math:`t ∈ \mathcal F_0`, :math:`g(t) = t^{𝐀}`.
     
      Note that since :math:`𝐀 = ⟨A, fᴬ⟩` is an algebra of type :math:`f` and :math:`t` is a nullary operation symbol, :math:`t^{𝐀}` is defined.
     
      For the inductive step, let :math:`|t| = n + 1`. Then :math:`t = f(s_1, \dots, s_k)` for some :math:`f ∈ \mathcal F_k` and :math:`s_1, \dots, s_k` each of height at most :math:`n`. We define :math:`g(t) = f^{𝐀}(g(s_1), \dots, g(s_k))`.
     
      By its very definition, :math:`g` is a homomorphism. Finally, the uniqueness of :math:`g` follows from Exercise 1.16.6 in :cite:`Bergman:2012`.
 
.. _obs-seven:

.. proof:observation::

   Let :math:`𝐀 = ⟨A, f^{𝐀}⟩` and :math:`𝐁 = ⟨B, f^{𝐁}⟩` be algebras of type :math:`ρ`.
 
    (a) For every :math:`n`-ary term :math:`t` and homomorphism :math:`g : 𝐀 → 𝐁`, :math:`g(t^{𝐀}(a_1,\dots, a_n)) = t^{𝐁}(g(a_1),\dots, g(a_n))`.

    (b) For every term :math:`t ∈ T_ρ(X_ω)` and every :math:`θ ∈ \mathrm{Con}⟨A, fᴬ⟩`, :math:`𝐀 ≡_θ 𝐁` implies :math:`t^{𝐀}(𝐀) ≡_θ t^{𝐀}(𝐁)`.

    (c) For every subset :math:`Y` of :math:`A`,

        .. math:: \Sg^{𝐀}(Y) = \{ t^{𝐀}(a_1, \dots, a_n) : t ∈ Tᵨ (X_n), a_i ∈ Y, i ≤ n < ω\}.

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      The first statement is an easy induction on :math:`|t|`.
    
      The second statement follows from the first by taking :math:`⟨B, f^{𝐁}⟩ = ⟨A, f^{𝐀}⟩/θ` and :math:`g` the canonical homomorphism.
    
      For the third statement, again by induction on the height of :math:`t`, every subalgebra must be closed under the action of :math:`t^{𝐀}`.
    
      Thus the right-hand side is contained in the left. On the other hand, the right-hand side is clearly a subalgebra containing the elements of :math:`Y` (take :math:`t = x_1`) from which the reverse inclusion follows.

------------------------

.. rubric:: Footnotes

.. [1]
   Note that even in the special case when :math:`\Proj_j 𝐑 = 𝐀_{σ(j)}` for each :math:`j<k` so that :math:`𝐑 ≤_{\mathrm{sd}} ∏_{j<k} 𝐀_{σ(j)}`, we refrain from using :math:`\Proj_σ 𝐀` to denote :math:`∏_{j<k} 𝐀_{σ(j)}`  for the simple reason that σ might not be one-to-one.  For example, we could have :math:`𝐀 = 𝐀_0 × 𝐀_1` and :math:`σ = (1,0,1)`, in which case :math:`∏_{j<k} 𝐀_{σ(j)} = 𝐀_1 × 𝐀_0 × 𝐀_1` and this is not the "projection" of 𝐀 onto a subset of its factors.
   
.. [2]
   The **height** of a type is simply type's *level* (see Section ???) and the syntax :math:`Type*` indicates that we do not wish to commit in advance to a specific height.

.. [3]
   The construction of :math:`𝐓_ρ (X)` may seem to be making something out of nothing, but it plays a crucial role in the theory.

.. [4]
   To see the proofs, click the black triangles.

.. _Agda: https://wiki.portal.chalmers.se/agda/pmwiki.php

.. _Coq: http://coq.inria.fr

.. _NuPRL: http://www.nuprl.org/

.. _Lean: https://leanprover.github.io/

.. _Logic and Proof: https://leanprover.github.io/logic_and_proof/

.. _lean-ualib: https://github.com/UniversalAlgebra/lean-ualib/

.. _mathlib: https://github.com/leanprover-community/mathlib/

.. _lean_src: https://github.com/leanprover/lean

.. _lattice.lean: https://github.com/leanprover-community/mathlib/blob/master/src/data/set/lattice.lean

.. _basic.lean: https://github.com/leanprover-community/mathlib/blob/master/src/data/set/basic.lean

.. _set.lean: https://github.com/leanprover/lean/blob/master/library/init/data/set.lean

.. _2015 post by Floris van Doorn: https://homotopytypetheory.org/2015/12/02/the-proof-assistant-lean/

