---
layout: default
title : The Agda Universal Algebra Library (UALib)
date : 2020-10-10
---
<!--

LICENSE:

The software in this file is subject to the GNU General Public License v3.0.

The text and software is copyright of the author. It can be used for scholarly purposes subject to the usual academic conventions of citation.

-->

<!--

  * The file ualib.lagda is *not* meant to be read by people.

  * It is used to automatically generate the following files, which are meant to be read by people:

    - https://ualib.org/ualib.html

    - https://ualib.org/ualib.pdf

  * The html file is better rendered and probably easier to read than the pdf file, but both have internal links, including to the Agda definitions.

  * Warning: this file takes a long time to be checked by Agda.  We are avoiding a modular development so that a single pdf file with internal links, including to the Agda definitions, can be produced. This works by first using Agda to generate html for the Agda code, then using jekyll to process the markdown code to generate html for everything else, and finally using google-chrome in headless mode to generate pdf from the html code.  See the makefile.

-->

# <a id="ualib">The Agda Universal Algebra Library (UALib)</a>

10 Oct 2020, version of {{ "now" | date: "%d %B %Y, %H:%M" }}.

[William DeMeo](https://williamdemeo.gitlab.io)

## Preface

To support formalization in type theory of research level mathematics in universal algebra and related fields, we are developing a software library, called the [Agda Universal Algebra Library](https://github.com/UniversalAlgebra/agda-ualib/) ([agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io) ). Our library contains formal statements and proofs of some of the core, foundational definitions and results universal algebra and is written in [Agda](https://wiki.portal.chalmers.se/agda/pmwiki.php).

[Agda](https://wiki.portal.chalmers.se/agda/pmwiki.php) is a programming language and [proof assistant](https://en.wikipedia.org/wiki/Proof_assistant), or "interactive theorem prover" (ITP), that not only supports dependent and inductive types, but also provides powerful *proof tactics* for proving things about the objects that inhabit these types.

### Vision and Goals

The idea for the the Agda Universal Algebra Library ([UALib](https://gitlab.com/ualib/ualib.gitlab.io)) originated with the observation that, on the one hand a number of basic and important constructs in universal algebra can be defined recursively, and theorems about them proved inductively, while on the other hand the *types* (of [type theory](https://en.wikipedia.org/wiki/Type_theory) ---in particular, [dependent types](https://en.wikipedia.org/wiki/Dependent_type) and [inductive types](https://en.wikipedia.org/wiki/Intuitionistic_type_theory#Inductive_types)) make possible elegant formal representations of recursively defined objects, and constructive (*computable*) proofs of their properties. These observations suggest that there is much to gain from implementing universal algebra in a language that facilitates working with dependent and inductive types.

#### Primary Goals

The first goal of the [UALib][] project is to demonstrate that it is possible to express the foundations of universal algebra in type theory and to formalize (and formally verify) the foundations in the Agda programming language. We will formalize a substantial portion of the edifice on which our own mathematical
research depends, and demonstrate that our research can also be
expressed in type theory and formally implemented in such a way that we
and other working mathematicians can understand and verify the results.
The resulting library will also serve to educate our peers, and
encourage and help them to formally verify their own mathematics
research.

Our field is deep and wide and codifying all of its foundations may seem
like a daunting task and possibly risky investment of time and
resources. However, we believe our subject is well served by a new,
modern, [constructive](constructive%20mathematics) presentation of its
foundations. Our new presentation expresses the foundations of universal
algebra in the language of type theory, and uses the Agda proof
assistant to codify and formally verify everything.

#### Secondary Goals

We wish to emphasize that our ultimate objective is not merely to
translate existing results into a more modern and formal language.
Indeed, one important goal is to develop a system that is useful for
conducting research in mathematics, and that is how we intend to use our
library once we have achieved our immediate objective of implementing
the basic foundational core of universal algebra in Agda.

To this end, our intermediate-term objectives include

-   developing domain specific "proof tactics" to express the idioms of universal algebra,
-   incorporating automated proof search for universal algebra, and
-   formalizing theorems emerging from our own mathematics research,
-   documenting the resulting software libraries so they are usable by
    other working mathematicians.

For our own mathematics research, we believe a proof assistant equipped with specialized libraries for universal algebra, as well as domain-specific tactics to automate proof idioms of our field, will be extremely useful. Thus, a secondary goal is to demonstrate (to ourselves and colleagues) the utility of such libraries and tactics for proving new theorems.

### Intended audience

This document describes the Agda Universal Algebra Library
([agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io)) in enough
detail so that working mathematicians (and possibly some normal people,
too) might be able to learn enough about Agda and its libraries to put
them to use when creating, formalizing, and verifying new mathematics.

While there are no strict prerequisites, we expect anyone with an
interest in this work will have been motivated by prior exposure to
universal algebra, as presented in, say, Bergman:2012 or McKenzie:1987,
and to a lesser extent category theory, as presented in
[categorytheory.gitlab.io](https://categorytheory.gitlab.io) or
Riehl:2017.

Some prior exposure to [type
theory](https://en.wikipedia.org/wiki/Type_theory) and Agda would be
helpful, but even without this background one might still be able to get
something useful out of this by referring to the appendix and glossary,
while simultaneously consulting one or more of the references mentioned
in references to fill in gaps as needed.

Finally, it is assumed that while reading these materials the reader is
actively experimenting with Agda using
[emacs](https://www.gnu.org/software/emacs/) with its
[agda2-mode](https://agda.readthedocs.io/en/v2.6.0.1/tools/emacs-mode.html)
extension installed.

### Installing the library

The main repository for the
[agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io) is
<https://gitlab.com/ualib/ualib.gitlab.io> (which will become publicly
available again in the summer of 2020).

There are installation instructions in the main README.md file in that
repository, but really all you need to do is have a working Agda (and
agda2-mode) installation and clone the
[agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io) repository with,
e.g.,

``` {.sourceCode .bash}
git clone git@gitlab.com:ualib/ualib.gitlab.io.git
```

OR

``` {.sourceCode .bash}
git clone https://gitlab.com/ualib/ualib.gitlab.io.git
```

(We assume you have
[Agda](https://wiki.portal.chalmers.se/agda/pmwiki.php) and
[agda2-mode](https://agda.readthedocs.io/en/v2.6.0.1/tools/emacs-mode.html)
installed on your machine. If not, follow the directions on [the main
Agda website](Agda) to install them.)


### Unicode hints

At the end of each chapter of this documentation we show how to produce
in Emacs
[agda2-mode](https://agda.readthedocs.io/en/v2.6.0.1/tools/emacs-mode.html)
some of the fancy unicode characters that we use in our code. For
example, we might say "type `\MCI` to produce the symbol ùìò". We hope
these occasional hints are convenient for the reader, but they are not
meant to be comprehensive. Instead, information about unicode symbols is
readily available in Emacs
[agda2-mode](https://agda.readthedocs.io/en/v2.6.0.1/tools/emacs-mode.html);
simply place the cursor on the character of interest and enter the
command `M-x describe-char`; alternatively, use the shortcut
`M-m h d c`. To see a full list of available characters, enter
`M-x describe-input-method` (or `C-h I`).

### Acknowledgments

Besides the main authors and developers of
[agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io) (William DeMeo
and Siva Somayyajula), a number of other people have contributed to the
project in one way or another.

Special thanks go to [Clifford Bergman](https://orion.math.iastate.edu/cbergman/), [Venanzio Capretta](https://www.duplavis.com/venanzio/), [Andrej Bauer](http://www.andrej.com/index.html), [Mikl√≥s Mar√≥ti](http://www.math.u-szeged.hu/~mmaroti/), and [Ralph Freese](https://math.hawaii.edu/~ralph/), for many helpful discussions, as well as the invaluable instruction, advice, and encouragement that they continue to lend to this project, often without even knowing it.

The first author would also like to thank his postdoctoral advisors and
their institutions for supporting (sometimes without their knowledge)
work on this project. These include [Libor
Barto](http://www.karlin.mff.cuni.cz/~barto/) and Charles University in
Prague (Nov 2019--Jun 2021), [Peter
Mayr](http://math.colorado.edu/~mayr/) and University of Colorado in
Boulder (Aug 2017--May 2019), [Ralph
Freese](https://math.hawaii.edu/~ralph/) and the University of Hawaii in
Honolulu (Aug 2016--May 2017), [Cliff
Bergman](https://orion.math.iastate.edu/cbergman/) and Iowa State
University in Ames (Aug 2014--May 2016).

### Attributions and citations

William DeMeo and Siva Somayyajula (hereinafter, "The Authors") are the
developers of the [Agda Universal Algebra
Library](https://github.com/UniversalAlgebra/agda-ualib/)
([agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io)).

Regarding the mathematical results that are implemented in the
[agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io) library, as well
as the presentation and informal statements of these results in the
documentation, The Authors makes no claims to originality.

Regarding the Agda source code in the
[agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io) library, this is
mainly due to The Authors.

HOWEVER, we have benefited from the outstanding lecture notes on
[Univalent Foundations and Homotopy Type
Theory](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes)
and the [Type
Topology](%3Chttps://github.com/martinescardo/TypeTopology%3E%60_) Agda
Library, both by [Martin H√∂tzel
Escardo](https://www.cs.bham.ac.uk/~mhe). The first author is greatly
indebted to Martin for teaching him about type theory in Agda at the
[Midlands Graduate School in the Foundations of Computing
Science](http://events.cs.bham.ac.uk/mgs2019/) in Birmingham in 2019.

The development of the
[agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io) and its
documentation is informed by and benefits from the references listed in
the references section below.


### References

The following Agda documentation and tutorials are excellent. They have
been quite helpful to The Author of
[agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io), and have
informed the development of the latter and its documentation.

-   Altenkirk, [Computer Aided Formal
    Reasoning](http://www.cs.nott.ac.uk/~psztxa/g53cfr/)
-   Bove and Dybjer, [Dependent Types at
    Work](http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf)
-   Escardo, [Introduction to Univalent Foundations of Mathematics with
    Agda](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/index.html)
-   Gunther, Gadea, Pagano, [Formalization of Universal Algebra in
    Agda](http://www.sciencedirect.com/science/article/pii/S1571066118300768)
-   J√°nos, [Agda
    Tutorial](https://people.inf.elte.hu/pgj/agda/tutorial/Index.html)
-   Norell and Chapman, [Dependently Typed Programming in
    Agda](http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf)
-   Wadler, [Programming Language Foundations in
    Agda](https://plfa.github.io/)

Finally, the official [Agda
Wiki](https://wiki.portal.chalmers.se/agda/pmwiki.php), [Agda User's
Manual](https://agda.readthedocs.io/en/v2.6.1/), [Agda Language
Reference](https://agda.readthedocs.io/en/v2.6.1/language), and the
(open source) [Agda Standard
Library](https://agda.github.io/agda-stdlib/) source code are also quite
useful.

------------------------------------------------------------------------

## Agda Preliminaries

This chapter describes the [prelude
module](https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/prelude.lagda.rst)
of the [agda-ualib](https://gitlab.com/ualib/ualib.gitlab.io). The
source code for this module comprises the (literate)
[Agda](https://wiki.portal.chalmers.se/agda/pmwiki.php) program that was
used to generate the html page displaying the sentence you are now
reading. This source code inhabits the file
[prelude.lagda.rst](prelude%20module), which resides in the [git
repository of the agda-ualib](agda-ualib).

**Notation**. Here are some acronyms that we use frequently.

-   MHE = [Martin H√∂tzel Escardo](https://www.cs.bham.ac.uk/~mhe/)
-   MLTT = [Martin-L√∂f Type Theory](https://ncatlab.org/nlab/show/Martin-L%C3%B6f+dependent+type+theory)

------------------------------------------------------------------------

Options and imports
-------------------

All but the most trivial Agda programs begin by setting some options
that effect how Agda behaves and importing from existing libraries
(e.g., the [Agda Standard Library](https://agda.github.io/agda-stdlib/)
or, in our case, MHE's [Type
Topology](%3Chttps://github.com/martinescardo/TypeTopology%3E%60_)
library). In particular, logical axioms and deduction rules can be
specified according to what one wishes to assume.

For example, we begin our agda development with the line

\begin{code}
{-# OPTIONS --without-K --exact-split --safe #-}

module ualib where
\end{code}

This specifies Agda `OPTIONS` that we will use throughout the library.

- `without-K` disables [Streicher's K axiom](https://ncatlab.org/nlab/show/axiom+K+%28type+theory%29);
  see also the [section on axiom K](https://agda.readthedocs.io/en/v2.6.1/language/without-k.html)
  in the [Agda Language Reference](https://agda.readthedocs.io/en/v2.6.1/language) manual.
- `exact-split` makes Agda accept only those definitions that behave
  like so-called *judgmental* or *definitional* equalities. MHE
  explains this by saying it "makes sure that pattern matching
  corresponds to Martin-L√∂f eliminators;" see also the [Pattern
  matching and equality
  section](https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#pattern-matching-and-equality)
  of the [Agda Tools](https://agda.readthedocs.io/en/v2.6.1/tools/)
  documentation.
- `safe` ensures that nothing is postulated outright---every
  non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module);
  see also [this section](https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#cmdoption-safe)
  of the [Agda Tools](https://agda.readthedocs.io/en/v2.6.1/tools/) documentation and the
  [Safe Agda section](https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html#safe-agda)
  of the [Agda Language Reference](https://agda.readthedocs.io/en/v2.6.1/language).

### Universes

We import the `Universes` module from MHE's [Type Topology](%3Chttps://github.com/martinescardo/TypeTopology%3E%60_)
library.

\begin{code}
open import Universes public
\end{code}

This `Universes` module provides, among other things, an elegant notation for type universes that we have fully adopted and we use MHE's notation throughout the [UALib](https://gitlab.com/ualib/ualib.gitlab.io).

MHE has authored an outstanding set of notes on [HoTT-UF-in-Agda](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) called [Introduction to Univalent Foundations of Mathematics with Agda](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/index.html). We highly recommend these notes to anyone wanting more details than we provide here about MLTT and the Univalent Foundations/HoTT extensions thereof.

Following MHE, we refer to universes using capitalized script letters ùì§,ùì•,ùì¶,ùì£. We add a few more to Martin's list.

\begin{code}
variable ùìò ùìô ùìö ùìõ ùìú ùìù ùìû ùì† ùì° ùì¢ ùìß : Universe
\end{code}

In the `Universes` module, MHE defines the Ãá operator which maps a universe ùì§ (i.e., a level) to `Set ùì§`, and the latter has type `Set (lsuc ùì§)`.

The level `lzero` is renamed ùì§‚ÇÄ, so ùì§‚ÇÄ Ãá is an alias for `Set lzero` (which, incidentally, corresponds to `Sort 0` in [Lean](https://leanprover.github.io/)).

Although it is nice and short, we won't show all of the `Universes` module here. Instead, we highlight the few lines of code from MHE's `Universes.lagda` file that makes available the notational devices that we just described and will adopt throughout the [UALib](https://gitlab.com/ualib/ualib.gitlab.io).

Thus, ùì§ Ãá is simply an alias for `Set ùì§`, and we have `Set ùì§ : Set (lsuc ùì§)`.

Finally, `Set (lsuc lzero)` is denoted by `Set ùì§‚ÇÄ ‚Å∫` which (MHE and) we denote by `ùì§‚ÇÄ ‚Å∫ Ãá`.

The following dictionary translates between standard Agda syntax and MHE/[UALib](https://gitlab.com/ualib/ualib.gitlab.io) notation.

```agda
Agda              MHE/UALib
====              ==============
Level             Universe
lzero             ùì§‚ÇÄ
ùì§ : Level         ùì§ : Universe
Set lzero         ùì§‚ÇÄ Ãá
Set ùì§             ùì§ Ãá
lsuc lzero        ùì§‚ÇÄ ‚Å∫
lsuc ùì§            ùì§ ‚Å∫
Set (lsuc lzero)  ùì§‚ÇÄ ‚Å∫ Ãá
Set (lsuc ùì§)      ùì§ ‚Å∫ Ãá
Setœâ              ùì§œâ
```

To justify the introduction of this somewhat nonstandard notation for
universe levels, MHE points out that the Agda library uses `Level` for
universes (so what we write as ùì§ Ãá is written `Set ùì§` in standard Agda),
but in univalent mathematics the types in ùì§ Ãá need not be sets, so the
standard Agda notation can be misleading. Furthermore, the standard
notation places emphasis on levels rather than universes themselves.

There will be many occasions calling for a type living in the universe
that is the least upper bound of two universes, say, ùì§ Ãá and ùì• Ãá . The
universe ùì§ ‚äî ùì• Ãá denotes this least upper bound. Here ùì§ ‚äî ùì• is used to
denote the universe level corresponding to the least upper bound of the
levels ùì§ and ùì•, where the `_‚äî_` is an Agda primitive designed for
precisely this purpose.

### Public imports

Next we import other parts of MHE's [Type
Topology](%3Chttps://github.com/martinescardo/TypeTopology%3E%60_)
library, using the Agda directive `public`, which means these imports
will be available wherever the `prelude` module in imported. We describe
some of these imports later, when making use of them, but we don't
describe each one in detail. (The interested or confused reader should
consult
[HoTT-UF-in-Agda](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html)
to learn more.)

\begin{code}
open import Identity-Type renaming (_‚â°_ to infix 0 _‚â°_ ;
 refl to ùìá‚ÑØùíªùìÅ) public

pattern refl x = ùìá‚ÑØùíªùìÅ {x = x}

open import Sigma-Type renaming (_,_ to infixr 50 _,_) public

open import MGS-MLTT using (_‚àò_; domain; codomain; transport;
 _‚â°‚ü®_‚ü©_; _‚àé; pr‚ÇÅ; pr‚ÇÇ; -Œ£; Œ†; ¬¨; _√ó_; ùëñùëë; _‚àº_; _+_; ùüò; ùüô; ùüö;
 _‚áî_; lr-implication; rl-implication; id; _‚Åª¬π; ap) public

open import MGS-Equivalences using (is-equiv; inverse;
 invertible) public

open import MGS-Subsingleton-Theorems using (funext;
 dfunext; is-singleton; is-subsingleton; is-prop; Univalence;
 global-dfunext; univalence-gives-global-dfunext; _‚óè_; _‚âÉ_;
 logically-equivalent-subsingletons-are-equivalent;
 Œ†-is-subsingleton) public

open import MGS-Powerset renaming (_‚àà_ to _‚àà‚ÇÄ_; _‚äÜ_ to _‚äÜ‚ÇÄ_)
 using (ùìü; ‚àà-is-subsingleton; equiv-to-subsingleton;
 powersets-are-sets'; subset-extensionality'; propext) public

open import MGS-Embeddings using (is-embedding; pr‚ÇÅ-embedding;
 is-set; _‚Ü™_; embedding-gives-ap-is-equiv; embeddings-are-lc;
 √ó-is-subsingleton) public

open import MGS-Solved-Exercises using (to-subtype-‚â°) public

open import MGS-Subsingleton-Truncation hiding (refl; _‚àà_; _‚äÜ_) public
\end{code}

------------------------------------------------------------------------

### Dependent pair type

Our preferred notations for the first and second projections of a
product are `‚à£_‚à£` and `‚à•_‚à•`, respectively; however, we will sometimes
use the more standard `pr‚ÇÅ` and `pr‚ÇÇ`, or even `fst` and `snd`, for
emphasis, readability, or compatibility with other libraries.

\begin{code}
‚à£_‚à£ fst : {X : ùì§ Ãá }{Y : X ‚Üí ùì• Ãá} ‚Üí Œ£ Y ‚Üí X
‚à£ x , y ‚à£ = x
fst (x , y) = x

‚à•_‚à• snd : {X : ùì§ Ãá }{Y : X ‚Üí ùì• Ãá } ‚Üí (z : Œ£ Y) ‚Üí Y (pr‚ÇÅ z)
‚à• x , y ‚à• = y
snd (x , y) = y
\end{code}

For the dependent pair type, we prefer the notation `Œ£ x Íûâ X , y`, which
is more pleasing (and more standard in the literature) than Agda's
default syntax (`Œ£ Œª(x Íûâ X) ‚Üí y`), and MHE has a useful trick that makes
the preferred notation available by making index type explicit.

```agda
infixr -1 -Œ£
-Œ£ : {ùì§ ùì• : Universe} (X : ùì§ Ãá ) (Y : X ‚Üí ùì• Ãá ) ‚Üí ùì§ ‚äî ùì• Ãá
-Œ£ X Y = Œ£ Y
syntax -Œ£ X (Œª x ‚Üí y) = Œ£ x Íûâ X , y -- type `Íûâ` as `\:4`
```

<div class="admonition warning">

The symbol Íûâ is not the same as : despite how similar they may appear.
The correct colon in the expression `Œ£ x Íûâ X , y` above is obtained by
typing `\:4` in
[agda2-mode](https://agda.readthedocs.io/en/v2.6.0.1/tools/emacs-mode.html).

</div>

MHE explains Sigma induction as follows: "To prove that `A z` holds for
all `z : Œ£ Y`, for a given property `A`, we just prove that we have
`A (x , y)` for all `x : X` and `y : Y x`. This is called `Œ£` induction
or `Œ£` elimination (or `uncurry`).

```agda
Œ£-induction : {X : ùì§ Ãá }{Y : X ‚Üí ùì• Ãá }{A : Œ£ Y ‚Üí ùì¶ Ãá }
 ‚Üí            ((x : X)(y : Y x) ‚Üí A (x , y))
              -------------------------------
 ‚Üí            ((x , y) : Œ£ Y) ‚Üí A (x , y)
Œ£-induction g (x , y) = g x y

curry : {X : ùì§ Ãá }{Y : X ‚Üí ùì• Ãá }{A : Œ£ Y ‚Üí ùì¶ Ãá }
 ‚Üí      (((x , y) : Œ£ Y ) ‚Üí A (x , y))
       ---------------------------------
 ‚Üí      ((x : X) (y : Y x) ‚Üí A (x , y))
curry f x y = f (x , y)
```

The special case in which the type `Y` doesn't depend on `X` is of
course the usual Cartesian product.

```agda
infixr 30 _√ó_
_√ó_ : ùì§ Ãá ‚Üí ùì• Ãá ‚Üí ùì§ ‚äî ùì• Ãá
X √ó Y = Œ£ x Íûâ X , Y
```

------------------------------------------------------------------------

### Dependent function type

To make the syntax for `Œ†` conform to the standard notation for "Pi
types" (or dependent function type), MHE uses the same trick as the one
used above for "Sigma types."

```agda
Œ† : {X : ùì§ Ãá } (A : X ‚Üí ùì• Ãá ) ‚Üí ùì§ ‚äî ùì• Ãá
Œ† {ùì§} {ùì•} {X} A = (x : X) ‚Üí A x

-Œ† : {ùì§ ùì• : Universe}(X : ùì§ Ãá )(Y : X ‚Üí ùì• Ãá ) ‚Üí ùì§ ‚äî ùì• Ãá
-Œ† X Y = Œ† Y
infixr -1 -Œ†
syntax -Œ† A (Œª x ‚Üí b) = Œ† x Íûâ A , b
```

------------------------------------------------------------------------

### Application

An important tool that we use often in Agda proofs is application of a
function to an identification `p : x ‚â° x'`. We apply the `ap` operator
to obtain the identification `ap f p : f x ‚â° f x'` when given
`p : x ‚â° x'` and `f : X ‚Üí Y`.

Since `ap` is already defined in MHE's Type Topolgy library, we don't
redefine it here. However, we do define some variations of `ap` that are
sometimes useful.

\begin{code}
ap-cong : {X : ùì§ Ãá}{Y : ùì• Ãá}{f g : X ‚Üí Y} {a b : X}
 ‚Üí        f ‚â° g  ‚Üí  a ‚â° b
          -----------------
 ‚Üí        f a ‚â° g b

ap-cong (refl _) (refl _) = refl _
\end{code}

Here is a related tool that we borrow from the `Relation/Binary/Core.agda` module of the [Agda standard library](https://agda.github.io/agda-stdlib/).

\begin{code}
cong-app : {A : ùì§ Ãá}{B : A ‚Üí ùì¶ Ãá}{f g : (a : A) ‚Üí B a}
 ‚Üí          f ‚â° g   ‚Üí   (a : A)
          -----------------------
 ‚Üí              f a ‚â° g a

cong-app (refl _) a = refl _
\end{code}

------------------------------------------------------------------------

### Function extensionality

Extensional equality of functions, or function extensionality, means
that any two point-wise equal functions are equal. As MHE points out,
this is known to be not provable or disprovable in Martin-L√∂f Type
Theory (MLTT).

Nonetheless, we will mainly work with pointwise equality of functions,
which MHE defines (in [Type
Topology](%3Chttps://github.com/martinescardo/TypeTopology%3E%60_) ) as
follows:

```agda
_‚àº_ : {X : ùì§ Ãá } {A : X ‚Üí ùì• Ãá } ‚Üí Œ† A ‚Üí Œ† A ‚Üí ùì§ ‚äî ùì• Ãá 
f ‚àº g = ‚àÄ x ‚Üí f x ‚â° g x
infix 0 _‚àº_
```

(The `_‚àº_` relation will be equivalent to equality of functions, once we
have the principle of *univalence* at our disposal.)

------------------------------------------------------------------------

### Predicates, Subsets

We need a mechanism for implementing the notion of subsets in Agda. A
typical one is called `Pred` (for predicate). More generally, `Pred A ùì§`
can be viewed as the type of a property that elements of type `A` might
satisfy. We write `P : Pred A ùì§` (read "`P` has type `Pred A ùì§`") to
represent the subset of elements of `A` that satisfy property `P`.

Here is the definition (which is similar to the one found in the
`Relation/Unary.agda` file of [Agda standard
library](https://agda.github.io/agda-stdlib/) ).

\begin{code}
Pred : ùì§ Ãá ‚Üí (ùì• : Universe) ‚Üí ùì§ ‚äî ùì• ‚Å∫ Ãá
Pred A ùì• = A ‚Üí ùì• Ãá
\end{code}

Below we will often consider predicates over the class of all algebras
of a particular type. We will define the type of algebras `Algebra ùì§ ùëÜ`
(for some universe level ùì§). Like all types, `Algebra ùì§ ùëÜ` itself has a
type which happens to be ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ Ãá (as we will see in algebra type).
Therefore, the type of `Pred (Algebra ùì§ ùëÜ) ùì§` will be ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ Ãá as
well.

The inhabitants of the type `Pred (Algebra ùì§ ùëÜ) ùì§` are maps of the form
ùë® ‚Üí ùì§ Ãá; indeed, given an algebra ùë® : Algebra ùì§ ùëÜ, we have Pred ùë® ùì§ = ùë® ‚Üí
ùì§ Ãá.

### The membership relation

We introduce notation so that we may indicate that `x` "belongs to" a
"subset" `P`, or that `x` "has property" `P`, by writing either `x ‚àà P`
or `P x` (cf. `Relation/Unary.agda` in the [Agda standard
library](https://agda.github.io/agda-stdlib/) ).

\begin{code}
infix 4 _‚àà_ _‚àâ_
_‚àà_ : {A : ùì§ Ãá } ‚Üí A ‚Üí Pred A ùì¶ ‚Üí ùì¶ Ãá
x ‚àà P = P x

_‚àâ_ : {A : ùì§ Ãá } ‚Üí A ‚Üí Pred A ùì¶ ‚Üí ùì¶ Ãá
x ‚àâ P = ¬¨ (x ‚àà P)
\end{code}

----------------------------------------------

### Subset relations and operations

The subset relation is then denoted, as usual, with the `‚äÜ` symbol (cf.
`Relation/Unary.agda` in the [Agda standard
library](https://agda.github.io/agda-stdlib/) ).

\begin{code}
infix 4 _‚äÜ_ _‚äá_
_‚äÜ_ : {A : ùì§ Ãá } ‚Üí Pred A ùì¶ ‚Üí Pred A ùì£ ‚Üí ùì§ ‚äî ùì¶ ‚äî ùì£ Ãá
P ‚äÜ Q = ‚àÄ {x} ‚Üí x ‚àà P ‚Üí x ‚àà Q

_‚äá_ : {A : ùì§ Ãá } ‚Üí Pred A ùì¶ ‚Üí Pred A ùì£ ‚Üí ùì§ ‚äî ùì¶ ‚äî ùì£ Ãá
P ‚äá Q = Q ‚äÜ P

infixr 1 _‚äé_

-- Disjoint Union.
data _‚äé_ (A : ùì§ Ãá) (B : ùì• Ãá) : ùì§ ‚äî ùì• Ãá where
  inj‚ÇÅ : (x : A) ‚Üí A ‚äé B
  inj‚ÇÇ : (y : B) ‚Üí A ‚äé B

-- Union.
infixr 6 _‚à™_
_‚à™_ : {A : ùì§ Ãá} ‚Üí Pred A ùì• ‚Üí Pred A ùì¶ ‚Üí Pred A _
P ‚à™ Q = Œª x ‚Üí x ‚àà P ‚äé x ‚àà Q


-- The empty set.
‚àÖ : {A : ùì§ Ãá} ‚Üí Pred A ùì§‚ÇÄ
‚àÖ = Œª _ ‚Üí ùüò
\end{code}

------------------------------------------------------------------------

### Miscellany

Finally, we include the following list of "utilities" that will come in
handy later. Most of these are self-explanatory, but we make a few
remarks below when we feel there is something worth noting.

\begin{code}
_‚àà‚àà_ : {A : ùì§ Ãá } {B : ùì¶ Ãá } ‚Üí (A  ‚Üí  B) ‚Üí Pred B ùì£ ‚Üí ùì§ ‚äî ùì£ Ãá
_‚àà‚àà_ f S = (x : _) ‚Üí f x ‚àà S

Im_‚äÜ_ : {A : ùì§ Ãá } {B : ùì• Ãá } ‚Üí (A ‚Üí B) ‚Üí Pred B ùì£ ‚Üí ùì§ ‚äî ùì£ Ãá
Im_‚äÜ_ {A = A} f S = (x : A) ‚Üí f x ‚àà S

img : {X : ùì§ Ãá } {Y : ùì§ Ãá }
      (f : X ‚Üí Y) (P : Pred Y ùì§)
 ‚Üí    Im f ‚äÜ P ‚Üí  X ‚Üí Œ£ P
img {Y = Y} f P Imf‚äÜP = Œª x‚ÇÅ ‚Üí f x‚ÇÅ , Imf‚äÜP x‚ÇÅ

‚â°-elim-left : {A‚ÇÅ A‚ÇÇ : ùì§ Ãá } {B‚ÇÅ B‚ÇÇ : ùì¶ Ãá }
 ‚Üí            (A‚ÇÅ , B‚ÇÅ) ‚â° (A‚ÇÇ , B‚ÇÇ)
              ----------------------
 ‚Üí                   A‚ÇÅ ‚â° A‚ÇÇ
‚â°-elim-left e = ap pr‚ÇÅ e

‚â°-elim-right : {A‚ÇÅ A‚ÇÇ : ùì§ Ãá }{B‚ÇÅ B‚ÇÇ : ùì¶ Ãá }
 ‚Üí             (A‚ÇÅ , B‚ÇÅ) ‚â° (A‚ÇÇ , B‚ÇÇ)
              -----------------------
 ‚Üí                    B‚ÇÅ ‚â° B‚ÇÇ
‚â°-elim-right e = ap pr‚ÇÇ e

‚â°-√ó-intro : {A‚ÇÅ A‚ÇÇ : ùì§ Ãá } {B‚ÇÅ B‚ÇÇ : ùì¶ Ãá }
 ‚Üí           A‚ÇÅ ‚â° A‚ÇÇ  ‚Üí  B‚ÇÅ ‚â° B‚ÇÇ
          ------------------------
 ‚Üí          (A‚ÇÅ , B‚ÇÅ) ‚â° (A‚ÇÇ , B‚ÇÇ)
‚â°-√ó-intro (refl _ ) (refl _ ) = (refl _ )

cong-app-pred : ‚àÄ{A : ùì§ Ãá }{B‚ÇÅ B‚ÇÇ : Pred A ùì§}
                (x : A) ‚Üí  x ‚àà B‚ÇÅ  ‚Üí  B‚ÇÅ ‚â° B‚ÇÇ
               ------------------------------
 ‚Üí                         x ‚àà B‚ÇÇ
cong-app-pred x x‚ààB‚ÇÅ (refl _ ) = x‚ààB‚ÇÅ

cong-pred : {A : ùì§ Ãá }{B : Pred A ùì§}
            (x y : A) ‚Üí  x ‚àà B  ‚Üí  x ‚â° y
            ----------------------------
 ‚Üí                       y ‚àà B
cong-pred x .x x‚ààB (refl _ ) = x‚ààB


data Image_‚àã_ {A : ùì§ Ãá }{B : ùì¶ Ãá }(f : A ‚Üí B) : B ‚Üí ùì§ ‚äî ùì¶ Ãá
  where
  im : (x : A) ‚Üí Image f ‚àã f x
  eq : (b : B) ‚Üí (a : A) ‚Üí b ‚â° f a ‚Üí Image f ‚àã b

ImageIsImage : {A : ùì§ Ãá }{B : ùì¶ Ãá }
               (f : A ‚Üí B) (b : B) (a : A)
 ‚Üí              b ‚â° f a
              ----------------------------
 ‚Üí              Image f ‚àã b
ImageIsImage {A = A}{B = B} f b a b‚â°fa = eq b a b‚â°fa
\end{code}

N.B. the assertion `Image f ‚àã y` must come with a proof, which is of the
form `‚àÉa f a = y`, so we have a witness. Thus, the inverse can be
"computed" in the following way:

\begin{code}
Inv : {A : ùì§ Ãá }{B : ùì¶ Ãá }(f : A ‚Üí B)(b : B) ‚Üí Image f ‚àã b  ‚Üí  A
Inv f .(f a) (im a) = a
Inv f b (eq b a b‚â°fa) = a
\end{code}

The special case for Set (i.e., `ùì§‚ÇÄ Ãá`) is

\begin{code}
inv : {A B : ùì§‚ÇÄ Ãá }(f : A ‚Üí B)(b : B) ‚Üí Image f ‚àã b ‚Üí A
inv {A} {B} = Inv {ùì§‚ÇÄ}{ùì§‚ÇÄ}{A}{B}

InvIsInv : {A : ùì§ Ãá } {B : ùì¶ Ãá } (f : A ‚Üí B)
           (b : B) (b‚ààImgf : Image f ‚àã b)
          ---------------------------------
 ‚Üí         f (Inv f b b‚ààImgf) ‚â° b
InvIsInv f .(f a) (im a) = refl _
InvIsInv f b (eq b a b‚â°fa) = b‚â°fa ‚Åª¬π
\end{code}

An epic (or surjective) function from ùì§ Ãá to ùì¶ Ãá (and the special case for `ùì§‚ÇÄ Ãá`) is defined as follows.

\begin{code}
Epic : {A : ùì§ Ãá } {B : ùì¶ Ãá } (g : A ‚Üí B) ‚Üí  ùì§ ‚äî ùì¶ Ãá
Epic g = ‚àÄ y ‚Üí Image g ‚àã y

epic : {A B : ùì§‚ÇÄ Ãá } (g : A ‚Üí B) ‚Üí ùì§‚ÇÄ Ãá
epic = Epic {ùì§‚ÇÄ} {ùì§‚ÇÄ}
\end{code}

The (pseudo-)inverse of an epic function is

\begin{code}
EpicInv : {A : ùì§ Ãá } {B : ùì¶ Ãá } (f : A ‚Üí B) ‚Üí Epic f ‚Üí B ‚Üí A
EpicInv f fEpic b = Inv f b (fEpic b)

-- The (psudo-)inverse of an epic is the right inverse.
EInvIsRInv : funext ùì¶ ùì¶ ‚Üí {A : ùì§ Ãá } {B : ùì¶ Ãá }
             (f : A ‚Üí B)  (fEpic : Epic f)
            ---------------------------------
 ‚Üí           f ‚àò (EpicInv f fEpic) ‚â° ùëñùëë B
EInvIsRInv fe f fEpic = fe (Œª x ‚Üí InvIsInv f x (fEpic x))
\end{code}

Monics (or injective) functions are defined this way.

\begin{code}
monic : {A : ùì§ Ãá } {B : ùì¶ Ãá } (g : A ‚Üí B) ‚Üí ùì§ ‚äî ùì¶ Ãá
monic g = ‚àÄ a‚ÇÅ a‚ÇÇ ‚Üí g a‚ÇÅ ‚â° g a‚ÇÇ ‚Üí a‚ÇÅ ‚â° a‚ÇÇ
monic‚ÇÄ : {A B : ùì§‚ÇÄ Ãá } (g : A ‚Üí B) ‚Üí ùì§‚ÇÄ Ãá
monic‚ÇÄ = monic {ùì§‚ÇÄ}{ùì§‚ÇÄ}

--The (pseudo-)inverse of a monic function
monic-inv : {A : ùì§ Ãá } {B : ùì¶ Ãá } (f : A ‚Üí B) ‚Üí monic f
 ‚Üí           (b : B) ‚Üí Image f ‚àã b ‚Üí A
monic-inv f fmonic  = Œª b Imf‚àãb ‚Üí Inv f b Imf‚àãb

--The (psudo-)inverse of a monic is the left inverse.
monic-inv-is-linv : {A : ùì§ Ãá }{B : ùì¶ Ãá }
                    (f : A ‚Üí B) (fmonic : monic f)(x : A)
                   ----------------------------------------
  ‚Üí                 (monic-inv f fmonic) (f x) (im x) ‚â° x
monic-inv-is-linv f fmonic x = refl _
\end{code}

Finally, we define bijective functions as follows.

\begin{code}
bijective : {A B : ùì§‚ÇÄ Ãá }(g : A ‚Üí B) ‚Üí ùì§‚ÇÄ Ãá
bijective g = epic g √ó monic g

Bijective : {A : ùì§ Ãá }{B : ùì¶ Ãá }(g : A ‚Üí B) ‚Üí ùì§ ‚äî ùì¶ Ãá
Bijective g = Epic g √ó monic g
\end{code}

------------------------------------------------------------------------

### More extensionality

Here we collect miscellaneous definitions and proofs related to
extensionality that will come in handy later.

\begin{code}
--Ordinary function extensionality
extensionality : ‚àÄ ùì§ ùì¶  ‚Üí ùì§ ‚Å∫ ‚äî ùì¶ ‚Å∫ Ãá
extensionality ùì§ ùì¶ = {A : ùì§ Ãá } {B : ùì¶ Ãá } {f g : A ‚Üí B}
 ‚Üí                f ‚àº g   ‚Üí   f ‚â° g

--Opposite of function extensionality
intensionality : ‚àÄ {ùì§ ùì¶} {A : ùì§ Ãá } {B : ùì¶ Ãá } {f g : A ‚Üí B}
 ‚Üí                f ‚â° g  ‚Üí  (x : A)
                  ------------------
 ‚Üí                    f x ‚â° g x

intensionality  (refl _ ) _  = refl _

--Dependent intensionality
dep-intensionality : ‚àÄ {ùì§ ùì¶}{A : ùì§ Ãá }{B : A ‚Üí ùì¶ Ãá }
                     {f g : ‚àÄ(x : A) ‚Üí B x}
 ‚Üí                   f ‚â° g  ‚Üí  (x : A)
                    ------------------
 ‚Üí                    f x ‚â° g x

dep-intensionality (refl _ ) _ = refl _

--------------------------------------
--Dependent function extensionality
dep-extensionality : ‚àÄ ùì§ ùì¶ ‚Üí ùì§ ‚Å∫ ‚äî ùì¶ ‚Å∫ Ãá
dep-extensionality ùì§ ùì¶ = {A : ùì§ Ãá } {B : A ‚Üí ùì¶ Ãá }
  {f g : ‚àÄ(x : A) ‚Üí B x} ‚Üí  f ‚àº g  ‚Üí  f ‚â° g

‚àÄ-extensionality : ùì§œâ
‚àÄ-extensionality = ‚àÄ  {ùì§ ùì•} ‚Üí extensionality ùì§ ùì•

‚àÄ-dep-extensionality : ùì§œâ
‚àÄ-dep-extensionality = ‚àÄ {ùì§ ùì•} ‚Üí dep-extensionality ùì§ ùì•

extensionality-lemma : {I : ùìò Ãá }{X : ùì§ Ãá }{A : I ‚Üí ùì• Ãá }
                       (p q : (i : I) ‚Üí (X ‚Üí A i) ‚Üí ùì£ Ãá )
                       (args : X ‚Üí (Œ† A))
 ‚Üí                     p ‚â° q
   -------------------------------------------------------------
 ‚Üí (Œª i ‚Üí (p i)(Œª x ‚Üí args x i)) ‚â° (Œª i ‚Üí (q i)(Œª x ‚Üí args x i))

extensionality-lemma p q args pq = ap (Œª - ‚Üí Œª i ‚Üí (- i) (Œª x ‚Üí args x i)) pq
\end{code}


[UALib]: https://ualib.org
[Agda Universal Algebra Library](https://github.com/UniversalAlgebra/agda-ualib/)
