.. File: facts.lagda.rst
.. Author: William DeMeo <williamdemeo@gmail.com>
.. Date: 23 May 2019
.. Updated: 13 Feb 2020
.. Copyright (c) 2019 William DeMeo

.. .. include:: _static/math_macros.rst

.. .. highlight:: agda

.. role:: cat
.. role:: code

.. _basic facts in agda:

======================
Basic Facts in Agda
======================

In this chapter we show how to state and prove in Agda the basic facts that we first encountered in :numref:`basic facts`. As in that section, we begin with the simple observation that

.. _homomorphisms in agda:

Homomorphisms
---------------------------

.. index:: equalizer

.. _equalizers in agda:

Equalizers
~~~~~~~~~~~~~~~

Recall, the **equalizer** of the functions :math:`g` and :math:`h` is the set :math:`𝖤(g,h) = \{ a : A ∣ g(a) = h(a) \}`. We begin by defining this in Agda, and then we implement the proof that the equalizer ``𝖤 g h`` of two homomorphisms ``g`` and ``h`` is a subuniverse of 𝔸 (cf. :numref:`Obs %s <obs 1>`).

.. -- (Obs 1) -------------------------------------------------------

.. include:: _static/homs1.lagda.rst


.. -- (Obs 2) -------------------------------------------------------

.. _composing homomorphisms:

Composing Homomorphisms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next, we formalize the proof that composing homomorphisms gives a homomorphism. (See :numref:`Obs %s <obs 2>`.)

.. include:: _static/homs2.lagda.rst


.. -- (Obs 3) -------------------------------------------------------

.. _homomorphisms agreeing on a generating set:

Homomorphisms agreeing on a generating set
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall (:numref:`Obs %s <obs 3>`), if two homomorphisms agree on a generating set, then they are equal.

More precisely, if a subset ``X`` is contained in the equalizer of two homomorphisms, then ``Sg X`` is also contained in the equalizer; thus, homomorphisms that agree on ``X`` also agree on ``Sg X``. Let us now state and prove this in Agda.

.. include:: _static/homs3.lagda.rst

Alternatively, we could have proved the last fact using the inductive nature of the definition of subalgebra generated by a set.

Indeed, recall the definition of ``Y`` above and the proof that ``Y X`` is equal to ``Sg X``; thus, properties of the subuniverse generated by the set ``X`` can be proved using the recursor of ``Y``.

.. todo:: insert include directive pointing to source file _static/???.rst

.. .. include:: _static/???.rst

.. -- (Obs 5) -------------------------------------------------------

.. _factoring homomorphisms:

Factoring homomorphisms
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next we implement in Agda the result on factoring homomorphisms (:numref:`Obs %s <obs 5>`).

.. Here is a related passage from `Theorem Proving in Lean`_:
   "The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces 'data' from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions ``noncomputable`` to flag that fact... To summarize, then, on top of the underlying framework of universes, dependent function types, and inductive types, the standard library adds three additional components:
..  #. the axiom of propositional extensionality
..  #. a quotient construction, which implies function extensionality
..  #. a choice principle, which produces data from an existential proposition.
..  The first two of these block normalization within Lean, but are compatible with byte-code evaluation, whereas the third is not amenable to computational interpretation."
.. The upshot is that we cannot always use Lean's ``exists.elim`` to produce data.
.. Nonetheless, we can use Lean's ``classical`` library and the ``noncomputable`` keyword to formalize proofs of nonconstructive results, like :numref:`Obs %s <obs 4>` on factoring homomorphisms.

.. .. index:: pair: epic; surjective
.. .. index:: pair: monic; injective
.. .. index:: bijective
.. .. index:: inverse, right inverse

.. First we define what it means for a function to be **epic** (or **surjective**), **monic** (or **injective**), and **bijective** (i.e., both epic and monic).

First, we need a couple of basic definitions, namely, the kernel of a function (which we define here as a binary predicate), and the **inverse** and **right inverse** of a surjective (or "epic") function. We also prove that an epic function has a right inverse.

.. include:: _static/homs4.lagda.rst

Now we are ready to prove the homomorphism factorization lemma of :numref:`Obs %s <obs 5>`.

.. include:: _static/homs5.lagda.rst



Subuniverses
------------------------------

.. -- (obs 6) -------------------------------------------------------

.. _s is closed under intersection:

S is closed under intersection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next we implement the prove that the collection of subuniverses of an algebra is closed under intersection (:numref:`Obs %s <obs 6>`).

The proof is left as an easy exercise.

.. todo:: insert include directive pointing to source file _static/subs.agda.4.rst

.. .. include:: _static/subs.agda.4.rst

.. -- (Obs 7) -------------------------------------------------------

.. _subalgebras in agda:

Subalgebras in Agda
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here we implement the recursive strategy for generating subuniverses (:numref:`Obs %s <obs 7>`).

.. todo:: insert include directive pointing to source file _static/subs.agda.4.rst

.. .. include:: _static/subs.agda.4.rst

.. --------------------------------------------------------------------------------------
.. CLONE GENERATION
.. We seek a "bottom-up," inductive description of the members of :math:`\mathsf{Clo}(F)`.  By thinking of the clone itself as a kind of algebra, a description analogous to :numref:`Obs %s <obs 6>` ought to be possible.  In fact, since function composition is associative, a slightly slicker formulation is available.

Terms and free algebras
--------------------------------

.. -- (Obs 9) -------------------------------------------------------

.. _freeness of the term algebra in Agda:

Freeness of the term algebra in Agda
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. todo:: insert include directive pointing to source file

.. .. include:: _static/???.rst

   
.. -- (Obs 10) -------------------------------------------------------

.. _homomorphisms commute with terms:

Homomorphisms commute with terms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We present an Agda proof of the fact that homomorphisms commute with terms.

Assume :math:`𝑨 = ⟨A, F^𝑨⟩` and :math:`𝑩 = ⟨B, F^𝑩⟩` are algebras in the same signature :math:`σ = (F, ρ)`, and :math:`t ∈ T_σ (X)` is an :math:`n`-ary term. In particular, :math:`t` has an interpretation in :math:`𝑨` (see :numref:`interpretation of terms`). We denote the interpretation of :math:`t` in :math:`𝑨` by :math:`t^𝑨 a = t^𝑨 (a\, 0, a\, 1, \dots, a\, (n-1))`, where :math:`a: \mathsf{Fin}(n) → A`. Similarly, :math:`t^𝑩: (\mathsf{Fin}(n) → B) → B` is the interpretation of :math:`t` in :math:`𝑩`. 
    
.. todo:: insert include directive pointing to source file

.. .. include:: _static/???.rst

   
.. -- (Obs 11) -------------------------------------------------------

.. _terms are compatible with congruences:

Terms are compatible with congruences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If :math:`θ` is a congruence of :math:`𝑨` and :math:`a, a': \mathsf{Fin}(n) → A` are :math:`n`-tuples over :math:`A`, then
    
.. math:: (a, a') ∈ θ \; ⟹  \; (t^𝑨\,a, t^𝑨\,a') ∈ θ.

.. todo:: insert include directive pointing to source file

.. .. include:: _static/???.rst

.. -- (Obs 12) -------------------------------------------------------

.. _subuniverse generation as image of terms:

Subuniverse generation as image of terms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If :math:`Y` is a subset of :math:`A`, then

.. math:: \mathsf{Sg}^{𝑨}(Y) = \{ t^𝑨 \, a ∣ t ∈ T_σ(X_n), \, n ∈ ℕ, \; a: ρ t → Y\}.

.. todo:: insert include directive pointing to source file

.. .. include:: _static/???.rst

Equational logic
--------------------------------------

.. -- (Obs 13) -------------------------------------------------------

.. _Identities satisfied by S, H, P, V:

Identities satisfied by S, H, P, V
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For every class 𝒦, each of the classes :math:`𝖲(𝒦)`, :math:`𝖧(𝒦)`, :math:`𝖯(𝒦)`, and :math:`𝕍(𝒦)` satisfies exactly the same identities as does 𝒦.

.. todo:: insert include directive pointing to source file

.. .. include:: _static/???.rst


.. -- (Obs 14) -------------------------------------------------------

.. _homomorphisms respect identities:

Homomorphisms respect identities
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:math:`𝒦 ⊧ p ≈ q` if and only if :math:`∀ 𝔸 ∈ 𝒦`, :math:`∀ h ∈ \mathsf{Hom}(𝕋(X_ω), 𝔸)`, :math:`h\, p^𝔸 = h\, q^𝔸`.

.. todo:: insert include directive pointing to source file

.. .. include:: _static/???.rst

   
.. -- (Obs 15) -------------------------------------------------------

.. _identities satisfied by the free algebra:

Identities satisfied by the free algebra
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here we prove that we can determine whether an identity is true in a variety by consulting :math:`𝔽(X_ω)`. 

Let 𝒦 be a class of algebras and :math:`p ≈ q` an equation. The following are equivalent.

     #. :math:`𝒦 ⊧ p ≈ q`.

     #. :math:`(p, q)` belongs to the congruence :math:`λ_{𝒦}` on :math:`𝕋(X_ω)`.

     #. :math:`𝔽_{𝒦}(X_ω) ⊧ p ≈ q`.

.. todo:: insert include directive pointing to source file

.. .. include:: _static/???.rst


.. -- (Obs 16) -------------------------------------------------------

.. _identities on generating sets:

Identities on generating sets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let :math:`𝒦` be a class of algebras, :math:`p` and :math:`q` :math:`n`-ary terms, :math:`Y` a set and :math:`y_1, \dots, y_n` distinct elements of :math:`Y`. Then :math:`𝒦 ⊧ p ≈ q` if and only if :math:`p^{𝔽_{𝒦}(Y)}(y_1, \dots, y_n) = q^{𝔽_{𝒦}(Y)}(y_1, \dots, y_n)`. In particular, :math:`𝒦 ⊧ p ≈ q` if and only if :math:`𝔽_{𝒦}(X_n) ⊧ p ≈ q`.

.. todo:: insert include directive pointing to source file

.. .. include:: _static/???.rst

-------------------

.. include:: hyperlink_references.rst
