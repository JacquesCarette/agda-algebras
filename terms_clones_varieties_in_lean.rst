.. include:: _static/math_macros.rst

.. highlight:: lean

.. _inductively-defined-types:

==================================
Inductively Defined Types
==================================

.. todo:: add chapter intro

We briefly introduced inductively defined types in :numref:`inductive-types`.  Many more details can be found in the chapter on `Inductive Types`_ in :term:`TPIL`. 

The availability and utility of inductively defined types were among our primary original motivations for formalizing universal algebra in a language (like Lean) that supports such types. In the present chapter, we show how these types come into play in our formalization project.  

---------------------------------------------------

.. _the-recursor:

The Recursor
-------------

Each inductively defined type, say ``foo``, is accompanied by an elimination principle known as a **recursor** (denoted by ``foo.rec`` in Lean). This elimination principle is what makes the type "inductive"; it allows us to define a function on ``foo`` by assigning values for each of ``foo``'s constructors.

.. todo:: complete this section; include an example.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: subalgebra, subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean_reprise:

Subalgebras in Lean (reprise)
-----------------------------

The Lean code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of the lean-ualib_ repository. [1]_

In :numref:`Section %s <subalgebras-in-lean>`, we saw how subalgebras can be implemented in Lean and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and implements the statement and proof of the :ref:`subuniverse generation theorem <thm-1-14>` formally in Lean.

First, we define an inductive type that represents the **subuniverse generated by a set**; cf. the informal language definition in given by :eq:`subalgebra-inductive` .

.. include:: _static/subuniverse.lean.2.rst

Next we prove that the type ``Y X`` is a subuniverse. Moreover, ``Y X`` is equal to :math:`\mathrm{Sg}^𝔸(X)`, which is another fact that we formalize and prove below.

.. include:: _static/subuniverse.lean.3.rst

Finally, we prove that ``Y`` is the smallest subuniverse containing ``X``.

.. include:: _static/subuniverse.lean.4.rst

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A ⊆ B → B ⊆ A → A = B`.

.. index:: recursor

We proved ``Y X ⊆ Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined. (We will see many more examples of inductive proofs below.)

The Lean keyword ``assume`` is syntactic sugar for ``λ``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: variables, word, term, free algebra
.. index:: universal for; σ-algebras
.. index:: absolutely free for; σ-algebras

.. _terms-in-lean:

Terms in Lean
-------------

The Lean code described in this section is in the source files ``free.lean`` and ``term.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`T(X)` of all terms of a given signature over a collection :math:`X` of variables.

.. include:: _static/free.lean.1.rst

We have defined some ``local notation``, so we can write, e.g., ``f: ℱ`` instead of ``f: σ.ℱ`` and ``ρ f`` instead of ``σ.ρ f``. This bit of syntactic sugar results in Lean syntax for operation symbols that matches the informal algebraic analogue almost exactly. [2]_ 

The collection of terms over :math:`X`, along with the operations :math:`F^{𝕋(X)} := \{\mathsf{app} f ∣ f : F\}` forms an algebra in the signature :math:`σ = (F, ρ)`, which we denote and define by :math:`𝕋(X) = ⟨T(X), F^{𝕋(X)}⟩` .

Now, suppose :math:`𝔸 = ⟨A, F^𝔸⟩` is an algebra in the signature σ and :math:`h : X → A` is an arbitrary function.  We will show that :math:`h : X → A` has a unique *extension* (or *lift*) to a homomorphism from :math:`𝕋(X)` to 𝔸.

Since 𝔸 and :math:`h : X → A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`𝕋(X)` is **universal for** σ-algebras. Some authors say, ":math:`𝕋(X)` is **absolutely free for** σ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. include:: _static/free.lean.2.rst

If :math:`h : X → A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`𝕋(X)` is defined inductively as follows:

.. include:: _static/free.lean.3.rst

To prove that the term algebra is universal for σ-algebras, we show that the lift of an arbitrary function :math:`h : X → A` is a homomorphism and that this lift is unique.

.. include:: _static/free.lean.4.rst

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

In this section we see how the clone concept, described above in :numref:`clones`, can be implemented in Lean.  We then formalize the proof of :numref:`Obs %s <obs-five>` which asserts that we can define *clone* inductively and that the inductive definition is equivalent to our initial definition.

The Lean code described in this section is in the source file `clone.lean`_, which reside in the ``src`` directory of the lean-ualib_ repository.

In order to ensure that the code in this section works without importing other parts of the `lean-ualib`_, we begin with a block of code comprised of excerpts from other parts of the `lean-ualib`_.

.. include:: _static/clone.lean.preamble.rst

Apart from the little "preamble" above, the remaining code blocks in this section should be surrounded by the lines

.. code::

    namespace ualib
      section clo 
        ... 
      end clo
    end ualib

although sometimes we don't show these lines explicitly.

We are now ready to define the ``structure`` that specifies the properties that a clone must have.  Recall (:numref:`clones`), a collection of operations is called a **clone** if and only if it *includes all projections* and is *closed under general composition*.

.. include:: _static/clone.lean.1.rst

Next we define an inductive type that represents the clone generated by a given collection ``𝒪`` of operations. Of course, a collection generated by ``𝒪`` should, at the very least, contain the generators (i.e., inhabitants of ``𝒪``); we check this fact as well.

.. include:: _static/clone.lean.2.rst

Finally, we check that the foregoing definition is indeed a clone and that it is the smallest clone containing the given collection of operations.

.. include:: _static/clone.lean.3.rst

-------------------------

Varieties in Lean
------------------

.. todo:: write this section

------------------------------

Birkhoff's HSP Theorem in Lean
--------------------------------

.. todo:: write this section

------------------------------


.. rubric:: Footnotes

.. [1]
   As of this writing (summer 2019), this documentation describes code residing on the william_ branch of the lean-ualib_ repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.

.. [2]
   The only exception is that in type theory we make *typing judgments*, denoted by ``:``, rather than set membership judgments, denoted by ``∈``.

.. include:: hyperlink_references.rst
