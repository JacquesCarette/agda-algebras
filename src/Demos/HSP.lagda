---
layout: default
title : "Demos.HSP module (Agda Universal Algebra Library)"
date : "2021-10-24"
author: "agda-algebras development team"
---

# <a id="introduction">Introduction</a>
The Agda Universal Algebra Library ([agda-algebras][]) is a collection of types and programs
(theorems and proofs) formalizing the foundations of universal algebra in dependent type
theory using the [Agda][] programming language and proof assistant.
The agda-algebras library now includes a substantial collection of definitions, theorems, and
proofs from universal algebra and equational logic and as such provides many
examples that exhibit the power of inductive and dependent types for
representing and reasoning about general algebraic and relational structures.

The first major milestone of the [agda-algebras][] project is a new formal
proof of *Birkhoff's variety theorem* (also known as the *HSP theorem*), the first version
of which was completed in [January of 2021](https://github.com/ualib/ualib.github.io/blob/b968e8af1117fc77700d3a588746cbefbd464835/sandbox/birkhoff-exp-new-new.lagda).
To the best of our knowledge, this was the first time Birkhoff's theorem had
been formulated and proved in dependent type theory and verified with a proof
assistant.

In this paper, we present a subset of the [agda-algebras][]
library that culminates in a complete, self-contained, formal proof of the HSP
theorem. In the course of our exposition of the proof, we discuss some of the
more challenging aspects of formalizing universal algebra in type theory and the
issues that arise when attempting to constructively prove some of the basic
results in that area.  We demonstrate that dependent type theory and Agda,
despite the demands they place on the user, are accessible to working
mathematicians who have sufficient patience and a strong enough desire to
constructively codify their work and formally verify the correctness of their
results.

Our presentation may be viewed as a sobering glimpse at the painstaking process
of doing mathematics in the languages of dependent types and Agda. Nonetheless we
hope to make a compelling case for investing in these languages. Indeed, we
are excited to share the gratifying rewards that come with some mastery of type
theory and interactive theorem proving technologies.

## <a id="preliminaries">Preliminaries</a>

### <a id="logical-foundations">Logical foundations</a>

An Agda program typically begins by setting some language options and by
importing types from existing Agda libraries. The language options are specified
using the `OPTIONS` *pragma* which affect control the way Agda behaves by controlling
the deduction rules that are available to us and the logical axioms 
that are assumed when the program is type-checked by Agda to verify its
correctness. Every Agda program in the [agda-algebras](https://github.com/ualib/agda-algebras) library begins with the
following line. 

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

\end{code}

These options control certain foundational assumptions that Agda makes when type-checking the program to verify its correctness.

* `--without-K` disables [Streicher's K axiom](https://ncatlab.org/nlab/show/axiom+K+%28type+theory%29) ; see also the [section on axiom K](https://agda.readthedocs.io/en/v2.6.1/language/without-k.html) in the [Agda Language Reference Manual](https://agda.readthedocs.io/en/v2.6.1.3/language).

* `--exact-split` makes Agda accept only those definitions that behave like so-called *judgmental* equalities.  [Mart√≠n Escard√≥](https://www.cs.bham.ac.uk/~mhe) explains this by saying it "makes sure that pattern matching corresponds to Martin-L√∂f eliminators;" see also the [Pattern matching and equality section](https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#pattern-matching-and-equality) of the [Agda Tools](https://agda.readthedocs.io/en/v2.6.1.3/tools/) documentation.

* `safe` ensures that nothing is postulated outright---every non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module); see also [this section](https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#cmdoption-safe) of the [Agda Tools](https://agda.readthedocs.io/en/v2.6.1.3/tools/) documentation and the [Safe Agda section](https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html#safe-agda) of the [Agda Language Reference](https://agda.readthedocs.io/en/v2.6.1.3/language).


### <a id="agda-modules">Agda Modules</a>

The `OPTIONS` pragma is usually followed by the start of a module.  Indeed, the
`HSP.lagda` program that is subject of this paper begins with the following
`import` directives, which import the parts of the [Agda Standard Library][]
that we will use in our program.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

open import Algebras.Basic using ( ùìû ; ùì• ; Signature )
module Demos.HSP {ùëÜ : Signature ùìû ùì•} where
open import Agda.Primitive using ( _‚äî_ ; lsuc ) renaming ( Set to Type )
open import Data.Product using ( Œ£-syntax ; _√ó_ ; _,_ ; Œ£ ) renaming ( proj‚ÇÅ to fst ; proj‚ÇÇ to snd )
open import Function using ( id ; _‚àò_ ; flip ; Surjection ) renaming ( Func to _‚ü∂_ )
open import Level using ( Level )
open import Relation.Binary using ( Setoid ; Rel ; IsEquivalence )
open import Relation.Binary.Definitions using ( Reflexive ; Sym ; Trans ; Symmetric ; Transitive )
open import Relation.Unary using ( Pred ; _‚äÜ_ ; _‚àà_ )
open import Relation.Binary.PropositionalEquality as ‚â° using (_‚â°_)
import Function.Definitions                       as FD
import Relation.Binary.Reasoning.Setoid           as SetoidReasoning
open _‚ü∂_  using ( cong ) renaming ( f to _‚ü®$‚ü©_ )
private variable
 Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà œÅ œá ‚Ñì : Level
 Œì Œî : Type œá
 f : fst ùëÜ

\end{code}

### <a id="setoids">Setoids</a>

A *setoid* is a type packaged with an equivalence relation on that type.  Setoids are
very useful for representing classical (set-theory-based) mathematics in a
constructive, type-theoretic setting because most mathematical structures are
assumed to come equipped with some (often implicit) notion of equality.

The [agda-algebras][] library was first developed without the use of setoids,
opting instead for experimenting with specially constructed quotient types.
However, this approach resulted in a code base that was hard to comprehend and
it became difficult to determine whether the resulting proofs were fully
constructive.  In particular, our initial proof of the Birkhoff variety theorem
required postulating function extensionality, an axiom that is not provable in
pure Martin-L√∂f type theory.[reference needed]

In contrast, our current approach uses setoids and thus makes explicit notions
of equality manifest for each type and makes it easier to determine the
correctness and constructivity of the proofs. Indeed, using setiods we need
no additional axioms beyond Martin-L√∂f type theory; in particular, no function
extensionality axioms are postulated in our current formalization of Birkhoff's
variety theorem.

Since it plays such a central role in the present development and exposition, we
reproduce in the appendix the definition of the `Setoid` type of the [Agda
Standard Library][]. In addition to `Setoid`, much of our code employs the
standard library's `Func` record type which represents a function from one
setoid to another and packages such a function with a proof (called `cong`) that
the function respects the underlying setoid equalities.
The definition of the `Func` type appears in the appendix. In the list
of imports above we rename `Func` to the (more visually appealing)
long-arrow symbol `‚ü∂`, but we will refer to inhabitants of the `Func`
type as "setoid functions" or "funcs" throughout this paper.

A special example of a func is the identity function from a setoid to itself.
We define it, along with a composition-of-funcs operation, as follows.

\begin{code}

ùëñùëë : {A : Setoid Œ± œÅ·µÉ} ‚Üí A ‚ü∂ A
ùëñùëë {A} = record { f = id ; cong = id }

_‚ü®‚àò‚ü©_ : {A : Setoid Œ± œÅ·µÉ} {B : Setoid Œ≤ œÅ·µá} {C : Setoid Œ≥ œÅ·∂ú}
 ‚Üí      B ‚ü∂ C  ‚Üí  A ‚ü∂ B  ‚Üí  A ‚ü∂ C

f ‚ü®‚àò‚ü© g = record { f = (_‚ü®$‚ü©_ f) ‚àò (_‚ü®$‚ü©_ g)
                 ; cong = (cong f) ‚àò (cong g) }

\end{code}


### <a id="projection-notation">Projection notation</a>

The definition of `Œ£` (and thus, of `√ó`) includes the fields `proj‚ÇÅ` and `proj‚ÇÇ`
representing the first and second projections out of the product.  However, we
prefer the shorter names `fst` and `snd`.  Sometimes we prefer to denote these
projections by `‚à£_‚à£` and `‚à•_‚à•`, respectively. We define these alternative
notations for projections out of pairs as follows.

\begin{code}

module _ {A : Type Œ± }{B : A ‚Üí Type Œ≤} where

 ‚à£_‚à£ : Œ£[ x ‚àà A ] B x ‚Üí A
 ‚à£_‚à£ = fst

 ‚à•_‚à• : (z : Œ£[ a ‚àà A ] B a) ‚Üí B ‚à£ z ‚à£
 ‚à•_‚à• = snd

\end{code}

Here we put the definitions inside an *anonymous module*, which starts with the
`module` keyword followed by an underscore (instead of a module name). The
purpose is simply to move the postulated typing judgments---the "parameters" of
the module (e.g., `A : Type Œ±`)---out of the way so they don't obfuscate the
definitions inside the module.


### <a id="inverses-of-functions-on-setoids">Inverses of functions on setoids</a>

(cf. the [Overture.Func.Inverses][] module of the [agda-algebras][] library.)

We define a data type that represent the semantic concept of the *image*
of a function.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë® using () renaming ( Carrier to A )
 open Setoid ùë© using ( _‚âà_ ; sym ) renaming ( Carrier to B )

 data Image_‚àã_ (F : ùë® ‚ü∂ ùë©) : B ‚Üí Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá) where
  eq : {b : B} ‚Üí (a : A) ‚Üí b ‚âà (F ‚ü®$‚ü© a) ‚Üí Image F ‚àã b

 open Image_‚àã_

\end{code}

An inhabitant of `Image f ‚àã b` is a dependent pair `(a , p)`, where `a : A` and `p : b ‚âà f a` is a proof that `f` maps `a` to `b`.  Since the proof that `b` belongs to the image of `f` is always accompanied by a witness `a : A`, we can actually *compute* a (pseudo)inverse of `f`. For convenience, we define this inverse function, which we call `Inv`, and which takes an arbitrary `b : B` and a (witness, proof)-pair, `(a , p) : Image f ‚àã b`, and returns the witness `a`.

\begin{code}

 Inv : (F : ùë® ‚ü∂ ùë©){b : B} ‚Üí Image F ‚àã b ‚Üí A
 Inv _ (eq a _) = a

\end{code}

In fact, `Inv f` is the range-restricted right-inverse of `f`, which we prove as follows.

\begin{code}

 InvIsInverse ≥ : {F : ùë® ‚ü∂ ùë©}{b : B}(q : Image F ‚àã b) ‚Üí (F ‚ü®$‚ü© (Inv F q)) ‚âà b
 InvIsInverse ≥ (eq _ p) = sym p

\end{code}


### <a id="injective-functions-on-setoids">Injective functions on setoids</a>

(cf. the [Overture.Func.Injective][] module of the [agda-algebras][] library.)

Naturally, we call a function `f : A ‚ü∂ B` from one setoid `(A , ‚âà‚ÇÄ)` to another
`(B , ‚âà‚ÇÅ)` and *injective* function provided `‚àÄ a‚ÇÄ a‚ÇÅ`, if `f ‚ü®$‚ü© a‚ÇÄ ‚âà‚ÇÅ f ‚ü®$‚ü©
a‚ÇÅ`, then `a‚ÇÄ ‚âà‚ÇÄ a‚ÇÅ`.  The [Agda Standard Library][] defines the type
`Injective` to representing injective functions on bare types and we use this to
define the type `IsInjective` which represents the property of being an
injective function from one setoid to another.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë® using () renaming ( _‚âà_ to _‚âà‚ÇÅ_)
 open Setoid ùë© using () renaming ( _‚âà_ to _‚âà‚ÇÇ_)
 open FD _‚âà‚ÇÅ_ _‚âà‚ÇÇ_

 IsInjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá)
 IsInjective f = Injective (_‚ü®$‚ü©_ f)

\end{code}

Proving that the composition of injective functions on setoids is again injective
is simply a matter of composing the two assumed witnesses to injectivity.

\begin{code}

module compose {A : Type Œ±}{B : Type Œ≤}{C : Type Œ≥}
               (_‚âà‚ÇÅ_ : Rel A œÅ·µÉ)(_‚âà‚ÇÇ_ : Rel B œÅ·µá)(_‚âà‚ÇÉ_ : Rel C œÅ·∂ú) where
 open FD {A = A} {B} _‚âà‚ÇÅ_ _‚âà‚ÇÇ_ using () renaming ( Injective to InjectiveAB )
 open FD {A = B} {C} _‚âà‚ÇÇ_ _‚âà‚ÇÉ_ using () renaming ( Injective to InjectiveBC )
 open FD {A = A} {C} _‚âà‚ÇÅ_ _‚âà‚ÇÉ_ using () renaming ( Injective to InjectiveAC )

 ‚àò-injective-func : {f : A ‚Üí B}{g : B ‚Üí C} ‚Üí InjectiveAB f ‚Üí InjectiveBC g ‚Üí InjectiveAC (g ‚àò f)
 ‚àò-injective-func finj ginj = finj ‚àò ginj

\end{code}



### <a id="surjective-functions-on-setoids">Surjective functions on setoids</a>

(cf. the [Overture.Func.Surjective][] module of the [agda-algebras][] library.)

A *surjective function* from one setoid `ùë® = (A, ‚âà‚ÇÄ)` to another `ùë© = (B, ‚âà‚ÇÅ)`
is a function `f : ùë® ‚ü∂ ùë©` such that for all `b : B` there exists `a : A` such
that `(f ‚ü®$‚ü© a) ‚âà‚ÇÅ b`.  In other words, the range and codomain of `f` agree.
Here is how we codify this notion in the [agda-algebras][] library.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Surjection renaming (f to _‚ü®$‚ü©_)
 open Setoid ùë® using () renaming (Carrier to A )
 open Setoid ùë© using () renaming (Carrier to B; _‚âà_ to _‚âà‚ÇÇ_ )

 IsSurjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá)
 IsSurjective F = ‚àÄ {y} ‚Üí Image F ‚àã y where open Image_‚àã_

\end{code}

With the next definition we represent a *right-inverse* of a surjective function.

\begin{code}

 SurjInv : (f : ùë® ‚ü∂ ùë©) ‚Üí IsSurjective f ‚Üí B ‚Üí A
 SurjInv f fE b = Inv f (fE {b})

\end{code}

Thus, a right-inverse of `f` is obtained by applying `Inv` to `f` and a proof of
`IsSurjective f`.  Next we prove that this does indeed give the right-inverse.
Thereafter, we prove that surjectivity is preserved under composition as follows.

\begin{code}

 SurjInvIsInverse ≥ : (f : ùë® ‚ü∂ ùë©)(fE : IsSurjective f)
  ‚Üí                  ‚àÄ {b} ‚Üí (f ‚ü®$‚ü© ((SurjInv f fE) b)) ‚âà‚ÇÇ b
 SurjInvIsInverse ≥ f fE = InvIsInverse ≥ fE

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá}{ùë™ : Setoid Œ≥ œÅ·∂ú}
         {G : ùë® ‚ü∂ ùë™}{H : ùë™ ‚ü∂ ùë©} where
 open Surjection renaming ( f to _‚ü®$‚ü©_ )
 open Setoid ùë© using ( trans ; sym )

 ‚àò-IsSurjective : IsSurjective G ‚Üí IsSurjective H ‚Üí IsSurjective (H ‚ü®‚àò‚ü© G)
 ‚àò-IsSurjective gE hE {y} = Goal
  where
  mp : Image H ‚àã y ‚Üí Image H ‚ü®‚àò‚ü© G ‚àã y
  mp (eq c p) = Œ∑ gE
   where
   Œ∑ : Image G ‚àã c ‚Üí Image H ‚ü®‚àò‚ü© G ‚àã y
   Œ∑ (eq a q) = eq a (trans p (cong H q))

  Goal : Image H ‚ü®‚àò‚ü© G ‚àã y
  Goal = mp hE

\end{code}



### <a id="kernels">Kernels</a>

The *kernel* of a function `f : A ‚Üí B` is defined informally by `{(x , y) ‚àà A √ó A : f x = f y}`.
This can be represented in Agda in a number of ways, but for our purposes it
is most convenient to define the kernel as an inhabitant of a (unary)
predicate over the square of the function's domain, as follows.

\begin{code}

module _ {A : Type Œ±}{B : Type Œ≤} where

 kernel : Rel B œÅ ‚Üí (A ‚Üí B) ‚Üí Pred (A √ó A) œÅ
 kernel _‚âà_ f (x , y) = f x ‚âà f y

\end{code}

The kernel of a function `f : ùê¥ ‚ü∂ ùêµ` from a setoid ùê¥ to a setoid ùêµ (with
carriers A and B, respectively) is defined informally by `{(x , y) ‚àà A √ó A : f
‚ü®$‚ü© x ‚âà‚ÇÇ f ‚ü®$‚ü© y}` and may be defined in Agda as follows.

\begin{code}

module _ {ùê¥ : Setoid Œ± œÅ·µÉ}{ùêµ : Setoid Œ≤ œÅ·µá} where
 open Setoid ùê¥ using () renaming ( Carrier to A )

 ker : (ùê¥ ‚ü∂ ùêµ) ‚Üí Pred (A √ó A) œÅ·µá
 ker g (x , y) = g ‚ü®$‚ü© x ‚âà g ‚ü®$‚ü© y where open Setoid ùêµ using ( _‚âà_ )

\end{code}


## Algebras


### <a id="algebras-basic-definitions">Basic definitions</a>

Here we define algebras over a setoid, instead of a mere type with no equivalence on it.

First we define an operator that translates an ordinary signature into a signature over a setoid domain.

\begin{code}


open Setoid using ( Carrier ; isEquivalence )

EqArgs : {ùëÜ : Signature ùìû ùì•}{Œæ : Setoid Œ± œÅ·µÉ}
 ‚Üí       ‚àÄ {f g} ‚Üí f ‚â° g ‚Üí (‚à• ùëÜ ‚à• f ‚Üí Carrier Œæ) ‚Üí (‚à• ùëÜ ‚à• g ‚Üí Carrier Œæ) ‚Üí Type (ùì• ‚äî œÅ·µÉ)

EqArgs {Œæ = Œæ} ‚â°.refl u v = ‚àÄ i ‚Üí u i ‚âà v i
 where
 open Setoid Œæ using ( _‚âà_ )


module _ where
 open Setoid        using ( _‚âà_ )
 open IsEquivalence using ( refl ; sym ; trans )

 ‚ü®_‚ü© : Signature ùìû ùì• ‚Üí Setoid Œ± œÅ·µÉ ‚Üí Setoid _ _
 Carrier (‚ü® ùëÜ ‚ü© Œæ) = Œ£[ f ‚àà ‚à£ ùëÜ ‚à£ ] ((‚à• ùëÜ ‚à• f) ‚Üí Œæ .Carrier)
 _‚âà_ (‚ü® ùëÜ ‚ü© Œæ) (f , u) (g , v) = Œ£[ eqv ‚àà f ‚â° g ] EqArgs{Œæ = Œæ} eqv u v
 refl  (isEquivalence (‚ü® ùëÜ ‚ü© Œæ))                          = ‚â°.refl , Œª _ ‚Üí Setoid.refl  Œæ
 sym   (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)             = ‚â°.refl , Œª i ‚Üí Setoid.sym   Œæ (g i)
 trans (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)(‚â°.refl , h) = ‚â°.refl , Œª i ‚Üí Setoid.trans Œæ (g i) (h i)

\end{code}


We represent an algebra using a record type with two fields: `Domain` is a setoid denoting the underlying *universe* of the algebra (informally, the set of elements of the algebra); `Interp` represents the *interpretation* in the algebra of each operation symbol of the given signature.  The record type `Func` from the Agda Standard Library provides what we need for an operation on the domain setoid.

Let us present the definition of the `Algebra` type and then discuss the definition of the `Func` type that provides the interpretation of each operation symbol.

\begin{code}

record Algebra Œ± œÅ : Type (ùìû ‚äî ùì• ‚äî lsuc (Œ± ‚äî œÅ)) where
 field
  Domain : Setoid Œ± œÅ
  Interp : (‚ü® ùëÜ ‚ü© Domain) ‚ü∂ Domain
 ‚â°‚Üí‚âà : ‚àÄ{x}{y} ‚Üí x ‚â° y ‚Üí (Setoid._‚âà_ Domain) x y
 ‚â°‚Üí‚âà ‚â°.refl = Setoid.refl Domain

\end{code}

We have thus codified the concept of (universal) algebra as a record type with
 two fields

1. a function  `f : Carrier (‚ü® ùëÜ ‚ü© Domain) ‚Üí Carrier Domain`
2. a proof `cong : f Preserves _‚âà‚ÇÅ_ ‚ü∂ _‚âà‚ÇÇ_` that `f` preserves the underlying setoid equalities.

Comparing this with the definition of the `Func` (or `_‚ü∂_`) type shown in the
appendix, here `A` is `Carrier (‚ü® ùëÜ ‚ü© Domain)` and `B` is `Carrier Domain`. Thus
`Interp` gives, for each operation symbol in the signature `ùëÜ`, a setoid
function `f`---namely, a function where the domain is a power of `Domain` and
the codomain is `Domain`---along with a proof that all operations so interpreted
respect the underlying setoid equality on `Domain`.

We define the following syntactic sugar: if `ùë®` is an algebra, `ùîª[ ùë® ]`
gives the setoid `Domain ùë®`, while `ùïå[ ùë® ]` exposes the underlying
carrier or "universe" of the algebra `ùë®`; finally, `f ÃÇ ùë®` denotes the
interpretation in the algebra `ùë®` of the operation symbol `f`.

\begin{code}

open Algebra

ùïå[_] : Algebra Œ± œÅ·µÉ ‚Üí  Type Œ±
ùïå[ ùë® ] = Carrier (Domain ùë®)

ùîª[_] : Algebra Œ± œÅ·µÉ ‚Üí  Setoid Œ± œÅ·µÉ
ùîª[ ùë® ] = Domain ùë®

_ÃÇ_ : (f : ‚à£ ùëÜ ‚à£)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí (‚à• ùëÜ ‚à• f  ‚Üí  ùïå[ ùë® ]) ‚Üí ùïå[ ùë® ]

f ÃÇ ùë® = Œª a ‚Üí (Interp ùë®) ‚ü®$‚ü© (f , a)

\end{code}


### <a id="universe-lifting-of-algebra-types">Universe lifting of algebra types</a>

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) where
 open Algebra ùë® using () renaming ( Domain to A ; Interp to InterpA )
 open Setoid A using (sym ; trans ) renaming ( Carrier to ‚à£A‚à£ ; _‚âà_ to _‚âà‚ÇÅ_ ; refl to refl‚ÇÅ )

 open Level


 Lift-AlgÀ° : (‚Ñì : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì) œÅ·µÉ

 Domain (Lift-AlgÀ° ‚Ñì) = record { Carrier = Lift ‚Ñì ‚à£A‚à£
                               ; _‚âà_ = Œª x y ‚Üí lower x ‚âà‚ÇÅ lower y
                               ; isEquivalence = record { refl = refl‚ÇÅ
                                                        ; sym = sym
                                                        ; trans = trans }}

 Interp (Lift-AlgÀ° ‚Ñì) ‚ü®$‚ü© (f , la) = lift ((f ÃÇ ùë®) (lower ‚àò la))
 cong (Interp (Lift-AlgÀ° ‚Ñì)) (‚â°.refl , la=lb) = cong InterpA ((‚â°.refl , la=lb))


 Lift-Alg ≥ : (‚Ñì : Level) ‚Üí Algebra Œ± (œÅ·µÉ ‚äî ‚Ñì)

 Domain (Lift-Alg ≥ ‚Ñì) =
  record { Carrier       = ‚à£A‚à£
         ; _‚âà_           = Œª x y ‚Üí Lift ‚Ñì (x ‚âà‚ÇÅ y)
         ; isEquivalence = record { refl  = lift refl‚ÇÅ
                                  ; sym   = Œª x ‚Üí lift (sym (lower x))
                                  ; trans = Œª x y ‚Üí lift (trans (lower x) (lower y)) }}

 Interp (Lift-Alg ≥ ‚Ñì ) ‚ü®$‚ü© (f , la) = (f ÃÇ ùë®) la
 cong (Interp (Lift-Alg ≥ ‚Ñì)) (‚â°.refl , la‚â°lb) =
  lift (cong (Interp ùë®) (‚â°.refl , Œª i ‚Üí lower (la‚â°lb i)))

Lift-Alg : (ùë® : Algebra Œ± œÅ·µÉ)(‚Ñì‚ÇÄ ‚Ñì‚ÇÅ : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì‚ÇÄ) (œÅ·µÉ ‚äî ‚Ñì‚ÇÅ)
Lift-Alg ùë® ‚Ñì‚ÇÄ ‚Ñì‚ÇÅ = Lift-Alg ≥ (Lift-AlgÀ° ùë® ‚Ñì‚ÇÄ) ‚Ñì‚ÇÅ

\end{code}


### <a id="product-algebras">Product Algebras</a>

(cf. the [Algebras.Func.Products][] module of the [Agda Universal Algebra Library][].)

\begin{code}

module _ {Œπ : Level}{I : Type Œπ } where

 ‚®Ö : (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) ‚Üí Algebra (Œ± ‚äî Œπ) (œÅ·µÉ ‚äî Œπ)

 Domain (‚®Ö ùíú) =
  record { Carrier = ‚àÄ i ‚Üí ùïå[ ùíú i ]
         ; _‚âà_ = Œª a b ‚Üí ‚àÄ i ‚Üí (Setoid._‚âà_ ùîª[ ùíú i ]) (a i)(b i)
         ; isEquivalence =
            record { refl  =     Œª i ‚Üí IsEquivalence.refl  (isEquivalence ùîª[ ùíú i ])
                   ; sym   =   Œª x i ‚Üí IsEquivalence.sym   (isEquivalence ùîª[ ùíú i ])(x i)
                   ; trans = Œª x y i ‚Üí IsEquivalence.trans (isEquivalence ùîª[ ùíú i ])(x i)(y i) }}


 Interp (‚®Ö ùíú) ‚ü®$‚ü© (f , a) = Œª i ‚Üí (f ÃÇ (ùíú i)) (flip a i)
 cong (Interp (‚®Ö ùíú)) (‚â°.refl , f=g ) = Œª i ‚Üí cong (Interp (ùíú i)) (‚â°.refl , flip f=g i )

\end{code}


## <a id="Homomorphisms">Homomorphisms</a>
### <a id="homomorphism-basic-definitions">Basic definitions</a>
Here are some useful definitions and theorems extracted from the [Homomorphisms.Func.Basic][] module of the [Agda Universal Algebra Library][].

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where
 open Algebra ùë® using () renaming (Domain to A )
 open Algebra ùë© using () renaming (Domain to B )
 open Setoid A using () renaming ( _‚âà_ to _‚âà‚ÇÅ_ )
 open Setoid B using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ )

 compatible-map-op : (A ‚ü∂ B) ‚Üí ‚à£ ùëÜ ‚à£ ‚Üí Type (ùì• ‚äî Œ± ‚äî œÅ·µá)
 compatible-map-op h f = ‚àÄ {a} ‚Üí (h ‚ü®$‚ü© ((f ÃÇ ùë®) a)) ‚âà‚ÇÇ ((f ÃÇ ùë©) (Œª x ‚Üí (h ‚ü®$‚ü© (a x))))

 compatible-map : (A ‚ü∂ B) ‚Üí Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µá)
 compatible-map h = ‚àÄ {f} ‚Üí compatible-map-op h f

 -- The property of being a homomorphism.
 record IsHom (h : A ‚ü∂ B) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá) where
  field compatible : compatible-map h

 hom : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá)
 hom = Œ£ (A ‚ü∂ B) IsHom

\end{code}


### <a id="monomorphisms-and-epimorphisms">Monomorphisms and epimorphisms</a>

\begin{code}

 record IsMon (h : A ‚ü∂ B) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá) where
  field isHom : IsHom h ; isInjective : IsInjective h

  HomReduct : hom
  HomReduct = h , isHom

 mon : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá)
 mon = Œ£ (A ‚ü∂ B) IsMon

 record IsEpi (h : A ‚ü∂ B) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá) where
  field isHom : IsHom h ; isSurjective : IsSurjective h

  HomReduct : hom
  HomReduct = h , isHom

 epi : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá)
 epi = Œ£ (A ‚ü∂ B) IsEpi

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where
 open IsEpi ;  open IsMon

 mon‚Üíintohom : mon ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£
 mon‚Üíintohom (hh , hhM) = (hh , isHom hhM) , isInjective hhM

 epi‚Üíontohom : epi ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsSurjective ‚à£ h ‚à£
 epi‚Üíontohom (hh , hhE) = (hh , isHom hhE) , isSurjective hhE

\end{code}


### <a id="basic-properties-of-homomorphisms">Basic properties of homomorphisms</a>

Here are some definitions and theorems extracted from the [Homomorphisms.Func.Properties][] module of the [Agda Universal Algebra Library][].


#### <a id="composition-of-homomorphisms">Composition of homomorphisms</a>


\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}
         {ùë© : Algebra Œ≤ œÅ·µá}
         {ùë™ : Algebra Œ≥ œÅ·∂ú} where

  open Algebra ùë® using () renaming (Domain to A )
  open Algebra ùë© using () renaming (Domain to B )
  open Algebra ùë™ using () renaming (Domain to C )
  open Setoid A using ()        renaming ( _‚âà_ to _‚âà‚ÇÅ_ )
  open Setoid B using ()        renaming ( _‚âà_ to _‚âà‚ÇÇ_ )
  open Setoid C using ( trans ) renaming ( _‚âà_ to _‚âà‚ÇÉ_ )

  open IsHom

  -- The composition of homomorphisms is again a homomorphism
  ‚àò-is-hom : {g : A ‚ü∂ B}{h : B ‚ü∂ C} ‚Üí IsHom ùë® ùë© g ‚Üí IsHom ùë© ùë™ h ‚Üí IsHom ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-hom {g} {h} ghom hhom = record { compatible = c }
   where
   c : compatible-map ùë® ùë™ (h ‚ü®‚àò‚ü© g)
   c {f}{a} = trans lemg lemh
    where
    lemg : (h ‚ü®$‚ü© (g ‚ü®$‚ü© ((f ÃÇ ùë®) a))) ‚âà‚ÇÉ (h ‚ü®$‚ü© ((f ÃÇ ùë©) (Œª x ‚Üí g ‚ü®$‚ü© (a x))))
    lemg = cong h (compatible ghom)

    lemh : (h ‚ü®$‚ü© ((f ÃÇ ùë©) (Œª x ‚Üí g ‚ü®$‚ü© (a x)))) ‚âà‚ÇÉ ((f ÃÇ ùë™) (Œª x ‚Üí h ‚ü®$‚ü© (g ‚ü®$‚ü© (a x))))
    lemh = compatible hhom

  ‚àò-hom : hom ùë® ùë© ‚Üí hom ùë© ùë™  ‚Üí hom ùë® ùë™
  ‚àò-hom (h , hhom) (g , ghom) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-hom hhom ghom

  -- The composition of epimorphisms is again an epimorphism
  open IsEpi

  ‚àò-is-epi : {g : A ‚ü∂ B}{h : B ‚ü∂ C} ‚Üí IsEpi ùë® ùë© g ‚Üí IsEpi ùë© ùë™ h ‚Üí IsEpi ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-epi gE hE =
   record { isHom = ‚àò-is-hom (isHom gE) (isHom hE)
          ; isSurjective = ‚àò-IsSurjective (isSurjective gE) (isSurjective hE) }

  ‚àò-epi : epi ùë® ùë© ‚Üí epi ùë© ùë™  ‚Üí epi ùë® ùë™
  ‚àò-epi (h , hepi) (g , gepi) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-epi hepi gepi

\end{code}


#### <a id="universe-lifting-of-homomorphisms">Universe lifting of homomorphisms</a>

First we define the identity homomorphism for setoid algebras and then we prove that the operations of lifting and lowering of a setoid algebra are homomorphisms.

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ} where
 open Algebra ùë® using () renaming (Domain to A )
 open Setoid A using ( reflexive ) renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; refl to refl‚ÇÅ )

 ùíæùíπ :  hom ùë® ùë®
 ùíæùíπ = ùëñùëë , record { compatible = reflexive ‚â°.refl }

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 open Algebra ùë® using () renaming (Domain to A )
 open Setoid A using ( reflexive ) renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; refl to refl‚ÇÅ )

 open Setoid ùîª[ Lift-AlgÀ° ùë® ‚Ñì ] using () renaming ( _‚âà_ to _‚âàÀ°_ ; refl to reflÀ°)
 open Setoid ùîª[ Lift-Alg ≥ ùë® ‚Ñì ] using () renaming ( _‚âà_ to _‚âà ≥_ ; refl to refl ≥)

 open Level
 ToLiftÀ° : hom ùë® (Lift-AlgÀ° ùë® ‚Ñì)
 ToLiftÀ° = record { f = lift ; cong = id } , record { compatible = reflexive ‚â°.refl }

 FromLiftÀ° : hom (Lift-AlgÀ° ùë® ‚Ñì) ùë®
 FromLiftÀ° = record { f = lower ; cong = id } , record { compatible = reflÀ° }

 ToFromLiftÀ° : ‚àÄ b ‚Üí  (‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© b)) ‚âàÀ° b
 ToFromLiftÀ° b = refl‚ÇÅ

 FromToLiftÀ° : ‚àÄ a ‚Üí (‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© a)) ‚âà‚ÇÅ a
 FromToLiftÀ° a = refl‚ÇÅ


 ToLift ≥ : hom ùë® (Lift-Alg ≥ ùë® ‚Ñì)
 ToLift ≥ = record { f = id ; cong = lift } , record { compatible = lift (reflexive ‚â°.refl) }

 FromLift ≥ : hom (Lift-Alg ≥ ùë® ‚Ñì) ùë®
 FromLift ≥ = record { f = id ; cong = lower } , record { compatible = reflÀ° }

 ToFromLift ≥ : ‚àÄ b ‚Üí (‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© b)) ‚âà ≥ b
 ToFromLift ≥ b = lift refl‚ÇÅ

 FromToLift ≥ : ‚àÄ a ‚Üí (‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© a)) ‚âà‚ÇÅ a
 FromToLift ≥ a = refl‚ÇÅ


module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì r : Level} where
 open Level
 open Setoid ùîª[ ùë® ] using (refl)
 open Setoid ùîª[ Lift-Alg ùë® ‚Ñì r ] using ( _‚âà_ )

 ToLift : hom ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift = ‚àò-hom ToLiftÀ° ToLift ≥

 FromLift : hom (Lift-Alg ùë® ‚Ñì r) ùë®
 FromLift = ‚àò-hom FromLift ≥ FromLiftÀ°

 ToFromLift : ‚àÄ b ‚Üí (‚à£ ToLift ‚à£ ‚ü®$‚ü© (‚à£ FromLift ‚à£ ‚ü®$‚ü© b)) ‚âà b
 ToFromLift b = lift refl

 ToLift-epi : epi ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift-epi = ‚à£ ToLift ‚à£ , (record { isHom = ‚à• ToLift ‚à•
                           ; isSurjective = Œª {y} ‚Üí eq (‚à£ FromLift ‚à£ ‚ü®$‚ü© y) (ToFromLift y) })

\end{code}



### <a id="homomorphisms-of-product-algebras">Homomorphisms of product algebras</a>

(cf. the [Homomorphisms.Func.Products][] module of the [Agda Universal Algebra Library][].)


Suppose we have an algebra `ùë®`, a type `I : Type ùìò`, and a family `‚Ñ¨ : I ‚Üí Algebra Œ≤ ùëÜ` of algebras.  We sometimes refer to the inhabitants of `I` as *indices*, and call `‚Ñ¨` an *indexed family of algebras*.

If in addition we have a family `ùíΩ : (i : I) ‚Üí hom ùë® (‚Ñ¨ i)` of homomorphisms, then we can construct a homomorphism from `ùë®` to the product `‚®Ö ‚Ñ¨` in the natural way.

\begin{code}

module _ {Œπ : Level}{I : Type Œπ}{ùë® : Algebra Œ± œÅ·µÉ}(‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá)  where
 open Algebra ùë® using () renaming ( Domain to A )
 open Setoid A using ( ) renaming ( refl to refl‚ÇÅ )
 open Algebra (‚®Ö ‚Ñ¨) using () renaming ( Domain to ‚®ÖB )
 open Setoid using ( refl )
 open IsHom

 ‚®Ö-hom-co : (‚àÄ(i : I) ‚Üí hom ùë® (‚Ñ¨ i)) ‚Üí hom ùë® (‚®Ö ‚Ñ¨)
 ‚®Ö-hom-co ùíΩ = h , hhom
  where
  h : A ‚ü∂ ‚®ÖB
  _‚ü®$‚ü©_ h = Œª a i ‚Üí ‚à£ ùíΩ i ‚à£ ‚ü®$‚ü© a
  cong h xy i = cong ‚à£ ùíΩ i ‚à£ xy
  hhom : IsHom ùë® (‚®Ö ‚Ñ¨) h
  compatible hhom = Œª i ‚Üí compatible ‚à• ùíΩ i ‚à•


\end{code}



### <a id="factorization-of-homomorphisms">Factorization of homomorphisms</a>

(cf. the [Homomorphisms.Func.Factor][] module of the [Agda Universal Algebra Library][].)


If `g : hom ùë® ùë©`, `h : hom ùë® ùë™`, `h` is surjective, and `ker h ‚äÜ ker g`, then there exists `œÜ : hom ùë™ ùë©` such that `g = œÜ ‚àò h` so the following diagram commutes:

```
ùë® --- h -->> ùë™
 \         .
  \       .
   g     œÜ
    \   .
     \ .
      V
      ùë©
```

We will prove this in case h is both surjective and injective.

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá){ùë™ : Algebra Œ≥ œÅ·∂ú}
         (gh : hom ùë® ùë©)(hh : hom ùë® ùë™) where
 open Algebra ùë© using () renaming (Domain to B )
 open Algebra ùë™ using ( Interp ) renaming (Domain to C )
 open Setoid B using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ ; sym to sym‚ÇÇ )
 open Setoid C using ( trans ) renaming ( _‚âà_ to _‚âà‚ÇÉ_ ; sym to sym‚ÇÉ )
 open SetoidReasoning B
 open IsHom
 open Image_‚àã_

 private
  gfunc = ‚à£ gh ‚à£ ; g = _‚ü®$‚ü©_ gfunc
  hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc

 HomFactor : kernel _‚âà‚ÇÉ_ h ‚äÜ kernel _‚âà‚ÇÇ_ g ‚Üí IsSurjective hfunc
  ‚Üí          Œ£[ œÜ ‚àà hom ùë™ ùë© ] ‚àÄ a ‚Üí (g a) ‚âà‚ÇÇ ‚à£ œÜ ‚à£ ‚ü®$‚ü© (h a)

 HomFactor Khg hE = (œÜmap , œÜhom) , gœÜh
  where
  kerpres : ‚àÄ a‚ÇÄ a‚ÇÅ ‚Üí h a‚ÇÄ ‚âà‚ÇÉ h a‚ÇÅ ‚Üí g a‚ÇÄ ‚âà‚ÇÇ g a‚ÇÅ
  kerpres a‚ÇÄ a‚ÇÅ hyp = Khg hyp

  h‚Åª¬π : ùïå[ ùë™ ] ‚Üí ùïå[ ùë® ]
  h‚Åª¬π = SurjInv hfunc hE

  Œ∑ : ‚àÄ {c} ‚Üí h (h‚Åª¬π c) ‚âà‚ÇÉ c
  Œ∑ = SurjInvIsInverse ≥ hfunc hE

  Œæ : ‚àÄ {a} ‚Üí h a ‚âà‚ÇÉ h (h‚Åª¬π (h a))
  Œæ = sym‚ÇÉ Œ∑

  Œ∂ : ‚àÄ{x y} ‚Üí x ‚âà‚ÇÉ y ‚Üí h (h‚Åª¬π x) ‚âà‚ÇÉ h (h‚Åª¬π y)
  Œ∂ xy = trans Œ∑ (trans xy (sym‚ÇÉ Œ∑))


  œÜmap : C ‚ü∂ B
  _‚ü®$‚ü©_ œÜmap = g ‚àò h‚Åª¬π
  cong œÜmap = Khg ‚àò Œ∂

  gœÜh : (a : ùïå[ ùë® ]) ‚Üí g a ‚âà‚ÇÇ œÜmap ‚ü®$‚ü© (h a)
  gœÜh a = Khg Œæ

  open _‚ü∂_ œÜmap using () renaming (cong to œÜcong)

  œÜcomp : compatible-map ùë™ ùë© œÜmap
  œÜcomp {f}{c} =
   begin
    œÜmap ‚ü®$‚ü© ((f ÃÇ ùë™) c)              ‚âàÀò‚ü® œÜcong (cong (Interp ùë™) (‚â°.refl , (Œª _ ‚Üí Œ∑))) ‚ü©
    g (h‚Åª¬π ((f ÃÇ ùë™)(h ‚àò (h‚Åª¬π ‚àò c)))) ‚âàÀò‚ü® œÜcong (compatible ‚à• hh ‚à•) ‚ü©
    g (h‚Åª¬π (h ((f ÃÇ ùë®)(h‚Åª¬π ‚àò c))))   ‚âàÀò‚ü® gœÜh ((f ÃÇ ùë®)(h‚Åª¬π ‚àò c)) ‚ü©
    g ((f ÃÇ ùë®)(h‚Åª¬π ‚àò c))             ‚âà‚ü® compatible ‚à• gh ‚à• ‚ü©
    (f ÃÇ ùë©)(g ‚àò (h‚Åª¬π ‚àò c))           ‚àé

  œÜhom : IsHom ùë™ ùë© œÜmap
  compatible œÜhom = œÜcomp

\end{code}



### <a id="isomorphisms">Isomorphisms</a>

(cf. the [Homomorphisms.Func.Isomorphisms] of the [Agda Universal Algebra Library][].)

Two structures are *isomorphic* provided there are homomorphisms going back and forth between them which compose to the identity map.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) (ùë© : Algebra Œ≤ œÅ·µá) where
 open Setoid ùîª[ ùë® ] using ( sym ; trans ) renaming ( _‚âà_ to _‚âà‚ÇÅ_ )
 open Setoid ùîª[ ùë© ] using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ ; sym to sym‚ÇÇ ; trans to trans‚ÇÇ)

 record _‚âÖ_ : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî Œ≤ ‚äî œÅ·µÉ ‚äî œÅ·µá ) where
  constructor mkiso
  field
   to : hom ùë® ùë©
   from : hom ùë© ùë®
   to‚àºfrom : ‚àÄ b ‚Üí (‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© b)) ‚âà‚ÇÇ b
   from‚àºto : ‚àÄ a ‚Üí (‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© a)) ‚âà‚ÇÅ a

  toIsSurjective : IsSurjective ‚à£ to ‚à£
  toIsSurjective {y} = eq (‚à£ from ‚à£ ‚ü®$‚ü© y) (sym‚ÇÇ (to‚àºfrom y))

  toIsInjective : IsInjective ‚à£ to ‚à£
  toIsInjective {x} {y} xy = Goal
   where
   Œæ : ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© x) ‚âà‚ÇÅ ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© y)
   Œæ = cong ‚à£ from ‚à£ xy
   Goal : x ‚âà‚ÇÅ y
   Goal = trans (sym (from‚àºto x)) (trans Œæ (from‚àºto y))


  fromIsSurjective : IsSurjective ‚à£ from ‚à£
  fromIsSurjective {y} = eq (‚à£ to ‚à£ ‚ü®$‚ü© y) (sym (from‚àºto y))

  fromIsInjective : IsInjective ‚à£ from ‚à£
  fromIsInjective {x} {y} xy = Goal
   where
   Œæ : ‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© x) ‚âà‚ÇÇ ‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© y)
   Œæ = cong ‚à£ to ‚à£ xy
   Goal : x ‚âà‚ÇÇ y
   Goal = trans‚ÇÇ (sym‚ÇÇ (to‚àºfrom x)) (trans‚ÇÇ Œæ (to‚àºfrom y))

\end{code}


#### <a id="properties-of-isomorphisms">Properties of isomorphisms</a>

\begin{code}

open _‚âÖ_

‚âÖ-refl : Reflexive (_‚âÖ_ {Œ±}{œÅ·µÉ})
‚âÖ-refl {Œ±}{œÅ·µÉ}{ùë®} = mkiso ùíæùíπ ùíæùíπ (Œª b ‚Üí refl) Œª a ‚Üí refl
 where open Setoid ùîª[ ùë® ] using ( refl )

‚âÖ-sym : Sym (_‚âÖ_{Œ≤}{œÅ·µá}) (_‚âÖ_{Œ±}{œÅ·µÉ})
‚âÖ-sym œÜ = mkiso (from œÜ) (to œÜ) (from‚àºto œÜ) (to‚àºfrom œÜ)

‚âÖ-trans : Trans (_‚âÖ_ {Œ±}{œÅ·µÉ})(_‚âÖ_{Œ≤}{œÅ·µá})(_‚âÖ_{Œ±}{œÅ·µÉ}{Œ≥}{œÅ·∂ú})
‚âÖ-trans {œÅ·∂ú = œÅ·∂ú}{ùë®}{ùë©}{ùë™} ab bc = mkiso ùëì ùëî œÑ ŒΩ
 where
  open Setoid ùîª[ ùë® ] using () renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; trans to trans‚ÇÅ )
  open Setoid ùîª[ ùë™ ] using () renaming ( _‚âà_ to _‚âà‚ÇÉ_ ; trans to trans‚ÇÉ )
  ùëì : hom ùë® ùë™
  ùëì = ‚àò-hom (to ab) (to bc)
  ùëî : hom ùë™ ùë®
  ùëî = ‚àò-hom (from bc) (from ab)
  œÑ : ‚àÄ b ‚Üí (‚à£ ùëì ‚à£  ‚ü®$‚ü© (‚à£ ùëî ‚à£ ‚ü®$‚ü© b)) ‚âà‚ÇÉ b
  œÑ b = trans‚ÇÉ (cong ‚à£ to bc ‚à£ (to‚àºfrom ab (‚à£ from bc ‚à£ ‚ü®$‚ü© b))) (to‚àºfrom bc b)
  ŒΩ : ‚àÄ a ‚Üí (‚à£ ùëî ‚à£ ‚ü®$‚ü© (‚à£ ùëì ‚à£ ‚ü®$‚ü© a)) ‚âà‚ÇÅ a
  ŒΩ a = trans‚ÇÅ (cong ‚à£ from ab ‚à£ (from‚àºto bc (‚à£ to ab ‚à£ ‚ü®$‚ü© a))) (from‚àºto ab a)



\end{code}

Fortunately, the lift operation preserves isomorphism (i.e., it's an *algebraic invariant*). As our focus is universal algebra, this is important and is what makes the lift operation a workable solution to the technical problems that arise from the noncumulativity of Agda's universe hierarchy.

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 Lift-‚âÖÀ° : ùë® ‚âÖ (Lift-AlgÀ° ùë® ‚Ñì)
 Lift-‚âÖÀ° = mkiso ToLiftÀ° FromLiftÀ° (ToFromLiftÀ°{ùë® = ùë®}) (FromToLiftÀ°{ùë® = ùë®}{‚Ñì})

 Lift-‚âÖ ≥ : ùë® ‚âÖ (Lift-Alg ≥ ùë® ‚Ñì)
 Lift-‚âÖ ≥ = mkiso ToLift ≥ FromLift ≥ (ToFromLift ≥{ùë® = ùë®}) (FromToLift ≥{ùë® = ùë®}{‚Ñì})

Lift-‚âÖ : {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì œÅ : Level} ‚Üí ùë® ‚âÖ (Lift-Alg ùë® ‚Ñì œÅ)
Lift-‚âÖ = ‚âÖ-trans Lift-‚âÖÀ° Lift-‚âÖ ≥

\end{code}


### Homomorphic Images

(cf. the [Homomorphisms.Func.HomomorphicImages][] module of the [Agda Universal Algebra Library][].)

We begin with what seems, for our purposes, the most useful way to represent the class of *homomorphic images* of an algebra in dependent type theory.

\begin{code}

ov : Level ‚Üí Level
ov Œ± = ùìû ‚äî ùì• ‚äî lsuc Œ±

_IsHomImageOf_ : (ùë© : Algebra Œ≤ œÅ·µá)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî Œ≤ ‚äî œÅ·µÉ ‚äî œÅ·µá)
ùë© IsHomImageOf ùë® = Œ£[ œÜ ‚àà hom ùë® ùë© ] IsSurjective ‚à£ œÜ ‚à£

HomImages : Algebra Œ± œÅ·µÉ ‚Üí Type (Œ± ‚äî œÅ·µÉ ‚äî ov (Œ≤ ‚äî œÅ·µá))
HomImages {Œ≤ = Œ≤}{œÅ·µá = œÅ·µá} ùë® = Œ£[ ùë© ‚àà Algebra Œ≤ œÅ·µá ] ùë© IsHomImageOf ùë®

\end{code}

These types should be self-explanatory, but just to be sure, let's describe the Sigma type appearing in the second definition. Given an `ùëÜ`-algebra `ùë® : Algebra Œ± œÅ`, the type `HomImages ùë®` denotes the class of algebras `ùë© : Algebra Œ≤ œÅ` with a map `œÜ : ‚à£ ùë® ‚à£ ‚Üí ‚à£ ùë© ‚à£` such that `œÜ` is a surjective homomorphism.


\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} where
 open _‚âÖ_
 Lift-HomImage-lemma : ‚àÄ{Œ≥} ‚Üí (Lift-Alg ùë® Œ≥ Œ≥) IsHomImageOf ùë© ‚Üí ùë® IsHomImageOf ùë©
 Lift-HomImage-lemma {Œ≥} œÜ = ‚àò-hom ‚à£ œÜ ‚à£ (from Lift-‚âÖ) ,
                             ‚àò-IsSurjective ‚à• œÜ ‚à• (fromIsSurjective (Lift-‚âÖ{ùë® = ùë®}))

module _ {ùë® ùë®' : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} where
 open _‚âÖ_
 HomImage-‚âÖ : ùë® IsHomImageOf ùë®' ‚Üí ùë® ‚âÖ ùë© ‚Üí ùë© IsHomImageOf ùë®'
 HomImage-‚âÖ œÜ A‚âÖB = ‚àò-hom ‚à£ œÜ ‚à£ (to A‚âÖB) , ‚àò-IsSurjective ‚à• œÜ ‚à• (toIsSurjective A‚âÖB)

\end{code}






## <a id="subalgebras">Subalgebras</a>

### <a id="subalgebras-basic-definitions">Basic definitions</a>

\begin{code}

_‚â§_  -- (alias for subalgebra relation))
 _IsSubalgebraOf_ : Algebra Œ± œÅ·µÉ ‚Üí Algebra Œ≤ œÅ·µá ‚Üí Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá)
ùë® IsSubalgebraOf ùë© = Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£

-- Syntactic sugar for the subalgebra relation.
ùë® ‚â§ ùë© = ùë® IsSubalgebraOf ùë©

\end{code}

### <a id="subalgebras-basic-properties">Basic properties</a>

\begin{code}

‚â§-reflexive : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí ùë® ‚â§ ùë®
‚â§-reflexive {ùë® = ùë®} = ùíæùíπ , id

mon‚Üí‚â§ : {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} ‚Üí mon ùë® ùë© ‚Üí ùë® ‚â§ ùë©
mon‚Üí‚â§ {ùë® = ùë®}{ùë©} x = mon‚Üíintohom ùë® ùë© x

module _ {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{ùë™ : Algebra Œ≥ œÅ·∂ú} where
 open Setoid ùîª[ ùë® ] using () renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; Carrier to ‚à£A‚à£ )
 open Setoid ùîª[ ùë© ] using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ ; Carrier to ‚à£B‚à£ )
 open Setoid ùîª[ ùë™ ] using () renaming ( _‚âà_ to _‚âà‚ÇÉ_ ; Carrier to ‚à£C‚à£ )
 open compose {A = ‚à£A‚à£}{B = ‚à£B‚à£}{C = ‚à£C‚à£} _‚âà‚ÇÅ_ _‚âà‚ÇÇ_ _‚âà‚ÇÉ_ using ( ‚àò-injective-func )

 ‚â§-trans : ùë® ‚â§ ùë© ‚Üí ùë© ‚â§ ùë™ ‚Üí ùë® ‚â§ ùë™
 ‚â§-trans A‚â§B B‚â§C = (‚àò-hom ‚à£ A‚â§B ‚à£ ‚à£ B‚â§C ‚à£ ) , ‚àò-injective-func ‚à• A‚â§B ‚à• ‚à• B‚â§C ‚à•
 open _‚âÖ_ using () renaming ( to to ùë°ùëú )

 ‚âÖ-trans-‚â§ : ùë® ‚âÖ ùë© ‚Üí ùë© ‚â§ ùë™ ‚Üí ùë® ‚â§ ùë™
 ‚âÖ-trans-‚â§ A‚âÖB (h , hinj) = (‚àò-hom (ùë°ùëú A‚âÖB) h) , (‚àò-injective-func (toIsInjective A‚âÖB) hinj)

\end{code}

### <a id="products-of-subalgebras">Products of subalgebras</a>

\begin{code}

module _ {Œπ : Level} {I : Type Œπ}{ùíú : I ‚Üí Algebra Œ± œÅ·µÉ}{‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá} where

 open Algebra (‚®Ö ùíú) using () renaming ( Domain to ‚®ÖA )
 open Algebra (‚®Ö ‚Ñ¨) using () renaming ( Domain to ‚®ÖB )
 open Setoid ‚®ÖA using ( refl )
 open IsHom

 ‚®Ö-‚â§ : (‚àÄ i ‚Üí ‚Ñ¨ i ‚â§ ùíú i) ‚Üí ‚®Ö ‚Ñ¨ ‚â§ ‚®Ö ùíú
 ‚®Ö-‚â§ B‚â§A = h , hM
  where
  h : hom (‚®Ö ‚Ñ¨) (‚®Ö ùíú)
  h = hfunc , hhom
   where
   hi : ‚àÄ i ‚Üí hom (‚Ñ¨ i) (ùíú i)
   hi i = ‚à£ B‚â§A i ‚à£

   hfunc : ‚®ÖB ‚ü∂ ‚®ÖA
   (hfunc ‚ü®$‚ü© x) i = ‚à£ hi i ‚à£ ‚ü®$‚ü© (x i)
   cong hfunc = Œª xy i ‚Üí cong ‚à£ hi i ‚à£ (xy i)
   hhom : IsHom (‚®Ö ‚Ñ¨) (‚®Ö ùíú) hfunc
   compatible hhom = Œª i ‚Üí compatible ‚à• hi i ‚à•

  hM : IsInjective ‚à£ h ‚à£
  hM = Œª xy i ‚Üí ‚à• B‚â§A i ‚à• (xy i)

\end{code}


## Terms

### <a id="terms-basic-definitions">Basic definitions</a>

Fix a signature `ùëÜ` and let `X` denote an arbitrary nonempty collection of variable symbols. Assume the symbols in `X` are distinct from the operation symbols of `ùëÜ`, that is `X ‚à© ‚à£ ùëÜ ‚à£ = ‚àÖ`.

By a *word* in the language of `ùëÜ`, we mean a nonempty, finite sequence of members of `X ‚à™ ‚à£ ùëÜ ‚à£`. We denote the concatenation of such sequences by simple juxtaposition.

Let `S‚ÇÄ` denote the set of nullary operation symbols of `ùëÜ`. We define by induction on `n` the sets `ùëá‚Çô` of *words* over `X ‚à™ ‚à£ ùëÜ ‚à£` as follows (cf. [Bergman (2012)][] Def. 4.19):

`ùëá‚ÇÄ := X ‚à™ S‚ÇÄ` and `ùëá‚Çô‚Çä‚ÇÅ := ùëá‚Çô ‚à™ ùíØ‚Çô`

where `ùíØ‚Çô` is the collection of all `f t` such that `f : ‚à£ ùëÜ ‚à£` and `t : ‚à• ùëÜ ‚à• f ‚Üí ùëá‚Çô`. (Recall, `‚à• ùëÜ ‚à• f` is the arity of the operation symbol f.)

We define the collection of *terms* in the signature `ùëÜ` over `X` by `Term X := ‚ãÉ‚Çô ùëá‚Çô`. By an ùëÜ-*term* we mean a term in the language of `ùëÜ`.

The definition of `Term X` is recursive, indicating that an inductive type could be used to represent the semantic notion of terms in type theory. Indeed, such a representation is given by the following inductive type.

\begin{code}

data Term (X : Type œá ) : Type (ov œá)  where
 ‚Ñä : X ‚Üí Term X    -- (‚Ñä for "generator")
 node : (f : ‚à£ ùëÜ ‚à£)(t : ‚à• ùëÜ ‚à• f ‚Üí Term X) ‚Üí Term X
open Term

\end{code}

This is a very basic inductive type that represents each term as a tree with an operation symbol at each `node` and a variable symbol at each leaf (`generator`).

**Notation**. As usual, the type `X` represents an arbitrary collection of variable symbols. Recall, `ov œá` is our shorthand notation for the universe level `ùìû ‚äî ùì• ‚äî lsuc œá`.


### <a id="equality-of-terms">Equality of terms</a>

We take a different approach here, using Setoids instead of quotient types.
That is, we will define the collection of terms in a signature as a setoid
with a particular equality-of-terms relation, which we must define.
Ultimately we will use this to define the (absolutely free) term algebra
as a Algebra whose carrier is the setoid of terms.

\begin{code}

module _ {X : Type œá } where

 -- Equality of terms as an inductive datatype
 data _‚âê_ : Term X ‚Üí Term X ‚Üí Type (ov œá) where
  rfl : {x y : X} ‚Üí x ‚â° y ‚Üí (‚Ñä x) ‚âê (‚Ñä y)
  gnl : ‚àÄ {f}{s t : ‚à• ùëÜ ‚à• f ‚Üí Term X} ‚Üí (‚àÄ i ‚Üí (s i) ‚âê (t i)) ‚Üí (node f s) ‚âê (node f t)

 -- Equality of terms is an equivalence relation
 open Level
 ‚âê-isRefl : Reflexive _‚âê_
 ‚âê-isRefl {‚Ñä _} = rfl ‚â°.refl
 ‚âê-isRefl {node _ _} = gnl (Œª _ ‚Üí ‚âê-isRefl)

 ‚âê-isSym : Symmetric _‚âê_
 ‚âê-isSym (rfl x) = rfl (‚â°.sym x)
 ‚âê-isSym (gnl x) = gnl (Œª i ‚Üí ‚âê-isSym (x i))

 ‚âê-isTrans : Transitive _‚âê_
 ‚âê-isTrans (rfl x) (rfl y) = rfl (‚â°.trans x y)
 ‚âê-isTrans (gnl x) (gnl y) = gnl (Œª i ‚Üí ‚âê-isTrans (x i) (y i))

 ‚âê-isEquiv : IsEquivalence _‚âê_
 ‚âê-isEquiv = record { refl = ‚âê-isRefl ; sym = ‚âê-isSym ; trans = ‚âê-isTrans }

\end{code}


### <a id="the-term-algebra">The term algebra</a>

For a given signature `ùëÜ`, if the type `Term X` is nonempty (equivalently, if `X` or `‚à£ ùëÜ ‚à£` is nonempty), then we can define an algebraic structure, denoted by `ùëª X` and called the *term algebra in the signature* `ùëÜ` *over* `X`.  Terms are viewed as acting on other terms, so both the domain and basic operations of the algebra are the terms themselves.


+ For each operation symbol `f : ‚à£ ùëÜ ‚à£`, denote by `f ÃÇ (ùëª X)` the operation on `Term X` that maps a tuple `t : ‚à• ùëÜ ‚à• f ‚Üí ‚à£ ùëª X ‚à£` to the formal term `f t`.
+ Define `ùëª X` to be the algebra with universe `‚à£ ùëª X ‚à£ := Term X` and operations `f ÃÇ (ùëª X)`, one for each symbol `f` in `‚à£ ùëÜ ‚à£`.

In [Agda][] the term algebra can be defined as simply as one might hope.

\begin{code}

TermSetoid : (X : Type œá) ‚Üí Setoid (ov œá) (ov œá)
TermSetoid X = record { Carrier = Term X ; _‚âà_ = _‚âê_ ; isEquivalence = ‚âê-isEquiv }

ùëª : (X : Type œá) ‚Üí Algebra (ov œá) (ov œá)
Algebra.Domain (ùëª X) = TermSetoid X
Algebra.Interp (ùëª X) ‚ü®$‚ü© (f , ts) = node f ts
cong (Algebra.Interp (ùëª X)) (‚â°.refl , ss‚âêts) = gnl ss‚âêts

\end{code}

### <a id="interpretation-of-terms">Interpretation of terms</a>

The approach to terms and their interpretation in this module was inspired by
[Andreas Abel's formal proof of Birkhoff's completeness theorem](http://www.cse.chalmers.se/~abela/agda/MultiSortedAlgebra.pdf).

A substitution from `X` to `Y` associates a term in `X` with each variable in `Y`.

\begin{code}

-- Parallel substitutions.
Sub : Type œá ‚Üí Type œá ‚Üí Type (ov œá)
Sub X Y = (y : Y) ‚Üí Term X

-- Application of a substitution.
_[_] : {X Y : Type œá}(t : Term Y) (œÉ : Sub X Y) ‚Üí Term X
(‚Ñä x) [ œÉ ] = œÉ x
(node f ts) [ œÉ ] = node f (Œª i ‚Üí ts i [ œÉ ])

\end{code}

An environment for `Œì` maps each variable `x : Œì` to an element of `A`, and equality of environments is defined pointwise.

\begin{code}

module Environment (ùë® : Algebra Œ± ‚Ñì) where
 open Algebra ùë® using ( Interp ) renaming ( Domain to A )
 open Setoid ùîª[ ùë® ] using ( refl ; sym ; trans ) renaming ( _‚âà_ to _‚âà‚Çê_ ; Carrier to ‚à£A‚à£ )
 Env : Type œá ‚Üí Setoid _ _
 Env X = record { Carrier = X ‚Üí ‚à£A‚à£
                ; _‚âà_ = Œª œÅ œÅ' ‚Üí (x : X) ‚Üí œÅ x ‚âà‚Çê œÅ' x
                ; isEquivalence =
                   record { refl = Œª _ ‚Üí refl
                          ; sym = Œª h x ‚Üí sym (h x)
                          ; trans = Œª g h x ‚Üí trans (g x) (h x) }}

 ‚ü¶_‚üß : {X : Type œá}(t : Term X) ‚Üí (Env X) ‚ü∂ A
 ‚ü¶ ‚Ñä x ‚üß ‚ü®$‚ü© œÅ = œÅ x
 ‚ü¶ node f args ‚üß ‚ü®$‚ü© œÅ = (Interp ùë®) ‚ü®$‚ü© (f , Œª i ‚Üí ‚ü¶ args i ‚üß ‚ü®$‚ü© œÅ)
 cong ‚ü¶ ‚Ñä x ‚üß u‚âàv = u‚âàv x
 cong ‚ü¶ node f args ‚üß x‚âày = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí cong ‚ü¶ args i ‚üß x‚âày )

\end{code}

An equality between two terms holds in a model if the two terms are equal under all valuations of their free variables (cf. [Andreas Abel's formal proof of Birkhoff's completeness theorem](http://www.cse.chalmers.se/~abela/agda/MultiSortedAlgebra.pdf)).


\begin{code}

 Equal : ‚àÄ {X : Type œá} (s t : Term X) ‚Üí Type _
 Equal {X = X} s t = ‚àÄ (œÅ : Carrier (Env X)) ‚Üí  ‚ü¶ s ‚üß ‚ü®$‚ü© œÅ ‚âà‚Çê ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ

 ‚âê‚ÜíEqual : {X : Type œá}(s t : Term X) ‚Üí s ‚âê t ‚Üí Equal s t
 ‚âê‚ÜíEqual .(‚Ñä _) .(‚Ñä _) (rfl ‚â°.refl) = Œª _ ‚Üí refl
 ‚âê‚ÜíEqual (node _ s)(node _ t)(gnl x) =
  Œª œÅ ‚Üí cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí ‚âê‚ÜíEqual(s i)(t i)(x i)œÅ )

\end{code}

`Equal` is an equivalence relation.

\begin{code}

 EqualIsEquiv : {Œì : Type œá} ‚Üí IsEquivalence (Equal {X = Œì})
 IsEquivalence.refl  EqualIsEquiv = Œª _ ‚Üí refl
 IsEquivalence.sym   EqualIsEquiv = Œª x=y œÅ ‚Üí sym (x=y œÅ)
 IsEquivalence.trans EqualIsEquiv = Œª ij jk œÅ ‚Üí trans (ij œÅ) (jk œÅ)

\end{code}

Evaluation of a substitution gives an environment (cf. [Andreas Abel's formal proof of Birkhoff's completeness theorem](http://www.cse.chalmers.se/~abela/agda/MultiSortedAlgebra.pdf))

\begin{code}

 ‚ü¶_‚üßs : {X Y : Type œá} ‚Üí Sub X Y ‚Üí Carrier(Env X) ‚Üí Carrier (Env Y)
 ‚ü¶ œÉ ‚üßs œÅ x = ‚ü¶ œÉ x ‚üß ‚ü®$‚ü© œÅ

\end{code}

### Substitution lemma

We prove that ‚ü¶t[œÉ]‚üßœÅ ‚âÉ ‚ü¶t‚üß‚ü¶œÉ‚üßœÅ (cf. [Andreas Abel's formal proof of Birkhoff's completeness theorem](http://www.cse.chalmers.se/~abela/agda/MultiSortedAlgebra.pdf)).

\begin{code}

 substitution : {X Y : Type œá} ‚Üí (t : Term Y) (œÉ : Sub X Y) (œÅ : Carrier( Env X ) )
  ‚Üí             ‚ü¶ t [ œÉ ] ‚üß ‚ü®$‚ü© œÅ  ‚âà‚Çê  ‚ü¶ t ‚üß ‚ü®$‚ü© (‚ü¶ œÉ ‚üßs œÅ)

 substitution (‚Ñä x) œÉ œÅ = refl
 substitution (node f ts) œÉ œÅ = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí substitution (ts i) œÉ œÅ)

\end{code}


### <a id="compatibility-of-terms">Compatibility of terms</a>

We now prove two important facts about term operations.  The first of these, which is used very often in the sequel, asserts that every term commutes with every homomorphism.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}(hh : hom ùë® ùë©) where
 open Algebra ùë® using () renaming (Domain to A ; Interp to Interp‚ÇÅ )
 open Setoid A using () renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; Carrier to ‚à£A‚à£ )
 open Algebra ùë© using () renaming (Domain to B ; Interp to Interp‚ÇÇ )
 open Setoid B using ( _‚âà_ ; sym ; refl )
 open SetoidReasoning B
 private hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc

 open Environment ùë® using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
 open Environment ùë© using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÇ )
 open IsHom

 comm-hom-term : (t : Term X) (a : X ‚Üí ‚à£A‚à£)
                 -----------------------------------------
  ‚Üí              h (‚ü¶ t ‚üß‚ÇÅ ‚ü®$‚ü© a) ‚âà ‚ü¶ t ‚üß‚ÇÇ ‚ü®$‚ü© (h ‚àò a)

 comm-hom-term (‚Ñä x) a = refl
 comm-hom-term (node f t) a = goal
  where
  goal : h (‚ü¶ node f t ‚üß‚ÇÅ ‚ü®$‚ü© a) ‚âà (‚ü¶ node f t ‚üß‚ÇÇ ‚ü®$‚ü© (h ‚àò a))
  goal =
   begin
    h (‚ü¶ node f t ‚üß‚ÇÅ ‚ü®$‚ü© a)             ‚âà‚ü® (compatible ‚à• hh ‚à•) ‚ü©
    (f ÃÇ ùë©)(Œª i ‚Üí h (‚ü¶ t i ‚üß‚ÇÅ ‚ü®$‚ü© a))   ‚âà‚ü® cong Interp‚ÇÇ (‚â°.refl , Œª i ‚Üí comm-hom-term (t i) a) ‚ü©
    (f ÃÇ ùë©)(Œª i ‚Üí ‚ü¶ t i ‚üß‚ÇÇ ‚ü®$‚ü© (h ‚àò a)) ‚âà‚ü® refl ‚ü©
    (‚ü¶ node f t ‚üß‚ÇÇ ‚ü®$‚ü© (h ‚àò a))
   ‚àé

\end{code}



### <a id="interpretation-of-terms-in-product-algebras">Interpretation of terms in product algebras</a>

\begin{code}

module _ {X : Type œá}{Œπ : Level} {I : Type Œπ} (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) where
 open Algebra (‚®Ö ùíú) using () renaming ( Domain to ‚®ÖA ; Interp to ‚®ÖInterp )
 open Setoid ‚®ÖA using ( _‚âà_ ; refl )
 open Environment (‚®Ö ùíú) using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
 open Environment using ( ‚ü¶_‚üß ; ‚âê‚ÜíEqual )

 interp-prod : (p : Term X) ‚Üí ‚àÄ œÅ ‚Üí ‚ü¶ p ‚üß‚ÇÅ ‚ü®$‚ü© œÅ ‚âà (Œª i ‚Üí (‚ü¶ ùíú i ‚üß p) ‚ü®$‚ü© (Œª x ‚Üí (œÅ x) i))
 interp-prod (‚Ñä x) = Œª œÅ i ‚Üí ‚âê‚ÜíEqual (ùíú i) (‚Ñä x) (‚Ñä x) ‚âê-isRefl Œª x' ‚Üí (œÅ x) i
 interp-prod (node f t) = Œª œÅ i ‚Üí cong ‚®ÖInterp (‚â°.refl , (Œª j k ‚Üí interp-prod (t j) œÅ k)) i

\end{code}


## <a id="model-theory-and-equational-logic">Model Theory and Equational Logic</a>

(cf. the [Varieties.Func.SoundAndComplete][] module of the [Agda Universal Algebra Library][])

### <a id="model-theory-basic-definitions">Basic definitions</a>

Let `ùëÜ` be a signature. By an *identity* or *equation* in `ùëÜ` we mean an ordered pair of terms in a given context.  For instance, if the context happens to be the type `X : Type œá`, then an equation will be a pair of inhabitants of the domain of term algebra `ùëª X`.

We define an equation in Agda using the following record type with fields denoting the left-hand and right-hand sides of the equation, along with an equation "context" representing the underlying collection of variable symbols (cf. [Andreas Abel's formal proof of Birkhoff's completeness theorem](http://www.cse.chalmers.se/~abela/agda/MultiSortedAlgebra.pdf)).

\begin{code}

record Eq : Type (ov œá) where
 constructor _‚âàÃá_
 field
  {cxt} : Type œá
  lhs   : Term cxt
  rhs   : Term cxt

open Eq public

\end{code}

We now define a type representing the notion of an equation `p ‚âàÃá q` holding (when `p` and `q` are interpreted) in algebra `ùë®`.

If `ùë®` is an `ùëÜ`-algebra we say that `ùë®` *satisfies* `p ‚âà q` provided for all environments `œÅ : X ‚Üí ‚à£ ùë® ‚à£` (assigning values in the domain of `ùë®` to variable symbols in `X`) we have `‚ü¶ p ‚üß‚ü®$‚ü© œÅ ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© œÅ`.  In this situation, we write `ùë® ‚äß (p ‚âàÃá q)` and say that `ùë®` *models* the identity `p ‚âà q`.

If `ùí¶` is a class of algebras, all of the same signature, we write `ùí¶ ‚ä´ (p ‚âàÃá q) if, for every `ùë® ‚àà ùí¶`, we have `ùë® ‚äß (p ‚âàÃá q)`.

Because a class of structures has a different type than a single structure, we must use a slightly different syntax to avoid overloading the relations `‚äß` and `‚âà`. As a reasonable alternative to what we would normally express informally as `ùí¶ ‚äß p ‚âà q`, we have settled on `ùí¶ ‚ä´ (p ‚âàÃá q)` to denote this relation.  To reiterate, if `ùí¶` is a class of `ùëÜ`-algebras, we write `ùí¶ ‚ä´ (p ‚âàÃá q)` provided every `ùë® ‚àà ùí¶` satisfies `ùë® ‚äß (p ‚âàÃá q)`.

\begin{code}

_‚äß_ : (ùë® : Algebra Œ± œÅ·µÉ)(term-identity : Eq{œá}) ‚Üí Type _
ùë® ‚äß (p ‚âàÃá q) = Equal p q where open Environment ùë®

_‚ä´_ : Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Eq{œá} ‚Üí Type (‚Ñì ‚äî œá ‚äî ov(Œ± ‚äî œÅ·µÉ))
ùí¶ ‚ä´ equ = ‚àÄ ùë® ‚Üí ùí¶ ùë® ‚Üí ùë® ‚äß equ

\end{code}

We denote by `ùë® ‚ä® ‚Ñ∞` the assertion that the algebra ùë® models every equation in a collection `‚Ñ∞` of equations.

\begin{code}

_‚ä®_ : (ùë® : Algebra Œ± œÅ·µÉ) ‚Üí {Œπ : Level}{I : Type Œπ} ‚Üí (I ‚Üí Eq{œá}) ‚Üí Type _
ùë® ‚ä® ‚Ñ∞ = ‚àÄ i ‚Üí Equal (lhs (‚Ñ∞ i))(rhs (‚Ñ∞ i)) where open Environment ùë®

\end{code}

### <a id="equational-theories-and-models">Equational theories and models</a>

If `ùí¶` denotes a class of structures, then `Th ùí¶` represents the set of identities
modeled by the members of `ùí¶`.

\begin{code}

Th : {X : Type œá} ‚Üí Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Pred(Term X √ó Term X) _
Th ùí¶ = Œª (p , q) ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q)

Mod : {X : Type œá} ‚Üí Pred(Term X √ó Term X) ‚Ñì ‚Üí Pred (Algebra Œ± œÅ·µÉ) _
Mod ‚Ñ∞ ùë® = ‚àÄ {p q} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí Equal p q where open Environment ùë®

\end{code}

### <a id="the-entailment-relation">The entailment relation</a>

Based on [Andreas Abel's Agda formalization of Birkhoff's completeness theorem](http://www.cse.chalmers.se/~abela/agda/MultiSortedAlgebra.pdf).)

\begin{code}

module _ {œá Œπ : Level} where

 data _‚ä¢_‚ñπ_‚âà_ {I : Type Œπ}(‚Ñ∞ : I ‚Üí Eq) : (X : Type œá)(p q : Term X) ‚Üí Type (Œπ ‚äî ov œá) where
  hyp   : ‚àÄ i ‚Üí let p ‚âàÃá q = ‚Ñ∞ i in ‚Ñ∞ ‚ä¢ _ ‚ñπ p ‚âà q
  app   : ‚àÄ {ps qs} ‚Üí (‚àÄ i ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ ps i ‚âà qs i) ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ (node f ps) ‚âà (node f qs)
  sub   : ‚àÄ {p q} ‚Üí ‚Ñ∞ ‚ä¢ Œî ‚ñπ p ‚âà q ‚Üí ‚àÄ (œÉ : Sub Œì Œî) ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ (p [ œÉ ]) ‚âà (q [ œÉ ])

  ‚ä¢refl  : ‚àÄ {p}              ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà p
  ‚ä¢sym   : ‚àÄ {p q : Term Œì}   ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ q ‚âà p
  ‚ä¢trans : ‚àÄ {p q r : Term Œì} ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ q ‚âà r ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà r

 ‚ä¢‚ñπ‚âàIsEquiv : {X : Type œá}{I : Type Œπ}{‚Ñ∞ : I ‚Üí Eq} ‚Üí IsEquivalence (‚Ñ∞ ‚ä¢ X ‚ñπ_‚âà_)
 ‚ä¢‚ñπ‚âàIsEquiv = record { refl = ‚ä¢refl ; sym = ‚ä¢sym ; trans = ‚ä¢trans }


\end{code}

### <a id="soundness">Soundness</a>

In any model ùë® that satisfies the equations ‚Ñ∞, derived equality is actual equality
(cf. [Andreas Abel's Agda formalization of Birkhoff's completeness theorem](http://www.cse.chalmers.se/~abela/agda/MultiSortedAlgebra.pdf).)

\begin{code}

module Soundness {œá Œ± Œπ : Level}{I : Type Œπ} (‚Ñ∞ : I ‚Üí Eq{œá})
                 (ùë® : Algebra Œ± œÅ·µÉ)     -- We assume an algebra ùë®
                 (V : ùë® ‚ä® ‚Ñ∞)         -- that models all equations in ‚Ñ∞.
                 where

 open Algebra ùë® using () renaming (Domain to A ; Interp to InterpA)
 open SetoidReasoning A
 open Environment ùë® renaming ( ‚ü¶_‚üßs to ‚ü™_‚ü´ )
 open IsEquivalence using ( refl ; sym ; trans )

 sound : ‚àÄ {p q} ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ùë® ‚äß (p ‚âàÃá q)
 sound (hyp i)                      = V i
 sound (app {f = f} es) œÅ           = cong InterpA (‚â°.refl , Œª i ‚Üí sound (es i) œÅ)
 sound (sub {p = p} {q} Epq œÉ) œÅ    =
  begin
   ‚ü¶ p [ œÉ ] ‚üß ‚ü®$‚ü©       œÅ ‚âà‚ü® substitution p œÉ œÅ ‚ü©
   ‚ü¶ p       ‚üß ‚ü®$‚ü© ‚ü™ œÉ ‚ü´ œÅ ‚âà‚ü® sound Epq (‚ü™ œÉ ‚ü´ œÅ)  ‚ü©
   ‚ü¶ q       ‚üß ‚ü®$‚ü© ‚ü™ œÉ ‚ü´ œÅ ‚âàÀò‚ü® substitution  q œÉ œÅ ‚ü©
   ‚ü¶ q [ œÉ ] ‚üß ‚ü®$‚ü©       œÅ ‚àé

 sound (‚ä¢refl {p = p})               = refl  EqualIsEquiv {x = p}
 sound (‚ä¢sym {p = p} {q} Epq)        = sym   EqualIsEquiv {x = p}{q}   (sound Epq)
 sound (‚ä¢trans{p = p}{q}{r} Epq Eqr) = trans EqualIsEquiv {i = p}{q}{r}(sound Epq)(sound Eqr)

\end{code}


## <a id="the-closure-operators-h-s-p-and-v">The Closure Operators H, S, P and V</a>

Fix a signature `ùëÜ`, let `ùí¶` be a class of `ùëÜ`-algebras, and define

* `H ùí¶` = algebras isomorphic to a homomorphic image of a member of `ùí¶`;
* S ùí¶ = algebras isomorphic to a subalgebra of a member of ùí¶;
* P ùí¶ = algebras isomorphic to a product of members of ùí¶.

A straight-forward verification confirms that `H`, `S`, and `P` are *closure operators* (expansive, monotone, and idempotent).  A class `ùí¶` of `ùëÜ`-algebras is said to be *closed under the taking of homomorphic images* provided `H ùí¶ ‚äÜ ùí¶`. Similarly, `ùí¶` is *closed under the taking of subalgebras* (resp., *arbitrary products*) provided `S ùí¶ ‚äÜ ùí¶` (resp., `P ùí¶ ‚äÜ ùí¶`). The operators `H`, `S`, and `P` can be composed with one another repeatedly, forming yet more closure operators.

An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class `H ùí¶` (resp., `S ùí¶`; resp., `P ùí¶`) is closed under isomorphism.

A *variety* is a class of `ùëÜ`-algebras that is closed under the taking of homomorphic images, subalgebras, and arbitrary products.  To represent varieties we define types for the closure operators `H`, `S`, and `P` that are composable.  Separately, we define a type `V` which represents closure under all three operators, `H`, `S`, and `P`.


### <a id="closure-basic-definitions">Basic definitions</a>

We now define the type `H` to represent classes of algebras that include all homomorphic images of algebras in the class---i.e., classes that are closed under the taking of homomorphic images---the type `S` to represent classes of algebras that closed under the taking of subalgebras, and the type `P` to represent classes of algebras closed under the taking of arbitrary products.

\begin{code}

H : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) (Œ≤ ‚äî œÅ·µá ‚äî ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì))
H {Œ±}{œÅ·µÉ} _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© IsHomImageOf ùë®

S : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) (Œ≤ ‚äî œÅ·µá ‚äî ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì))
S {Œ±}{œÅ·µÉ} _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© ‚â§ ùë®

P : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) (Œ≤ ‚äî œÅ·µá ‚äî ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ‚äî Œπ))
P {Œ±}{œÅ·µÉ} _ Œπ ùí¶ ùë© = Œ£[ I ‚àà Type Œπ ] (Œ£[ ùíú ‚àà (I ‚Üí Algebra Œ± œÅ·µÉ) ] (‚àÄ i ‚Üí ùíú i ‚àà ùí¶) √ó (ùë© ‚âÖ ‚®Ö ùíú))

\end{code}

A class `ùí¶` of `ùëÜ`-algebras is called a *variety* if it is closed under each of the closure operators `H`, `S`, and `P` defined above. The corresponding closure operator is often denoted `ùïç` or `ùí±`, but we will denote it by `V`.

\begin{code}

module _  {Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà : Level} where
 private a = Œ± ‚äî œÅ·µÉ ; b = Œ≤ ‚äî œÅ·µá ; c = Œ≥ ‚äî œÅ·∂ú ; d = Œ¥ ‚äî œÅ·µà

 V : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí  Pred(Algebra Œ¥ œÅ·µà) (d ‚äî ov(a ‚äî b ‚äî c ‚äî ‚Ñì ‚äî Œπ))
 V ‚Ñì Œπ ùí¶ = H{Œ≥}{œÅ·∂ú}{Œ¥}{œÅ·µà} (a ‚äî b ‚äî ‚Ñì ‚äî Œπ) (S{Œ≤}{œÅ·µá} (a ‚äî ‚Ñì ‚äî Œπ) (P ‚Ñì Œπ ùí¶))

module _ {Œ± œÅ·µÉ ‚Ñì : Level}(ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì))
         (ùë® : Algebra (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)) where
 private Œπ = ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)

 V-‚âÖ-lc : Lift-Alg ùë® Œπ Œπ ‚àà V{Œ≤ = Œπ}{Œπ} ‚Ñì Œπ ùí¶ ‚Üí ùë® ‚àà V{Œ≥ = Œπ}{Œπ} ‚Ñì Œπ ùí¶
 V-‚âÖ-lc (ùë®' , spA' , lAimgA') = ùë®' , (spA' , AimgA')
  where
  AimgA' : ùë® IsHomImageOf ùë®'
  AimgA' = Lift-HomImage-lemma lAimgA'


\end{code}


### <a id="properties">Properties</a>

#### <a id="idempotence-of-s">Idempotence of S</a>

`S` is a closure operator.  The facts that S is monotone and expansive won't be needed, so we omit the proof of these facts.  However, we will make use of idempotence of `S`, so we prove that property as follows.

\begin{code}

S-idem : {ùí¶ : Pred (Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}
 ‚Üí       S{Œ≤ = Œ≥}{œÅ·∂ú} (Œ± ‚äî œÅ·µÉ  ‚äî ‚Ñì) (S{Œ≤ = Œ≤}{œÅ·µá} ‚Ñì ùí¶) ‚äÜ S{Œ≤ = Œ≥}{œÅ·∂ú} ‚Ñì ùí¶

S-idem (ùë® , (ùë© , sB , A‚â§B) , x‚â§A) = ùë© , (sB , ‚â§-trans x‚â§A A‚â§B)

\end{code}

#### <a id="algebraic-invariance-of-models">Algebraic invariance of ‚äß</a>

The binary relation `‚äß` would be practically useless if it were not an *algebraic invariant* (i.e., invariant under isomorphism). Let us now verify that the models relation we defined above has this essential property.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá)(p q : Term X) where
 open Environment ùë®     using () renaming ( ‚ü¶_‚üß   to ‚ü¶_‚üß‚ÇÅ )
 open Environment ùë©     using () renaming ( ‚ü¶_‚üß   to ‚ü¶_‚üß‚ÇÇ )
 open Setoid ùîª[ ùë® ] using () renaming ( _‚âà_   to _‚âà‚ÇÅ_ )
 open Setoid ùîª[ ùë© ] using ( _‚âà_ ; sym )
 open SetoidReasoning ùîª[ ùë© ]

 ‚äß-I-invar : ùë® ‚äß (p ‚âàÃá q)  ‚Üí  ùë® ‚âÖ ùë©  ‚Üí  ùë© ‚äß (p ‚âàÃá q)
 ‚äß-I-invar Apq (mkiso fh gh f‚àºg g‚àºf) œÅ =
  begin
   ‚ü¶ p ‚üß‚ÇÇ ‚ü®$‚ü© œÅ             ‚âàÀò‚ü® cong ‚ü¶ p ‚üß‚ÇÇ (Œª x ‚Üí f‚àºg (œÅ x)) ‚ü©
   ‚ü¶ p ‚üß‚ÇÇ ‚ü®$‚ü© (ff ‚àò (g ‚àò œÅ)) ‚âàÀò‚ü® comm-hom-term fh p (g ‚àò œÅ) ‚ü©
   ff (‚ü¶ p ‚üß‚ÇÅ ‚ü®$‚ü© (g ‚àò œÅ))   ‚âà‚ü® cong ‚à£ fh ‚à£ (Apq (g ‚àò œÅ)) ‚ü©
   ff (‚ü¶ q ‚üß‚ÇÅ ‚ü®$‚ü© (g ‚àò œÅ))   ‚âà‚ü® comm-hom-term fh q (g ‚àò œÅ) ‚ü©
   ‚ü¶ q ‚üß‚ÇÇ ‚ü®$‚ü© (ff ‚àò (g ‚àò œÅ)) ‚âà‚ü® cong ‚ü¶ q ‚üß‚ÇÇ (Œª x ‚Üí f‚àºg (œÅ x)) ‚ü©
   ‚ü¶ q ‚üß‚ÇÇ ‚ü®$‚ü© œÅ             ‚àé
  where private ff = _‚ü®$‚ü©_ ‚à£ fh ‚à£ ; g = _‚ü®$‚ü©_ ‚à£ gh ‚à£

\end{code}

#### <a id="subalgebraic-invariance-of-models">Subalgebraic invariance of ‚äß</a>
Identities modeled by an algebra `ùë®` are also modeled by every subalgebra of `ùë®`, which fact can be formalized as follows.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{p q : Term X} where
 open Environment ùë® using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
 open Environment ùë© using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÇ )
 open Setoid ùîª[ ùë® ] using ( _‚âà_ )
 open Setoid ùîª[ ùë© ] using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ )
 open SetoidReasoning ùîª[ ùë® ]

 ‚äß-S-invar : ùë® ‚äß (p ‚âàÃá q) ‚Üí  ùë© ‚â§ ùë®  ‚Üí  ùë© ‚äß (p ‚âàÃá q)
 ‚äß-S-invar Apq B‚â§A b = goal
  where
  hh : hom ùë© ùë®
  hh = ‚à£ B‚â§A ‚à£
  h = _‚ü®$‚ü©_ ‚à£ hh ‚à£
  Œæ : ‚àÄ b ‚Üí h (‚ü¶ p ‚üß‚ÇÇ ‚ü®$‚ü© b) ‚âà h (‚ü¶ q ‚üß‚ÇÇ ‚ü®$‚ü© b)
  Œæ b = begin
         h (‚ü¶ p ‚üß‚ÇÇ ‚ü®$‚ü© b)   ‚âà‚ü® comm-hom-term hh p b ‚ü©
         ‚ü¶ p ‚üß‚ÇÅ ‚ü®$‚ü© (h ‚àò b) ‚âà‚ü® Apq (h ‚àò b) ‚ü©
         ‚ü¶ q ‚üß‚ÇÅ ‚ü®$‚ü© (h ‚àò b) ‚âàÀò‚ü® comm-hom-term hh q b ‚ü©
         h (‚ü¶ q ‚üß‚ÇÇ ‚ü®$‚ü© b)   ‚àé
  goal : ‚ü¶ p ‚üß‚ÇÇ ‚ü®$‚ü© b ‚âà‚ÇÇ ‚ü¶ q ‚üß‚ÇÇ ‚ü®$‚ü© b
  goal = ‚à• B‚â§A ‚à• (Œæ b)

\end{code}

#### <a id="product-invariance-of-models">Product invariance of ‚äß</a>
An identity satisfied by all algebras in an indexed collection is also satisfied by the product of algebras in that collection.

 \begin{code}


module _ {X : Type œá}{I : Type ‚Ñì}(ùíú : I ‚Üí Algebra Œ± œÅ·µÉ){p q : Term X} where

 ‚äß-P-invar : (‚àÄ i ‚Üí ùíú i ‚äß (p ‚âàÃá q)) ‚Üí ‚®Ö ùíú ‚äß (p ‚âàÃá q)
 ‚äß-P-invar ùíúpq a = goal
  where
  open Algebra (‚®Ö ùíú) using () renaming ( Domain to ‚®ÖA )
  open Environment   (‚®Ö ùíú) using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
  open Environment using ( ‚ü¶_‚üß )
  open Setoid ‚®ÖA   using ( _‚âà_ )
  open SetoidReasoning ‚®ÖA

  Œæ : (Œª i ‚Üí (‚ü¶ ùíú i ‚üß p) ‚ü®$‚ü© (Œª x ‚Üí (a x) i)) ‚âà (Œª i ‚Üí (‚ü¶ ùíú i ‚üß q) ‚ü®$‚ü© (Œª x ‚Üí (a x) i))
  Œæ = Œª i ‚Üí ùíúpq i (Œª x ‚Üí (a x) i)
  goal : ‚ü¶ p ‚üß‚ÇÅ ‚ü®$‚ü© a ‚âà ‚ü¶ q ‚üß‚ÇÅ ‚ü®$‚ü© a
  goal = begin
          ‚ü¶ p ‚üß‚ÇÅ ‚ü®$‚ü© a ‚âà‚ü® interp-prod ùíú p a ‚ü©
          (Œª i ‚Üí (‚ü¶ ùíú i ‚üß p) ‚ü®$‚ü© (Œª x ‚Üí (a x) i)) ‚âà‚ü® Œæ ‚ü©
          (Œª i ‚Üí (‚ü¶ ùíú i ‚üß q) ‚ü®$‚ü© (Œª x ‚Üí (a x) i)) ‚âàÀò‚ü® interp-prod ùíú q a ‚ü©
          ‚ü¶ q ‚üß‚ÇÅ ‚ü®$‚ü© a ‚àé

\end{code}


#### <a id="PS-subset-SP">PS ‚äÜ SP</a>

Another important fact we will need about the operators `S` and `P` is that a product of subalgebras of algebras in a class `ùí¶` is a subalgebra of a product of algebras in `ùí¶`. We denote this inclusion by `PS‚äÜSP`, which we state and prove as follows.

\begin{code}

module _  {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private
  a = Œ± ‚äî œÅ·µÉ
  oa‚Ñì = ov (a ‚äî ‚Ñì)

 PS‚äÜSP : P (a ‚äî ‚Ñì) oa‚Ñì (S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶) ‚äÜ S oa‚Ñì (P ‚Ñì oa‚Ñì ùí¶)
 PS‚äÜSP {ùë©} (I , ( ùíú , sA , B‚âÖ‚®ÖA )) = Goal
  where
  ‚Ñ¨ : I ‚Üí Algebra Œ± œÅ·µÉ
  ‚Ñ¨ i = ‚à£ sA i ‚à£
  kB : (i : I) ‚Üí ‚Ñ¨ i ‚àà ùí¶
  kB i =  fst ‚à• sA i ‚à•
  ‚®ÖA‚â§‚®ÖB : ‚®Ö ùíú ‚â§ ‚®Ö ‚Ñ¨
  ‚®ÖA‚â§‚®ÖB = ‚®Ö-‚â§ Œª i ‚Üí snd ‚à• sA i ‚à•
  Goal : ùë© ‚àà S{Œ≤ = oa‚Ñì}{oa‚Ñì}oa‚Ñì (P {Œ≤ = oa‚Ñì}{oa‚Ñì} ‚Ñì oa‚Ñì ùí¶)
  Goal = ‚®Ö ‚Ñ¨ , (I , (‚Ñ¨ , (kB , ‚âÖ-refl))) , (‚âÖ-trans-‚â§ B‚âÖ‚®ÖA ‚®ÖA‚â§‚®ÖB)

\end{code}

### <a id="identity-preservation">Identity preservation</a>

The classes `H ùí¶`, `S ùí¶`, `P ùí¶`, and `V ùí¶` all satisfy the same set of equations.  We will only use a subset of the inclusions used to prove this fact. (For a complete proof, see the
[Varieties.Func.Preservation][] module of the [Agda Universal Algebra Library][].)


#### <a id="h-preserves-identities">H preserves identities</a>

First we prove that the closure operator H is compatible with identities that hold in the given class.

\begin{code}

module _  {X : Type œá}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where

 H-id1 : ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí (H {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì ùí¶) ‚ä´ (p ‚âàÃá q)
 H-id1 œÉ ùë© (ùë® , kA , BimgOfA) œÅ = B‚äßpq
  where
  IH : ùë® ‚äß (p ‚âàÃá q)
  IH = œÉ ùë® kA
  open Environment ùë®     using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ)
  open Environment ùë©     using ( ‚ü¶_‚üß )
  open Setoid ùîª[ ùë© ] using ( _‚âà_ )
  open SetoidReasoning ùîª[ ùë© ]

  œÜ : hom ùë® ùë©
  œÜ = ‚à£ BimgOfA ‚à£
  œÜE : IsSurjective ‚à£ œÜ ‚à£
  œÜE = ‚à• BimgOfA ‚à•
  œÜ‚Åª¬π : ùïå[ ùë© ] ‚Üí ùïå[ ùë® ]
  œÜ‚Åª¬π = SurjInv ‚à£ œÜ ‚à£ œÜE

  Œ∂ : ‚àÄ x ‚Üí (‚à£ œÜ ‚à£ ‚ü®$‚ü© (œÜ‚Åª¬π ‚àò œÅ) x ) ‚âà œÅ x
  Œ∂ = Œª _ ‚Üí SurjInvIsInverse ≥ ‚à£ œÜ ‚à£ œÜE

  B‚äßpq : (‚ü¶ p ‚üß ‚ü®$‚ü© œÅ) ‚âà (‚ü¶ q ‚üß ‚ü®$‚ü© œÅ)
  B‚äßpq = begin
           ‚ü¶ p ‚üß ‚ü®$‚ü© œÅ                               ‚âàÀò‚ü® cong ‚ü¶ p ‚üß Œ∂ ‚ü©
           ‚ü¶ p ‚üß ‚ü®$‚ü© (Œª x ‚Üí (‚à£ œÜ ‚à£ ‚ü®$‚ü© (œÜ‚Åª¬π ‚àò œÅ) x)) ‚âàÀò‚ü® comm-hom-term œÜ p (œÜ‚Åª¬π ‚àò œÅ) ‚ü©
           ‚à£ œÜ ‚à£ ‚ü®$‚ü©  (‚ü¶ p ‚üß‚ÇÅ ‚ü®$‚ü© (œÜ‚Åª¬π ‚àò œÅ))         ‚âà‚ü® cong ‚à£ œÜ ‚à£ (IH (œÜ‚Åª¬π ‚àò œÅ)) ‚ü©
           ‚à£ œÜ ‚à£ ‚ü®$‚ü©  (‚ü¶ q ‚üß‚ÇÅ ‚ü®$‚ü© (œÜ‚Åª¬π ‚àò œÅ))         ‚âà‚ü® comm-hom-term œÜ q (œÜ‚Åª¬π ‚àò œÅ) ‚ü©
           ‚ü¶ q ‚üß ‚ü®$‚ü© (Œª x ‚Üí (‚à£ œÜ ‚à£ ‚ü®$‚ü© (œÜ‚Åª¬π ‚àò œÅ) x)) ‚âà‚ü® cong ‚ü¶ q ‚üß Œ∂ ‚ü©
           ‚ü¶ q ‚üß ‚ü®$‚ü© œÅ                               ‚àé

\end{code}


#### <a id="s-preserves-identities">S preserves identities</a>

\begin{code}

 S-id1 : ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí (S {Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶) ‚ä´ (p ‚âàÃá q)
 S-id1 œÉ ùë© (ùë® , kA , B‚â§A) = ‚äß-S-invar{p = p}{q} (œÉ ùë® kA) B‚â§A

\end{code}

The obvious converse is barely worth the bits needed to formalize it, but we will use it below, so let's prove it now.

\begin{code}

 S-id2 : S ‚Ñì ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q)
 S-id2 Spq ùë® kA = Spq ùë® (ùë® , (kA , ‚â§-reflexive))

\end{code}


#### <a id="p-preserves-identities">P preserves identities</a>

\begin{code}

 P-id1 : ‚àÄ{Œπ} ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶ ‚ä´ (p ‚âàÃá q)
 P-id1 œÉ ùë® (I , ùíú , kA , A‚âÖ‚®ÖA) = ‚äß-I-invar ùë® p q IH (‚âÖ-sym A‚âÖ‚®ÖA)
  where
  ih : ‚àÄ i ‚Üí ùíú i ‚äß (p ‚âàÃá q)
  ih i = œÉ (ùíú i) (kA i)
  IH : ‚®Ö ùíú ‚äß (p ‚âàÃá q)
  IH = ‚äß-P-invar ùíú {p}{q} ih

\end{code}


#### <a id="v-preserves-identities">V preserves identities</a>

Finally, we prove the analogous preservation lemmas for the closure operator `V`.

\begin{code}

module _ {X : Type œá}{Œπ : Level}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where
 private
  a‚ÑìŒπ = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ‚äî Œπ

 V-id1 : ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí V ‚Ñì Œπ ùí¶ ‚ä´ (p ‚âàÃá q)
 V-id1 œÉ ùë© (ùë® , (‚®ÖA , p‚®ÖA , A‚â§‚®ÖA) , BimgA) =
  H-id1{‚Ñì = a‚ÑìŒπ}{ùí¶ = S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)}{p = p}{q} spK‚äßpq ùë© (ùë® , (spA , BimgA))
   where
   spA : ùë® ‚àà S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)
   spA = ‚®ÖA , (p‚®ÖA , A‚â§‚®ÖA)
   spK‚äßpq : S a‚ÑìŒπ (P ‚Ñì Œπ ùí¶) ‚ä´ (p ‚âàÃá q)
   spK‚äßpq = S-id1{‚Ñì = a‚ÑìŒπ}{p = p}{q} (P-id1{‚Ñì = ‚Ñì} {ùí¶ = ùí¶}{p = p}{q} œÉ)

\end{code}

#### <a id="th-k-subset-th-v">Th ùí¶ ‚äÜ Th (V ùí¶)</a>

From `V-id1` it follows that if ùí¶ is a class of algebras, then the set of identities modeled by the algebras in `ùí¶` is contained in the set of identities modeled by the algebras in `V ùí¶`.  In other terms, `Th ùí¶ ‚äÜ Th (V ùí¶)`.  We formalize this observation as follows.

\begin{code}

 classIds-‚äÜ-VIds : ùí¶ ‚ä´ (p ‚âàÃá q)  ‚Üí (p , q) ‚àà Th (V ‚Ñì Œπ ùí¶)
 classIds-‚äÜ-VIds pKq ùë® = V-id1 pKq ùë®

\end{code}

## <a id="free-algebras">Free Algebras</a>

### <a id="the-absolutely-free-algebra-tx">The absolutely free algebra ùëª X</a>

The term algebra `ùëª X` is *absolutely free* (or *universal*, or *initial*) for algebras in the signature `ùëÜ`. That is, for every ùëÜ-algebra `ùë®`, the following hold.

1. Every function from `ùëã` to `‚à£ ùë® ‚à£` lifts to a homomorphism from `ùëª X` to `ùë®`.
2. The homomorphism that exists by item 1 is unique.

We now prove this in [Agda][], starting with the fact that every map from `X` to `‚à£ ùë® ‚à£` lifts to a map from `‚à£ ùëª X ‚à£` to `‚à£ ùë® ‚à£` in a natural way, by induction on the structure of the given term.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(h : X ‚Üí ùïå[ ùë® ]) where
 open Algebra ùë® using () renaming ( Domain to A ; Interp to InterpA)
 open Setoid A using ( _‚âà_ ; reflexive ; refl ; trans ) renaming ( Carrier to ‚à£A‚à£ )
 open Algebra (ùëª X) using () renaming ( Domain to TX )
 open Setoid TX using () renaming ( Carrier to ‚à£TX‚à£ )

 free-lift : ùïå[ ùëª X ] ‚Üí ùïå[ ùë® ]
 free-lift (‚Ñä x) = h x
 free-lift (node f t) = (f ÃÇ ùë®) (Œª i ‚Üí free-lift (t i))

 free-lift-func : TX ‚ü∂ A
 free-lift-func ‚ü®$‚ü© x = free-lift x
 cong free-lift-func = flcong
  where
  flcong : ‚àÄ {s t} ‚Üí s ‚âê t ‚Üí  free-lift s ‚âà free-lift t
  flcong (_‚âê_.rfl x) = reflexive (‚â°.cong h x)
  flcong (_‚âê_.gnl x) = cong InterpA (‚â°.refl , (Œª i ‚Üí flcong (x i)))

\end{code}

Naturally, at the base step of the induction, when the term has the form `generator`
x, the free lift of `h` agrees with `h`.  For the inductive step, when the
given term has the form `node f t`, the free lift is defined as
follows: Assuming (the induction hypothesis) that we know the image of each
subterm `t i` under the free lift of `h`, define the free lift at the
full term by applying `f ÃÇ ùë®` to the images of the subterms.

The free lift so defined is a homomorphism by construction. Indeed, here is the trivial proof.

\begin{code}

 lift-hom : hom (ùëª X) ùë®
 lift-hom = free-lift-func , hhom
  where
  hfunc : TX ‚ü∂ A
  hfunc = free-lift-func

  hcomp : compatible-map (ùëª X) ùë® free-lift-func
  hcomp {f}{a} = cong InterpA (‚â°.refl , (Œª i ‚Üí (cong free-lift-func){a i} ‚âê-isRefl))

  hhom : IsHom (ùëª X) ùë® hfunc
  hhom = record { compatible = Œª{f}{a} ‚Üí hcomp{f}{a} }


module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ} where
 open Algebra ùë® using () renaming ( Domain to A ; Interp to InterpA )
 open Setoid A using ( _‚âà_ ; refl ) renaming ( Carrier to ‚à£A‚à£ )
 open Environment ùë® using ( ‚ü¶_‚üß )

 free-lift-interp : (Œ∑ : X ‚Üí ‚à£A‚à£)(p : Term X) ‚Üí ‚ü¶ p ‚üß ‚ü®$‚ü© Œ∑ ‚âà (free-lift {ùë® = ùë®} Œ∑) p

 free-lift-interp Œ∑ (‚Ñä x) = refl
 free-lift-interp Œ∑ (node f t) = cong InterpA (‚â°.refl , (free-lift-interp Œ∑) ‚àò t)

\end{code}

### <a id="the-relatively-free-algebra-f">The relatively free algebra ùîΩ</a>

We now define the algebra `ùîΩ[ X ]`, which plays the role of the relatively free algebra, along with the natural epimorphism `epiùîΩ : epi (ùëª X) ùîΩ[ X ]` from `ùëª X` to `ùîΩ[ X ]`.

\begin{code}

module FreeAlgebra {œá : Level}{Œπ : Level}{I : Type Œπ}(‚Ñ∞ : I ‚Üí Eq) where
 open Algebra

 FreeDomain : Type œá ‚Üí Setoid _ _
 FreeDomain X = record { Carrier       = Term X
                       ; _‚âà_           = ‚Ñ∞ ‚ä¢ X ‚ñπ_‚âà_
                       ; isEquivalence = ‚ä¢‚ñπ‚âàIsEquiv }
\end{code}

The interpretation of an operation is simply the operation itself.
This works since `‚Ñ∞ ‚ä¢ X ‚ñπ_‚âà_` is a congruence.

\begin{code}

 FreeInterp : ‚àÄ {X} ‚Üí ‚ü® ùëÜ ‚ü© (FreeDomain X) ‚ü∂ FreeDomain X
 FreeInterp ‚ü®$‚ü© (f , ts) = node f ts
 cong FreeInterp (‚â°.refl , h) = app h

 ùîΩ[_] : Type œá ‚Üí Algebra (ov œá) (Œπ ‚äî ov œá)
 Domain ùîΩ[ X ] = FreeDomain X
 Interp ùîΩ[ X ] = FreeInterp

\end{code}

### <a id="basic-properties-of-free-algebras">Basic properties of free algebras</a>

In the code below, `X` will play the role of an arbitrary collection of variables; it would suffice to take `X` to be the cardinality of the largest algebra in ùí¶, but since we don't know that cardinality, we leave `X` aribtrary for now.

\begin{code}

module FreeHom (œá : Level) {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private Œπ = ov(œá ‚äî Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)
 open Eq

 ‚Ñê : Type Œπ -- indexes the collection of equations modeled by ùí¶
 ‚Ñê = Œ£[ eq ‚àà Eq{œá} ] ùí¶ ‚ä´ ((lhs eq) ‚âàÃá (rhs eq))

 ‚Ñ∞ : ‚Ñê ‚Üí Eq
 ‚Ñ∞ (eqv , p) = eqv

 ‚Ñ∞‚ä¢[_]‚ñπThùí¶ : (X : Type œá) ‚Üí ‚àÄ{p q} ‚Üí ‚Ñ∞ ‚ä¢ X ‚ñπ p ‚âà q ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q)
 ‚Ñ∞‚ä¢[ X ]‚ñπThùí¶ x ùë® kA = sound (Œª i œÅ ‚Üí ‚à• i ‚à• ùë® kA œÅ) x
  where open Soundness ‚Ñ∞ ùë®

 open FreeAlgebra {Œπ = Œπ}{I = ‚Ñê} ‚Ñ∞ using ( ùîΩ[_] )

\end{code}


#### <a id="the-natural-epimorphism-from-tx-to-f">The natural epimorphism from ùëª X to ùîΩ[ X ]</a>
Next we define an epimorphism from `ùëª X` onto the relatively free algebra `ùîΩ[ X ]`.  Of course, the kernel of this epimorphism will be the congruence of `ùëª X` defined by identities modeled by (`S ùí¶`, hence) `ùí¶`.

\begin{code}

 epiùîΩ[_] : (X : Type œá) ‚Üí epi (ùëª X) ùîΩ[ X ]
 epiùîΩ[ X ] = h , hepi
  where
  open Algebra ùîΩ[ X ] using () renaming ( Domain to F ; Interp to InterpF )
  open Setoid F using () renaming ( _‚âà_  to _‚âàF‚âà_ ; refl to reflF )
  open Algebra (ùëª X) using () renaming (Domain to TX)
  open Setoid TX using () renaming ( _‚âà_ to _‚âàT‚âà_ ; refl to reflT )
  open _‚âê_ ; open IsEpi ; open IsHom

  c : ‚àÄ {x y} ‚Üí x ‚âàT‚âà y ‚Üí x ‚âàF‚âà y
  c (rfl {x}{y} ‚â°.refl) = reflF
  c (gnl {f}{s}{t} x) = cong InterpF (‚â°.refl , c ‚àò x)

  h : TX ‚ü∂ F
  h = record { f = id ; cong = c }

  hepi : IsEpi (ùëª X) ùîΩ[ X ] h
  compatible (isHom hepi) = cong h reflT
  isSurjective hepi {y} = eq y reflF

 homùîΩ[_] : (X : Type œá) ‚Üí hom (ùëª X) ùîΩ[ X ]
 homùîΩ[ X ] = IsEpi.HomReduct ‚à• epiùîΩ[ X ] ‚à•

 homùîΩ[_]-is-epic : (X : Type œá) ‚Üí IsSurjective ‚à£ homùîΩ[ X ] ‚à£
 homùîΩ[ X ]-is-epic = IsEpi.isSurjective (snd (epiùîΩ[ X ]))

\end{code}


#### <a id="the-kernel-of-the-natural-epimorphism">The kernel of the natural epimorphism</a>

\begin{code}

 class-models-kernel : ‚àÄ{X p q} ‚Üí (p , q) ‚àà ker ‚à£ homùîΩ[ X ] ‚à£ ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q)
 class-models-kernel {X = X}{p}{q} pKq = ‚Ñ∞‚ä¢[ X ]‚ñπThùí¶ pKq

 kernel-in-theory : {X : Type œá} ‚Üí ker ‚à£ homùîΩ[ X ] ‚à£ ‚äÜ Th (V ‚Ñì Œπ ùí¶)
 kernel-in-theory {X = X} {p , q} pKq vkA x = classIds-‚äÜ-VIds {‚Ñì = ‚Ñì} {p = p}{q}
                                      (class-models-kernel pKq) vkA x

 module _ {X : Type œá} {ùë® : Algebra Œ± œÅ·µÉ}{sA : ùë® ‚àà S {Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶} where
  open Environment ùë® using ( Equal )
  kerùîΩ‚äÜEqual : ‚àÄ{p q} ‚Üí (p , q) ‚àà ker ‚à£ homùîΩ[ X ] ‚à£ ‚Üí Equal p q
  kerùîΩ‚äÜEqual{p = p}{q} x = S-id1{‚Ñì = ‚Ñì}{p = p}{q} (‚Ñ∞‚ä¢[ X ]‚ñπThùí¶ x) ùë® sA

 ùí¶‚ä´‚Üí‚Ñ∞‚ä¢ : {X : Type œá} ‚Üí ‚àÄ{p q} ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí ‚Ñ∞ ‚ä¢ X ‚ñπ p ‚âà q
 ùí¶‚ä´‚Üí‚Ñ∞‚ä¢ {p = p} {q} pKq = hyp ((p ‚âàÃá q) , pKq) where open _‚ä¢_‚ñπ_‚âà_ using (hyp)

\end{code}

#### <a id="the-universal-property">The universal property</a>

\begin{code}

module _ {ùë® : Algebra (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)}
         {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private Œπ = ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)
 open IsEpi ; open IsHom
 open FreeHom {‚Ñì = ‚Ñì}(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) {ùí¶}
 open FreeAlgebra {Œπ = Œπ}{I = ‚Ñê} ‚Ñ∞ using ( ùîΩ[_] )
 open Algebra ùë® using() renaming (Domain to A ; Interp to InterpA )
 open Setoid A using ( trans ; sym ; refl ) renaming ( Carrier to ‚à£A‚à£ )

 ùîΩ-ModTh-epi : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶))
  ‚Üí            epi ùîΩ[ ‚à£A‚à£ ] ùë®
 ùîΩ-ModTh-epi A‚ààModThK = œÜ , isEpi
  where
   œÜ : ùîª[ ùîΩ[ ‚à£A‚à£ ] ] ‚ü∂ A
   _‚ü®$‚ü©_ œÜ = free-lift{ùë® = ùë®} id
   cong œÜ {p} {q} pq = trans (sym (free-lift-interp{ùë® = ùë®} id p))
                      (trans (A‚ààModThK{p = p}{q} (kernel-in-theory pq) id)
                      (free-lift-interp{ùë® = ùë®} id q))

   isEpi : IsEpi ùîΩ[ ‚à£A‚à£ ] ùë® œÜ
   compatible (isHom isEpi) = cong InterpA (‚â°.refl , (Œª _ ‚Üí refl))
   isSurjective isEpi {y} = eq (‚Ñä y) refl

 ùîΩ-ModTh-epi-lift : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí epi ùîΩ[ ‚à£A‚à£ ] (Lift-Alg ùë® Œπ Œπ)
 ùîΩ-ModTh-epi-lift A‚ààModThK = ‚àò-epi (ùîΩ-ModTh-epi (Œª {p q} ‚Üí A‚ààModThK{p = p}{q})) ToLift-epi

\end{code}


## <a id="products-of-classes-of-algebras">Products of classes of algebras</a>

We want to pair each `(ùë® , p)` (where p : ùë® ‚àà S ùí¶) with an environment
`œÅ : X ‚Üí ‚à£ ùë® ‚à£` so that we can quantify over all algebras *and* all
assignments of values in the domain `‚à£ ùë® ‚à£` to variables in `X`.

\begin{code}

module _ (ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)){X : Type (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} where
 private Œπ = ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)
 open FreeHom {‚Ñì = ‚Ñì} (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì){ùí¶}
 open FreeAlgebra {Œπ = Œπ}{I = ‚Ñê} ‚Ñ∞ using ( ùîΩ[_] )
 open Environment   using ( Env )

 ‚Ñë‚Å∫ : Type Œπ
 ‚Ñë‚Å∫ = Œ£[ ùë® ‚àà (Algebra Œ± œÅ·µÉ) ] (ùë® ‚àà S ‚Ñì ùí¶) √ó (Carrier (Env ùë® X))

 ùîÑ‚Å∫ : ‚Ñë‚Å∫ ‚Üí Algebra Œ± œÅ·µÉ
 ùîÑ‚Å∫ i = ‚à£ i ‚à£

 ‚Ñ≠ : Algebra Œπ Œπ
 ‚Ñ≠ = ‚®Ö ùîÑ‚Å∫

\end{code}

Next we define a useful type, `skEqual`, which we use to represent a term identity `p ‚âà q` for any
given `i = (ùë® , sA , œÅ)` (where `ùë®` is an algebra, `sA : ùë® ‚àà S ùí¶` is a proof that `ùë®` belongs
to `S ùí¶`, and `œÅ` is a mapping from `X` to the domain of `ùë®`). Then we prove `AllEqual‚äÜkerùîΩ` which
asserts that if the identity `p ‚âà q` holds in all `ùë® ‚àà S ùí¶` (for all environments), then `p ‚âà q`
holds in the relatively free algebra `ùîΩ[ X ]`; equivalently, the pair `(p , q)` belongs to the
kernel of the natural homomorphism from `ùëª X` onto `ùîΩ[ X ]`. We will use this fact below to prove
that there is a monomorphism from `ùîΩ[ X ]` into `‚Ñ≠`, and thus `ùîΩ[ X ]` is a subalgebra of ‚Ñ≠,
so belongs to `S (P ùí¶)`.

\begin{code}

 skEqual : (i : ‚Ñë‚Å∫) ‚Üí ‚àÄ{p q} ‚Üí Type œÅ·µÉ
 skEqual i {p}{q} = ‚ü¶ p ‚üß ‚ü®$‚ü© snd ‚à• i ‚à• ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© snd ‚à• i ‚à•
  where
  open Setoid ùîª[ ùîÑ‚Å∫ i ] using ( _‚âà_ )
  open Environment (ùîÑ‚Å∫ i) using ( ‚ü¶_‚üß )

 AllEqual‚äÜkerùîΩ : ‚àÄ {p q} ‚Üí (‚àÄ i ‚Üí skEqual i {p}{q}) ‚Üí (p , q) ‚àà ker ‚à£ homùîΩ[ X ] ‚à£
 AllEqual‚äÜkerùîΩ {p} {q} x = Goal
  where
  open Algebra ùîΩ[ X ] using () renaming ( Domain to F ; Interp to InterpF )
  open Setoid F using () renaming ( _‚âà_  to _‚âàF‚âà_ ; refl to reflF )
  Sùí¶‚ä´pq : S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶ ‚ä´ (p ‚âàÃá q)
  Sùí¶‚ä´pq ùë® sA œÅ = x (ùë® , sA , œÅ)
  Goal : p ‚âàF‚âà q
  Goal = ùí¶‚ä´‚Üí‚Ñ∞‚ä¢ (S-id2{‚Ñì = ‚Ñì}{p = p}{q} Sùí¶‚ä´pq)

 hom‚Ñ≠ : hom (ùëª X) ‚Ñ≠
 hom‚Ñ≠ = ‚®Ö-hom-co ùîÑ‚Å∫ h
  where
  h : ‚àÄ i ‚Üí hom (ùëª X) (ùîÑ‚Å∫ i)
  h i = lift-hom (snd ‚à• i ‚à•)

 open Algebra ùîΩ[ X ] using () renaming ( Domain to F ; Interp to InterpF )
 open Setoid F using () renaming (refl to reflF ; _‚âà_ to _‚âàF‚âà_ ; Carrier to ‚à£F‚à£)

 kerùîΩ‚äÜker‚Ñ≠ : ker ‚à£ homùîΩ[ X ] ‚à£ ‚äÜ ker ‚à£ hom‚Ñ≠ ‚à£
 kerùîΩ‚äÜker‚Ñ≠ {p , q} pKq (ùë® , sA , œÅ) = Goal
  where
  open Setoid ùîª[ ùë® ] using ( _‚âà_ ; sym ; trans )
  open Environment ùë® using ( ‚ü¶_‚üß )
  fl : ‚àÄ t ‚Üí ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ ‚âà free-lift œÅ t
  fl t = free-lift-interp {ùë® = ùë®} œÅ t
  subgoal : ‚ü¶ p ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© œÅ
  subgoal = kerùîΩ‚äÜEqual{ùë® = ùë®}{sA} pKq œÅ
  Goal : (free-lift{ùë® = ùë®} œÅ p) ‚âà (free-lift{ùë® = ùë®} œÅ q)
  Goal = trans (sym (fl p)) (trans subgoal (fl q))


 homùîΩ‚Ñ≠ : hom ùîΩ[ X ] ‚Ñ≠
 homùîΩ‚Ñ≠ = ‚à£ HomFactor ‚Ñ≠ hom‚Ñ≠ homùîΩ[ X ] kerùîΩ‚äÜker‚Ñ≠ homùîΩ[ X ]-is-epic ‚à£

 open Environment ‚Ñ≠

 ker‚Ñ≠‚äÜkerùîΩ : ‚àÄ{p q} ‚Üí (p , q) ‚àà ker ‚à£ hom‚Ñ≠ ‚à£ ‚Üí (p , q) ‚àà ker ‚à£ homùîΩ[ X ] ‚à£
 ker‚Ñ≠‚äÜkerùîΩ {p}{q} pKq = E‚ä¢pq
  where
  pqEqual : ‚àÄ i ‚Üí skEqual i {p}{q}
  pqEqual i = goal
   where
   open Environment (ùîÑ‚Å∫ i) using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·µ¢ )
   open Setoid ùîª[ ùîÑ‚Å∫ i ] using ( _‚âà_ ; sym ; trans )
   goal : ‚ü¶ p ‚üß·µ¢ ‚ü®$‚ü© snd ‚à• i ‚à• ‚âà ‚ü¶ q ‚üß·µ¢ ‚ü®$‚ü© snd ‚à• i ‚à•
   goal = trans (free-lift-interp{ùë® = ‚à£ i ‚à£}(snd ‚à• i ‚à•) p)
           (trans (pKq i)(sym (free-lift-interp{ùë® = ‚à£ i ‚à£} (snd ‚à• i ‚à•) q)))
  E‚ä¢pq : ‚Ñ∞ ‚ä¢ X ‚ñπ p ‚âà q
  E‚ä¢pq = AllEqual‚äÜkerùîΩ pqEqual

 monùîΩ‚Ñ≠ : mon ùîΩ[ X ] ‚Ñ≠
 monùîΩ‚Ñ≠ = ‚à£ homùîΩ‚Ñ≠ ‚à£ , isMon
  where
  open IsMon
  open IsHom
  isMon : IsMon ùîΩ[ X ] ‚Ñ≠ ‚à£ homùîΩ‚Ñ≠ ‚à£
  isHom isMon = ‚à• homùîΩ‚Ñ≠ ‚à•
  isInjective isMon {p} {q} œÜpq = ker‚Ñ≠‚äÜkerùîΩ œÜpq

\end{code}

Now that we have proved the existence of a monomorphism from `ùîΩ[ X ]` to `‚Ñ≠` we are in a position
to prove that `ùîΩ[ X ]` is a subalgebra of ‚Ñ≠, so belongs to `S (P ùí¶)`.  In fact, we will show
that `ùîΩ[ X ]` is a subalgebra of the *lift* of `‚Ñ≠`, denoted `‚Ñì‚Ñ≠`.

\begin{code}

 ùîΩ‚â§‚Ñ≠ : ùîΩ[ X ] ‚â§ ‚Ñ≠
 ùîΩ‚â§‚Ñ≠ = mon‚Üí‚â§ monùîΩ‚Ñ≠

 SPùîΩ : ùîΩ[ X ] ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
 SPùîΩ = S-idem SSPùîΩ
  where
  PS‚Ñ≠ : ‚Ñ≠ ‚àà P (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) Œπ (S ‚Ñì ùí¶)
  PS‚Ñ≠ = ‚Ñë‚Å∫ , (ùîÑ‚Å∫ , ((Œª i ‚Üí fst ‚à• i ‚à•) , ‚âÖ-refl))
  SP‚Ñ≠ : ‚Ñ≠ ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
  SP‚Ñ≠ = PS‚äÜSP {‚Ñì = ‚Ñì} PS‚Ñ≠
  SSPùîΩ : ùîΩ[ X ] ‚àà S Œπ (S Œπ (P ‚Ñì Œπ ùí¶))
  SSPùîΩ = ‚Ñ≠ , (SP‚Ñ≠ , ùîΩ‚â§‚Ñ≠)

\end{code}

## <a id="the-hsp-theorem">The HSP Theorem</a>

Finally, we are in a position to prove Birkhoff's celebrated variety theorem.

\begin{code}

module _ {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private Œπ = ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)
 open FreeHom {‚Ñì = ‚Ñì}(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì){ùí¶}
 open FreeAlgebra {Œπ = Œπ}{I = ‚Ñê} ‚Ñ∞ using ( ùîΩ[_] )

 Birkhoff : ‚àÄ ùë® ‚Üí ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí ùë® ‚àà V ‚Ñì Œπ ùí¶
 Birkhoff ùë® ModThA = V-‚âÖ-lc{Œ±}{œÅ·µÉ}{‚Ñì} ùí¶ ùë® VlA
  where
  open Setoid ùîª[ ùë® ] using () renaming ( Carrier to A )
  spùîΩA : ùîΩ[ A ] ‚àà S{Œπ} Œπ (P ‚Ñì Œπ ùí¶)
  spùîΩA = SPùîΩ{‚Ñì = ‚Ñì} ùí¶
  epiùîΩlA : epi ùîΩ[ A ] (Lift-Alg ùë® Œπ Œπ)
  epiùîΩlA = ùîΩ-ModTh-epi-lift{‚Ñì = ‚Ñì} (Œª {p q} ‚Üí ModThA{p = p}{q})
  lAimgùîΩA : Lift-Alg ùë® Œπ Œπ IsHomImageOf ùîΩ[ A ]
  lAimgùîΩA = epi‚Üíontohom ùîΩ[ A ] (Lift-Alg ùë® Œπ Œπ) epiùîΩlA
  VlA : Lift-Alg ùë® Œπ Œπ ‚àà V ‚Ñì Œπ ùí¶
  VlA = ùîΩ[ A ] , spùîΩA , lAimgùîΩA

\end{code}

The converse inclusion, `V ùí¶ ‚äÜ Mod (Th (V ùí¶))`, is a simple consequence of the
fact that `Mod Th` is a closure operator. Nonetheless, completeness demands
that we formalize this inclusion as well, however trivial the proof.

\begin{code}

 module _ {ùë® : Algebra Œ± œÅ·µÉ} where
  open Setoid ùîª[ ùë® ] using () renaming ( Carrier to A )

  Birkhoff-converse : ùë® ‚àà V{Œ±}{œÅ·µÉ}{Œ±}{œÅ·µÉ}{Œ±}{œÅ·µÉ} ‚Ñì Œπ ùí¶ ‚Üí ùë® ‚àà Mod{X = A} (Th (V ‚Ñì Œπ ùí¶))
  Birkhoff-converse vA pThq = pThq ùë® vA

\end{code}

We have thus proved that every variety is an equational class.

Readers familiar with the classical formulation of the Birkhoff HSP theorem as an
"if and only if" assertion might worry that the proof is still incomplete. However,
recall that in the [Varieties.Func.Preservation][] module we proved the following
identity preservation lemma:

`V-id1 : ùí¶ ‚ä´ p ‚âàÃá q ‚Üí V ùí¶ ‚ä´ p ‚âàÃá q`

Thus, if `ùí¶` is an equational class---that is, if `ùí¶` is the class of algebras
satisfying all identities in some set---then `V ùí¶` ‚äÜ ùí¶`.  On the other hand, we
proved that `V` is expansive in the [Varieties.Func.Closure][] module:

`V-expa : ùí¶ ‚äÜ V ùí¶`

so `ùí¶` (= `V ùí¶` = `HSP ùí¶`) is a variety.

Taken together, `V-id1` and `V-expa` constitute formal proof that every equational
class is a variety.

This completes the formal proof of Birkhoff's variety theorem.


## Appendix

The `Setoid` type is defined in the [Agda Standard Library][] as follows.

```
record Setoid c ‚Ñì : Set (suc (c ‚äî ‚Ñì)) where
  field
    Carrier       : Set c
    _‚âà_           : Rel Carrier ‚Ñì
    isEquivalence : IsEquivalence _‚âà_
```

The `Func` type is defined in the [Agda Standard Library][] as follows.

```
  record Func : Set (a ‚äî b ‚äî ‚Ñì‚ÇÅ ‚äî ‚Ñì‚ÇÇ) where
    field
      f    : A ‚Üí B
      cong : f Preserves _‚âà‚ÇÅ_ ‚ü∂ _‚âà‚ÇÇ_

    isCongruent : IsCongruent f
    isCongruent = record
      { cong           = cong
      ; isEquivalence‚ÇÅ = isEquivalence From
      ; isEquivalence‚ÇÇ = isEquivalence To
      }

    open IsCongruent isCongruent public
      using (module Eq‚ÇÅ; module Eq‚ÇÇ)
```

Here, `A` and `B` are setoids with respective equality relations `‚âà‚ÇÅ` and `‚âà‚ÇÇ`.


--------------------------------

<span style="float:left;">[‚Üê Varieties.Func.FreeAlgebras](Varieties.Func.FreeAlgebras.html)</span>
<span style="float:right;">[Structures ‚Üí](Structures.html)</span>

{% include UALib.Links.md %}

