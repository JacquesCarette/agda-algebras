\section{Introduction}
The \agdaalgebras library is a repository of types and programs
(theorems and proofs) formalizing the foundations of universal algebra in Martin-L√∂f dependent type
theory using the \agda programming language.
The library now includes an fairly extensive collection of formal definitions, theorems, and
proofs that codify, in the formal language of type theory, the analogous definitions,
theorems, and proofs of classical, set-theory-based universal algebra and equational
logic. As such, the \agdaalgebras library provides many examples that exhibit the
expressiveness of inductive and dependent types for representing and reasoning about
general algebraic and relational structures in a formal language. The main advantage of
formalizing mathematics in type theory using a \emph{proof assistant} (like Agda) is that
the software checks the correctness of our proofs by a process known as ``type-checking.''

The first major milestone of the \agdaalgebras project is a formal proof of \emph{Birkhoff's
variety theorem} (also known as the \emph{HSP theorem})~\cite{Birkhoff:1935} in dependent
type theory. Our first formal proof of the theorem, completed in January of 2021,
contained some flaws and there were concerns that the proof was not truly
constructive.
%\footnote{See \url{https://github.com/ualib/ualib.github.io/blob/b968e8af1117fc77700d3a588746cbefbd464835/sandbox/birkhoff-exp-new-new.lagda}.}
We are confident that the version we present here is fully constructive and correct. To the
best of our knowledge, it is the first formulation of the HSP theorem in Martin-L√∂f
dependent type theory, and the first formal, machine-verified proof of Birkhoff's
celebrated 1935 result.

In this paper, we present a nearly self-contained formal proof of Birkhoff's theorem by
extracting into a single Agda module only those parts of the \agdaalgebras library that we
need for the proof.  The main body of the paper is generated by a literate Agda file which
is available online\footnote{See
\url{https://github.com/ualib/agda-algebras/blob/master/src/Demos/HSP.lagda}}
and which others can type-check (using \agda version 2.6.2 and \agdastdlib version 1.7) to
verify its correctness.
\ifshort

In order to present the proof in under 20 pages, we omit some of the formalities,
but strive to preserve the essential content and character of the development.
We leave out the routine or overly technical components, as well as anything that does not
seem to offer any insight into the central ideas of the proof. For readers wishing to see all the
details, we have posted on the arXiv an unabridged version of the paper, which includes
every line of code of our formal proof of Birkhoff's theorem in a single, self-contained
(apart from a few dozen imports from the \agdastdlib) Agda module~\cite{DeMeo:2021b}.
\else
We include here every line of code of our formal proof of Birkhoff's theorem
in a single, self-contained (apart from a few dozen imports from the \agdastdlib) Agda
module.
For readers preferring a more concise presentation, an abridged version of this paper is also
available~\cite{DeMeo:2021c}.
\fi

In the course of this presentation we highlight some of the challenging aspects of
formalizing the basic definitions and theorems of universal algebra in type theory.
%In particular, we touch on some technical issues that arise when attempting
%to constructively prove basic results of our field.  Nonetheless,
One positive contribution of this project is that it lends support to the claim that
dependent type theory and the Agda language, despite the technical demands they place on
the user, are accessible to working mathematicians (such as ourselves) who possess
sufficient patience and resolve to codify their work in order to formally verify
the their results.

\ifshort\else
Our presentation gives a sobering glimpse of the technical hurdles that must be overcome
to conduct research in mathematics using dependent type theory and the Agda language.
Nonetheless we hope our work does not discourage anyone from investing in these
technologies and we remain committed to the use and promotion of type theory and proof
assistants in general and in our own research. Indeed, we are excited to share the
gratifying outcomes and achievements that resulted from attaining some degree of mastery
of type theory, interactive theorem proving, and the Agda language.
\fi

\section{Preliminaries}

\subsection{Logical foundations}

An Agda program typically begins by setting some language options and by
importing types from existing Agda libraries. The language options are specified
using the \ak{OPTIONS} \emph{pragma} which affects the way Agda behaves by controlling
the deduction rules that are available and the logical axioms
that are assumed when the program is type-checked to verify its
correctness. Every Agda program in the \agdaalgebras library, including the
module described in this paper,\footnote{\url{https://github.com/ualib/agda-algebras/blob/master/src/Demos/HSP.lagda}} begins with the following line.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

\end{code}
Here are brief descriptions of these options, accompanied by links to related documentation.

\begin{itemize}
\item
\AgdaPragma{without-K} disables \href{https://ncatlab.org/nlab/show/axiom+K+%28type+theory%29}{Streicher's K axiom}.
See the \href{https://agda.readthedocs.io/en/v2.6.1/language/without-k.html}{section on axiom K} in the \href{https://agda.readthedocs.io/en/v2.6.1.3/language}{Agda Language Reference Manual}~\cite{agdaref-axiomk}.

\item
\AgdaPragma{exact-split} makes Agda accept only those definitions that behave like so-called {\it judgmental} equalities.
See the \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#pattern-matching-and-equality}%
{Pattern matching and equality} section of the \href{https://agda.readthedocs.io/en/v2.6.1.3/tools/}{Agda Tools} documentation~\cite{agdatools-patternmatching}.

\item
\AgdaPragma{safe} ensures that nothing is postulated outright---every non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module).
See the \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#cmdoption-safe}{cmdoption-safe}
section of the \href{https://agda.readthedocs.io/en/v2.6.1.3/tools/}{Agda Tools documentation} and the \href{https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html#safe-agda}{Safe Agda section} of the \href{https://agda.readthedocs.io/en/v2.6.1.3/language}{Agda Language Reference}~\cite{agdaref-safeagda}.
\end{itemize}


The \AgdaKeyword{OPTIONS} pragma is usually followed by the start of a module and a list of import directives.
For example, the present module (\DemosHSPlagda) begins as follows.

\begin{code}[hide]
{-# OPTIONS --without-K --exact-split --safe #-}
\end{code}
\begin{code}

-- Import universe levels and Signature type (described below) from the agda-algebras library.
open import Algebras.Basic using ( ùìû ; ùì• ; Signature )

module Demos.HSP {ùëÜ : Signature ùìû ùì•} where

-- Import 16 definitions from the Agda Standard Library.
open import  Data.Unit.Polymorphic                           using ( ‚ä§ ; tt                        )
open import  Function                                        using ( id ; flip ; _‚àò_               )
open import  Level                                           using ( Level                         )
open import  Relation.Binary                                 using ( Rel ; Setoid ; IsEquivalence  )
open import  Relation.Binary.Definitions                     using ( Reflexive ; Symmetric         )
                                                             using ( Transitive ; Sym ; Trans      )
open import  Relation.Binary.PropositionalEquality           using ( _‚â°_                           )
open import  Relation.Unary                                  using ( Pred ; _‚äÜ_ ; _‚àà_              )

-- Import 23 definitions from the Agda Standard Library and rename 12 of them.
open import  Agda.Primitive  renaming ( Set    to Type    )  using ( _‚äî_ ; lsuc                    )
open import  Data.Product    renaming ( proj‚ÇÅ  to fst     )
                             renaming ( proj‚ÇÇ  to snd     )  using ( _√ó_ ; _,_ ; Œ£ ; Œ£-syntax      )
open import  Function        renaming ( Func   to _‚ü∂_     )  using ( Injection ; Surjection        )
open         _‚ü∂_             renaming ( f      to _‚ü®$‚ü©_   )  using ( cong                          )
open         Setoid          renaming ( refl   to reflÀ¢   )
                             renaming ( sym    to symÀ¢    )
                             renaming ( trans  to transÀ¢  )
                             renaming ( _‚âà_    to _‚âàÀ¢_    )  using ( Carrier ; isEquivalence       )
open         IsEquivalence   renaming ( refl   to refl·µâ   )
                             renaming ( sym    to sym·µâ    )
                             renaming ( trans  to trans·µâ  )  using ()

\end{code}
\ifshort\else
\begin{code}
-- Assign handles to 3 modules of the Agda Standard Library.
import       Function.Definitions                   as FD
import       Relation.Binary.PropositionalEquality  as ‚â°
import       Relation.Binary.Reasoning.Setoid       as SetoidReasoning

private variable
 Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà œÅ œá ‚Ñì : Level
 Œì Œî : Type œá
 ùëì : fst ùëÜ

\end{code}
\fi
Note that the above imports include some adjustments to ``standard Agda'' syntax to suite our own taste.
In particular, the following conventions used throughout the \agdaalgebras library and this paper: we use \AgdaPrimitive{Type} in place of \AgdaPrimitive{Set}, the infix long arrow symbol,
\AgdaRecord{\AgdaUnderscore{}‚ü∂\AgdaUnderscore{}}, instead of \AgdaRecord{Func} (the type of ``setoid functions'' discussed in ¬ß\ref{setoid-functions} below), and the symbol \aofld{\au{}‚ü®\$‚ü©\au{}} in place of \afld{f} (application of the map of a setoid function); we use
\AgdaField{fst} and \AgdaField{snd}, and sometimes \AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}} and
\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}}, to denote the first and second
projections out of the product type
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}√ó\AgdaUnderscore{}}}.
\ifshort\else

\begin{code}

module _ {A : Type Œ± }{B : A ‚Üí Type Œ≤} where
 ‚à£_‚à£ : Œ£[ x ‚àà A ] B x ‚Üí A
 ‚à£_‚à£ = fst
 ‚à•_‚à• : (z : Œ£[ a ‚àà A ] B a) ‚Üí B ‚à£ z ‚à£
 ‚à•_‚à• = snd
\end{code}
\fi

%% -----------------------------------------------------------------------------
\subsection{Setoids}\label{setoids}
A \defn{setoid} is a pair (\ab A, \af{‚âà}) where \ab A is a type and \af{‚âà}
is an equivalence relation on \ab A. Setoids seem to have gotten a bad wrap
in some parts of the interactive theorem proving community because of the extra
overhead that their use requires. However, we feel they are ideally suited to
the task of representing the basic objects of informal mathematics (i.e., sets)
in a constructive, type-theoretic way.

A set used informally typically comes equipped with an equivalence relation manifesting
the notion of equality of elements of the set. When working informally, we
often take the equivalence for granted or view it as self-evident; rarely do we
take the time to define it explicitly. While this approach is well-suited to informal
mathematics, formalization using a machine demands that we make nearly everything
explicit, including notions of equality.

Actually, the \agdaalgebras library was first developed without setoids, relying exclusively
on the inductively defined equality type \ad{\au{}‚â°\au{}} from \am{Agda.Builtin.Equality},
along with some experimental, domain-specific types for equivalence classes, quotients, etc.
One notable consequence of this design decision was that our formalization of many
theorem required postulating function extensionality, an axiom that is not provable
in pure Martin-L√∂f type theory (MLTT). [reference needed]

In contrast, our current approach using setoids makes the equality relation
of a given type explicit.  A primary motivation for taking this approach is to make it
clear that the library is fully constructive and confined to pure Martin-L√∂f dependent
type theory (as defined, e.g., in [ref needed]). In particular, there are no appeals to
function extensionality in the present work. Finally, we are confident that the current
version of the \agdaalgebras library\footnote{[ref. with version information needed]} is
free of hidden assumptions or inconsistencies that could be used to fool the type-checker.


%% -----------------------------------------------------------------------------
\subsection{Setoid functions}
\label{setoid-functions}
In addition to the \ar{Setoid} type, much of our code employs the
standard library's \ar{Func} type which represents a function from one
setoid to another and packages such a function with a proof (called \afld{cong}) that
the function respects the underlying setoid equalities. As mentioned above, we renamed
\ar{Func} to the more visually appealing infix long arrow symbol,
\AgdaRecord{\AgdaUnderscore{}‚ü∂\AgdaUnderscore{}}, and  throughout the paper we
refer to inhabitants of this type as ``setoid functions.''

\ifshort\else
An example of a setoid function is the identity function from a setoid to itself.
We define it, along with a binary composition operation for setoid functions,
\AgdaOperator{\AgdaFunction{‚ü®‚àò‚ü©}}, as follows.

\begin{code}

ùëñùëë : {A : Setoid Œ± œÅ·µÉ} ‚Üí A ‚ü∂ A
ùëñùëë {A} = record { f = id ; cong = id }

_‚ü®‚àò‚ü©_ :  {A : Setoid Œ± œÅ·µÉ} {B : Setoid Œ≤ œÅ·µá} {C : Setoid Œ≥ œÅ·∂ú}
 ‚Üí       B ‚ü∂ C  ‚Üí  A ‚ü∂ B  ‚Üí  A ‚ü∂ C

f ‚ü®‚àò‚ü© g = record  { f = (_‚ü®$‚ü©_ f) ‚àò (_‚ü®$‚ü©_ g)
                  ; cong = (cong f) ‚àò (cong g) }
\end{code}
\fi

\paragraph*{Inverses of setoid functions}
We begin by defining an inductive type that represents the semantic concept of the \emph{image} of a function.\footnote{cf.~the \ualmodule{Overture.Func.Inverses} module of the \agdaalgebras library.}

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë© using ( _‚âà_ ; sym ) renaming ( Carrier to B )

 data Image_‚àã_ (f : ùë® ‚ü∂ ùë©) : B ‚Üí Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá) where
  eq : {b : B} ‚Üí ‚àÄ a ‚Üí b ‚âà f ‚ü®$‚ü© a ‚Üí Image f ‚àã b

\end{code}
An inhabitant of \aod{Image} \ab f \aod{‚àã} \ab b is a dependent pair \AgdaPair{a}{p},
where \AgdaTyped{a}{A} and \ab p~\as :~\ab b \af{‚âà} \ab f~\ab a is a proof that
\ab f maps \ab a to \ab b.  Since the proof that \ab b
belongs to the image of \ab f is always accompanied by a witness \AgdaTyped{a}{A}, we can
actually \emph{compute} a range-restricted right-inverse of \ab f. For convenience, we define this
inverse function and give it the name \af{Inv}.

\begin{code}

 Inv : (f : ùë® ‚ü∂ ùë©){b : B} ‚Üí Image f ‚àã b ‚Üí Carrier ùë®
 Inv _ (eq a _) = a

\end{code}
For each \ab b : \afld{B}, given a pair \AgdaPair{a}{p}~\as :~\aod{Image}~\ab f~\aod{‚àã}~\ab b witnessing the fact that \ab b belongs to the image of \ab f, the function \af{Inv} simply returns the witness \ab a, which is a preimage of \ab b under \ab f.
We can formally verify that \af{Inv} \ab f is indeed the (range-restricted) right-inverse of \ab f, as follows.

\begin{code}

 InvIsInverse ≥ : {f : ùë® ‚ü∂ ùë©}{b : B}(q : Image f ‚àã b) ‚Üí f ‚ü®$‚ü© (Inv f q) ‚âà b
 InvIsInverse ≥ (eq _ p) = sym p
\end{code}


\paragraph*{Injective and surjective setoid functions}
If \ab{f} % : \ab{ùë®} \aor{‚ü∂} \ab{ùë©}
is a setoid function from % \ab{ùë®} =
(\ab A, \af{‚âà‚ÇÄ}) to
% \ab{ùë©} =
(\ab B, \af{‚âà‚ÇÅ}), then we call \ab f \defn{injective} provided
\as{‚àÄ} (\ab{a‚ÇÄ} \ab{a‚ÇÅ} \as : \ab{A}), \ab{f} \aofld{‚ü®\$‚ü©} \ab{a‚ÇÄ} \af{‚âà‚ÇÅ} \ab{f} \aofld{‚ü®\$‚ü©} \ab{a‚ÇÅ}
implies \ab{a‚ÇÄ} \af{‚âà‚ÇÄ} \ab{a‚ÇÅ}; we call \ab{f} \defn{surjective} provided
\as{‚àÄ} (\AgdaTyped{b}{B}), \as{‚àÉ}~(\AgdaTyped{a}{A}) such that \ab{f} \aofld{‚ü®\$‚ü©} \ab{a} \af{‚âà‚ÇÅ} \ab{b}.
The \agdastdlib represents injective functions on bare types by the
type \af{Injective}, and uses this to define the \af{IsInjective} type to represent
the property of being an injective setoid function. Similarly, the type \af{IsSurjective}
represents the property of being a surjective setoid function. \af{SurjInv} represents the \emph{right-inverse} of a surjective function.
\ifshort %%% BEGIN SHORT VERSION ONLY
 We omit the straightforward definitions and proofs of these types, but \seeshort for details.
\else    %%% END SHORT VERSION ONLY
         %%% BEGIN LONG VERSION ONLY SECTION
 We reproduce the definitions and prove some of their properties
 inside the next submodule where we first set the stage by declaring two
 setoids \ab{ùë®} and \ab{ùë©}, naming their equality relations, and making some
 definitions from the standard library available.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë® using () renaming ( _‚âà_ to _‚âà‚ÇÅ_ )
 open Setoid ùë© using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ )
 open FD _‚âà‚ÇÅ_ _‚âà‚ÇÇ_

 IsInjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá)
 IsInjective f = Injective (_‚ü®$‚ü©_ f)

 IsSurjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá)
 IsSurjective F = ‚àÄ {y} ‚Üí Image F ‚àã y

 SurjInv : (f : ùë® ‚ü∂ ùë©) ‚Üí IsSurjective f ‚Üí Carrier ùë© ‚Üí Carrier ùë®
 SurjInv f fonto b = Inv f (fonto {b})

\end{code}

Proving that the composition of injective setoid functions is again injective
is simply a matter of composing the two assumed witnesses to injectivity.
Proving that surjectivity is preserved under composition is only slightly more involved.

\begin{code}

module _  {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá}{ùë™ : Setoid Œ≥ œÅ·∂ú}
          (f : ùë® ‚ü∂ ùë©)(g : ùë© ‚ü∂ ùë™) where

 ‚àò-IsInjective : IsInjective f ‚Üí IsInjective g ‚Üí IsInjective (g ‚ü®‚àò‚ü© f)
 ‚àò-IsInjective finj ginj = finj ‚àò ginj

 ‚àò-IsSurjective : IsSurjective f ‚Üí IsSurjective g ‚Üí IsSurjective (g ‚ü®‚àò‚ü© f)
 ‚àò-IsSurjective fonto gonto {y} = Goal
  where
  mp : Image g ‚àã y ‚Üí Image g ‚ü®‚àò‚ü© f ‚àã y
  mp (eq c p) = Œ∑ fonto
   where
   open Setoid ùë™ using ( trans )
   Œ∑ : Image f ‚àã c ‚Üí Image g ‚ü®‚àò‚ü© f ‚àã y
   Œ∑ (eq a q) = eq a (trans p (cong g q))

  Goal : Image g ‚ü®‚àò‚ü© f ‚àã y
  Goal = mp gonto
\end{code}
\fi      %%% END LONG VERSION ONLY SECTION

\paragraph*{Kernels of setoid functions}
The \defn{kernel} of a function \ab f~\as :~\ab A~\as{‚Üí}~\ab B (where \ab A and \ab B are bare types) is defined
informally by \{\AgdaPair{x}{y} \aod{‚àà} \ab A \aof{√ó} \ab A \as : \ab f \ab x \as{=} \ab f \ab y \}.
This can be represented in Agda in a number of ways, but for our purposes it is most
convenient to define the kernel as an inhabitant of a (unary) predicate over the square of
the function's domain, as follows.

\begin{code}

kernel : {A : Type Œ±}{B : Type Œ≤} ‚Üí Rel B œÅ ‚Üí (A ‚Üí B) ‚Üí Pred (A √ó A) œÅ
kernel _‚âà_ f (x , y) = f x ‚âà f y

\end{code}
The kernel of a \emph{setoid} function \ab f \as : \ab{ùê¥} \aor{‚ü∂} \ab{ùêµ} is \{\AgdaPair{x}{y} \as{‚àà} \ab A \aof{√ó} \ab A \as : \ab f \aofld{‚ü®\$‚ü©} \ab x \aofld{‚âà} \ab f \aofld{‚ü®\$‚ü©} \ab y\},
where \afld{\au{}‚âà\au} denotes equality in \ab{ùêµ}. This can be formalized in Agda as follows.

\begin{code}

module _ {ùê¥ : Setoid Œ± œÅ·µÉ}{ùêµ : Setoid Œ≤ œÅ·µá} where
 open Setoid ùê¥ using () renaming ( Carrier to A )

 ker : (ùê¥ ‚ü∂ ùêµ) ‚Üí Pred (A √ó A) œÅ·µá
 ker g (x , y) = g ‚ü®$‚ü© x ‚âà g ‚ü®$‚ü© y where open Setoid ùêµ using ( _‚âà_ )
\end{code}


%% -------------------------------------------------------------------------------------

\section{Types for Basic Universal Algebra}
\label{types-for-basic-universal-algebra}
In this section we develop a working vocabulary and formal types for classical,
single-sorted, set-based universal algebra.
We cover a number of important concepts, but we limit ourselves to those
concepts required in our formal proof of Birkhoff's HSP theorem.
In each case, we give a type-theoretic version of the informal definition,
followed by a formal implementation of the definition in Martin-L√∂f dependent
type theory using the Agda language.

\ifshort\else
This section is organized into the following subsections:
¬ß\ref{signatures} defines a general notion of \emph{signature} of a structure and then defines a type that represent signatures;
¬ß\ref{algebras} does the same for \emph{algebraic structures} and \emph{product algebras};
¬ß\ref{homomorphisms} defines \emph{homomorphisms}, \emph{monomorphisms}, and \emph{epimorphisms}, presents types that codify these concepts and formally verifies some of their basic properties;
¬ß¬ß\ref{subalgebras}--\ref{terms} do the same for \emph{subalgebras} and \emph{terms}, respectively.
\fi

%% -----------------------------------------------------------------------------
\subsection{Signatures}
\label{signatures}

In model theory, the \defn{signature} of a structure is a quadruple \ab{ùëÜ} = (\ab{C},
\ab{F}, \ab{R}, \ab{œÅ}) consisting of three (possibly empty) sets \ab{C}, \ab{F}, and
\ab{R}---called \emph{constant}, \emph{function}, and \emph{relation} symbols,
respectively---along with a function \ab{œÅ} : \ab{C} \as{+} \ab{F} \as{+} \ab{R}
\as{‚Üí} \ab{N} that assigns an \emph{arity} to each symbol. Often, but not always, \ab{N}
is taken to be the set of natural numbers.

As our focus here is universal algebra, we consider the restricted notion of an
\emph{algebraic signature}, that is, a signature for ``purely algebraic'' structures. Such
a signature is a pair \ab{ùëÜ} = \AgdaPair{F}{œÅ} where \ab{F} is a collection of
\defn{operation symbols} and \ab{œÅ} : \ab{F} \as{‚Üí} \ab{N} is an \defn{arity function}
which maps each operation symbol to its arity. Here, \ab{N} denotes the \emph{arity type}.
Heuristically, the arity \ab{œÅ} \ab{f} of an operation symbol \ab{f} \as{‚àà} \ab{F} may be
thought of as the number of arguments that \ab{f} takes as ``input.''

The \agdaalgebras library represents an (algebraic) signature as an
inhabitant of the following dependent pair type:

\begin{center}

\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Level}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPrimitive{lsuc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{))}\\[4pt]
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£[}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaFunction{‚àà}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{)}

\end{center}

Using special syntax for the first and second
projections---\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}} and
\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}} (resp.)---if
\ab{ùëÜ} \as{:} \af{Signature} \ab{ùìû} \ab{ùì•} is a signature, then
\aof{‚à£} \ab{ùëÜ} \aof{‚à£} denotes the set of operation symbols and \aof{‚à•} \ab{ùëÜ} \aof{‚à•} denotes the arity function.
Thus, if \ab{f} \as{:} \aof{‚à£} \ab{ùëÜ} \aof{‚à£} is an operation symbol in the
signature \ab{ùëÜ}, then \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab{f} is the arity of \ab{f}.

We need to augment the ordinary \af{Signature} type so that it supports algebras over setoid domains.
To do so, following Andreas Abel's lead, we define an operator that translates an
ordinary signature into a \defn{setoid signature}, that is, a signature over a setoid
domain (cf.~\cite{Abel:2021}). This raises a minor technical issue concerning the
dependent types involved in the definition; some readers might find the resolution of this
issue instructive, so let's discuss it briefly.
If we are given two operations \ab{f} and \ab{g}, a tuple \ab{u} \as{:} \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab{f} \as{‚Üí}
\ab{A} of arguments for \ab{f}, and a tuple \ab{v} \as{:} \aof{‚à•} \ab{ùëÜ}
\aof{‚à•} \ab{g} \as{‚Üí} \ab{A} of arguments for \ab{g}, and if we know that \ab f is identically equal to
\ab{g}---that is, \ab{f} \aod{‚â°} \ab{g} (intensionally)---then we should be able to
check whether \ab u and \ab v are point-wise equal.  Technically, though, \ab{u} and
\ab{v} inhabit different types, so, in order to compare them, we must convince Agda
that \ab u and \ab v inhabit the same type. Of course, this requires an appeal to the
hypothesis \ab f \aod{‚â°} \ab g, as we see in the definition of \af{EqArgs} below (adapted
from Andreas Abel's development~\cite{Abel:2021}), which neatly resolves this minor
technicality.

\begin{code}

EqArgs :  {ùëÜ : Signature ùìû ùì•}{Œæ : Setoid Œ± œÅ·µÉ}
 ‚Üí        ‚àÄ {f g} ‚Üí f ‚â° g ‚Üí (‚à• ùëÜ ‚à• f ‚Üí Carrier Œæ) ‚Üí (‚à• ùëÜ ‚à• g ‚Üí Carrier Œæ) ‚Üí Type (ùì• ‚äî œÅ·µÉ)

EqArgs {Œæ = Œæ} ‚â°.refl u v = ‚àÄ i ‚Üí u i ‚âà v i where open Setoid Œæ using ( _‚âà_ )

\end{code}

Finally, we are ready to define an operator which
translates an ordinary (algebraic) signature into a signature of algebras over setoids.
We denote this operator by \aof{‚ü®\AgdaUnderscore{}‚ü©} and define it as follows.

\begin{code}

‚ü®_‚ü© : Signature ùìû ùì• ‚Üí Setoid Œ± œÅ·µÉ ‚Üí Setoid _ _

Carrier  (‚ü® ùëÜ ‚ü© Œæ)                = Œ£[ f ‚àà ‚à£ ùëÜ ‚à£ ] (‚à• ùëÜ ‚à• f ‚Üí Œæ .Carrier)
_‚âàÀ¢_     (‚ü® ùëÜ ‚ü© Œæ)(f , u)(g , v)  = Œ£[ eqv ‚àà f ‚â° g ] EqArgs{Œæ = Œæ} eqv u v

refl·µâ   (isEquivalence (‚ü® ùëÜ ‚ü© Œæ))                           = ‚â°.refl , Œª i ‚Üí reflÀ¢   Œæ
sym·µâ    (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)              = ‚â°.refl , Œª i ‚Üí symÀ¢    Œæ (g i)
trans·µâ  (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)(‚â°.refl , h)  = ‚â°.refl , Œª i ‚Üí transÀ¢  Œæ (g i) (h i)
\end{code}

%% -----------------------------------------------------------------------------
\subsection{Algebras}\label{algebras}
Informally, an \defn{algebraic structure in the signature} \ab{ùëÜ} = (\ab{F}, \ab{œÅ}), or
\ab{ùëÜ}-\defn{algebra}, is denoted by \ab{ùë®} = (\ab{A}, \ab{F·¥¨}) and consists of
\begin{itemize}
\item a \emph{nonempty} set (or type) \ab A, called the \defn{domain} (or \defn{carrier} or
\defn{universe}) of the algebra;
\item a collection \ab{F·¥¨} :=
  \{ \ab{f·¥¨} \as{‚à£} \ab f \as{‚àà} \ab F, \ab{f·¥¨} \as :
    (\ab{œÅ} \ab f \as{‚Üí} \ab A) \as{‚Üí} \ab A \} of \defn{operations} on \ab{A};
\item a (potentially empty) collection of \defn{identities} satisfied by elements and
operations of \ab{ùë®}.
\end{itemize}
The \agdaalgebras library represents algebras as inhabitants of a record type with two
fields:\footnote{We postpone introducing identities until~¬ß\ref{equational-logic}.}
\begin{itemize}
\item \afld{Domain}, representing the domain of the algebra;
\item \afld{Interp}, representing the \emph{interpretation} in the algebra of each
operation symbol in \ab{ùëÜ}.
\end{itemize}
The \afld{Domain} is a setoid whose \afld{Carrier} denotes the domain of the algebra and
whose equivalence relation denotes equality of elements of the domain.

Here is the definition of the \ar{Algebra} type followed by an explanation of how the
standard library's \ar{Func} type is used to represent the interpretation of operation
symbols in an algebra.

\begin{code}

record Algebra Œ± œÅ : Type (ùìû ‚äî ùì• ‚äî lsuc (Œ± ‚äî œÅ)) where
 field  Domain  : Setoid Œ± œÅ
        Interp  : ‚ü® ùëÜ ‚ü© Domain ‚ü∂ Domain

\end{code}
Recall, we renamed Agda's \ar{Func} type, preferring instead the long-arrow symbol
\AgdaRecord{‚ü∂}, so the \afld{Interp} field has type \ar{Func} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©}
\afld{Domain}) \afld{Domain}, a record type with two fields:
\begin{itemize}
\item a function  \ab{f} \as : \afld{Carrier} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©} \afld{Domain})
  \as{‚Üí} \afld{Carrier} \afld{Domain} representing the operation;
\item a proof \af{cong} \as : \ab f \aof{Preserves \au{}‚âà‚ÇÅ\au{} ‚ü∂ \au{}‚âà‚ÇÇ\au{}} that the
operation preserves the relevant setoid equalities.
\end{itemize}
Thus, for each operation symbol in the signature \ab{ùëÜ}, we have a setoid function
\ab f---with domain a power of \afld{Domain} and codomain \afld{Domain}---along with
a proof that this function respects the setoid equalities.  The latter means that the
operation \ab{f} is accompanied by a proof of the following: ‚àÄ \ab u \ab v in
\afld{Carrier} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©} \afld{Domain}), if \ab u \af{‚âà‚ÇÅ} \ab v, then \ab{f}
\aofld{‚ü®\$‚ü©} \ab{u} \af{‚âà‚ÇÇ} \ab{f} \aofld{‚ü®\$‚ü©} \ab{v}.

In the \agdaalgebras library is defined some syntactic sugar that helps to make our
formalizations easier to read and comprehend.
The following are three examples of such syntax that we use below: if \ab{ùë®} is an algebra, then
\begin{itemize}
\item \aof{ùîª[ \ab{ùë®} ]} denotes the setoid \afld{Domain} \ab{ùë®},
\item \aof{ùïå[ \ab{ùë®} ]} is the underlying carrier of the algebra \ab{ùë®}, and
\item \ab f \aof{ÃÇ} \ab{ùë®} denotes the interpretation in the algebra \ab{ùë®} of the operation symbol \ab f.
\end{itemize}
\ifshort %%% BEGIN SHORT VERSION ONLY
 We omit the straightforward formal definitions of these types.
\else    %%% END SHORT VERSION ONLY
         %%% BEGIN LONG VERSION ONLY SECTION
\begin{code}
open Algebra
ùîª[_] : Algebra Œ± œÅ·µÉ ‚Üí  Setoid Œ± œÅ·µÉ
ùîª[ ùë® ] = Domain ùë®
ùïå[_] : Algebra Œ± œÅ·µÉ ‚Üí  Type Œ±
ùïå[ ùë® ] = Carrier (Domain ùë®)
_ÃÇ_ : (f : ‚à£ ùëÜ ‚à£)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí (‚à• ùëÜ ‚à• f  ‚Üí  ùïå[ ùë® ]) ‚Üí ùïå[ ùë® ]
f ÃÇ ùë® = Œª a ‚Üí (Interp ùë®) ‚ü®$‚ü© (f , a)
\end{code}
\fi

%% -----------------------------------------------------------------------------
\paragraph*{Universe levels of algebra types}
The hierarchy of type universes in Agda is structured as follows:
\ap{Type} \ab{‚Ñì} : \ap{Type} (\ap{lsuc} \ab{‚Ñì}), \ap{Type} (\ap{lsuc} \ab{‚Ñì}) : \ap{Type}
(\ap{lsuc} (\ap{lsuc} \ab{‚Ñì})), ‚Ä¶. This means that \ap{Type} \ab{‚Ñì} has type \ap{Type}
(\ap{lsuc} \ab{‚Ñì}), etc.  However, this does \emph{not} imply that \ap{Type} \ab{‚Ñì} :
\ap{Type} (\ap{lsuc} (\ap{lsuc} \ab{‚Ñì})). In other words, Agda's universe hierarchy is
\emph{noncumulative}.
\ifshort
An
\else
This can be advantageous as it becomes possible to treat universe
levels more generally and precisely. On the other hand, an
\fi
unfortunate side-effect of this noncumulativity is that it can sometimes seem unreasonably
difficult to convince Agda that a program or proof is correct.
\ifshort\else
This aspect of the language was one of the few stumbling
blocks we encountered while learning how to use Agda for formalizing universal algebra in
type theory. Although some may consider this to be one of the least interesting and most
technical aspects of this paper, others might find the presentation more helpful if we
resist the urge to gloss over these technicalities.
\fi
Therefore, it seems worthwhile to explain how we make use
of the general universe lifting and lowering functions, available in the \agdastdlib, to
develop domain-specific tools for dealing with Agda's noncumulative universe hierarchy.

\ifshort\else
Let us be more concrete about what is at issue by considering a typical example. Agda
frequently encounters problems during the type-checking process and responds by printing a
message like the following.
{\color{red}{\small
\begin{verbatim}
  HSP.lagda:498,20-23
  Œ± != ùìû ‚äî ùì• ‚äî (lsuc Œ±) when checking that... has type...
\end{verbatim}}}
\noindent Here Agda informs us that it encountered universe level \ab{Œ±} on line 498 of
the HSP module, where it was expecting level \ab{ùìû}~\aop{‚äî}~\ab{ùì•}~\aop{‚äî}~(\ap{lsuc}
\ab{Œ±}). In this case, we tried to use an algebra inhabiting the type \ar{Algebra}
\ab{Œ±} \ab{œÅ·µÉ} whereas Agda expected an inhabitant of the type \ar{Algebra} (\ab{ùìû}
\aop{‚äî} \ab{ùì•} \aop{‚äî} (\ap{lsuc} \ab{Œ±})) \ab{œÅ·µÉ}.
\fi
To resolve such problems, we use the \AgdaRecord{Lift} record type of the \agdastdlib,
which takes a type inhabiting a particular universe and embeds it into a higher universe.
Specializing the \ar{Lift} type to our domain of interest, the \agdaalgebras library
defines a function called \af{Lift-Alg}%
\ifshort
, whose interface is the following.
\else
.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; refl ; sym ; trans ) ; open Level
 Lift-AlgÀ° : (‚Ñì : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì) œÅ·µÉ
 Domain (Lift-AlgÀ° ‚Ñì) =
  record  { Carrier        = Lift ‚Ñì ùïå[ ùë® ]
          ; _‚âà_            = Œª x y ‚Üí lower x ‚âà lower y
          ; isEquivalence  = record { refl = refl ; sym = sym ; trans = trans }}

 Interp (Lift-AlgÀ° ‚Ñì) ‚ü®$‚ü© (f , la) = lift ((f ÃÇ ùë®) (lower ‚àò la))
 cong (Interp (Lift-AlgÀ° ‚Ñì)) (‚â°.refl , lab) = cong (Interp ùë®) ((‚â°.refl , lab))

 Lift-Alg ≥ : (‚Ñì : Level) ‚Üí Algebra Œ± (œÅ·µÉ ‚äî ‚Ñì)
 Domain (Lift-Alg ≥ ‚Ñì) =
  record  { Carrier        = ùïå[ ùë® ]
          ; _‚âà_            = Œª x y ‚Üí Lift ‚Ñì (x ‚âà y)
          ; isEquivalence  = record  { refl  = lift refl
                                     ; sym   = lift ‚àò sym ‚àò lower
                                     ; trans = Œª x y ‚Üí lift (trans (lower x)(lower y)) }}

 Interp (Lift-Alg ≥ ‚Ñì ) ‚ü®$‚ü© (f , la) = (f ÃÇ ùë®) la
 cong (Interp (Lift-Alg ≥ ‚Ñì))(‚â°.refl , lab) = lift(cong(Interp ùë®)(‚â°.refl , Œª i ‚Üí lower (lab i)))
\end{code}
\fi

\begin{code}

Lift-Alg : (ùë® : Algebra Œ± œÅ·µÉ)(‚Ñì‚ÇÄ ‚Ñì‚ÇÅ : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì‚ÇÄ) (œÅ·µÉ ‚äî ‚Ñì‚ÇÅ)
\end{code}
\ifshort
\vskip2mm
\else
\begin{code}
Lift-Alg ùë® ‚Ñì‚ÇÄ ‚Ñì‚ÇÅ = Lift-Alg ≥ (Lift-AlgÀ° ùë® ‚Ñì‚ÇÄ) ‚Ñì‚ÇÅ

\end{code}
\fi
\noindent To see why the \af{Lift-Alg} function is useful, recall that our definition of the algebra
record type uses two universe level parameters corresponding to those of the algebra's
underlying domain setoid. Concretely, an algebra of type \ar{Algebra} \ab{Œ±} \ab{œÅ·µÉ} has a
\afld{Domain} of type \ar{Setoid} \ab{Œ±} \ab{œÅ·µÉ}. This packages a ``carrier set''
(\afld{Carrier}), inhabiting \ap{Type} \ab{Œ±}, with an equality on \afld{Carrier} of type
\af{Rel} \afld{Carrier} \ab{œÅ·µÉ}. Now, examining the \af{Lift-Alg} function, we see that it
takes an algebra---one whose carrier inhabits \ap{Type \ab{Œ±}} with equality
of type \af{Rel} \afld{Carrier} \ab{œÅ·µÉ}---and constructs a new algebra whose carrier
inhabits \ap{Type} (\ab{Œ±} \ap{‚äî} \ab{‚Ñì‚ÇÄ}) with equality of type \af{Rel} \afld{Carrier}
(\ab{œÅ·µÉ} \ap{‚äî} \ab{‚Ñì‚ÇÅ}). This lifting operation would be worthless without a useful
semantic connection between the input and output algebras.
Fortunately, \af{Lift-Alg} is an \defn{algebraic invariant}, which is
to say that the lifted algebra has the same algebraic properties as the original algebra,
a fact we will codify later in a type called \af{Lift-‚âÖ}.

\paragraph*{Product Algebras}
We give an informal description of the \defn{product} of a family of \ab{ùëÜ}-algebras and
then define a type which formalizes this notion.
Let \ab{Œπ} be a universe and \ab I~:~\ap{Type}~\ab{Œπ} a type (the ``indexing type'').
Then the dependent function type \ab{ùíú}~:~\ab
I~\as{‚Üí}~\ab{Algebra}~\ab{Œ±}~\ab{œÅ·µÉ} represents an \defn{indexed family of algebras}.
Denote by \af{‚®Ö}~\ab{ùíú} the \defn{product of algebras} in \ab{ùíú} (or \defn{product
algebra}), by which we mean the algebra whose domain is the Cartesian product \af{Œ†}~\ab
i~Íûâ~\ab I~\af{,}~\aof{ùîª[~\ab{ùíú}~\ab i~]} of the domains of the algebras in \ab{ùíú}, and
whose operations are those arising by point-wise interpretation in the obvious way: if
\ab{f} is a \ab J-ary operation symbol and if
\ab a~:~\af{Œ†}~\ab i~Íûâ~\ab I~\af{,}~\ab J~\as{‚Üí}~\aof{ùîª[~\ab{ùíú}~\ab i~]} is, for each
\ab i~:~\ab I, a \ab J-tuple of elements of the domain \aof{ùîª[~\ab{ùíú}~\ab i~]}, then
we define the interpretation of \ab f in \af{‚®Ö}~\ab{ùíú} by\\[-2mm]

(\ab{f}~\af{ÃÇ}~\af{‚®Ö}~\ab{ùíú}) \ab a := \as{Œª}~(\ab i~:~\ab I)~\as{‚Üí}
(\ab{f}~\af{ÃÇ}~\ab{ùíú}~\ab i)(\ab{a}~\ab i).

In the \agdaalgebras library we define a function called \af{‚®Ö} which formalizes the
foregoing notion of \defn{product algebra} in Martin-L√∂f type theory.
\ifshort
Here we merely display this function's interface, but \seeshort for the complete definition.

\else
\fi
\begin{code}

module _ {Œπ : Level}{I : Type Œπ } where
 ‚®Ö : (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) ‚Üí Algebra (Œ± ‚äî Œπ) (œÅ·µÉ ‚äî Œπ)
\end{code}
\ifshort\else
\begin{code}
 Domain (‚®Ö ùíú) =
  record { Carrier = ‚àÄ i ‚Üí ùïå[ ùíú i ]
         ; _‚âà_ = Œª a b ‚Üí ‚àÄ i ‚Üí (_‚âàÀ¢_ ùîª[ ùíú i ]) (a i)(b i)
         ; isEquivalence =
            record  { refl   = Œª i ‚Üí      refl·µâ   (isEquivalence ùîª[ ùíú i ])
                    ; sym    = Œª x i ‚Üí    sym·µâ    (isEquivalence ùîª[ ùíú i ])(x i)
                    ; trans  = Œª x y i ‚Üí  trans·µâ  (isEquivalence ùîª[ ùíú i ])(x i)(y i) }}
 Interp (‚®Ö ùíú) ‚ü®$‚ü© (f , a) = Œª i ‚Üí (f ÃÇ (ùíú i)) (flip a i)
 cong (Interp (‚®Ö ùíú)) (‚â°.refl , f=g ) = Œª i ‚Üí cong (Interp (ùíú i)) (‚â°.refl , flip f=g i )
\end{code}
\fi




%% -------------------------------------------------------------------------------------
\subsection{Homomorphisms}\label{homomorphisms}
Suppose \ab{ùë®} and \ab{ùë©} are \ab{ùëÜ}-algebras. A \defn{homomorphism} (or ``hom'') from
\ab{ùë®} to \ab{ùë©} is a setoid function \ab{h}~:~\aof{ùîª[~\ab{ùë®}~]} \as{‚Üí} \aof{ùîª[~\ab{ùë©}~]}
that is \defn{compatible} with all basic operations; that is, for
every operation symbol \ab{f} : \af{‚à£~\ab{ùëÜ}~‚à£} and all tuples
\ab{a} : \af{‚à•~\ab{ùëÜ}~‚à•}~\ab{f} \as{‚Üí} \aof{ùîª[~\ab{ùë®}~]}, the following
equality holds: \ab{h} \aofld{‚ü®\$‚ü©} (\ab{f}~\af{ÃÇ}~\ab{ùë®}) \ab{a} \af{‚âà}
(\ab{f}~\af{ÃÇ}~\ab{ùë©}) \as{Œª} \ab{x} \as{‚Üí} \ab{h} \aofld{‚ü®\$‚ü©} (\ab{a} \ab{x}).
To formalize this concept in Agda, we first define the type \af{compatible-map-op}
representing the assertion that a given setoid function
\ab{h}~:~\aof{ùîª[~\ab{ùë®}~]} \as{‚Üí} \aof{ùîª[~\ab{ùë©}~]} commutes with a given
basic operation \ab{f}. Then we generalize over operation symbols in the definition
of \af{compatible-map}, the type of compatible maps from (the domain of) \ab{ùê¥} to
(the domain of) \ab{ùë©}.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where
 compatible-map-op : (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) ‚Üí ‚à£ ùëÜ ‚à£ ‚Üí Type _
 compatible-map-op h f = ‚àÄ {a} ‚Üí h ‚ü®$‚ü© (f ÃÇ ùë®) a ‚âà (f ÃÇ ùë©) Œª x ‚Üí h ‚ü®$‚ü© (a x)
  where open Setoid ùîª[ ùë© ] using ( _‚âà_ )

 compatible-map : (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) ‚Üí Type _
 compatible-map h = ‚àÄ {f} ‚Üí compatible-map-op h f

\end{code}
Using these we define a record type \ar{IsHom} representing the property of being
a homomorphism, and finally the type \af{hom} of homomorphisms from \ab{ùë®} to \ab{ùêµ}.

\begin{code}

 record IsHom (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µá) where
  constructor mkhom ; field compatible : compatible-map h

 hom : Type _
 hom = Œ£ (ùîª[¬†ùë® ] ‚ü∂ ùîª[ ùë© ]) IsHom

\end{code}
Thus, an inhabitant of \af{hom} is a pair (\ab h , \ab p) whose first component is
a setoid function from the domain of \ab{ùë®} to that of \ab{ùë©} and whose second component
is \ab p : \ar{IsHom} \ab h, a proof that \ab h is a homomorphism.

A \defn{monomorphism} (resp. \defn{epimorphism}) is an injective (resp. surjective)
homomorphism.  The \agdaalgebras library defines types \ar{IsMon} and \ar{IsEpi} to
represent these properties, as well as \af{mon} and \af{epi}, the types of monomorphisms
and epimorphisms, respectively.
\ifshort %%% BEGIN SHORT VERSION ONLY
\else    %%% BEGIN LONG VERSION ONLY

\begin{code}

 record IsMon (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá) where
  field  isHom : IsHom h
         isInjective : IsInjective h

  HomReduct : hom
  HomReduct = h , isHom

 mon : Type _
 mon = Œ£ (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) IsMon

\end{code}
As with \af{hom}, the type \af{mon} is a dependent product type; each inhabitant is a pair consisting of a setoid function, say, \ab h, along with a proof that \ab h is a monomorphism.

\begin{code}

 record IsEpi (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî Œ≤ ‚äî œÅ·µá) where
  field  isHom : IsHom h
         isSurjective : IsSurjective h

  HomReduct : hom
  HomReduct = h , isHom

 epi : Type _
 epi = Œ£ (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) IsEpi
\end{code}

Here are two mere utilities that are useful for translating between types.

\begin{code}
open IsHom ; open IsMon ; open IsEpi

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where

 mon‚Üíintohom : mon ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£
 mon‚Üíintohom (hh , hhM) = (hh , isHom hhM) , isInjective hhM

 epi‚Üíontohom : epi ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsSurjective ‚à£ h ‚à£
 epi‚Üíontohom (hh , hhE) = (hh , isHom hhE) , isSurjective hhE
\end{code}

\paragraph*{Composition of homomorphisms}
\fi      %%% END LONG VERSION ONLY SECTION
The composition of homomorphisms is again a homomorphism, and similarly for epimorphisms (and monomorphisms).
\ifshort
The proofs of these facts are straightforward so we omit them, but give them names,
\af{‚àò-hom} and \af{‚àò-epi}, so we can refer to them below.
\else

\begin{code}

module _  {ùë® : Algebra Œ± œÅ·µÉ} {ùë© : Algebra Œ≤ œÅ·µá} {ùë™ : Algebra Œ≥ œÅ·∂ú}
          {g : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]}{h : ùîª[ ùë© ] ‚ü∂ ùîª[ ùë™ ]} where

  open Setoid ùîª[ ùë™ ] using ( trans )

  ‚àò-is-hom : IsHom ùë® ùë© g ‚Üí IsHom ùë© ùë™ h ‚Üí IsHom ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-hom ghom hhom = mkhom c
   where
   c : compatible-map ùë® ùë™ (h ‚ü®‚àò‚ü© g)
   c = trans (cong h (compatible ghom)) (compatible hhom)

  ‚àò-is-epi : IsEpi ùë® ùë© g ‚Üí IsEpi ùë© ùë™ h ‚Üí IsEpi ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-epi gE hE = record  { isHom = ‚àò-is-hom (isHom gE) (isHom hE)
                           ; isSurjective = ‚àò-IsSurjective g h (isSurjective gE) (isSurjective hE) }

module _ {ùë® : Algebra Œ± œÅ·µÉ} {ùë© : Algebra Œ≤ œÅ·µá} {ùë™ : Algebra Œ≥ œÅ·∂ú} where

  ‚àò-hom : hom ùë® ùë© ‚Üí hom ùë© ùë™  ‚Üí hom ùë® ùë™
  ‚àò-hom (h , hhom) (g , ghom) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-hom hhom ghom

  ‚àò-epi : epi ùë® ùë© ‚Üí epi ùë© ùë™  ‚Üí epi ùë® ùë™
  ‚àò-epi (h , hepi) (g , gepi) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-epi hepi gepi
\end{code}

\paragraph*{Universe lifting of homomorphisms}
Here we define the identity homomorphism for setoid algebras. Then we prove that the
operations of lifting and lowering of a setoid algebra are homomorphisms.

\begin{code}

ùíæùíπ : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí hom ùë® ùë®
ùíæùíπ {ùë® = ùë®} = ùëñùëë , mkhom (reflexive ‚â°.refl) where open Setoid ( Domain ùë® ) using ( reflexive )

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 open Setoid ùîª[ ùë® ]              using ( reflexive )  renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; refl to refl‚ÇÅ )
 open Setoid ùîª[ Lift-AlgÀ° ùë® ‚Ñì ]  using ()             renaming ( _‚âà_ to _‚âàÀ°_ ; refl to reflÀ°)
 open Setoid ùîª[ Lift-Alg ≥ ùë® ‚Ñì ]  using ()             renaming ( _‚âà_ to _‚âà ≥_ ; refl to refl ≥)
 open Level

 ToLiftÀ° : hom ùë® (Lift-AlgÀ° ùë® ‚Ñì)
 ToLiftÀ° = record { f = lift ; cong = id } , mkhom (reflexive ‚â°.refl)

 FromLiftÀ° : hom (Lift-AlgÀ° ùë® ‚Ñì) ùë®
 FromLiftÀ° = record { f = lower ; cong = id } , mkhom reflÀ°

 ToFromLiftÀ° : ‚àÄ b ‚Üí  ‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© b) ‚âàÀ° b
 ToFromLiftÀ° b = refl‚ÇÅ

 FromToLiftÀ° : ‚àÄ a ‚Üí ‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© a) ‚âà‚ÇÅ a
 FromToLiftÀ° a = refl‚ÇÅ

 ToLift ≥ : hom ùë® (Lift-Alg ≥ ùë® ‚Ñì)
 ToLift ≥ = record { f = id ; cong = lift } , mkhom (lift (reflexive ‚â°.refl))

 FromLift ≥ : hom (Lift-Alg ≥ ùë® ‚Ñì) ùë®
 FromLift ≥ = record { f = id ; cong = lower } , mkhom reflÀ°

 ToFromLift ≥ : ‚àÄ b ‚Üí ‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© b) ‚âà ≥ b
 ToFromLift ≥ b = lift refl‚ÇÅ

 FromToLift ≥ : ‚àÄ a ‚Üí ‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© a) ‚âà‚ÇÅ a
 FromToLift ≥ a = refl‚ÇÅ


module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì r : Level} where
 open  Setoid ùîª[ ùë® ]               using ( refl )
 open  Setoid ùîª[ Lift-Alg ùë® ‚Ñì r ]  using ( _‚âà_ )
 open  Level

 ToLift : hom ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift = ‚àò-hom ToLiftÀ° ToLift ≥

 FromLift : hom (Lift-Alg ùë® ‚Ñì r) ùë®
 FromLift = ‚àò-hom FromLift ≥ FromLiftÀ°

 ToFromLift : ‚àÄ b ‚Üí ‚à£ ToLift ‚à£ ‚ü®$‚ü© (‚à£ FromLift ‚à£ ‚ü®$‚ü© b) ‚âà b
 ToFromLift b = lift refl

 ToLift-epi : epi ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift-epi = ‚à£ ToLift ‚à£ ,  record { isHom = ‚à• ToLift ‚à•
                            ; isSurjective = Œª {y} ‚Üí eq (‚à£ FromLift ‚à£ ‚ü®$‚ü© y) (ToFromLift y) }
\end{code}

\paragraph*{Homomorphisms of product algebras}
Suppose we have an algebra \ab{ùë®}, a type \ab I : \ap{Type} \ab{ùìò}, and a family \ab{‚Ñ¨} :
\ab I \as{‚Üí} \ar{Algebra} \ab{Œ≤} \ab{œÅ·µá} of algebras.
We sometimes refer to the inhabitants of \ab{I} as \emph{indices}, and call \ab{‚Ñ¨} an
\defn{indexed family of algebras}. If in addition we have a family \ab{ùíΩ} : (\ab i : \ab
I) ‚Üí \af{hom} \ab{ùë®} (\ab{‚Ñ¨} \ab i) of homomorphisms, then we can construct a homomorphism
from \ab{ùë®} to the product \af{‚®Ö} \ab{‚Ñ¨} in the natural way.  We codify the latter in
dependent type theory as follows.

\begin{code}

module _ {Œπ : Level}{I : Type Œπ}{ùë® : Algebra Œ± œÅ·µÉ}(‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá)  where
 ‚®Ö-hom-co : (‚àÄ(i : I) ‚Üí hom ùë® (‚Ñ¨ i)) ‚Üí hom ùë® (‚®Ö ‚Ñ¨)
 ‚®Ö-hom-co ùíΩ = h , hhom
  where
  h : ùîª[ ùë® ] ‚ü∂ ùîª[ ‚®Ö ‚Ñ¨ ]
  h ‚ü®$‚ü© a = Œª i ‚Üí ‚à£ ùíΩ i ‚à£ ‚ü®$‚ü© a
  cong h xy i = cong ‚à£ ùíΩ i ‚à£ xy
  hhom : IsHom ùë® (‚®Ö ‚Ñ¨) h
  compatible hhom = Œª i ‚Üí compatible ‚à• ùíΩ i ‚à•
\end{code}

\paragraph*{Factorization of homomorphisms}
\fi      %%% END LONG VERSION ONLY SECTION
Another basic fact about homomorphisms that we formalize in the \agdaalgebras library
(as the type \af{HomFactor}) is the following factorization theorem: if \ab g : \af{hom}
\ab{ùë®} \ab{ùë©}, \ab h : \af{hom} \ab{ùë®} \ab{ùë™}, \ab h is surjective, and \af{ker} \ab h
\aof{‚äÜ} \af{ker} \ab g, then there exists \ab{œÜ} : \af{hom} \ab{ùë™} \ab{ùë©} such that \ab g
= \ab{œÜ} \aof{‚àò} \ab h.
\ifshort\else

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá){ùë™ : Algebra Œ≥ œÅ·∂ú}
         (gh : hom ùë® ùë©)(hh : hom ùë® ùë™) where
 open Setoid ùîª[ ùë© ] using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ )
 open Setoid ùîª[ ùë™ ] using () renaming ( _‚âà_ to _‚âà‚ÇÉ_ )
 private gfunc = ‚à£ gh ‚à£ ; g = _‚ü®$‚ü©_ gfunc ; hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc

 HomFactor :  kernel _‚âà‚ÇÉ_ h ‚äÜ kernel _‚âà‚ÇÇ_ g
  ‚Üí           IsSurjective hfunc
  ‚Üí           Œ£[ œÜ ‚àà hom ùë™ ùë© ] ‚àÄ a ‚Üí g a ‚âà‚ÇÇ ‚à£ œÜ ‚à£ ‚ü®$‚ü© h a
 HomFactor Khg hE = (œÜmap , œÜhom) , gœÜh
  where
  kerpres : ‚àÄ a‚ÇÄ a‚ÇÅ ‚Üí h a‚ÇÄ ‚âà‚ÇÉ h a‚ÇÅ ‚Üí g a‚ÇÄ ‚âà‚ÇÇ g a‚ÇÅ
  kerpres a‚ÇÄ a‚ÇÅ hyp = Khg hyp

  h‚Åª¬π : ùïå[ ùë™ ] ‚Üí ùïå[ ùë® ]
  h‚Åª¬π = SurjInv hfunc hE

  Œ∑ : ‚àÄ {c} ‚Üí h (h‚Åª¬π c) ‚âà‚ÇÉ c
  Œ∑ = InvIsInverse ≥ hE

  open Setoid ùîª[ ùë™ ] using ( sym ; trans )
  Œ∂ : ‚àÄ{x y} ‚Üí x ‚âà‚ÇÉ y ‚Üí h (h‚Åª¬π x) ‚âà‚ÇÉ h (h‚Åª¬π y)
  Œ∂ xy = trans Œ∑ (trans xy (sym Œ∑))

  œÜmap : ùîª[ ùë™ ] ‚ü∂ ùîª[ ùë© ]
  _‚ü®$‚ü©_ œÜmap = g ‚àò h‚Åª¬π
  cong œÜmap = Khg ‚àò Œ∂

  open _‚ü∂_ œÜmap using () renaming (cong to œÜcong)

  gœÜh : (a : ùïå[ ùë® ]) ‚Üí g a ‚âà‚ÇÇ œÜmap ‚ü®$‚ü© h a
  gœÜh a = Khg (sym Œ∑)

  œÜcomp : compatible-map ùë™ ùë© œÜmap
  œÜcomp {f}{c} =
   begin
    œÜmap ‚ü®$‚ü©  (f ÃÇ ùë™)                   c       ‚âàÀò‚ü®  œÜcong (cong (Interp ùë™) (‚â°.refl , Œª _ ‚Üí Œ∑))  ‚ü©
    g(h‚Åª¬π(    (f ÃÇ ùë™)  (h ‚àò    h‚Åª¬π  ‚àò  c  )))   ‚âàÀò‚ü®  œÜcong (compatible ‚à• hh ‚à•)                   ‚ü©
    g(h‚Åª¬π(h(  (f ÃÇ ùë®)  (       h‚Åª¬π  ‚àò  c  ))))  ‚âàÀò‚ü®  gœÜh ((f ÃÇ ùë®)(h‚Åª¬π ‚àò c))                      ‚ü©
    g(        (f ÃÇ ùë®)  (       h‚Åª¬π  ‚àò  c  ))    ‚âà‚ü®   compatible ‚à• gh ‚à•                           ‚ü©
              (f ÃÇ ùë©)  (g ‚àò (  h‚Åª¬π  ‚àò  c  ))    ‚àé where open SetoidReasoning ùîª[ ùë© ]

  œÜhom : IsHom ùë™ ùë© œÜmap
  compatible œÜhom = œÜcomp
\end{code}
\paragraph*{Isomorphisms}
\fi      %%% END LONG VERSION ONLY SECTION

Two structures are \defn{isomorphic} provided there are homomorphisms from each to the
other that compose to the identity. In the \agdaalgebras library we codify this notion as
well as some of its obvious consequences, as a record type called \ar{\au{}‚âÖ\au{}}.
\ifshort
Here we display only the essential part of the defition, but \seemedium.
\else
Note that the definition, shown below, includes a proof of the fact that the maps \afld{to} and
\afld{from} are bijective, which makes this fact more accessible.
\fi
\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) (ùë© : Algebra Œ≤ œÅ·µá) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ )
 open Setoid ùîª[ ùë© ] using () renaming ( _‚âà_ to _‚âà·¥Æ_ )

 record _‚âÖ_ : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá ) where
  constructor  mkiso
  field        to : hom ùë® ùë©
               from : hom ùë© ùë®
               to‚àºfrom : ‚àÄ b ‚Üí ‚à£ to ‚à£    ‚ü®$‚ü© (‚à£ from ‚à£  ‚ü®$‚ü© b)  ‚âà·¥Æ b
               from‚àºto : ‚àÄ a ‚Üí ‚à£ from ‚à£  ‚ü®$‚ü© (‚à£ to ‚à£    ‚ü®$‚ü© a)  ‚âà a

\end{code}
\ifshort\else    %%% BEGIN LONG VERSION ONLY
\begin{code}
  toIsSurjective : IsSurjective ‚à£ to ‚à£
  toIsSurjective {y} = eq (‚à£ from ‚à£ ‚ü®$‚ü© y) (sym (to‚àºfrom y))
   where open Setoid ùîª[ ùë© ] using ( sym )

  toIsInjective : IsInjective ‚à£ to ‚à£
  toIsInjective {x}{y} xy = trans (sym (from‚àºto x)) (trans Œæ (from‚àºto y))
   where
   open Setoid ùîª[ ùë® ] using ( sym ; trans )
   Œæ : ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© x) ‚âà ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© y)
   Œæ = cong ‚à£ from ‚à£ xy

  fromIsSurjective : IsSurjective ‚à£ from ‚à£
  fromIsSurjective {x} = eq (‚à£ to ‚à£ ‚ü®$‚ü© x) (sym (from‚àºto x))
   where open Setoid ùîª[ ùë® ] using ( sym )

  fromIsInjective : IsInjective ‚à£ from ‚à£
  fromIsInjective {x}{y} xy = trans (sym (to‚àºfrom x)) (trans Œæ (to‚àºfrom y))
   where
   open Setoid ùîª[ ùë© ] using ( sym ; trans )
   Œæ : ‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© x) ‚âà·¥Æ ‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© y)
   Œæ = cong ‚à£ to ‚à£ xy

open _‚âÖ_

‚âÖ-refl : Reflexive (_‚âÖ_ {Œ±}{œÅ·µÉ})
‚âÖ-refl {Œ±}{œÅ·µÉ}{ùë®} = mkiso ùíæùíπ ùíæùíπ (Œª b ‚Üí refl) Œª a ‚Üí refl where open Setoid ùîª[ ùë® ] using ( refl )
‚âÖ-sym : Sym (_‚âÖ_{Œ≤}{œÅ·µá}) (_‚âÖ_{Œ±}{œÅ·µÉ})
‚âÖ-sym œÜ = mkiso (from œÜ) (to œÜ) (from‚àºto œÜ) (to‚àºfrom œÜ)

‚âÖ-trans : Trans (_‚âÖ_ {Œ±}{œÅ·µÉ}) (_‚âÖ_{Œ≤}{œÅ·µá}) (_‚âÖ_{Œ±}{œÅ·µÉ}{Œ≥}{œÅ·∂ú})
‚âÖ-trans {œÅ·∂ú = œÅ·∂ú}{ùë®}{ùë©}{ùë™} ab bc = mkiso f g œÑ ŒΩ
 where
  f : hom ùë® ùë™                ;  g : hom ùë™ ùë®
  f = ‚àò-hom (to ab) (to bc)  ;  g = ‚àò-hom (from bc) (from ab)

  open Setoid ùîª[ ùë® ] using ( _‚âà_ ; trans )
  open Setoid ùîª[ ùë™ ] using () renaming ( _‚âà_ to _‚âà·∂ú_ ; trans to trans·∂ú )

  œÑ : ‚àÄ b ‚Üí ‚à£ f ‚à£ ‚ü®$‚ü© (‚à£ g ‚à£ ‚ü®$‚ü© b) ‚âà·∂ú b
  œÑ b = trans·∂ú (cong ‚à£ to bc ‚à£ (to‚àºfrom ab (‚à£ from bc ‚à£ ‚ü®$‚ü© b))) (to‚àºfrom bc b)

  ŒΩ : ‚àÄ a ‚Üí ‚à£ g ‚à£ ‚ü®$‚ü© (‚à£ f ‚à£ ‚ü®$‚ü© a) ‚âà a
  ŒΩ a = trans (cong ‚à£ from ab ‚à£ (from‚àºto bc (‚à£ to ab ‚à£ ‚ü®$‚ü© a))) (from‚àºto ab a)

\end{code}
\fi

The \af{Lift-Alg} operation neatly resolves the technical problem arising from the noncumulativity of Agda's
universe hierarchy. It does so without changing the algebraic semantics because it is an
\emph{algebraic invariant}; that is, isomorphism classes of algebras are closed under
\af{Lift-Alg}.
\ifshort
The \agdaalgebras library formalizes this fact as the following type.

\else

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 Lift-‚âÖÀ° : ùë® ‚âÖ (Lift-AlgÀ° ùë® ‚Ñì)
 Lift-‚âÖÀ° = mkiso ToLiftÀ° FromLiftÀ° (ToFromLiftÀ°{ùë® = ùë®}) (FromToLiftÀ°{ùë® = ùë®}{‚Ñì})
 Lift-‚âÖ ≥ : ùë® ‚âÖ (Lift-Alg ≥ ùë® ‚Ñì)
 Lift-‚âÖ ≥ = mkiso ToLift ≥ FromLift ≥ (ToFromLift ≥{ùë® = ùë®}) (FromToLift ≥{ùë® = ùë®}{‚Ñì})
\end{code}
\fi
\begin{code}

Lift-‚âÖ : {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì œÅ : Level} ‚Üí ùë® ‚âÖ (Lift-Alg ùë® ‚Ñì œÅ)
\end{code}
\ifshort
\vskip2mm
\else
\begin{code}
Lift-‚âÖ = ‚âÖ-trans Lift-‚âÖÀ° Lift-‚âÖ ≥
\end{code}

\paragraph*{Homomorphic images}
\fi

We conclude this section on homomorphisms with what we have found to be the most useful
way to represent the class of \emph{homomorphic images} of an algebra in MLTT. For future
reference, we also record the fact that an algebra is its own homomorphic
image.\footnote{Here and in \agdaalgebras we use the shorthand \af{ov}~\ab{Œ±} := \ab{ùí™}
\ap{‚äî} \ab{ùí±} \ap{‚äî} \ab{Œ±}, for any level \ab{Œ±}.}

\begin{code}[hide]
ov : Level ‚Üí Level
ov Œ± = ùìû ‚äî ùì• ‚äî lsuc Œ±
\end{code}

\begin{code}

_IsHomImageOf_ : (ùë© : Algebra Œ≤ œÅ·µá)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí Type _
ùë© IsHomImageOf ùë® = Œ£[ œÜ ‚àà hom ùë® ùë© ] IsSurjective ‚à£ œÜ ‚à£

HomImages : Algebra Œ± œÅ·µÉ ‚Üí Type (Œ± ‚äî œÅ·µÉ ‚äî ov (Œ≤ ‚äî œÅ·µá))
HomImages {Œ≤ = Œ≤}{œÅ·µá = œÅ·µá} ùë® = Œ£[ ùë© ‚àà Algebra Œ≤ œÅ·µá ] ùë© IsHomImageOf ùë®

IdHomImage : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí ùë® IsHomImageOf ùë®
IdHomImage {Œ± = Œ±}{ùë® = ùë®} = ùíæùíπ , Œª {y} ‚Üí Image_‚àã_.eq y refl where open Setoid ùîª[ ùë® ] using ( refl )
\end{code}
\ifshort\else    %%% BEGIN LONG VERSION ONLY

\medskip

\noindent These types should be self-explanatory, but just to be sure, we pause
to describe the semantics of the Sigma type appearing in the definition of \af{HomImages}.
If \ab{ùë®} : \af{Algebra} \ab{Œ±} \ab{œÅ·µÉ} is an \ab{ùëÜ}-algebra, then \af{HomImages} \ab{ùë®}
denotes the type of pairs (\ab{ùë©} \aic{,} \ab p) such that \ab{ùë©} : \ar{Algebra} \ab{Œ≤} \ab{œÅ·µá}
and \ab p is a proof that there exists a homomorphism from \ab{ùë®} onto \ab{ùë©}.
\fi      %%% END LONG VERSION ONLY SECTION

%% -------------------------------------------------------------------------------------
\subsection{Subalgebras}
\label{subalgebras}
Given \ab{ùëÜ}-algebras \ab{ùë®} and \ab{ùë©}, we say that \ab{ùë®} is a \defn{subalgebra} of
\ab{ùë®} and write \ab{ùë®}~\aof{‚â§}~\ab{ùë©} just in case \ab{ùë®} can be \emph{homomorphically
embedded} in \ab{ùë©}; in other terms, \ab{ùë®}~\aof{‚â§}~\ab{ùë©} iff there exists an injective
homomorphism from \ab{ùë®} to \ab{ùë©}. The following definition codifies the \defn{binary
subalgebra relation}, \aof{\au{}‚â§\au{}}, on the class of \ab{ùëÜ}-algebras.

\begin{code}

_‚â§_ : Algebra Œ± œÅ·µÉ ‚Üí Algebra Œ≤ œÅ·µá ‚Üí Type _
ùë® ‚â§ ùë© = Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£

\end{code}
Obviously the subalgebra relation is reflexive by the identity monomorphism; it is also
transitive since composition of monomorphisms is a monomorphism.
\ifshort
Here we merely give the formal statements of these assertions, omitting the easy proofs,
but \seeshort for details.
\else\fi

\begin{code}

‚â§-reflexive   :  {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí ùë® ‚â§ ùë®
\end{code}
\ifshort
\vskip2mm
\else
\begin{code}
‚â§-reflexive {ùë® = ùë®} = ùíæùíπ , id
\end{code}
\fi
\begin{code}
‚â§-transitive  :  {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{ùë™ : Algebra Œ≥ œÅ·∂ú}
 ‚Üí               ùë® ‚â§ ùë© ‚Üí ùë© ‚â§ ùë™ ‚Üí ùë® ‚â§ ùë™
\end{code}

\ifshort
\vskip2mm
\else
\begin{code}
‚â§-transitive ( f , finj ) ( g , ginj ) = (‚àò-hom f g ) , ‚àò-IsInjective ‚à£ f ‚à£ ‚à£ g ‚à£ finj ginj
\end{code}
\fi
\noindent If
\ab{ùíú} : \ab I ‚Üí \af{Algebra} \ab{Œ±} \ab{œÅ·µÉ},
\ab{‚Ñ¨} : \ab I ‚Üí \af{Algebra} \ab{Œ≤} \ab{œÅ·µá} (families of \ab{ùëÜ}-algebras) and
\ab{‚Ñ¨} \ab i \af{‚â§} \ab{ùíú} \ab i for all \ab i~:~\ab I, then \af{‚®Ö} \ab{‚Ñ¨} is a subalgebra
of \af{‚®Ö} \ab{ùíú}.
\ifshort
Here is how we express this fact in Agda.
\else
\begin{code}
module _ {Œπ : Level} {I : Type Œπ}{ùíú : I ‚Üí Algebra Œ± œÅ·µÉ}{‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá} where
\end{code}
\fi
\begin{code}

 ‚®Ö-‚â§ : (‚àÄ i ‚Üí ‚Ñ¨ i ‚â§ ùíú i) ‚Üí ‚®Ö ‚Ñ¨ ‚â§ ‚®Ö ùíú
\end{code}
\ifshort
\vskip2mm
\else
\begin{code}
 ‚®Ö-‚â§ B‚â§A = (hfunc , hhom) , hM
  where
  hi : ‚àÄ i ‚Üí hom (‚Ñ¨ i) (ùíú i)
  hi i = ‚à£ B‚â§A i ‚à£
  hfunc : ùîª[ ‚®Ö ‚Ñ¨ ] ‚ü∂ ùîª[ ‚®Ö ùíú ]
  (hfunc ‚ü®$‚ü© x) i = ‚à£ hi i ‚à£ ‚ü®$‚ü© x i
  cong hfunc = Œª xy i ‚Üí cong ‚à£ hi i ‚à£ (xy i)
  hhom : IsHom (‚®Ö ‚Ñ¨) (‚®Ö ùíú) hfunc
  compatible hhom = Œª i ‚Üí compatible ‚à• hi i ‚à•
  hM : IsInjective hfunc
  hM = Œª xy i ‚Üí ‚à• B‚â§A i ‚à• (xy i)

\end{code}
\fi

We conclude this brief subsection on subalgebras
\ifshort
by mentioning the function \af{mon‚Üí‚â§}, which we apply once below; it merely converts a monomorphism into a pair in \aof{‚â§}.
\else
with two easy facts
that will be useful later. The first merely converts a monomorphism into a pair in the subalgebra relation
while the second is an algebraic invariance property of \aof{‚â§}.

\begin{code}

mon‚Üí‚â§      :  {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} ‚Üí mon ùë® ùë© ‚Üí ùë® ‚â§ ùë©
mon‚Üí‚â§ {ùë® = ùë®}{ùë©} x = mon‚Üíintohom ùë® ùë© x

‚âÖ-trans-‚â§  :  {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{ùë™ : Algebra Œ≥ œÅ·∂ú}
 ‚Üí            ùë® ‚âÖ ùë© ‚Üí ùë© ‚â§ ùë™ ‚Üí ùë® ‚â§ ùë™
‚âÖ-trans-‚â§ A‚âÖB (h , hinj) = (‚àò-hom (to A‚âÖB) h) , (‚àò-IsInjective ‚à£ to A‚âÖB ‚à£ ‚à£ h ‚à£ (toIsInjective A‚âÖB) hinj)
\end{code}
\fi

%% -------------------------------------------------------------------------------------

\subsection{Terms}
\label{terms}
Fix a signature \ab{ùëÜ} and let \ab X denote an arbitrary nonempty collection of variable
symbols. The chosen collection of variable symbols is called the \defn{context}.)
Assume the symbols in \ab X are distinct from the operation symbols of
\ab{ùëÜ}, that is \ab X \aof{‚à©} \aof{‚à£} \ab{ùëÜ} \aof{‚à£} = ‚àÖ.

A \defn{word} in the language of \ab{ùëÜ} is a finite sequence of members of \ab X \aof{‚à™}
\aof{‚à£~\ab{ùëÜ}~‚à£}. We denote the concatenation of such sequences by simple juxtaposition.
Let \ab{S‚ÇÄ} denote the set of nullary operation symbols of \ab{ùëÜ}. We define by induction
on \ab n the sets \ab{ùëá‚Çô} of \emph{words} over \ab X \aof{‚à™} \aof{‚à£~\ab{ùëÜ}~‚à£} as
follows (cf.~\cite[Def. 4.19]{Bergman:2012}): \ab{ùëá‚ÇÄ} := \ab X \aof{‚à™} \ab{S‚ÇÄ} and
\ab{ùëá‚Çô‚Çä‚ÇÅ} := \ab{ùëá‚Çô} \aof{‚à™} \ab{ùíØ‚Çô}, where \ab{ùíØ‚Çô} is the collection of all \ab f \ab t
such that \ab f : \aof{‚à£~\ab{ùëÜ}~‚à£} and \ab t : \aof{‚à•~\ab{ùëÜ}~‚à•} \ab f \as{‚Üí}
\ab{ùëá‚Çô}. (Recall, \aof{‚à•~\ab{ùëÜ}~‚à•} \ab f is the arity of the operation symbol \ab
f.) An \ab{ùëÜ}-\defn{term} is a term in the language of \ab{ùëÜ} and the collection of all
\ab{ùëÜ}-\defn{terms} in the context \ab X is given by \Term{X} := \aof{‚ãÉ‚Çô} \ab{ùëá‚Çô}.

As even its informal definition of \Term{X} is recursive, it should come as no surprise
that the semantics of terms can be faithfully represented in type theory as an inductive
type. Indeed, here is such a representation.

\begin{code}

data Term (X : Type œá ) : Type (ov œá)  where
 ‚Ñä : X ‚Üí Term X
 node : (f : ‚à£ ùëÜ ‚à£)(t : ‚à• ùëÜ ‚à• f ‚Üí Term X) ‚Üí Term X

\end{code}
This basic inductive type represents each term as a tree with an operation symbol at each
\aic{node} and a variable symbol at each leaf (\aic{‚Ñä}); hence the constructor names
(\aic{‚Ñä} for ``generator'' and \aic{node} for ``node''). We enrich the \ad{Term} type with
an inductive type \ad{\au{}‚âÉ\au{}} representing equality of terms, and then we package
up \ad{Term}, \ad{\au{}‚âÉ\au{}}, and a proof that \ad{\au{}‚âÉ\au{}} is an equivalence
relation into a setoid of \ab{ùëÜ}-terms. Ultimately we use this term setoid as the domain
of an algebra---the (absolutely free) \emph{term algebra} in the signature \ab{ùëÜ}.
The equality-of-terms type is defined as follows.

\ifshort\else
\begin{code}

module _ {X : Type œá } where
\end{code}
\fi
\begin{code}

 data _‚âÉ_ : Term X ‚Üí Term X ‚Üí Type (ov œá) where
  rfl : {x y : X} ‚Üí x ‚â° y ‚Üí (‚Ñä x) ‚âÉ (‚Ñä y)
  gnl : ‚àÄ {f}{s t : ‚à• ùëÜ ‚à• f ‚Üí Term X} ‚Üí (‚àÄ i ‚Üí (s i) ‚âÉ (t i)) ‚Üí (node f s) ‚âÉ (node f t)

\end{code}
It's easy to show that this equality of terms is an equivalence relation%
\ifshort
; the proof, called \af{‚âÉ-isEquiv} in the \agdaalgebras library, is trivial.
\else
, as follows.

\begin{code}

 ‚âÉ-isRefl   : Reflexive      _‚âÉ_
 ‚âÉ-isRefl {‚Ñä _} = rfl ‚â°.refl
 ‚âÉ-isRefl {node _ _} = gnl (Œª _ ‚Üí ‚âÉ-isRefl)

 ‚âÉ-isSym    : Symmetric      _‚âÉ_
 ‚âÉ-isSym (rfl x) = rfl (‚â°.sym x)
 ‚âÉ-isSym (gnl x) = gnl (Œª i ‚Üí ‚âÉ-isSym (x i))

 ‚âÉ-isTrans  : Transitive     _‚âÉ_
 ‚âÉ-isTrans (rfl x) (rfl y) = rfl (‚â°.trans x y)
 ‚âÉ-isTrans (gnl x) (gnl y) = gnl (Œª i ‚Üí ‚âÉ-isTrans (x i) (y i))

 ‚âÉ-isEquiv  : IsEquivalence  _‚âÉ_
 ‚âÉ-isEquiv = record { refl = ‚âÉ-isRefl ; sym = ‚âÉ-isSym ; trans = ‚âÉ-isTrans }
\end{code}
\fi

\paragraph*{The term algebra}
For a given signature \ab{ùëÜ},
\ifshort\else
if the type \Term{X} is nonempty (equivalently, if \ab X or
\aof{‚à£~\ab{ùëÜ}~‚à£} is nonempty), then
\fi
we define an algebraic structure, denoted by \T{X}
and called the \defn{term algebra in the signature} \ab{ùëÜ} \defn{over} \ab X.  Terms are
viewed as acting on other terms, so both the elements of the carrier of \T{X} and its
basic operations are the terms themselves.

For each operation symbol \ab f : \aof{‚à£~\ab{ùëÜ}~‚à£}, we denote by \ab f~\aof{ÃÇ}~\T{X} the
operation on \Term{X} that maps each tuple of terms, say,
\ab t : \aof{‚à•~\ab{ùëÜ}~‚à•} \ab f \as{‚Üí} \Term{X}, to the formal term \ab f \ab t.
We let \T{X} denote the term algebra in \ab{ùëÜ} over \ab X; it has universe \Term{X} and
operations \ab f \aof{ÃÇ} \T{X}, one for each symbol \ab f in \aof{‚à£~\ab{ùëÜ}~‚à£}.
Finally, we formalize this notion of term algebra in \agda as follows.

\begin{code}

TermSetoid : (X : Type œá) ‚Üí Setoid _ _
TermSetoid X = record { Carrier = Term X ; _‚âà_ = _‚âÉ_ ; isEquivalence = ‚âÉ-isEquiv }

ùëª : (X : Type œá) ‚Üí Algebra (ov œá) (ov œá)
Algebra.Domain (ùëª X) = TermSetoid X
Algebra.Interp (ùëª X) ‚ü®$‚ü© (f , ts) = node f ts
cong (Algebra.Interp (ùëª X)) (‚â°.refl , ss‚âÉts) = gnl ss‚âÉts
\end{code}

\paragraph*{Environments and the interpretation of terms therein}
In this section, we formalize the notions \emph{environment} and \emph{interpretation of terms} in an algebra, evaluated in an environment. The approach to formalizing these notions, as well as the Agda code presented in this subsection, is based on similar code developed by Andreas Abel to formalize Birkhoff's completeness theorem~\cite{Abel:2021}.

\ifshort\else
Recall that the domain of an algebra \ab{ùë®} is a setoid, which we denote by \af{ùîª[ \ab{ùë®} ]}, whose \afld{Carrier} is the universe of the algebra, \af{ùïå[~\ab{ùë®}~]}, and whose equivalence relation represents equality of elements in \af{ùïå[~\ab{ùë®}~]}.
\fi

Fix a signature \ab{ùëÜ}, a context of variable symbols \ab X, and an \ab{ùëÜ}-algebra \ab{ùë®}. An \defn{environment} for these data is a function \ab{œÅ} : \ab X \as{‚Üí} \af{ùïå[~\ab{ùë®}~]} which assigns a value in the universe to each variable symbol in the context.
We represent the notion of environment in Agda using a function, \af{Env}, which takes an algebra \ab{ùë®} and a context \ab{X} and returns a setoid whose \afld{Carrier} has type \ab X \as{‚Üí} \af{ùïå[~\ab{ùë®}~]} and whose equivalence relation is point-wise equality of functions in \ab X \as{‚Üí} \af{ùïå[~\ab{ùë®}~]} (relative to the setoid equality of \af{ùîª[~\ab{ùë®}~]}).

Before defining the \af{Env} function (which will depend on a specific algebra) we first
define a substitution from one context, say, \ab X, to another \ab Y, which assigns a term
in \ab X to each symbol in \ab Y.  The definition of \af{Sub} (which does not depend on a
specific algebra) is a slight modification of the one given by Andreas Abel
(\textit{op.~cit.}), as is the recursive definition of the syntax \af{[~\ab{œÉ}~]} \ab t,
which denotes a substitution \ab{œÉ} applied to a term \ab t.

\begin{code}

Sub : Type œá ‚Üí Type œá ‚Üí Type _
Sub X Y = (y : Y) ‚Üí Term X

[_]_ : {X Y : Type œá} ‚Üí Sub X Y ‚Üí Term Y ‚Üí Term X
[ œÉ ] (‚Ñä x) = œÉ x
[ œÉ ] (node f ts) = node f (Œª i ‚Üí [ œÉ ] (ts i))

\end{code}

Now we are ready to define the aforementioned environment function \af{Env}
as well as the recursive function \af{‚ü¶\au{}‚üß} which defines the \defn{interpretation} of
a term in a given algebra, \emph{evaluated} in a given environment.  Since the next few
definitions are relative to a certain fixed algebra, we put them inside a submodule called
\am{Environment} so that later, when we load the environment, we can associate its
definitions with different algebras.

\begin{code}

module Environment (ùë® : Algebra Œ± ‚Ñì) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; refl ; sym ; trans )
 Env : Type œá ‚Üí Setoid _ _
 Env X = record  { Carrier = X ‚Üí ùïå[ ùë® ]
                 ; _‚âà_ = Œª œÅ œÑ ‚Üí (x : X) ‚Üí œÅ x ‚âà œÑ x
                 ; isEquivalence = record  { refl   = Œª _      ‚Üí refl
                                           ; sym    = Œª h x    ‚Üí sym (h x)
                                           ; trans  = Œª g h x  ‚Üí trans (g x)(h x) }}

 ‚ü¶_‚üß : {X : Type œá}(t : Term X) ‚Üí (Env X) ‚ü∂ ùîª[ ùë® ]
 ‚ü¶ ‚Ñä x ‚üß          ‚ü®$‚ü© œÅ    = œÅ x
 ‚ü¶ node f args ‚üß  ‚ü®$‚ü© œÅ    = (Interp ùë®) ‚ü®$‚ü© (f , Œª i ‚Üí ‚ü¶ args i ‚üß ‚ü®$‚ü© œÅ)
 cong ‚ü¶ ‚Ñä x ‚üß u‚âàv          = u‚âàv x
 cong ‚ü¶ node f args ‚üß x‚âày  = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí cong ‚ü¶ args i ‚üß x‚âày )

\end{code}

Two terms interpreted in \ab{ùë®} are proclaimed \defn{equal} if they are equal for all environments.  This equivalence of terms%
\ifshort\else
, and proof that it is an equivalence relation,
\fi
~is formalized in Agda as follows.

\begin{code}

 Equal : {X : Type œá}(s t : Term X) ‚Üí Type _
 Equal {X = X} s t = ‚àÄ (œÅ : Carrier (Env X)) ‚Üí ‚ü¶ s ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ

\end{code}
\ifshort
Proof that \af{Equal} is an equivalence relation, and that the implication \ab
s~\af{‚âÉ}~\ab t \as{‚Üí} \af{Equal} \ab s \ab t holds for all terms \ab s and \ab t, is
trivial. %(\seeshort for details).
We denote these facts by \af{EqualIsEquiv} and \af{‚âÉ‚ÜíEqual} in the sequel.
\else
\begin{code}
 ‚âÉ‚ÜíEqual : {X : Type œá}(s t : Term X) ‚Üí s ‚âÉ t ‚Üí Equal s t
 ‚âÉ‚ÜíEqual .(‚Ñä _) .(‚Ñä _) (rfl ‚â°.refl) = Œª _ ‚Üí refl
 ‚âÉ‚ÜíEqual (node _ s)(node _ t)(gnl x) =
  Œª œÅ ‚Üí cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí ‚âÉ‚ÜíEqual(s i)(t i)(x i)œÅ )

 EqualIsEquiv : {Œì : Type œá} ‚Üí IsEquivalence (Equal {X = Œì})
 refl·µâ   EqualIsEquiv = Œª _        ‚Üí refl
 sym·µâ    EqualIsEquiv = Œª x=y œÅ    ‚Üí sym (x=y œÅ)
 trans·µâ  EqualIsEquiv = Œª ij jk œÅ  ‚Üí trans (ij œÅ) (jk œÅ)

\end{code}
\fi

The \defn{substitution lemma} says that applying a substitution \ab{œÉ} to a term \ab{t}
has the same effect on the meaning of \ab{t} as changing the environment so that each
subterm \ab{x} has the value \aof{‚ü¶~\ab{œÉ}~\ab{x}~‚üß}~\aofld{‚ü®\$‚ü©} \ab{œÅ}. (See, e.g.,~\cite[Lemma 3.3.11]{Mitchell:1996}.)

\begin{code}

 substitution :  {X Y : Type œá} ‚Üí (t : Term Y) (œÉ : Sub X Y) (œÅ : Carrier( Env X ) )
  ‚Üí              ‚ü¶ [ œÉ ] t ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ t ‚üß ‚ü®$‚ü© (Œª x ‚Üí ‚ü¶ œÉ x ‚üß ‚ü®$‚ü© œÅ)
 substitution (‚Ñä x)        œÉ œÅ = refl
 substitution (node f ts)  œÉ œÅ = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí substitution (ts i) œÉ œÅ)

\end{code}
This concludes the definition of the \am{Environment} module based on~\cite{Abel:2021}.

\ifshort\else
\paragraph*{Compatibility of terms}
\fi
We will need two more facts about term operations.  The first, called
\af{comm-hom-term}, asserts that every term commutes with every homomorphism.  The second,
\af{interp-prod}, shows how to express the interpretation of a term in a product algebra.
\ifshort
We omit the formalization of these facts, but \seeshort for details.
\else

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}(hh : hom ùë® ùë©) where
 open Environment ùë® using ( ‚ü¶_‚üß )
 open Environment ùë© using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥Æ )
 open Setoid ùîª[ ùë© ] using ( _‚âà_ ; refl )
 private hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc
 comm-hom-term : (t : Term X) (a : X ‚Üí ùïå[ ùë® ]) ‚Üí h (‚ü¶ t ‚üß ‚ü®$‚ü© a) ‚âà ‚ü¶ t ‚üß·¥Æ ‚ü®$‚ü© (h ‚àò a)
 comm-hom-term (‚Ñä x) a       = refl
 comm-hom-term (node f t) a  =
  begin
   h(‚ü¶ node f t ‚üß ‚ü®$‚ü© a)            ‚âà‚ü® compatible ‚à• hh ‚à• ‚ü©
   (f ÃÇ ùë©)(Œª i ‚Üí h(‚ü¶ t i ‚üß ‚ü®$‚ü© a))  ‚âà‚ü® cong(Interp ùë©)(‚â°.refl , Œª i ‚Üí comm-hom-term (t i) a)‚ü©
   ‚ü¶ node f t ‚üß·¥Æ ‚ü®$‚ü© (h ‚àò a)        ‚àé where  open SetoidReasoning ùîª[ ùë© ]

module _ {X : Type œá}{Œπ : Level} {I : Type Œπ} (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) where
 open Setoid ùîª[ ‚®Ö ùíú ]  using ( _‚âà_ )
 open Environment      using ( ‚ü¶_‚üß ; ‚âÉ‚ÜíEqual )
 interp-prod : (p : Term X) ‚Üí ‚àÄ œÅ ‚Üí  (‚ü¶ ‚®Ö ùíú ‚üß p) ‚ü®$‚ü© œÅ   ‚âà   Œª i ‚Üí (‚ü¶ ùíú i ‚üß p) ‚ü®$‚ü© Œª x ‚Üí (œÅ x) i
 interp-prod (‚Ñä x)       = Œª œÅ i  ‚Üí ‚âÉ‚ÜíEqual (ùíú i) (‚Ñä x) (‚Ñä x) ‚âÉ-isRefl Œª _ ‚Üí (œÅ x) i
 interp-prod (node f t)  = Œª œÅ    ‚Üí cong (Interp (‚®Ö ùíú)) ( ‚â°.refl , Œª j k ‚Üí interp-prod (t j) œÅ k )
\end{code}
\fi

\section{Equational Logic}
\label{equational-logic}

\paragraph*{Term identities, equational theories, and the ‚äß relation}
Given a signature \ab{ùëÜ} and a context \ab X, an \ab{ùëÜ}-\defn{term equation} or \ab{ùëÜ}-\defn{term identity}
is an ordered pair (\ab p , \ab q) of ùëÜ-terms. For instance, if the context is \ab X :
\ap{Type} \ab{œá}, then a term equation is a pair inhabiting the Cartesian product type
\ad{Term}~\ab{X} \aof{√ó} \ad{Term}~\ab{X}. Such pairs of terms are also denoted by \ab p \af{‚âà} \ab
q and are often simply called equations or identities, especially when the signature \ab{ùëÜ} is obvious.

We define an \defn{equational theory} (or \defn{algebraic theory}) to be a pair \ab{T} =
(\ab{ùëÜ} , \ab{‚Ñ∞·µÄ}) consisting of a signature \ab{ùëÜ} and a collection \ab{‚Ñ∞·µÄ} of
\ab{ùëÜ}-term equations. Some authors reserve the term \defn{theory} for
a \emph{deductively closed} set of equations, that is, a set of equations that is closed
under \emph{entailment} (defined below).

We say that the algebra \ab{ùë®} \emph{satisfies} the equation \ab p \af{‚âà} \ab q if,
for all \ab{œÅ} : \ab X \as{‚Üí} \aof{ùîª[~\ab{ùë®}~]},
%(assigning values in the domain of \ab{ùë®} to variable symbols in \ab X)
we have \aof{‚ü¶~\ab{p}~‚üß} \aofld{‚ü®\$‚ü©} \ab{œÅ} \af{‚âà} \aof{‚ü¶~\ab{q}~‚üß} \aofld{‚ü®\$‚ü©} \ab{œÅ}.
In other words, when they are interpreted in the algebra \ab{ùë®},
the terms \ab{p} and \ab{q} are equal no matter what values in \ab{ùë®} are assigned to variable symbols in \ab{X}.
In this situation, we write
\ab{ùë®}~\aof{‚äß}~\ab{p}~\aof{‚âà}~\ab{q} and say that \ab{ùë®} \defn{models} \ab{p}~\af{‚âà}~\ab{q},
or that \ab{ùë®} is a \defn{model} of \ab{p}~\af{‚âà}~\ab{q}.
If \ab{ùí¶} is a class of algebras, all of the same signature, we write \ab{ùí¶}~\aof{‚ä´}~\ab{p}~\aof{‚âà}~\ab{q}
and say that \ab{ùí¶} \defn{models} the identity \ab{p}~\af{‚âà}~\ab{q} provided for every \ab{ùë®} \aof{‚àà} \ab{ùí¶},
we have \ab{ùë®}~\aof{‚äß}~\ab{p}~\aof{‚âà}~\ab{q}.

\ifshort\else
\begin{code}
module _ {X : Type œá} where
\end{code}
\fi
\begin{code}

 _‚äß_‚âà_ : Algebra Œ± œÅ·µÉ ‚Üí Term X ‚Üí Term X ‚Üí Type _
 ùë® ‚äß p ‚âà q = Equal p q where open Environment ùë®

 _‚ä´_‚âà_ : Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Term X ‚Üí Term X ‚Üí Type _
 ùí¶ ‚ä´ p ‚âà q = ‚àÄ ùë® ‚Üí ùí¶ ùë® ‚Üí ùë® ‚äß p ‚âà q

\end{code}
We represent a collection of identities as a predicate over pairs of
terms, say, \ab{‚Ñ∞} : \af{Pred}(\ad{Term} \ab{X} \af{√ó} \ad{Term} \ab{X})~\au{}  and we denote by
\ab{ùë®}~\aof{‚ä®}~\ab{‚Ñ∞} the assertion that the algebra \ab{ùë®} models \ab{p}~\af{‚âà}~\ab{q}
for all pairs (\ab{p} , \ab{q}) \af{‚àà} \ab{‚Ñ∞}.\footnote{Notice that \af{‚ä®} is
a stretched version of the models symbol, \af{‚äß}; this makes it possible for Agda to
parse expressions involving the types \af{\au{}‚ä®\au{}} and \af{\au{}‚äß\au{}‚âà\au{}}.
\ifshort\else
The first denotes
models of \emph{collections} of equations, while the latter denotes models of a
\emph{single} equation.
\fi
In Emacs \texttt{agda2-mode}, the symbol \af{‚ä®} is produced by typing
\textbackslash\textbar{}=, while \af{‚äß} is
produced with \textbackslash{}models.}

\begin{code}

 _‚ä®_ : (ùë® : Algebra Œ± œÅ·µÉ) ‚Üí Pred(Term X √ó Term X)(ov œá) ‚Üí Type _
 ùë® ‚ä® ‚Ñ∞ = ‚àÄ {p q} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí Equal p q where open Environment ùë®

\end{code}

If \ab{ùí¶} is a class of structures and \ab{‚Ñ∞} a set of term identities, then the set of
term equations modeled by \ab{ùí¶} is denoted by \af{Th}~\ab{ùí¶} and is called the
\defn{equational theory} of \ab{ùí¶}, while the class of structures modeling \ab{‚Ñ∞} is
denoted by \af{Mod}~\ab{‚Ñ∞} and is called the \defn{equational class axiomatized} by
\ab{‚Ñ∞}. We formalize these concepts in Agda with the following types.

\begin{code}

Th : {X : Type œá} ‚Üí Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Pred(Term X √ó Term X) _
Th ùí¶ = Œª (p , q) ‚Üí ùí¶ ‚ä´ p ‚âà q

Mod : {X : Type œá} ‚Üí Pred(Term X √ó Term X) ‚Ñì ‚Üí Pred (Algebra Œ± œÅ·µÉ) _
Mod ‚Ñ∞ ùë® = ‚àÄ {p q} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí Equal p q where open Environment ùë®
\end{code}

\paragraph*{Entailment}

If \ab{‚Ñ∞} is a set of \ab{ùëÜ}-term equations and \ab{p} and \ab{q} are \ab{ùëÜ}-terms,
we say that \ab{‚Ñ∞} \defn{entails} the equation \ab{p}~\aof{‚âà}~\ab{q}, and we write
\ab{‚Ñ∞}~\ad{‚ä¢}~\ab{p}~\ad{‚âà}~\ab{q}, just in case every model of \ab{‚Ñ∞} also models
\ab{p}~\aof{‚âà}~\ab{q}.

We represent entailment in type theory using an inductive type that is similar to
the one defined by Andreas Abel in~\cite{Abel:2021}.  We call this the \defn{entailment type}
and define it as follows.

\begin{code}

data _‚ä¢_‚ñπ_‚âà_  (‚Ñ∞ : {Y : Type œá} ‚Üí Pred(Term Y √ó Term Y) (ov œá)) :
              (X : Type œá)(p q : Term X) ‚Üí Type (ov œá) where

 hyp         :  ‚àÄ{Y}{p q : Term Y} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí ‚Ñ∞ ‚ä¢ _ ‚ñπ p ‚âà q
 app         :  ‚àÄ{Y}{ps qs : ‚à• ùëÜ ‚à• ùëì ‚Üí Term Y}
                          ‚Üí (‚àÄ i ‚Üí ‚Ñ∞ ‚ä¢ Y ‚ñπ ps i ‚âà qs i) ‚Üí ‚Ñ∞ ‚ä¢ Y ‚ñπ (node ùëì ps) ‚âà (node ùëì qs)
 sub         :  ‚àÄ{p q}    ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí (œÉ : Sub Œî Œì) ‚Üí ‚Ñ∞ ‚ä¢ Œî ‚ñπ ([ œÉ ] p) ‚âà ([ œÉ ] q)
 reflexive   :  ‚àÄ{p}      ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà p
 symmetric   :  ‚àÄ{p q}    ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ q ‚âà p
 transitive  :  ‚àÄ{p q r}  ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ q ‚âà r ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà r

\end{code}

The fact that this type represents the informal semantic notion of entailment
given at the start of this subsection is called \defn{soundness} and
\defn{completeness}.
More precisely, \defn{the entailment type is sound} means the following:
if \ab{‚Ñ∞}~\ad{‚ä¢}~\ab{X}~\ad{‚ñπ}~\ab p~\ad{‚âà}~\ab q, then \ab p \aof{‚âà} \ab q holds in
every model of \ab{‚Ñ∞}.
\defn{The entailment type is complete} means the following:
if \ab p \aof{‚âà} \ab q holds in every model of \ab{‚Ñ∞},
then \ab{‚Ñ∞}~\ad{‚ä¢}~\ab{X}~\ad{‚ñπ}~\ab p~\aof{‚âà}~\ab q.
Soundness and completeness of an entailment type similar to the one defined above was
proved by Abel in~\cite{Abel:2021}.  We will invoke soundness of the entailment type only once below%
\ifshort
~(by the name \af{sound}), so we omit its proof, but see~\cite{Abel:2021}
or~\cite{DeMeo:2021c} for the complete formalization.
\else
; nonetheless, here is its formalization (due to Abel, \textit{op. cit.}):

\begin{code}

module Soundness  (‚Ñ∞ : {Y : Type œá} ‚Üí Pred(Term Y √ó Term Y) (ov œá))
                  (ùë® : Algebra Œ± œÅ·µÉ)                -- We assume an algebra ùë®
                  (V : ‚àÄ{Y} ‚Üí _‚ä®_{œá = œá} ùë® (‚Ñ∞{Y}))  -- that models all equations in ‚Ñ∞.
                  where
 open SetoidReasoning ùîª[ ùë® ]
 open Environment ùë®
 sound : ‚àÄ {p q} ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ùë® ‚äß p ‚âà q
 sound (hyp i) = V i
 sound (app es) œÅ = cong (Interp ùë®) (‚â°.refl , Œª i ‚Üí sound (es i) œÅ)
 sound (sub {p = p}{q} Epq œÉ) œÅ =
  begin
   ‚ü¶ [ œÉ ] p  ‚üß ‚ü®$‚ü©                     œÅ   ‚âà‚ü®   substitution p œÉ œÅ               ‚ü©
   ‚ü¶ p        ‚üß ‚ü®$‚ü© (Œª x ‚Üí ‚ü¶ œÉ x ‚üß ‚ü®$‚ü©  œÅ)  ‚âà‚ü®   sound Epq (Œª x ‚Üí ‚ü¶ œÉ x ‚üß ‚ü®$‚ü© œÅ)  ‚ü©
   ‚ü¶ q        ‚üß ‚ü®$‚ü© (Œª x ‚Üí ‚ü¶ œÉ x ‚üß ‚ü®$‚ü©  œÅ)  ‚âàÀò‚ü®  substitution q œÉ œÅ               ‚ü©
   ‚ü¶ [ œÉ ] q  ‚üß ‚ü®$‚ü©                     œÅ   ‚àé
 sound (reflexive   {p = p}                 ) = refl·µâ   EqualIsEquiv {x = p}
 sound (symmetric   {p = p}{q}     Epq      ) = sym·µâ    EqualIsEquiv {x = p}{q}     (sound Epq)
 sound (transitive  {p = p}{q}{r}  Epq Eqr  ) = trans·µâ  EqualIsEquiv {i = p}{q}{r}  (sound Epq)(sound Eqr)
\end{code}
\fi

\paragraph*{The Closure Operators H, S, P and V}
Fix a signature \ab{ùëÜ}, let \ab{ùí¶} be a class of \ab{ùëÜ}-algebras, and define
\begin{itemize}
\item \af H \ab{ùí¶} = algebras isomorphic to homomorphic images of members of \ab{ùí¶};
\item \af S \ab{ùí¶} = algebras isomorphic to subalgebras of a members of \ab{ùí¶};
\item \af P \ab{ùí¶} = algebras isomorphic to products of members of \ab{ùí¶}.
\end{itemize}
A straight-forward verification confirms that \af H, \af S, and \af P are \emph{closure operators} (expansive, monotone, and idempotent).  A class \ab{ùí¶} of \ab{ùëÜ}-algebras is said to be \emph{closed under the taking of homomorphic images} provided \af H \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}. Similarly, \ab{ùí¶} is \emph{closed under the taking of subalgebras} (resp., \emph{arbitrary products}) provided \af S \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶} (resp., \af P \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}). The operators \af H, \af S, and \af P can be composed with one another repeatedly, forming yet more closure operators.

% An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class \af H \ab{ùí¶} (resp., \af S \ab{ùí¶}; resp., \af P \ab{ùí¶}) is closed under isomorphism.

A \emph{variety} is a class of \ab{ùëÜ}-algebras that is closed under the taking of
homomorphic images, subalgebras, and arbitrary products.  To represent varieties
we define types for the closure operators \af H, \af S, and \af P that are composable; we
then define a type \af V which represents closure under all three operators, \af H, \af S,
and \af P. Thus, if \ab{ùí¶} is a class of \ab{ùëÜ}-algebras, then
\af V \ab{ùí¶} := \af H (\af S (\af P \ab{ùí¶})), and \ab{ùí¶} is a variety iff \af V \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}.
\ifshort\else

We now define the type \af H to represent classes of algebras that include all homomorphic images of algebras in the class---i.e., classes that are closed under the taking of homomorphic images---the type \af S to represent classes of algebras that closed under the taking of subalgebras, and the type \af P to represent classes of algebras closed under the taking of arbitrary products.
\fi

\begin{code}

module _ {Œ± œÅ·µÉ Œ≤ œÅ·µá : Level} where
 private a = Œ± ‚äî œÅ·µÉ
 H : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 H _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© IsHomImageOf ùë®

 S : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 S _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© ‚â§ ùë®

 P : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 P _ Œπ ùí¶ ùë© = Œ£[ I ‚àà Type Œπ ] (Œ£[ ùíú ‚àà (I ‚Üí Algebra Œ± œÅ·µÉ) ] (‚àÄ i ‚Üí ùíú i ‚àà ùí¶) √ó (ùë© ‚âÖ ‚®Ö ùíú))

\end{code}
Finally, we define the \defn{varietal closure} of a class \ab{ùí¶} to be the class \af{V} \ab{ùí¶} := \af{H} (\af{S} (\af{P} \ab{ùí¶})).
(Recall, \ab{ùí¶} is called a \defn{variety} if \af{V} \ab{ùí¶} = \ab{ùí¶}.)
\begin{code}

module _  {Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà : Level} where
 private a = Œ± ‚äî œÅ·µÉ ; b = Œ≤ ‚äî œÅ·µá
 V : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí  Pred(Algebra Œ¥ œÅ·µà) _
 V ‚Ñì Œπ ùí¶ = H{Œ≥}{œÅ·∂ú}{Œ¥}{œÅ·µà} (a ‚äî b ‚äî ‚Ñì ‚äî Œπ) (S{Œ≤}{œÅ·µá} (a ‚äî ‚Ñì ‚äî Œπ) (P ‚Ñì Œπ ùí¶))

\end{code}

An important property of the binary relation \aof{‚äß} is \emph{algebraic invariance} (i.e.,
invariance under isomorphism).
\ifshort
Here is the formal statement of this property, without proof.
\else
We formalize this property as follows.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá)(p q : Term X) where
\end{code}
\fi
\begin{code}

 ‚äß-I-invar : ùë® ‚äß p ‚âà q  ‚Üí  ùë® ‚âÖ ùë©  ‚Üí  ùë© ‚äß p ‚âà q

\end{code}
\ifshort\else
\begin{code}
 ‚äß-I-invar Apq (mkiso fh gh f‚àºg g‚àºf) œÅ =
  begin
      ‚ü¶ p ‚üß   ‚ü®$‚ü©               œÅ    ‚âàÀò‚ü®  cong ‚ü¶ p ‚üß (f‚àºg ‚àò œÅ)        ‚ü©
      ‚ü¶ p ‚üß   ‚ü®$‚ü© (f  ‚àò  (g  ‚àò  œÅ))  ‚âàÀò‚ü®  comm-hom-term fh p (g ‚àò œÅ)  ‚ü©
    f(‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü©        (g  ‚àò  œÅ))  ‚âà‚ü®   cong ‚à£ fh ‚à£ (Apq (g ‚àò œÅ))   ‚ü©
    f(‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü©        (g  ‚àò  œÅ))  ‚âà‚ü®   comm-hom-term fh q (g ‚àò œÅ)  ‚ü©
      ‚ü¶ q ‚üß   ‚ü®$‚ü© (f  ‚àò  (g  ‚àò  œÅ))  ‚âà‚ü®   cong ‚ü¶ q ‚üß (f‚àºg ‚àò œÅ)        ‚ü©
      ‚ü¶ q ‚üß   ‚ü®$‚ü©               œÅ    ‚àé
  where
  private f = _‚ü®$‚ü©_ ‚à£ fh ‚à£ ; g = _‚ü®$‚ü©_ ‚à£ gh ‚à£
  open Environment ùë®     using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨ )
  open Environment ùë©     using ( ‚ü¶_‚üß )
  open SetoidReasoning ùîª[ ùë© ]

\end{code}
\fi
Identities modeled by an algebra \ab{ùë®} are also modeled by every homomorphic image of
\ab{ùë®} and by every subalgebra of \ab{ùë®}.
\ifshort
We refer to these facts as \af{‚äß-H-invar} and \af{‚äß-S-invar}, but omit their formal
statements and proofs, which are analogous to those of \af{‚äß-I-invar}.
\else
These facts are formalized in Agda as follows.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{p q : Term X} where

 ‚äß-H-invar : ùë® ‚äß p ‚âà q ‚Üí ùë© IsHomImageOf ùë® ‚Üí ùë© ‚äß p ‚âà q
 ‚äß-H-invar Apq (œÜh , œÜE) œÅ =
  begin
       ‚ü¶ p ‚üß   ‚ü®$‚ü©               œÅ    ‚âàÀò‚ü®  cong ‚ü¶ p ‚üß(Œª _ ‚Üí InvIsInverse ≥ œÜE)  ‚ü©
       ‚ü¶ p ‚üß   ‚ü®$‚ü© (œÜ ‚àò  œÜ‚Åª¬π  ‚àò  œÅ)   ‚âàÀò‚ü®  comm-hom-term œÜh p (œÜ‚Åª¬π ‚àò œÅ)        ‚ü©
   œÜ(  ‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü© (     œÜ‚Åª¬π  ‚àò  œÅ))  ‚âà‚ü®   cong ‚à£ œÜh ‚à£ (Apq (œÜ‚Åª¬π ‚àò œÅ))         ‚ü©
   œÜ(  ‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü© (     œÜ‚Åª¬π  ‚àò  œÅ))  ‚âà‚ü®   comm-hom-term œÜh q (œÜ‚Åª¬π ‚àò œÅ)        ‚ü©
       ‚ü¶ q ‚üß   ‚ü®$‚ü© (œÜ ‚àò  œÜ‚Åª¬π  ‚àò  œÅ)   ‚âà‚ü®   cong ‚ü¶ q ‚üß(Œª _ ‚Üí InvIsInverse ≥ œÜE)  ‚ü©
       ‚ü¶ q ‚üß   ‚ü®$‚ü©               œÅ    ‚àé
  where
  œÜ‚Åª¬π : ùïå[ ùë© ] ‚Üí ùïå[ ùë® ]
  œÜ‚Åª¬π = SurjInv ‚à£ œÜh ‚à£ œÜE
  private œÜ = (_‚ü®$‚ü©_ ‚à£ œÜh ‚à£)
  open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨)
  open Environment ùë©  using ( ‚ü¶_‚üß )
  open SetoidReasoning ùîª[ ùë© ]

 ‚äß-S-invar : ùë® ‚äß p ‚âà q ‚Üí ùë© ‚â§ ùë® ‚Üí ùë© ‚äß p ‚âà q
 ‚äß-S-invar Apq B‚â§A b = ‚à• B‚â§A ‚à•
  ( begin
    h (  ‚ü¶ p ‚üß   ‚ü®$‚ü©       b)  ‚âà‚ü®   comm-hom-term hh p b  ‚ü©
         ‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü© (h ‚àò  b)  ‚âà‚ü®   Apq (h ‚àò b)           ‚ü©
         ‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü© (h ‚àò  b)  ‚âàÀò‚ü®  comm-hom-term hh q b  ‚ü©
    h (  ‚ü¶ q ‚üß   ‚ü®$‚ü©       b)  ‚àé )
  where
  open SetoidReasoning ùîª[ ùë® ]
  open Setoid ùîª[ ùë® ]  using ( _‚âà_ )
  open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨ )
  open Environment ùë©  using ( ‚ü¶_‚üß )
  private hh = ‚à£ B‚â§A ‚à£ ; h = _‚ü®$‚ü©_ ‚à£ hh ‚à£

\end{code}
\fi
An identity satisfied by all algebras in an indexed collection is
also satisfied by the product of algebras in the collection.
\ifshort
We refer to this fact as \af{‚äß-P-invar}.
\else

\begin{code}

module _ {X : Type œá}{I : Type ‚Ñì}(ùíú : I ‚Üí Algebra Œ± œÅ·µÉ){p q : Term X} where
 ‚äß-P-invar : (‚àÄ i ‚Üí ùíú i ‚äß p ‚âà q) ‚Üí ‚®Ö ùíú ‚äß p ‚âà q
 ‚äß-P-invar ùíúpq a =
  begin
   ‚ü¶ p ‚üß‚ÇÅ               ‚ü®$‚ü©  a                ‚âà‚ü®   interp-prod ùíú p a  ‚ü©
   ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß p)  ‚ü®$‚ü©  Œª x ‚Üí (a x) i )  ‚âà‚ü® (Œª i ‚Üí ùíúpq i (Œª x ‚Üí (a x) i)) ‚ü©
   ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß q)  ‚ü®$‚ü©  Œª x ‚Üí (a x) i )  ‚âàÀò‚ü®  interp-prod ùíú q a  ‚ü©
   ‚ü¶ q ‚üß‚ÇÅ               ‚ü®$‚ü©  a                ‚àé
  where
  open Environment (‚®Ö ùíú)  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
  open Environment        using ( ‚ü¶_‚üß )
  open Setoid ùîª[ ‚®Ö ùíú ]    using ( _‚âà_ )
  open SetoidReasoning ùîª[ ‚®Ö ùíú ]

\end{code}
\fi

The classes \af H \ab{ùí¶}, \af S \ab{ùí¶}, \af P \ab{ùí¶}, and \af V \ab{ùí¶} all satisfy the
same set of equations.  We will only use a subset of the inclusions needed to prove this
assertion, and we present here only the facts we need.\footnote{For more details, see the
\ualmodule{Varieties.Func.Preservation} module of the \agdaalgebras library.}
First, the closure operator \af H preserves the identities modeled by the
given class; this follows almost immediately from the invariance lemma
\af{‚äß-H-invar} proved above.

\begin{AgdaAlign}
\begin{code}

module _  {X : Type œá}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where
 H-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí H{Œ≤ = Œ±}{œÅ·µÉ}‚Ñì ùí¶ ‚ä´ p ‚âà q
 H-id1 œÉ ùë© (ùë® , kA , BimgOfA) œÅ = ‚äß-H-invar{p = p}{q} (œÉ ùë® kA) BimgOfA œÅ

\end{code}
The analogous preservation result for \af S is a simple consequence of
the invariance lemma \af{‚äß-S-invar}; the obvious converse, which we call
\af{S-id2}, has an equally straightforward proof.

\begin{code}

 S-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí S{Œ≤ = Œ±}{œÅ·µÉ}‚Ñì ùí¶ ‚ä´ p ‚âà q
 S-id1 œÉ ùë© (ùë® , kA , B‚â§A) = ‚äß-S-invar{p = p}{q} (œÉ ùë® kA) B‚â§A
 S-id2 : S ‚Ñì ùí¶ ‚ä´ p ‚âà q ‚Üí ùí¶ ‚ä´ p ‚âà q
 S-id2 Spq ùë® kA = Spq ùë® (ùë® , (kA , ‚â§-reflexive))

\end{code}
Finally, we have analogous pairs of implications for \af P and \af V,
\ifshort
called P-id1 and V-id1 in the \agdaalgebras library.
\else
In each case, we will only need the first implication, so we omit the others from this presentation.

\begin{code}

 P-id1 : ‚àÄ{Œπ} ‚Üí ùí¶ ‚ä´ p ‚âà q ‚Üí P{Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶ ‚ä´ p ‚âà q
 P-id1 œÉ ùë® (I , ùíú , kA , A‚âÖ‚®ÖA) = ‚äß-I-invar ùë® p q IH (‚âÖ-sym A‚âÖ‚®ÖA)
  where
  IH : ‚®Ö ùíú ‚äß p ‚âà q
  IH = ‚äß-P-invar ùíú {p}{q} (Œª i ‚Üí œÉ (ùíú i) (kA i))

module _ {X : Type œá}{Œπ : Level}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where
 private a‚ÑìŒπ = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ‚äî Œπ

 V-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí V ‚Ñì Œπ ùí¶ ‚ä´ p ‚âà q
 V-id1 œÉ ùë© (ùë® , (‚®ÖA , p‚®ÖA , A‚â§‚®ÖA) , BimgA) =
  H-id1{‚Ñì = a‚ÑìŒπ}{ùí¶ = S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)}{p = p}{q} spK‚äßpq ùë© (ùë® , (spA , BimgA))
   where
   spA : ùë® ‚àà S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)
   spA = ‚®ÖA , (p‚®ÖA , A‚â§‚®ÖA)
   spK‚äßpq : S a‚ÑìŒπ (P ‚Ñì Œπ ùí¶) ‚ä´ p ‚âà q
   spK‚äßpq = S-id1{‚Ñì = a‚ÑìŒπ}{p = p}{q} (P-id1{‚Ñì = ‚Ñì} {ùí¶ = ùí¶}{p = p}{q} œÉ)
\end{code}
\fi
\end{AgdaAlign}

%% -------------------------------------------------------------------------------------

\section{Free Algebras}
\label{free-algebras}
\paragraph*{The absolutely free algebra}
The term algebra \af{ùëª} \ab X is \emph{absolutely free} (or \emph{universal}, or
\emph{initial}) for algebras in the signature \ab{ùëÜ}. That is, for every
\ab{ùëÜ}-algebra \ab{ùë®}, the following hold.

\begin{itemize}
\item Every function from \ab{X} to \af{ùïå[ \ab{ùë®} ]} lifts to a homomorphism from \af{ùëª} \ab{X} to \ab{ùë®}.
\item The homomorphism that exists by the previous item is unique.
\end{itemize}

We now prove the first of these facts in Agda which we call \af{free-lift}.\footnote{The
 \agdaalgebras library also defines
 \af{free-lift-func} \as{:} \aof{ùîª[~\af{ùëª}~\ab X~]}~\aor{‚ü∂}~\aof{ùîª[~\ab{ùë®}~]}
 for constructing the analogous setoid function.}$^,$\footnote{For the proof of uniqueness,
see the \ualmodule{Terms.Func.Properties} module of the \agdaalgebras library.}

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(h : X ‚Üí ùïå[ ùë® ]) where
 free-lift : ùïå[ ùëª X ] ‚Üí ùïå[ ùë® ]
 free-lift (‚Ñä x) = h x
 free-lift (node f t) = (f ÃÇ ùë®) (Œª i ‚Üí free-lift (t i))

\end{code}
\ifshort\else
\begin{code}
 free-lift-func : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùë® ]
 free-lift-func ‚ü®$‚ü© x = free-lift x
 cong free-lift-func = flcong
  where
  open Setoid ùîª[ ùë® ] using ( _‚âà_ ) renaming ( reflexive to reflexive·¥¨ )
  flcong : ‚àÄ {s t} ‚Üí s ‚âÉ t ‚Üí free-lift s ‚âà free-lift t
  flcong (_‚âÉ_.rfl x) = reflexive·¥¨ (‚â°.cong h x)
  flcong (_‚âÉ_.gnl x) = cong (Interp ùë®) (‚â°.refl , (Œª i ‚Üí flcong (x i)))

\end{code}
\fi
Evidently, the proof is a straightforward structural induction argument.
\ifshort\else
At the base step, when the term has the form \aic{‚Ñä}
\ab x, the free lift of \ab h agrees with \ab h; at the inductive step, when the
term has the form \aic{node} \ab f \ab t, we assume (the induction hypothesis)
that the image of each subterm \ab t \ab i under the free lift of \ab h is known
and the free lift is defined by applying \ab f \aof{ÃÇ} \ab{ùë®} to these images.
\fi
Moreover, the free lift so defined is a homomorphism by construction;
\ifshort
for the proof---which is called \af{lift-hom} in the \agdaalgebras library---\seeshort.
\else
indeed, here is the trivial proof.

\begin{code}

 lift-hom : hom (ùëª X) ùë®
 lift-hom = free-lift-func , hhom
  where
  hfunc : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùë® ]
  hfunc = free-lift-func

  hcomp : compatible-map (ùëª X) ùë® free-lift-func
  hcomp {f}{a} = cong (Interp ùë®) (‚â°.refl , (Œª i ‚Üí (cong free-lift-func){a i} ‚âÉ-isRefl))

  hhom : IsHom (ùëª X) ùë® hfunc
  hhom = mkhom (Œª{f}{a} ‚Üí hcomp{f}{a})

\end{code}
\fi

It turns out that the interpretation of a term \ab p in an environment \ab{Œ∑} is the same
as the free lift of \ab{Œ∑} evaluated at \ab p.

\ifshort\else
\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ} where
 open Setoid ùîª[ ùë® ]  using ( _‚âà_ ; refl )
 open Environment ùë®  using ( ‚ü¶_‚üß )
\end{code}
\fi
\begin{code}

 free-lift-interp : (Œ∑ : X ‚Üí ùïå[ ùë® ])(p : Term X) ‚Üí ‚ü¶ p ‚üß ‚ü®$‚ü© Œ∑ ‚âà (free-lift{ùë® = ùë®} Œ∑) p
 free-lift-interp Œ∑ (‚Ñä x)       = refl
 free-lift-interp Œ∑ (node f t)  = cong (Interp ùë®) (‚â°.refl , (free-lift-interp Œ∑) ‚àò t)
\end{code}

\paragraph*{The relatively free algebra in theory}
In this subsection, we describe, for a given class \ab{ùí¶} of \ab{ùëÜ}-algebras, the
\emph{relatively free algebra} in \af{S} (\af{P} \ab{ùí¶}) over \ab X, using the informal
language that is typical of mathematics literature. In the next section we will present
the relatively free algebra in Agda using the formal language of type theory.

Above we defined the term algebra \T{X}, which is free in the class of all
\ab{ùëÜ}-algebras; that is, \T{X} has the universal property and belongs to the class of
\ab{ùëÜ}-algebras.  Given an arbitrary class \ab{ùí¶} of \ab{ùëÜ}-algebras, we can't expect that
\T{X} belongs to \ab{ùí¶}, so, in general, we say that \T{X} is free \emph{for} \ab{ùí¶}.
\ifshort\else
Indeed, it might not be possible to find a free algebra that belongs to \ab{ùí¶}.
\fi
However, for any class \ab{ùí¶} we can construct an algebra that is free \emph{for} \ab{ùí¶}
and belongs to the class \af{S} (\af{P} \ab{ùí¶}), and for most applications this suffices.

The informal construction of the free algebra in \af{S} (\af{P} \ab{ùí¶}), for an arbitrary
class \ab{ùí¶} of \ab{ùëÜ}-algebras, often proceeds by way of a quotient; letting \af{Œò} :=
\af{‚ãÇ}\{\ab{Œ∏} \af{‚àà} \af{Con} (\T{X}) : \T{X} \af{/} \ab{Œ∏} \af{‚àà} \af{S}
\ab{ùí¶}\},\footnote{\af{Con} (\T{X}) is the set of congruences of \T{X}.} we define the
\defn{relatively free algebra over} \ab{X} (relative to \ab{ùí¶}) to be
\T{X} modulo the congruence \af{Œò}, which we denote by \Free{X} := \T{X}~\af{/}~\ab{Œò}.
Evidently, \Free{X} is a subdirect product of the algebras in \{\T{X}~\af{/}~\ab{Œ∏}\},
where \ab{Œ∏} ranges over all congruences modulo which \T{X} belongs to \af{S}~\ab{ùí¶}.
Thus \Free{X} belongs to \af{P}(\af{S}~\ab{ùí¶}) ‚äÜ \af{S}(\af{P}~\ab{ùí¶}), and it follows
that \Free{X} satisfies the identities in \af{Th} \ab{ùí¶} (those modeled by all members of
\ab{ùí¶}).  Indeed, for each pair \ab p \ab q : \Term{X}, if \ab{ùí¶} \af{‚ä´} \ab p \af{‚âà} \ab
q, then \ab p and \ab q must belong to the same \ab{Œò}-class, so \ab p and \ab q are
identified in \Free{X}. \ifshort\else (Notice that \af{Œò} may be empty, in which case
\af{œà} = \T{X} \af{√ó} \T{X} and then \T{X}~\af{/}~\ab{œà} is trivial.) \fi


\paragraph*{The relatively free algebra in Agda}
We now define the relatively free algebra in Agda using the language of type theory.
Our approach will be different from the informal one described in the appendix.
In particular, we start with a set (or, rather, a type) \ab{‚Ñ∞} of identities, instead of a
class of algebras, and we avoid quotients altogether, in favor of setoids. The domain of
the free algebra will be a setoid whose \afld{Carrier} is the type \Term{X} of {ùëÜ}-terms
in \ab X and whose equivalence relation will include all pairs (\ab p , \ab q) \af{‚àà}
\Term{X} \af{√ó} \Term{X} such that \ab p \aod{‚âà} \ab q is derivable from \ab{‚Ñ∞}; that is,
\ab{‚Ñ∞} \aod{‚ä¢} \ab X \aod{‚ñπ} \ab p \aod{‚âà} \ab q. Finally, the interpretation of an
operation in the free algebra is simply the operation itself, which works since \ab{‚Ñ∞}
\aod{‚ä¢} \ab X \aod{‚ñπ\au{}‚âà\au{}} is a congruence relation.

\begin{code}

module FreeAlgebra {œá : Level}(‚Ñ∞ : {Y : Type œá} ‚Üí Pred (Term Y √ó Term Y) (ov œá)) where

 FreeDomain : Type œá ‚Üí Setoid _ _
 FreeDomain X =
  record  { Carrier        = Term X
          ; _‚âà_            = ‚Ñ∞ ‚ä¢ X ‚ñπ_‚âà_
          ; isEquivalence  = record { refl = reflexive ; sym = symmetric ; trans = transitive } }

 ùîΩ[_] : Type œá ‚Üí Algebra (ov œá) _
 Domain ùîΩ[ X ] = FreeDomain X
 Interp ùîΩ[ X ] = FreeInterp
  where
  FreeInterp : ‚àÄ {X} ‚Üí ‚ü® ùëÜ ‚ü© (FreeDomain X) ‚ü∂ FreeDomain X
  FreeInterp ‚ü®$‚ü© (f , ts)       = node f ts
  cong FreeInterp (‚â°.refl , h)  = app h
\end{code}

\paragraph*{The natural epimorphism} % from ùëª X to ùîΩ[ X ]}
We now define the natural epimorphism from \T{X} onto the relatively free algebra \Free{X} and prove that
the kernel of this morphism is the congruence of \T{X} defined by the identities modeled by (\af S \ab{ùí¶}, hence by) \ab{ùí¶}.

\ifshort\else
\begin{code}

module FreeHom {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c
 open FreeAlgebra {œá = c} (Th ùí¶) using ( ùîΩ[_] )
\end{code}
\fi
\begin{code}

 epiF[_] : (X : Type c) ‚Üí epi (ùëª X) ùîΩ[ X ]
 epiF[ X ] = h , hepi
  where
  open Setoid ùîª[ ùëª X ]     using ()        renaming ( _‚âà_ to _‚âà‚ÇÄ_  ; refl to refl·µÄ )
  open Setoid ùîª[ ùîΩ[ X ] ]  using ( refl )  renaming ( _‚âà_ to _‚âà‚ÇÅ_  )

  con : ‚àÄ {x y} ‚Üí x ‚âà‚ÇÄ y ‚Üí x ‚âà‚ÇÅ y
  con (rfl {x}{y} ‚â°.refl) = refl
  con (gnl {f}{s}{t} x) = cong (Interp ùîΩ[ X ]) (‚â°.refl , con ‚àò x)

  h : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùîΩ[ X ] ]
  h = record { f = id ; cong = con }

  hepi : IsEpi (ùëª X) ùîΩ[ X ] h
  compatible (isHom hepi) = cong h refl·µÄ
  isSurjective hepi {y} = eq y refl

 homF[_] : (X : Type c) ‚Üí hom (ùëª X) ùîΩ[ X ]
 homF[ X ] = IsEpi.HomReduct ‚à• epiF[ X ] ‚à•

 kernel-in-theory : {X : Type c} ‚Üí ker ‚à£ homF[ X ] ‚à£ ‚äÜ Th (V ‚Ñì Œπ ùí¶)
 kernel-in-theory {X = X} {p , q} pKq ùë® vkA = V-id1{‚Ñì = ‚Ñì}{p = p}{q} (Œ∂ pKq) ùë® vkA
  where
  Œ∂ : ‚àÄ{p q} ‚Üí (Th ùí¶) ‚ä¢ X ‚ñπ p ‚âà q ‚Üí ùí¶ ‚ä´ p ‚âà q
  Œ∂ x ùë® kA = sound (Œª y œÅ ‚Üí y ùë® kA œÅ) x where open Soundness (Th ùí¶) ùë®

\end{code}
Next we prove an important property of the relatively free algebra (relative to \ab{ùí¶} and satisfying the identities in \af{Th} \ab{ùí¶}), which will be used in the formalization of the HSP theorem; this is the assertion that for every algebra ùë®, if \ab{ùë®} \af{‚ä®} \ab{Th} (\af{V} \ab{ùí¶}), then there exists an epimorphism from \Free{A} onto \ab{ùë®}.

\ifshort\else
\begin{code}

module _  {ùë® : Algebra (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c
 open FreeHom {‚Ñì = ‚Ñì} {ùí¶}
 open FreeAlgebra {œá = c}(Th ùí¶)  using ( ùîΩ[_] )
 open Setoid ùîª[ ùë® ]              using ( refl ; sym ; trans ) renaming  ( Carrier  to A )
\end{code}
\fi
\begin{code}

 F-ModTh-epi : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí epi ùîΩ[ A ] ùë®
 F-ModTh-epi A‚ààModThK = œÜ , isEpi
  where
  œÜ : ùîª[ ùîΩ[ A ] ] ‚ü∂ ùîª[ ùë® ]
  _‚ü®$‚ü©_ œÜ = free-lift{ùë® = ùë®} id
  cong œÜ {p} {q} pq  =  trans  ( sym (free-lift-interp{ùë® = ùë®} id p) )
                     (  trans  ( A‚ààModThK{p = p}{q} (kernel-in-theory pq) id )
                               ( free-lift-interp{ùë® = ùë®} id q ) )
  isEpi : IsEpi ùîΩ[ A ] ùë® œÜ
  compatible (isHom isEpi) = cong (Interp ùë®) (‚â°.refl , (Œª _ ‚Üí refl))
  isSurjective isEpi {y} = eq (‚Ñä y) refl
\end{code}
\ifshort\else

\medskip

\noindent Actually, we will need the following lifted version of this result.

\begin{code}

 F-ModTh-epi-lift : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí epi ùîΩ[ A ] (Lift-Alg ùë® Œπ Œπ)
 F-ModTh-epi-lift A‚ààModThK = ‚àò-epi (F-ModTh-epi (Œª {p q} ‚Üí A‚ààModThK{p = p}{q})) ToLift-epi
\end{code}
\fi


%% -------------------------------------------------------------------------------------

\section{Birkhoff's Variety Theorem}

Birkhoff's variety theorem, also know as the HSP theorem, asserts that a class of algebras
is a variety if and only if it is an equational class.  In this section, we present the
statement and proof of the HSP theorem---first in the familiar, informal style similar to
what one finds in standard textbooks (see, e.g.,~\cite[Theorem 4.41]{Bergman:2012}),
and then in the formal language of Martin-L√∂f type theory using Agda.

\subsection{Informal proof}
Let \ab{ùí¶} be a class of algebras and recall that \ab{ùí¶} is a \emph{variety} provided
\ifshort\else
it is closed under homomorphisms, subalgebras and products; equivalently,
\fi
\af{V} \ab{ùí¶} ‚äÜ \ab{ùí¶}.\footnote{Recall, \af{V} \ab{ùí¶} := \af{H} (\af{S} (\af{P} \ab{ùí¶})),
and observe that \ab{ùí¶} ‚äÜ \af{V} \ab{ùí¶} holds for all \ab{ùí¶} since
\af{V} is a closure operator.}
We call \ab{ùí¶} an \emph{equational class} if it is precisely the class of all models of some set of identities.

It is easy to prove that \emph{every equational class is a variety}.  Indeed, suppose \ab{ùí¶} is an equational
class axiomatized by the set \ab{‚Ñ∞} of term identities; that is, \ab{ùë®} ‚àà \ab{ùí¶} iff
\ab{ùë®} \af{‚ä®} \ab{‚Ñ∞}. Since the classes \af H \ab{ùí¶}, \af S \ab{ùí¶}, \af P \ab{ùí¶} and
\ab{ùí¶} all satisfy the same set of equations, we have \af{V} \ab{ùí¶} \af{‚ä´} \ab p
\af{‚âà} \ab q for all (\ab p , \ab q) \af{‚àà} \ab{‚Ñ∞}, so \af{V} \ab{ùí¶} ‚äÜ \ab{ùí¶}.

The converse assertion---that \emph{every variety is an equational class}---is less obvious.
Let \ab{ùí¶} be an arbitrary variety.  We will describe a set of equations that axiomatizes
\ab{ùí¶}.  A natural choice is the set
\af{Th} \ab{ùí¶} of all equations that hold in \ab{ùí¶}. Define \ab{ùí¶‚Å∫} = \af{Mod} (\af{Th}
\ab{ùí¶}).  Clearly, \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶‚Å∫}. We prove the reverse inclusion. Let \ab{ùë®}
\af{‚àà} \ab{ùí¶‚Å∫}; it suffices to find an algebra \ab{ùë≠} \af{‚àà} \af{S} (\af{P} \ab{ùí¶}) such
that \ab{ùë®} is a homomorphic image of \ab{ùë≠}, as this will show that \ab{ùë®}
\af{‚àà} \af{H} (\af{S} (\af{P} \ab{ùí¶})) = \ab{ùí¶}.

Let \ab{X} be such that there exists a \emph{surjective} environment
\ab{œÅ} : \ab{X} \as{‚Üí} \af{ùïå[~\ab{ùë®}~]}.
%\footnote{This is usually done by assuming \ab{X} has cardinality at least max(|~\af{ùïå[~\ab{ùë®}~]}~|, œâ).}
By the \af{lift-hom} lemma, there is an epimorphism \ab{h} from \T{X} onto \af{ùïå[~\ab{ùë®}~]}
that extends \ab{œÅ}.
Now, put \aof{ùîΩ[~\ab{X}~]}~:=~\T{X}/\ab{Œò}, and let \ab{g} : \T{X} \as{‚Üí} \aof{ùîΩ[~\ab{X}~]}
be the natural epimorphism with kernel \ab{Œò}. We claim that \af{ker} \ab g \af{‚äÜ}
\af{ker} \ab h. If the claim is true, then there is a map \ab{f} : \aof{ùîΩ[~\ab{X}~]} \as{‚Üí} \ab{ùë®}
such that \ab f \af{‚àò} \ab g = \ab h. Since \ab h is surjective, so is \ab f. Hence \ab{ùë®}
\af{‚àà} \af{ùñß} (\af{ùîΩ} \ab X) \aof{‚äÜ} \ab{ùí¶‚Å∫} completing the proof.
To prove the claim, let \ab u , \ab v \af{‚àà} \T{X} and assume that \ab g \ab u =
\ab g \ab v. Since \T{X} is generated by \ab X, there are terms \ab p, \ab q ‚àà
\T{X} such that \ab u = \af{‚ü¶~\T{X}~‚üß} \ab p and v = \af{‚ü¶~\T{X}~‚üß} \ab
q.\footnote{Recall, \af{‚ü¶~\ab{ùë®}~‚üß} \ab t denotes the interpretation of the term
\ab t in the algebra \ab{ùë®}.} Therefore,\\[-4pt]

\af{‚ü¶~\Free{X}~‚üß} \ab p = \ab g (\af{‚ü¶~\T{X}~‚üß} \ab p) = \ab g \ab u = \ab g \ab v =
\ab g (\af{‚ü¶~\T{X}~‚üß} \ab q) = \af{‚ü¶~\Free{X}~‚üß} \ab q,\\[8pt]
so \ab{ùí¶} \af{‚ä´} \ab p \af{‚âà} \ab q, so (\ab p , \ab q) \af{‚àà} \af{Th}
\ab{ùí¶}. Since \ab{ùë®} \af{‚àà} \ab{ùí¶‚Å∫} =
\af{Mod} (\af{Th} \ab{ùí¶}), we obtain \ab{ùë®} \af{‚äß} \ab p \af{‚âà} \ab q, so \ab h
\ab u = (\af{‚ü¶~\ab{ùë®}~‚üß} \ab p) \aofld{‚ü®\$‚ü©} \ab{œÅ} = (\af{‚ü¶~\ab{ùë®}~‚üß} \ab q)
\aofld{‚ü®\$‚ü©} \ab{œÅ} = \ab h \ab v, as desired.

\subsection{Formal proof}
We now show how to formally express and prove the twin assertions that
(i) every equational class is a variety and (ii) every variety is an equational class.

\paragraph*{Every equational class is a variety}
For (i), we need an arbitrary equational class. To obtain one, we start with an arbitrary
collection \ab{‚Ñ∞} of equations and let \ab{ùí¶} = \af{Mod} \ab{‚Ñ∞}, the equational class
determined by \ab{‚Ñ∞}. We prove that \ab{ùí¶} is a variety by showing that
\ab{ùí¶} = \af{V} \ab{ùí¶}. The inclusion \ab{ùí¶} \aof{‚äÜ} \af V \ab{ùí¶}, which holds for all
classes \ab{ùí¶}, is called the \defn{expansive} property of \af{V}. The converse inclusion
\af V \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}, on the other hand, requires the hypothesis that \ab{ùí¶} is an
equation class. We now formalize each of these inclusions.

\ifshort\else
\begin{code}

module _ (ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)){X : Type (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} where
 private Œπ = ov (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)
\end{code}
\fi
\begin{code}

 V-expa : ùí¶ ‚äÜ V ‚Ñì Œπ ùí¶
 V-expa {x = ùë®} kA = ùë® ,(ùë® ,(‚ä§ ,(Œª _ ‚Üí ùë®), (Œª _ ‚Üí kA), Goal), ‚â§-reflexive), IdHomImage
  where
  open Setoid ùîª[ ùë® ] using ( refl )
  open Setoid ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ] using () renaming ( refl to refl‚®Ö )

  to‚®Ö : ùîª[ ùë® ] ‚ü∂ ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ]
  (to‚®Ö ‚ü®$‚ü© x) = Œª _ ‚Üí x
  cong to‚®Ö xy = Œª _ ‚Üí xy

  from‚®Ö : ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ] ‚ü∂ ùîª[ ùë® ]
  (from‚®Ö ‚ü®$‚ü© x) = x tt
  cong from‚®Ö xy = xy tt

  Goal : ùë® ‚âÖ ‚®Ö (Œª x ‚Üí ùë®)
  Goal = mkiso (to‚®Ö , mkhom refl‚®Ö) (from‚®Ö , mkhom refl) (Œª _ _ ‚Üí refl) (Œª _ ‚Üí refl)

\end{code}
Earlier we proved the identity preservation lemma,
\af{V-id1} : \ab{ùí¶} \aof{‚ä´} \ab p \aof{‚âà} \ab q \as{‚Üí} \af{V} \ab{‚Ñì} \ab{Œπ} \ab{ùí¶} \aof{‚ä´} \ab p \aof{‚âà} \ab q.
Thus, if \ab{ùí¶} is an equational class, then \af V \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}, as we now confirm.

\begin{code}

module _ {‚Ñì : Level}{X : Type ‚Ñì}{‚Ñ∞ : {Y : Type ‚Ñì} ‚Üí Pred (Term Y √ó Term Y) (ov ‚Ñì)} where
 private ùí¶ = Mod{Œ± = ‚Ñì}{‚Ñì}{X} ‚Ñ∞     -- an arbitrary equational class
 EqCl‚áíVar : V ‚Ñì (ov ‚Ñì) ùí¶ ‚äÜ ùí¶
 EqCl‚áíVar {ùë®}vA{p}{q} p‚Ñ∞q œÅ = V-id1{‚Ñì = ‚Ñì}{ùí¶ = ùí¶}{p}{q}(Œª _ x œÑ ‚Üí x p‚Ñ∞q œÑ)ùë® vA œÅ

\end{code}
Together, \af{V-expa} and \af{Eqcl‚áíVar} prove that every equational class is a variety.


\paragraph*{Every variety is an equational class}
To prove statement (ii), we need an arbitrary variety; to obtain one, we start with an arbitrary class
\ab{ùí¶} of \ab{ùëÜ}-algebras and take its \emph{varietal closure}, \af{V} \ab{ùí¶}.
We prove that \af{V} \ab{ùí¶} is an equational class by showing it is precisely the collection of
algebras that model the equations in \af{Th} (\af{V} \ab{ùí¶}); that is, we prove
\af{V} \ab{ùí¶} = \af{Mod} (\af{Th} (\af{V} \ab{ùí¶})).
The inclusion \af{V} \ab{ùí¶} \aof{‚äÜ} \af{Mod} (\af{Th} (\af{V} \ab{ùí¶})) is a simple consequence of the fact that \af{Mod} \af{Th} is a closure operator. Nonetheless, completeness demands
that we formalize this fact, however trivial is its proof.

\ifshort\else
\begin{code}

module _ (ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)){X : Type (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c
\end{code}
\fi
\begin{code}

 ModTh-closure : V{Œ≤ = Œ≤}{œÅ·µá}{Œ≥}{œÅ·∂ú}{Œ¥}{œÅ·µà} ‚Ñì Œπ ùí¶ ‚äÜ Mod{X = X} (Th (V ‚Ñì Œπ ùí¶))
 ModTh-closure {x = ùë®} vA {p}{q} x œÅ = x ùë® vA œÅ

\end{code}

It remains to prove the converse inclusion, \af{Mod} (\af{Th} (V ùí¶)) \aof{‚äÜ} \af{V} \ab{ùí¶},
which is the main focus of the rest of the paper.  We proceed as follows:

\begin{enumerate}
\item \label{item:1} Let \ab{ùë™} be the product of all algebras in \af{S} \ab{ùí¶}, so that \ab{ùë™} \af{‚àà} \af{P} (\af{S} \ab{ùí¶}).
\item Prove \af{P} (\af{S} \ab{ùí¶}) \af{‚äÜ} \af{S} (\af{P} \ab{ùí¶}), so \ab{ùë™} \af{‚àà} \af{S} (\af{P} \ab{ùí¶}) by item~\ref{item:1}.
\item Prove \aof{ùîΩ[ \ab{X} ]} \af{‚â§} \ab{ùë™}, so that \aof{ùîΩ[ \ab{X} ]} \af{‚àà} \af{S} (\af{S} (\af{P} \ab{ùí¶})) (= \af{S} (\af{P} \ab{ùí¶})).
\item Prove that every algebra in \af{Mod} (\af{Th} (V ùí¶)) is a homomorphic image of
\aof{ùîΩ[ \ab{X} ]} and thus belongs to \af{H} (\af{S} (\af{P} \ab{ùí¶})) (= \af{V} \ab{ùí¶}).
\end{enumerate}

To define \ab{ùë™} as the product of all algebras in \af{S} \ab{ùí¶}, we must first indexing the class \af{S} \ab{ùí¶}.
In fact, we will need to associate each ``indexing pair'' (\ab{ùë®} , \ab p) (where \ab p : \ab{ùë®} \af{‚àà} \af{S} \ab{ùí¶}) with an arbitrary environment
\ab{œÅ} : \ab X \as{‚Üí} \aof{ùïå[ \ab{ùë®} ]}. Consequently, the indices of the product will be triples (\ab{ùë®} , \ab p, \ab{œÅ}) ranging over all algebras in \af{S} \ab{ùí¶} and all
environments assigning values in the domain of \ab{ùë®} to variables in \ab X.  Here is the construction of \ab{ùë™}.

\ifshort\else
\begin{code}

 open FreeHom {‚Ñì = ‚Ñì} {ùí¶}
 open FreeAlgebra {œá = c}(Th ùí¶)  using ( ùîΩ[_] )
 open Environment                using ( Env )
\end{code}
\fi
\begin{code}

 ‚Ñë‚Å∫ : Type Œπ
 ‚Ñë‚Å∫ = Œ£[ ùë® ‚àà (Algebra Œ± œÅ·µÉ) ] (ùë® ‚àà S ‚Ñì ùí¶) √ó (Carrier (Env ùë® X))

 ùîÑ‚Å∫ : ‚Ñë‚Å∫ ‚Üí Algebra Œ± œÅ·µÉ
 ùîÑ‚Å∫ i = ‚à£ i ‚à£

 ùë™ : Algebra Œπ Œπ
 ùë™ = ‚®Ö ùîÑ‚Å∫
\end{code}

\ifshort\else
\begin{code}

 skEqual : (i : ‚Ñë‚Å∫) ‚Üí ‚àÄ{p q} ‚Üí Type œÅ·µÉ
 skEqual i {p}{q} = ‚ü¶ p ‚üß ‚ü®$‚ü© snd ‚à• i ‚à• ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© snd ‚à• i ‚à•
  where open Setoid ùîª[ ùîÑ‚Å∫ i ] using ( _‚âà_ ) ; open Environment (ùîÑ‚Å∫ i) using ( ‚ü¶_‚üß )

\end{code}
The type \af{skEqual} provides a term identity \ab p \af{‚âà} \ab q for each index \ab i = (\ab{ùë®} , \ab{p} , \ab{œÅ}) of the product.
%(here, as above, \ab{ùë®} is an algebra, \ab{sA} is a proof that \ab{ùë®} belongs to \af{S} \ab{ùí¶}, and \ab{œÅ} is an environment).
%map assigning values in the domain of \ab{ùë®} to variable symbols in \ab X).
Later we prove that if the identity \ab{p} \af{‚âà} \ab q holds in all \ab{ùë®} \aof{‚àà} \af S \ab{ùí¶} (for all environments), then \ab p \af{‚âà} \ab q
holds in the relatively free algebra \Free{X}; equivalently, the pair (\ab p , \ab q) belongs to the
kernel of the natural homomorphism from \T{X} onto \Free{X}. We will use that fact to prove
that the kernel of the natural hom from \T{X} to \ab{ùë™} is contained in the kernel of the natural hom from \T{X} onto \Free{X},
whence we construct a monomorphism from \Free{X} into \ab{ùë™}, and thus \Free{X} is a subalgebra of \ab{ùë™},
so belongs to \af S (\af P \ab{ùí¶}).
\fi

\begin{code}

 homC : hom (ùëª X) ùë™
 homC = ‚®Ö-hom-co ùîÑ‚Å∫ (Œª i ‚Üí lift-hom (snd ‚à• i ‚à•))
\end{code}
\ifshort\else
\begin{code}

 kerF‚äÜkerC : ker ‚à£ homF[ X ] ‚à£ ‚äÜ ker ‚à£ homC ‚à£
 kerF‚äÜkerC {p , q} pKq (ùë® , sA , œÅ) = Goal
  where
  open Setoid ùîª[ ùë® ]  using ( _‚âà_ ; sym ; trans )
  open Environment ùë®  using ( ‚ü¶_‚üß )
  fl : ‚àÄ t ‚Üí ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ ‚âà free-lift œÅ t
  fl t = free-lift-interp {ùë® = ùë®} œÅ t

  Œ∂ : ‚àÄ{p q} ‚Üí (Th ùí¶) ‚ä¢ X ‚ñπ p ‚âà q ‚Üí ùí¶ ‚ä´ p ‚âà q
  Œ∂ x ùë® kA = sound (Œª y œÅ ‚Üí y ùë® kA œÅ) x where open Soundness (Th ùí¶) ùë®

  subgoal : ‚ü¶ p ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© œÅ
  subgoal = S-id1{‚Ñì = ‚Ñì}{p = p}{q} (Œ∂ pKq) ùë® sA œÅ
  Goal : (free-lift{ùë® = ùë®} œÅ p) ‚âà (free-lift{ùë® = ùë®} œÅ q)
  Goal = trans (sym (fl p)) (trans subgoal (fl q))
\end{code}
\fi
\begin{code}

 homFC : hom ùîΩ[ X ] ùë™
 homFC = ‚à£ HomFactor ùë™ homC homF[ X ] kerF‚äÜkerC (isSurjective ‚à• epiF[ X ] ‚à•) ‚à£

\end{code}
If \AgdaPair{p}{q} belongs to the kernel of \af{homùë™}, then
\af{Th} \ab{ùí¶} includes the identity \ab{p} \af{‚âà} \ab{q}---that is,
\af{Th} \ab{ùí¶} \af{‚ä¢} \ab X \af{‚ñπ} \ab{p} \af{‚âà} \ab{q}. Equivalently,
if the kernel of \af{homùë™} is contained in that of \af{homùîΩ[ X ]}.
\ifshort
We omit the formal proof of this lemma and merely display its formal statement.
\else
We formalize this fact as follows.
\fi

\begin{code}

 kerC‚äÜkerF : ‚àÄ{p q} ‚Üí (p , q) ‚àà ker ‚à£ homC ‚à£ ‚Üí (p , q) ‚àà ker ‚à£ homF[ X ] ‚à£
\end{code}
\ifshort
\vskip2mm
\else
\begin{code}
 kerC‚äÜkerF {p}{q} pKq = Sùí¶‚ä´‚ÜíkerùîΩ (Sùí¶‚ä´ pqEqual)
  where
  Sùí¶‚ä´ : (‚àÄ i ‚Üí skEqual i {p}{q}) ‚Üí S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶ ‚ä´ p ‚âà q
  Sùí¶‚ä´ x ùë® sA œÅ = x (ùë® , sA , œÅ)
  Sùí¶‚ä´‚ÜíkerùîΩ : S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶ ‚ä´ p ‚âà q ‚Üí (p , q) ‚àà ker ‚à£ homF[ X ] ‚à£
  Sùí¶‚ä´‚ÜíkerùîΩ x = hyp (S-id2{‚Ñì = ‚Ñì}{p = p}{q} x)

  pqEqual : ‚àÄ i ‚Üí skEqual i {p}{q}
  pqEqual i = goal
   where
   open Environment (ùîÑ‚Å∫ i)  using ( ‚ü¶_‚üß )
   open Setoid ùîª[ ùîÑ‚Å∫ i ]    using ( _‚âà_ ; sym ; trans )
   goal : ‚ü¶ p ‚üß ‚ü®$‚ü© snd ‚à• i ‚à• ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© snd ‚à• i ‚à•
   goal  = trans (free-lift-interp{ùë® = ‚à£ i ‚à£}(snd ‚à• i ‚à•) p)
         ( trans (pKq i)(sym (free-lift-interp{ùë® = ‚à£ i ‚à£} (snd ‚à• i ‚à•) q)))

\end{code}
\fi
\noindent We conclude that the homomorphism from \Free{X} to \af{ùë™} is injective, whence \Free{X} is (isomorphic to) a subalgebra of \af{ùë™}.

\begin{code}

 monFC : mon ùîΩ[ X ] ùë™
 monFC = ‚à£ homFC ‚à£ , isMon
  where
  isMon : IsMon ùîΩ[ X ] ùë™ ‚à£ homFC ‚à£
  isHom isMon = ‚à• homFC ‚à•
  isInjective isMon {p}{q} œÜpq = kerC‚äÜkerF œÜpq

 F‚â§C : ùîΩ[ X ] ‚â§ ùë™
 F‚â§C = mon‚Üí‚â§ monFC

\end{code}
Using the last result we prove that \Free{X} belongs to \af{S} (\af{P} \ab{ùí¶}). This
requires one more technical lemma concerning the classes \af{S} and \af{P}; specifically,
\ifshort
\af{P} (\af{S} \ab{ùí¶}) \aof{‚äÜ} \af{S} (\af{P} \ab{ùí¶}) holds for every class \ab{ùí¶}.
The \agdaalgebras library contains the formal statement and proof of this result, where
it is called \af{PS‚äÜSP} (\seeshort).
\else
a product of subalgebras of algebras in a class is a subalgebra of a product of algebras in the class;
in other terms, \af{P} (\af{S} \ab{ùí¶}) \aof{‚äÜ} \af{S} (\af{P} \ab{ùí¶}), for every class \ab{ùí¶}.
We state and prove this in Agda as follows.

\begin{code}

 private a = Œ± ‚äî œÅ·µÉ ; oa‚Ñì = ov (a ‚äî ‚Ñì)

 PS‚äÜSP : P (a ‚äî ‚Ñì) oa‚Ñì (S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶) ‚äÜ S oa‚Ñì (P ‚Ñì oa‚Ñì ùí¶)
 PS‚äÜSP {ùë©} (I , ( ùíú , sA , B‚âÖ‚®ÖA )) = Goal
  where
  ‚Ñ¨ : I ‚Üí Algebra Œ± œÅ·µÉ
  ‚Ñ¨ i = ‚à£ sA i ‚à£
  kB : (i : I) ‚Üí ‚Ñ¨ i ‚àà ùí¶
  kB i =  fst ‚à• sA i ‚à•
  ‚®ÖA‚â§‚®ÖB : ‚®Ö ùíú ‚â§ ‚®Ö ‚Ñ¨
  ‚®ÖA‚â§‚®ÖB = ‚®Ö-‚â§ Œª i ‚Üí snd ‚à• sA i ‚à•
  Goal : ùë© ‚àà S{Œ≤ = oa‚Ñì}{oa‚Ñì}oa‚Ñì (P {Œ≤ = oa‚Ñì}{oa‚Ñì} ‚Ñì oa‚Ñì ùí¶)
  Goal = ‚®Ö ‚Ñ¨ , (I , (‚Ñ¨ , (kB , ‚âÖ-refl))) , (‚âÖ-trans-‚â§ B‚âÖ‚®ÖA ‚®ÖA‚â§‚®ÖB)

\end{code}
With this we can prove that \Free{X} belongs to \af{S} (\af{P} \ab{ùí¶}).
\fi

\begin{code}

 SPF : ùîΩ[ X ] ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
 SPF = ‚à£ spC ‚à£ , (fst ‚à• spC ‚à•) , (‚â§-transitive F‚â§C (snd ‚à• spC ‚à•))
  where
  psC : ùë™ ‚àà P (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) Œπ (S ‚Ñì ùí¶)
  psC = ‚Ñë‚Å∫ , (ùîÑ‚Å∫ , ((Œª i ‚Üí fst ‚à• i ‚à•) , ‚âÖ-refl))
  spC : ùë™ ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
  spC = PS‚äÜSP psC

\end{code}
Finally, we prove that every algebra in \af{Mod} (\af{Th} (\af{V} \ab{ùí¶})) is a homomorphic image of \af{ùîΩ[~\ab{X}~]}.

\ifshort\else
\begin{code}

module _ {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c
 open FreeAlgebra {œá = c}(Th ùí¶) using ( ùîΩ[_] )
\end{code}
\fi
\begin{code}

 Var‚áíEqCl : ‚àÄ ùë® ‚Üí ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí ùë® ‚àà V ‚Ñì Œπ ùí¶
 Var‚áíEqCl ùë® ModThA = ùîΩ[ ùïå[ ùë® ] ] , (spFA , AimgF)
  where
  spFA : ùîΩ[ ùïå[ ùë® ] ] ‚àà S{Œπ} Œπ (P ‚Ñì Œπ ùí¶)
  spFA = SPF{‚Ñì = ‚Ñì} ùí¶
  epiFlA : epi ùîΩ[ ùïå[ ùë® ] ] (Lift-Alg ùë® Œπ Œπ)
  epiFlA = F-ModTh-epi-lift{‚Ñì = ‚Ñì} (Œª {p q} ‚Üí ModThA{p = p}{q})
  œÜ : Lift-Alg ùë® Œπ Œπ IsHomImageOf ùîΩ[ ùïå[ ùë® ] ]
  œÜ = epi‚Üíontohom ùîΩ[ ùïå[ ùë® ] ] (Lift-Alg ùë® Œπ Œπ) epiFlA
  AimgF : ùë® IsHomImageOf ùîΩ[ ùïå[ ùë® ] ]
  AimgF = ‚àò-hom ‚à£ œÜ ‚à£ (from Lift-‚âÖ), ‚àò-IsSurjective _ _ ‚à• œÜ ‚à•(fromIsSurjective (Lift-‚âÖ{ùë® = ùë®}))

\end{code}
\af{ModTh-closure} and \af{Var‚áíEqCl} show that
\af{V} \ab{ùí¶} = \af{Mod} (\af{Th} (\af{V} \ab{ùí¶})) holds for every class \ab{ùí¶} of \ab{ùëÜ}-algebras.
Thus, every variety is an equational class. This completes the formal proof of Birkhoff's variety theorem.

%% -----------------------------------------------------------------------------
\section{Related work}
There have been a number of efforts to formalize parts of universal algebra in
type theory besides ours, most notably

\begin{enumerate}
\item
In~\cite{Capretta:1999}, Capretta formalized the basics of universal algebra in the
   Calculus of Inductive Constructions using the Coq proof assistant;
\item In~\cite{Spitters:2011}, Spitters and van der Weegen formalized the basics of universal algebra
   and some classical algebraic structures, also in the Calculus of Inductive Constructions using
   the Coq proof assistant and promoting the use of type classes;
\item In~\cite{Gunther:2018} Gunther et al developed what seemed (prior to the \agdaalgebras library) to be
   the most extensive library of formalized universal algebra to date; like \agdaalgebras, that work is based on dependent type theory, is programmed in Agda, and goes beyond the Noether isomorphism theorems to include some basic equational logic; although the coverage is less extensive than that of \agdaalgebras, Gunther et al do treat \emph{multi-sorted} algebras, whereas \agdaalgebras is currently limited to single sorted structures.
   \item In~\cite{Amato:2021}, ``Amato et al formalize multi-sorted algebras with finitary operators in UniMath. Limiting to finitary operators is due to the restrictions of the UniMath type theory, which does not have W-types nor user-defined inductive types. These restrictions also prompt the authors to code terms as lists of stack machine instructions rather than trees'' (quoting~\cite{Abel:2021}).
\item In~\cite{Lynge:2019}, ``Lynge and Spitters formalize multi-sorted algebras in HoTT, also restricting to finitary operators. Using HoTT they can define quotients as types, obsoleting setoids. They prove three isomorphism theorems concerning sub- and quotient algebras. A universal algebra or varieties are not formalized'' (quoting~\cite{Abel:2021}).
\item In~\cite{Abel:2021}, Abel gives a new formal proof of the soundness theorem and Birkhoff's completeness theorem for multi-sorted algebraic structures.
\end{enumerate}

%Some other projects aimed at formalizing mathematics generally, and algebra in particular, have developed into very extensive libraries that include definitions, theorems, and proofs about algebraic structures, such as groups, rings, modules, etc.  However, the goals of these efforts seem to be the formalization of special classical algebraic structures, as opposed to the general theory of (universal) algebras. Moreover, the part of universal algebra and equational logic formalized in the \agdaalgebras library extends beyond the scope of prior efforts.

%Prior to our work, a constructive version of Birkhoff's theorem was published by Carlstr\"om in~\cite{Carlstrom:2008}.  However, the logical foundations of that work is constructive set theory and, as far as we know, there was no attempt to formalized it in type theory and verify it with a proof assistant.


\paragraph*{Acknowledgments}
This work would not have been possible without the wonderful \agda language and the
\agdastdlib, developed and
maintained by The Agda Team~\cite{agdastdlib}.
%(Andreas Abel, Guillaume Allais, Liang-Ting Chen, Jesper Cockx, Nils Anders Danielsson,
%V√≠ctor L√≥pez Juan, Ulf Norell, Andr√©s Sicard-Ram√≠rez,Andrea Vezzosi, and Tesla Ice Zhang)
%, maintained by Matthew Daggitt and Guillaume Allais.
Most of the content of this paper was generated from the literate \agda file \HSPlagda and the \LaTeX2e file \agdahsp (processed with the commands
\texttt{agda --latex} and \texttt{pdflatex}), which are available in the \agdaalgebras GitHub repository ({\small \url{https://github.com/ualib/agda-algebras}}).


