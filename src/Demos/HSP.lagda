\section{Introduction}
The Agda Universal Algebra Library (\agdaalgebras) is a collection of types and programs
(theorems and proofs) formalizing the foundations of universal algebra in dependent type
theory using the \agda programming language and proof assistant.
The agda-algebras library now includes a substantial collection of definitions, theorems, and
proofs from universal algebra and equational logic and as such provides many
examples that exhibit the power of inductive and dependent types for
representing and reasoning about general algebraic and relational structures.

The first major milestone of the \agdaalgebras project is a new formal
proof of \emph{Birkhoff's variety theorem} (also known as the \emph{HSP theorem}), the first version
of which was completed in \href{https://github.com/ualib/ualib.github.io/blob/b968e8af1117fc77700d3a588746cbefbd464835/sandbox/birkhoff-exp-new-new.lagda}{January of 2021}.
To the best of our knowledge, this was the first time Birkhoff's theorem had
been formulated and proved in dependent type theory and verified with a proof
assistant.

In this paper, we present a single Agda module called \ualmodule{Demos.HSP}.
This module extracts only those parts of the library needed to prove
Birkhoff's variety theorem. In order to meet page limit guidelines, and to
reduce strain on the reader, we omit proofs of some routine or technical
lemmas that do not provide much insight into the overall development.
However, a long version of this paper, which includes all code in the
\DemosHSP module, is available on the arXiv. [reference needed]

In the course of our exposition of the proof of the HSP theorem, we discuss some of the
more challenging aspects of formalizing \emph{universal algebra} in type theory and the
issues that arise when attempting to constructively prove some of the basic
results in this area.  We demonstrate that dependent type theory and Agda,
despite the demands they place on the user, are accessible to working
mathematicians who have sufficient patience and a strong enough desire to
constructively codify their work and formally verify the correctness of their
results.  Perhpas our presentation will be viewed as a sobering glimpse of the
painstaking process of doing mathematics in the languages of dependent type theory
using the Agda proof assistant. Nonetheless we hope to make a compelling case for
investing in these technologies. Indeed, we are excited to share the gratifying
rewards that come with some mastery of type theory and interactive theorem proving.

%% -----------------------------------------------------------------------------
\subsection{Prior art}
There have been a number of efforts to formalize parts of universal algebra in
type theory prior to ours, most notably

\begin{enumerate}
\item
In~\cite{Capretta:1999}, Capretta formalized the basics of universal algebra in the
   Calculus of Inductive Constructions using the Coq proof assistant;
\item In~\cite{Spitters:2011}, Spitters and van der Weegen formalized the basics of universal algebra
   and some classical algebraic structures, also in the Calculus of Inductive Constructions using
   the Coq proof assistant and promoting the use of type classes;
\item In~\cite{Gunther:2018} Gunther, et al developed what was (prior to the \agdaalgebras library)
   the most extensive library of formalized universal algebra to date; like \agdaalgebras, that work is based on dependent type theory, is programmed in Agda, and goes beyond the Noether isomorphism theorems to include some basic equational logic; although the coverage is less extensive than that of \agdaalgebras, Gunther et al do treat \emph{multisorted} algebras, whereas \agdaalgebras is currently limited to single sorted structures.
\item Lynge and Spitters [@Lynge:2019] (2019) formalize basic, mutisorted universal algebra, up to the
   Noether isomorphism theorems, in homotopy type theory; in this setting, the authors can avoid using
   setoids by postulating a strong extensionality axiom called \textit{univalence}.
\end{enumerate}

Some other projects aimed at formalizing mathematics generally, and algebra in particular, have developed into very extensive libraries that include definitions, theorems, and proofs about algebraic structures, such as groups, rings, modules, etc.  However, the goals of these efforts seem to be the formalization of special classical algebraic structures, as opposed to the general theory of (universal) algebras. Moreover, the part of universal algebra and equational logic formalized in the \agdaalgebras library extends beyond the scope of prior efforts.

% After completing the formal proof in \agda, we learned about a constructive version of Birkhoff's theorem proved by Carlstr\"om in~\cite{Carlstrom:2008}.  The latter is presented in the informal style of standard mathematical writing, and as far as we know it was never formalized in type theory and type-checked with a proof assistant. Nonetheless, a comparison of Carlstr\"om's proof and the \ualib proof would be interesting.




% <!-- ----------------------------------------------------------------------------------- -->

\section{Preliminaries}

\subsection{Logical foundations}

An Agda program typically begins by setting some language options and by
importing types from existing Agda libraries. The language options are specified
using the \ak{OPTIONS} \emph{pragma} which affect control the way Agda behaves by controlling
the deduction rules that are available to us and the logical axioms 
that are assumed when the program is type-checked by Agda to verify its
correctness. Every Agda program in the agda-algebras library, including the
present module (\DemosHSP), begins with the following line.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

\end{code}

We give only very terse descriptions of these options, and refer the reader to
the accompanying links for more details.

\begin{itemize}
\item
\AgdaPragma{without-K} disables \href{https://ncatlab.org/nlab/show/axiom+K+%28type+theory%29}{Streicher's K axiom}.
See the \href{https://agda.readthedocs.io/en/v2.6.1/language/without-k.html}{section on axiom K} in the \href{https://agda.readthedocs.io/en/v2.6.1.3/language}{Agda Language Reference Manual}~\cite{agdaref-axiomk}.

\item
\AgdaPragma{exact-split} makes Agda accept only those definitions that behave like so-called {\it judgmental} equalities.
See the \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#pattern-matching-and-equality}%
{Pattern matching and equality} section of the \href{https://agda.readthedocs.io/en/v2.6.1.3/tools/}{Agda Tools} documentation~\cite{agdatools-patternmatching}.

\item
\AgdaPragma{safe} ensures that nothing is postulated outright---every non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module).
See the \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#cmdoption-safe}{cmdoption-safe}
section of the \href{https://agda.readthedocs.io/en/v2.6.1.3/tools/}{Agda Tools documentation} and the \href{https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html#safe-agda}{Safe Agda section} of the \href{https://agda.readthedocs.io/en/v2.6.1.3/language}{Agda Language Reference}~\cite{agdaref-safeagda}.
\end{itemize}


The \AgdaKeyword{OPTIONS} pragma is usually followed by the start of a module and a list of import directives.
For example, the collection of imports required for the present module, \DemosHSP, is relatively modest and appears below.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

open import Algebras.Basic using ( ùìû ; ùì• ; Signature )

module Demos.HSP {ùëÜ : Signature ùìû ùì•} where

open import  Agda.Primitive               using     ( _‚äî_ ; lsuc )
                                          renaming  ( Set to Type )
open import  Data.Product                 using     ( _√ó_  ; Œ£-syntax ; _,_ ; Œ£ )
                                          renaming  ( proj‚ÇÅ to  fst ; proj‚ÇÇ to snd )
open import  Function                     using     ( id ; Surjection ; flip ; Injection ; _‚àò_ )
                                          renaming  ( Func to _‚ü∂_ )
open import  Level                        using     ( Level )
open import  Relation.Binary              using     ( Setoid ; IsEquivalence ; Rel )
open import  Relation.Binary.Definitions  using     ( Sym ; Symmetric ; Trans ; Transitive ; Reflexive )
open import  Relation.Binary.PropositionalEquality
                                          using     ( _‚â°_ )
open import  Relation.Unary               using     ( Pred ; _‚äÜ_ ; _‚àà_ )

import  Function.Definitions                   as FD
import  Relation.Binary.PropositionalEquality  as ‚â°
import  Relation.Binary.Reasoning.Setoid       as SetoidReasoning

open _‚ü∂_     using ( cong ) renaming ( f to _‚ü®$‚ü©_ )

\end{code}
\ifshort\else
\begin{code}
open Setoid  using ( Carrier ; isEquivalence )
private variable
 Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà œÅ œá ‚Ñì : Level
 Œì Œî : Type œá
 ùëì : fst ùëÜ
\end{code}
\fi
Note, in particular, we prefer to use \AgdaPrimitive{Type} to denote the
built-in \AgdaPrimitive{Set} type, and the infix long arrow symbol,
\AgdaRecord{\AgdaUnderscore{}‚ü∂\AgdaUnderscore{}}, to denote the \AgdaRecord{Func}
type of the standard library.  We use \AgdaField{fst} and \AgdaField{snd} in
place of \AgdaField{proj‚ÇÅ} and  \AgdaField{proj‚ÇÇ} for the first and second
projections out of the product type,
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}√ó\AgdaUnderscore{}}}, and,
when it improves readability of the code, we use the alternative notation
\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}} and
\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}} (resp.) for these projections.
\ifshort
\else
\begin{code}
module _ {A : Type Œ± }{B : A ‚Üí Type Œ≤} where

 ‚à£_‚à£ : Œ£[ x ‚àà A ] B x ‚Üí A
 ‚à£_‚à£ = fst

 ‚à•_‚à• : (z : Œ£[ a ‚àà A ] B a) ‚Üí B ‚à£ z ‚à£
 ‚à•_‚à• = snd
\end{code}
\fi

%% -----------------------------------------------------------------------------
\subsection{Setoids}
A \emph{setoid} is a type packaged with an equivalence relation on the collection
of inhabitants of that type.  Setoids are useful for representing classical
(set-theory-based) mathematics in a constructive, type-theoretic way because
most mathematical structures are assumed to come equipped with some (often
implicit) equivalence relation manifesting a notion of equality of elements,
and therefore a type-theoretic representation of such a structure should
also model its equality relation.

The \agdaalgebras library was first developed without the use of setoids,
opting instead for specially constructed experimental quotient types.
However, this approach resulted in code that was hard to comprehend and
it became difficult to determine whether the resulting proofs were fully
constructive.  In particular, our initial proof of the Birkhoff variety theorem
required postulating function extensionality, an axiom that is not provable in
pure Martin-L√∂f type theory (MLTT). [reference needed]

In contrast, our current approach using setoids makes the equality relation
of a given type explicit and this transparency can make it easier to determine the
correctness and constructivity of the proofs. Using setiods we need
no additional axioms beyond MLTT; in particular, no function
extensionality axioms are postulated in our current formalization of Birkhoff's
variety theorem.

%% -----------------------------------------------------------------------------
\subsection{Setoid functions}
In addition to the \ar{Setoid} type, much of our code employs the
standard library's \ar{Func} type which represents a function from one
setoid to another and packages such a function with a proof (called \afld{cong}) that
the function respects the underlying setoid equalities. As mentioned above, we renamed
\ar{Func} to the more visually appealing infix long arrow symbol,
\AgdaRecord{\AgdaUnderscore{}‚ü∂\AgdaUnderscore{}}, and  throughout the paper we
refer to inhabitants of this type as ``setoid functions.''

\ifshort\else
An example of a setoid function is the identity function from a setoid to itself.
We define it, along with a binary composition operation for setoid functions, \AgdaOperator{\AgdaFunction{‚ü®‚àò‚ü©}}, as follows.

\begin{code}

ùëñùëë : {A : Setoid Œ± œÅ·µÉ} ‚Üí A ‚ü∂ A
ùëñùëë {A} = record { f = id ; cong = id }

_‚ü®‚àò‚ü©_ :  {A : Setoid Œ± œÅ·µÉ} {B : Setoid Œ≤ œÅ·µá} {C : Setoid Œ≥ œÅ·∂ú}
 ‚Üí       B ‚ü∂ C  ‚Üí  A ‚ü∂ B  ‚Üí  A ‚ü∂ C

f ‚ü®‚àò‚ü© g = record  { f = (_‚ü®$‚ü©_ f) ‚àò (_‚ü®$‚ü©_ g)
                  ; cong = (cong f) ‚àò (cong g) }
\end{code}
\fi

\paragraph*{Inverses of setoid functions}
We define a data type that represents the semantic concept of the \emph{image} of a function.\footnote{cf.~the \ualmodule{Overture.Func.Inverses} module of the \agdaalgebras library.}

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë© using ( _‚âà_ ; sym ) renaming ( Carrier to B )

 data Image_‚àã_ (f : ùë® ‚ü∂ ùë©) : B ‚Üí Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá) where
  eq : {b : B} ‚Üí ‚àÄ a ‚Üí b ‚âà f ‚ü®$‚ü© a ‚Üí Image f ‚àã b

\end{code}
An inhabitant of \aod{Image} \ab f \aod{‚àã} \ab b is a dependent pair \AgdaPair{a}{p},
where \AgdaTyped{a}{A} and \ab p~\as :~\ab b \aofld{‚âà} \ab f~\ab a is a proof that
\ab f maps \ab a to \ab b.  Since the proof that \ab b
belongs to the image of \ab f is always accompanied by a witness \AgdaTyped{a}{A}, we can
actually \emph{compute} a (pseudo)inverse of \ab f. For convenience, we define this
inverse function, which we call \af{Inv}, and which takes an arbitrary \AgdaTyped{b}{B} and
a (witness, proof)-pair, \AgdaPair{a}{p}~\as :~\aod{Image}~\ab f~\aod{‚àã}~\ab b, and returns the witness \ab a.

\begin{code}

 Inv : (f : ùë® ‚ü∂ ùë©){b : B} ‚Üí Image f ‚àã b ‚Üí Carrier ùë®
 Inv _ (eq a _) = a

 InvIsInverse ≥ : {f : ùë® ‚ü∂ ùë©}{b : B}(q : Image f ‚àã b) ‚Üí f ‚ü®$‚ü© (Inv f q) ‚âà b
 InvIsInverse ≥ (eq _ p) = sym p

\end{code}
The latter (\af{InvIsInverse ≥}) proves that \af{Inv} \ab f is the range-restricted right-inverse of the setoid function \ab f.



\paragraph*{Injective and surjective setoid functions}
If \ab{f} : \ab{ùë®} \aor{‚ü∂} \ab{ùë©} is a setoid function from \ab{ùë®} = (\ab{A} \AgdaComma \aofld{‚âà‚ÇÄ}) to
\ab{ùë©} = (\ab{B} \AgdaComma \aofld{‚âà‚ÇÅ}), then we call \ab f \emph{injective} provided \as{‚àÄ} (\ab{a‚ÇÄ} \ab{a‚ÇÅ} \as : \ab{A}),
\ab{f} \aofld{‚ü®\$‚ü©} \ab{a‚ÇÄ} \aofld{‚âà‚ÇÅ} \ab{f} \aofld{‚ü®\$‚ü©} \ab{a‚ÇÅ} implies \ab{a‚ÇÄ} \aofld{‚âà‚ÇÄ} \ab{a‚ÇÅ};
we call \ab{f} \emph{surjective} provided \as{‚àÄ} (\AgdaTyped{b}{B}), \as{‚àÉ}~(\AgdaTyped{a}{A}) such that
\ab{f} \aofld{‚ü®\$‚ü©} \ab{a} \aofld{‚âà‚ÇÅ} \ab{b}.
The \agdastdlib represents injective functions on bare types by the
type \af{Injective}, and uses this to define the \af{IsInjective} type to represent
the property of being an injective setoid function. Similarly, the type \af{IsSurjective}
represents the property of being a surjective setoid function. \af{SurjInv} represents the \emph{right-inverse} of a surjective function.
         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
 We omit the relatively straightforward formal definitions of these types, but \seeunabridged, as well as formal proofs of some of their properties.
         %%%
\else    %%% END SHORT VERSION ONLY
         %%% BEGIN LONG VERSION ONLY SECTION
         %%%
 We reproduce the definitions and prove some of their properties
 inside the next submodule where we first set the stage by declaring two
 setoids \ab{ùë®} and \ab{ùë©}, naming their equality relations, and making some
 definitions from the standard library available.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë® using () renaming ( _‚âà_ to _‚âà‚ÇÅ_ )
 open Setoid ùë© using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ )
 open FD _‚âà‚ÇÅ_ _‚âà‚ÇÇ_

 IsInjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá)
 IsInjective f = Injective (_‚ü®$‚ü©_ f)

 IsSurjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá)
 IsSurjective F = ‚àÄ {y} ‚Üí Image F ‚àã y

 SurjInv : (f : ùë® ‚ü∂ ùë©) ‚Üí IsSurjective f ‚Üí Carrier ùë© ‚Üí Carrier ùë®
 SurjInv f fonto b = Inv f (fonto {b})

\end{code}

Proving that the composition of injective setoid functions is again injective
is simply a matter of composing the two assumed witnesses to injectivity.
Proving that surjectivity is preserved under composition is only slightly more involved.

\begin{code}

module _  {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá}{ùë™ : Setoid Œ≥ œÅ·∂ú}
          (f : ùë® ‚ü∂ ùë©)(g : ùë© ‚ü∂ ùë™) where

 ‚àò-IsInjective : IsInjective f ‚Üí IsInjective g ‚Üí IsInjective (g ‚ü®‚àò‚ü© f)
 ‚àò-IsInjective finj ginj = finj ‚àò ginj

 ‚àò-IsSurjective : IsSurjective f ‚Üí IsSurjective g ‚Üí IsSurjective (g ‚ü®‚àò‚ü© f)
 ‚àò-IsSurjective fonto gonto {y} = Goal
  where
  mp : Image g ‚àã y ‚Üí Image g ‚ü®‚àò‚ü© f ‚àã y
  mp (eq c p) = Œ∑ fonto
   where
   open Setoid ùë™ using ( trans )
   Œ∑ : Image f ‚àã c ‚Üí Image g ‚ü®‚àò‚ü© f ‚àã y
   Œ∑ (eq a q) = eq a (trans p (cong g q))

  Goal : Image g ‚ü®‚àò‚ü© f ‚àã y
  Goal = mp gonto
\end{code}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

\paragraph*{Kernels of setoid functions}
The \emph{kernel} of a function \ab f~\as :~\ab A~\as{‚Üí}~\ab B (where \ab A and \ab B are bare types) is defined
informally by
\begin{center}
\{\AgdaPair{x}{y} \aod{‚àà} \ab A \aof{√ó} \ab A \as : \ab f \ab x \as{=} \ab f \ab y \}.
\end{center}
This can be represented in Agda in a number of ways, but for our purposes it is most
convenient to define the kernel as an inhabitant of a (unary) predicate over the square of
the function's domain, as follows.

\begin{code}

module _ {A : Type Œ±}{B : Type Œ≤} where

 kernel : Rel B œÅ ‚Üí (A ‚Üí B) ‚Üí Pred (A √ó A) œÅ
 kernel _‚âà_ f (x , y) = f x ‚âà f y

\end{code}

The kernel of a \emph{setoid} function \ab f \as : \ab{ùê¥} \aor{‚ü∂} \ab{ùêµ} is \{\AgdaPair{x}{y} \as{‚àà} \ab A \aof{√ó} \ab A \as : \ab f \aofld{‚ü®\$‚ü©} \ab x \aofld{‚âà} \ab f \aofld{‚ü®\$‚ü©} \ab y\},
where \afld{\au{}‚âà\au} denotes equality in \ab{ùêµ}. This can be formalized in Agda as follows.

\begin{code}

module _ {ùê¥ : Setoid Œ± œÅ·µÉ}{ùêµ : Setoid Œ≤ œÅ·µá} where
 open Setoid ùê¥ using () renaming ( Carrier to A )

 ker : (ùê¥ ‚ü∂ ùêµ) ‚Üí Pred (A √ó A) œÅ·µá
 ker g (x , y) = g ‚ü®$‚ü© x ‚âà g ‚ü®$‚ü© y where open Setoid ùêµ using ( _‚âà_ )
\end{code}


%% -------------------------------------------------------------------------------------

\section{Types for Basic Universal Algebra}
\label{types-for-basic-universal-algebra}
In this section we develop a working vocabulary and formal types for classical,
single-sorted, set-based universal algebra.
We cover a number of important concepts, but we limit ourselves to those
concepts required in our formal proof of Birkhoff's HSP theorem.
In each case, we give a type-theoretic version of the informal definition,
followed by a formal implementation of the definition in Martin-L√∂f dependent
type theory using the Agda language.

This section is organized into the following subsections:
¬ß\ref{signatures-and-signature-types} defines a general notion of \emph{signature} of a structure and then defines a type that represent signatures;
¬ß¬ß\ref{algebras-and-algebra-types}--\ref{product-algebras} do the same for
for \emph{algebraic structures} and \emph{product algebras}, respectively;
¬ß\ref{homomorphisms} defines \emph{homomorphism}, \emph{monomorphism}, and \emph{epimorphism}, presents types that codify these concepts and formally verifies some of their basic properties;
¬ß¬ß\ref{subalgebras}--\ref{terms} do the same for \emph{subalgebra} and \emph{term}, respectively.


%% -----------------------------------------------------------------------------
\subsection{Signatures and signature types}
\label{signatures-and-signature-types}

In model theory, the \emph{signature} \ab{ùëÜ} = (\ab{ùê∂}, \ab{ùêπ}, \ab{ùëÖ}, \ab{œÅ})
of a structure consists of three (possibly empty) sets \ab{ùê∂}, \ab{ùêπ}, and
\ab{ùëÖ}---called \emph{constant}, \emph{function}, and
\emph{relation} symbols, respectively---along with a function \ab{œÅ} : \ab{ùê∂} \as{+}
\ab{ùêπ} \as{+} \ab{ùëÖ} \as{‚Üí} \ab{ùëÅ} that assigns an \emph{arity} to each symbol. Often, but
not always, \ab{ùëÅ} is taken to be the set of natural numbers.

As our focus here is universal algebra, we are more concerned with the
restricted notion of an \emph{algebraic signature}, that is, a signature for
``purely algebraic'' structures, by which is meant a pair \ab{ùëÜ} = \AgdaPair{F}{œÅ}
consisting of a collection \ab{F} of \emph{operation symbols} and a function
\ab{œÅ} : \ab{F} \as{‚Üí} \ab{N} which maps each operation symbol to its arity.
Here, \ab{ùëÅ} denotes the \emph{arity type}. Heuristically, the arity
\ab{œÅ} \ab{f} of an operation symbol \ab{f} \as{‚àà} \ab{F} may be thought of as
the number of arguments that \ab{f} takes as ``input.''


The \agdaalgebras library represents an (algebraic) signature as an
inhabitant of the following dependent pair type:

\begin{center}

\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Level}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPrimitive{lsuc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{))}\\[4pt]
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£[}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaFunction{‚àà}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{)}

\end{center}

Using special syntax for the first and second
projections---\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}} and
\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}} (resp.)---if
\ab{ùëÜ} \as{:} \af{Signature} \ab{ùìû} \ab{ùì•} is a signature, then
\aof{‚à£} \ab{ùëÜ} \aof{‚à£} denotes the set of operation symbols and \aof{‚à•} \ab{ùëÜ} \aof{‚à•} denotes the arity function.
Thus, if \ab{f} \as{:} \aof{‚à£} \ab{ùëÜ} \aof{‚à£} is an operation symbol in the
signature \ab{ùëÜ}, then \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab{f} is the arity of \ab{f}.

We need to augment the ordinary \af{Signature} type so that it supports algebras over setoid domains.
To do so, we follow Andreas Abel's lead [ref needed] and define an operator that translates an
ordinary signature into a \defn{setoid signature}, that is, a signature over a setoid
domain. This raises a minor technical issue concerning the dependent types
involved in the definition; some readers might find the resolution of this issue instructive, so let's discuss it.

Suppose we are given two operations \ab{f} and \ab{g}, a tuple \ab{u} \as{:} \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab{f} \as{‚Üí}
\ab{A} of arguments for \ab{f}, and a tuple \ab{v} \as{:} \aof{‚à•} \ab{ùëÜ}
\aof{‚à•} \ab{g} \as{‚Üí} \ab{A} of arguments for \ab{g}.  If we know that \ab f is identically equal to
\ab{g}---that is, \ab{f} \aod{‚â°} \ab{g} (intensionally)---then we should be able to
check whether \ab u and \ab v are pointwise equal.  Technically, though, \ab{u} and \ab{v} inhabit different types, so, before comparing them,
we must first convince Agda that \ab u and \ab v inhabit the same type. Of course,
this requires an appeal to the hypothesis \ab f \aod{‚â°} \ab g, as we see in the definition of \af{EqArgs} below
(adapted from Andreas Abel's development [ref needed]), which neatly resolves this minor technicality.

\begin{code}

EqArgs :  {ùëÜ : Signature ùìû ùì•}{Œæ : Setoid Œ± œÅ·µÉ}
 ‚Üí        ‚àÄ {f g} ‚Üí f ‚â° g ‚Üí (‚à• ùëÜ ‚à• f ‚Üí Carrier Œæ) ‚Üí (‚à• ùëÜ ‚à• g ‚Üí Carrier Œæ) ‚Üí Type (ùì• ‚äî œÅ·µÉ)

EqArgs {Œæ = Œæ} ‚â°.refl u v = ‚àÄ i ‚Üí u i ‚âà v i where open Setoid Œæ using ( _‚âà_ )

\end{code}

Finally, we are ready to define an operator which
translates an ordinary (algebraic) signature into a signature of algebras over setoids.
We denote this operator by \aof{‚ü®\AgdaUnderscore{}‚ü©} and define it as follows.

\begin{code}

module _ where
 open Setoid        using ( _‚âà_ )
 open IsEquivalence using ( refl ; sym ; trans )

 ‚ü®_‚ü© : Signature ùìû ùì• ‚Üí Setoid Œ± œÅ·µÉ ‚Üí Setoid _ _

 Carrier (‚ü® ùëÜ ‚ü© Œæ)              = Œ£[ f ‚àà ‚à£ ùëÜ ‚à£ ] (‚à• ùëÜ ‚à• f ‚Üí Œæ .Carrier)

 _‚âà_ (‚ü® ùëÜ ‚ü© Œæ) (f , u) (g , v)  = Œ£[ eqv ‚àà f ‚â° g ] EqArgs{Œæ = Œæ} eqv u v

 refl   (isEquivalence (‚ü® ùëÜ ‚ü© Œæ))                           = ‚â°.refl , Œª i ‚Üí Setoid.refl   Œæ
 sym    (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)              = ‚â°.refl , Œª i ‚Üí Setoid.sym    Œæ (g i)
 trans  (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)(‚â°.refl , h)  = ‚â°.refl , Œª i ‚Üí Setoid.trans  Œæ (g i) (h i)
\end{code}

%% -----------------------------------------------------------------------------
\subsection{Algebras and algebra types}
\label{algebras-and-algebra-types}
Informally, an \emph{algebraic structure in the signature} \ab{ùëÜ} = (\ab{F}, \ab{œÅ}) (or \ab{ùëÜ}-\emph{algebra}) is denoted by \ab{ùë®} = (\ab{A}, \ab{F·¥¨}) and consists of
\begin{itemize}
\item a \emph{nonempty} set (or type) \ab A, called the \emph{domain} of the algebra;
\item a collection \ab{F·¥¨} := \{ \ab{f·¥¨} \as{‚à£} \ab f \as{‚àà} \ab F, \ab{f·¥¨} \as : (\ab{œÅ} \ab f \as{‚Üí} \ab A) \as{‚Üí} \ab A \} of \emph{operations} on \ab{A};
\item a (potentially empty) collection of \emph{identities} satisfied by elements and operations of \ab{ùë®}.
\end{itemize}
The \agdaalgebras library represents algebras as the inhabitants of a record type with two fields:
\begin{itemize}
\item \afld{Domain}, representing the domain of the algebra;
\item \afld{Interp}, representing the \emph{interpretation} in the algebra of each operation symbol in \ab{ùëÜ}.
\end{itemize}
We now present the definition of the \ar{Algebra} type and explain how the standard library's \ar{Func} type is used to represent the interpretation of operation symbols in an algebra.\footnote{We postpone introducing identities until they are needed (e.g., for equational logic); see~¬ß\ref{model-theory-and-equational-logic}.}
\begin{code}

record Algebra Œ± œÅ : Type (ùìû ‚äî ùì• ‚äî lsuc (Œ± ‚äî œÅ)) where
 field  Domain : Setoid Œ± œÅ
        Interp : (‚ü® ùëÜ ‚ü© Domain) ‚ü∂ Domain

\end{code}
Recall, we renamed Agda's \ar{Func} type, prefering instead the long-arrow symbol \AgdaRecord{‚ü∂}, so
the \afld{Interp} field has type \ar{Func} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©} \afld{Domain}) \afld{Domain}, a record type with two fields:
\begin{itemize}
\item a function  \ab{f} \as : \afld{Carrier} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©} \afld{Domain})
  \as{‚Üí} \afld{Carrier} \afld{Domain} representing the operation;
\item a proof \afld{cong} \as : \ab f \ao{\af{Preserves}} \ao{\afld{\au{}‚âà‚ÇÅ\au}} \ao{\ar{‚ü∂}}
  \ao{\afld{\au{}‚âà‚ÇÇ\au}} that the operation preserves the relevant setoid equalities.
\end{itemize}
Thus, for each operation symbol in the signature \ab{ùëÜ}, we have a setoid function \ab f---with domain a power of \afld{Domain} and codomain \afld{Domain}---along with a proof that this function respects the setoid equalities.  The latter means that the operation \ab{f} is accompanied by a proof of the following: ‚àÄ \ab u \ab v in \afld{Carrier} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©} \afld{Domain}), if \ab u \afld{‚âà‚ÇÅ} \ab v, then \ab{f} \aofld{‚ü®\$‚ü©} \ab{u} \aofld{‚âà‚ÇÇ} \ab{f} \aofld{‚ü®\$‚ü©} \ab{v}.

In the \agdaalgebras library is defined some syntactic sugar that helps to make our formalizations easier to read and
comprehend.
%\footnote{We omit the formal definitions, but see [reference needed].}
The following are three examples of such syntax that we use below: if \ab{ùë®} is an algebra, then
\begin{itemize}
\item \aof{ùîª[ \ab{ùë®} ]} denotes the setoid \afld{Domain} \ab{ùë®},
\item \aof{ùïå[ \ab{ùë®} ]} is the underlying carrier or ``universe'' of the algebra \ab{ùë®}, and
\item \ab f \aof{ÃÇ} \ab{ùë®} denotes the interpretation in the algebra \ab{ùë®} of the operation symbol \ab f.
\end{itemize}
         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
 We omit the straightforward formal definitions of these types, but \seeunabridged.
         %%%
\else    %%% END SHORT VERSION ONLY
         %%% BEGIN LONG VERSION ONLY SECTION
         %%%
\begin{code}
open Algebra
ùîª[_] : Algebra Œ± œÅ·µÉ ‚Üí  Setoid Œ± œÅ·µÉ
ùîª[ ùë® ] = Domain ùë®
ùïå[_] : Algebra Œ± œÅ·µÉ ‚Üí  Type Œ±
ùïå[ ùë® ] = Carrier (Domain ùë®)
_ÃÇ_ : (f : ‚à£ ùëÜ ‚à£)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí (‚à• ùëÜ ‚à• f  ‚Üí  ùïå[ ùë® ]) ‚Üí ùïå[ ùë® ]
f ÃÇ ùë® = Œª a ‚Üí (Interp ùë®) ‚ü®$‚ü© (f , a)
\end{code}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

%% -----------------------------------------------------------------------------
\paragraph*{Universe levels of algebra types}
%\paragraph*{Agda's universe hierarchy}\label{agdas-universe-hierarchy}
The hierarchy of type universes in Agda is structured as follows:
\ap{Type} \ab{‚Ñì} : \ap{Type} (\ap{lsuc} \ab{‚Ñì}), \ap{Type} (\ap{lsuc} \ab{‚Ñì}) : \ap{Type} (\ap{lsuc} (\ap{lsuc} \ab{‚Ñì})), ‚Ä¶.
This means that \ap{Type} \ab{‚Ñì} has type \ap{Type} (\ap{lsuc} \ab{‚Ñì}), etc.  However, this does \emph{not} imply that
\ap{Type} \ab{‚Ñì} : \ap{Type} (\ap{lsuc} (\ap{lsuc} \ab{‚Ñì})). In other words, Agda's universe hierarchy is \emph{noncumulative}.
This can be advantageous as it becomes possible to treat universe levels more generally and precisely. On the other hand,
an unfortunate side-effect of this noncumulativity is that it sometimes seems unduly difficult to convince Agda that a program
or proof is correct.

This aspect of the language was one of the few stumbling blocks we encountered while learning how to use Agda for formalizing universal algebra in type theory.
Although some may consider this to be one of the least interesting and most annoying aspects of our work, others might find
this presentation most helpful if we resist the urge to gloss over the more technical and less elegant aspects of the library.
Therefore, we will show how to use the general universe lifting and lowering functions, available in the \agdastdlib,
to develop bespoke, domain-specific tools for dealing with the noncumulative universe hierarchy.

%\paragraph*{Lifting and lowering}
Let us be more concrete about what is at issue here by considering a typical example. Agda frequently encounters errors during the type-checking process and responds by printing an error message. Often the message has the following form.
{\color{red}{\small
\begin{verbatim}
  HSP.lagda:498,20-23
  Œ± != ùìû ‚äî ùì• ‚äî (lsuc Œ±) when checking that... has type...
\end{verbatim}}}
\noindent Here Agda informs us that it encountered universe level \ab{Œ±} on line 498 of the HSP module, where it was expecting level \ab{ùìû}~\aop{‚äî}~\ab{ùì•}~\aop{‚äî}~(\ap{lsuc} \ab{Œ±}).
For example, we may have tried to use an algebra inhabiting the type \ar{Algebra} \ab{Œ±} \ab{œÅ·µÉ} whereas we should have used one inhabiting the type \ar{Algebra} (\ab{ùìû} \aop{‚äî} \ab{ùì•} \aop{‚äî} (\ap{lsuc} \ab{Œ±})) \ab{œÅ·µÉ}.
One resolves such problems using the general \AgdaRecord{Lift} record type, available in the standard library, which takes a type inhabiting some universe and embeds it into a higher universe.
To apply this strategy in our domain of interest, we develop the following utility functions.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; refl ; sym ; trans ) ; open Level

 Lift-AlgÀ° : (‚Ñì : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì) œÅ·µÉ

 Domain (Lift-AlgÀ° ‚Ñì) =
  record  { Carrier        = Lift ‚Ñì ùïå[ ùë® ]
          ; _‚âà_            = Œª x y ‚Üí lower x ‚âà lower y
          ; isEquivalence  = record { refl = refl ; sym = sym ; trans = trans }}

 Interp (Lift-AlgÀ° ‚Ñì) ‚ü®$‚ü© (f , la) = lift ((f ÃÇ ùë®) (lower ‚àò la))
 cong (Interp (Lift-AlgÀ° ‚Ñì)) (‚â°.refl , lab) = cong (Interp ùë®) ((‚â°.refl , lab))


 Lift-Alg ≥ : (‚Ñì : Level) ‚Üí Algebra Œ± (œÅ·µÉ ‚äî ‚Ñì)

 Domain (Lift-Alg ≥ ‚Ñì) =
  record  { Carrier        = ùïå[ ùë® ]
          ; _‚âà_            = Œª x y ‚Üí Lift ‚Ñì (x ‚âà y)
          ; isEquivalence  = record  { refl  = lift refl
                                     ; sym   = lift ‚àò sym ‚àò lower
                                     ; trans = Œª x y ‚Üí lift (trans (lower x)(lower y)) }}

 Interp (Lift-Alg ≥ ‚Ñì ) ‚ü®$‚ü© (f , la) = (f ÃÇ ùë®) la
 cong (Interp (Lift-Alg ≥ ‚Ñì))(‚â°.refl , lab) = lift(cong(Interp ùë®)(‚â°.refl , Œª i ‚Üí lower (lab i)))


Lift-Alg : (ùë® : Algebra Œ± œÅ·µÉ)(‚Ñì‚ÇÄ ‚Ñì‚ÇÅ : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì‚ÇÄ) (œÅ·µÉ ‚äî ‚Ñì‚ÇÅ)
Lift-Alg ùë® ‚Ñì‚ÇÄ ‚Ñì‚ÇÅ = Lift-Alg ≥ (Lift-AlgÀ° ùë® ‚Ñì‚ÇÄ) ‚Ñì‚ÇÅ

\end{code}
To see why these functions are useful, first recall that our definition of the algebra record type uses two universe level parameters corresponding to those of the algebra's underlying domain setoid.
Concretely, an algebra of type \ar{Algebra} \ab{Œ±} \ab{œÅ·µÉ} has a domain setoid (called \afld{Domain}) of type \ar{Setoid} \ab{Œ±} \ab{œÅ·µÉ}. This domain setoid packages a ``carrier set'' (\afld{Carrier}),
inhabiting \ap{Type} \ab{Œ±}, with an equality on \afld{Carrier} of type \af{Rel} \afld{Carrier} \ab{œÅ·µÉ}. Now, examining the \af{Lift-Alg} function, we see that it
takes an algebra---one whose carrier set inhabits \ap{Type \ab{Œ±}} and has an equality of type \af{Rel} \afld{Carrier} \ab{œÅ·µÉ}---and constructs a new algebra with carrier set inhabiting \ap{Type} (\ab{Œ±} \ap{‚äî} \ab{‚Ñì‚ÇÄ}) and having an equality of type \af{Rel} \afld{Carrier} (\ab{œÅ·µÉ} \ap{‚äî} \ab{‚Ñì‚ÇÅ}).
Of course, this lifting operation would be useless if we couldn't establish a connection (beyond universe levels) between the input and output algebras.
Fortunately, we can prove that universe lifting is an \defn{algebraic invariant}, which is to say that the lifted algebra
has the same algebraic properties as the original algebra; more precisely, the input algebra and the lifted algebra are \defn{isomorphic}, as we prove below. (See \af{Lift-‚âÖ}.)

\subsection{Product Algebras}
\label{product-algebras}
We give an informal description of the \defn{product} of a family of \ab{ùëÜ}-algebras and then define a type which formalizes this notion.

Let \ab{Œπ} be a universe and \ab I~:~\ap{Type}~\ab{Œπ} a type (which, in the
present context, we might refer to as the ``indexing type'').
Then the dependent function type \ab{ùíú}~:~\ab
I~\as{‚Üí}~\ab{Algebra}~\ab{Œ±}~\ab{œÅ·µÉ} represents an \defn{indexed family of algebras}.
Denote by \af{‚®Ö}~\ab{ùíú} the \defn{product of algebras} in \ab{ùíú} (or \defn{product algebra}),
by which we mean the algebra whose domain is the Cartesian product \af{Œ†}~\ab
i~Íûâ~\ab I~\af{,}~\aof{ùîª[~\ab{ùíú}~\ab i~]} of the domains of the algebras in
\ab{ùíú}, and whose operations are those arising by point-wise interpretation in the obvious
way: if \ab{f} is a \ab J-ary operation symbol and if \ab a~:~\af{Œ†}~\ab
i~Íûâ~\ab I~\af{,}~\ab J~\as{‚Üí}~\aof{ùîª[~\ab{ùíú}~\ab i~]} is, for each \ab
i~:~\ab I, a \ab J-tuple of elements of the domain \aof{ùîª[~\ab{ùíú}~\ab i~]}, then
we define the interpretation of \ab f in \af{‚®Ö}~\ab{ùíú} by (\ab{f}~\af{ÃÇ}~\af{‚®Ö}~\ab{ùíú}) \ab a := \as{Œª}~(\ab i~:~\ab I)~\as{‚Üí} (\ab{f}~\af{ÃÇ}~\ab{ùíú}~\ab i)(\ab{a}~\ab i).

The following type definition formalizes the foregoing notion of \defn{product algebra} in Martin-L√∂f type theory.\footnote{cf.~the \ualmodule{Algebras.Func.Products} module of the \agdaalgebras library.}

\begin{code}

module _ {Œπ : Level}{I : Type Œπ } where

 ‚®Ö : (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) ‚Üí Algebra (Œ± ‚äî Œπ) (œÅ·µÉ ‚äî Œπ)
 Domain (‚®Ö ùíú) =
  record  { Carrier = ‚àÄ i ‚Üí ùïå[ ùíú i ]
          ; _‚âà_ = Œª a b ‚Üí ‚àÄ i ‚Üí (Setoid._‚âà_ ùîª[ ùíú i ]) (a i)(b i)
          ; isEquivalence =
            record  { refl   = Œª i ‚Üí      IsEquivalence.refl   (isEquivalence ùîª[ ùíú i ])
                    ; sym    = Œª x i ‚Üí    IsEquivalence.sym    (isEquivalence ùîª[ ùíú i ])(x i)
                    ; trans  = Œª x y i ‚Üí  IsEquivalence.trans  (isEquivalence ùîª[ ùíú i ])(x i)(y i) }}
 Interp (‚®Ö ùíú) ‚ü®$‚ü© (f , a) = Œª i ‚Üí (f ÃÇ (ùíú i)) (flip a i)
 cong (Interp (‚®Ö ùíú)) (‚â°.refl , f=g ) = Œª i ‚Üí cong (Interp (ùíú i)) (‚â°.refl , flip f=g i )
\end{code}





%% -------------------------------------------------------------------------------------

\subsection{Homomorphisms}
\label{homomorphisms}

\paragraph*{Basic definitions}
\label{homomorphisms-basic-definitions}

Suppose \ab{ùë®} and \ab{ùë©} are \ab{ùëÜ}-algebras. A \defn{homomorphism} (or
``hom'') from \ab{ùë®} to \ab{ùë©} is a setoid function
\ab{h}~:~\aof{ùîª[ \ab{ùë®} ]} \as{‚Üí} \aof{ùîª[ \ab{ùë©} ]} that is \defn{compatible}
(or \defn{commutes}) with all basic operations; that is,
for every operation symbol \ab{f}~:~\af{‚à£ \ab{ùëÜ} ‚à£} and all tuples
\ab{a}~:~\af{‚à• \ab{ùëÜ} ‚à•}~\ab{f} \as{‚Üí} \aof{ùîª[ \ab{ùë®} ]}, the following
equality holds: \ab{h} \aofld{‚ü®\$‚ü©} (\ab{f}~\af{ÃÇ}~\ab{ùë®}) \ab{a} \aofld{‚âà}
(\ab{f}~\af{ÃÇ}~\ab{ùë©}) \as{Œª} \ab{x} \as{‚Üí} \ab{h} \aofld{‚ü®\$‚ü©} (\ab{a} \ab{x}).

To formalize this concept in Agda, we first define a type \af{compatible-map-op}
representing the assertion that a given setoid function
\ab{h}~:~\aof{ùîª[ \ab{ùë®} ]} \as{‚Üí} \aof{ùîª[ \ab{ùë©} ]} commutes with a given
basic operation \ab{f}.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where
 private ov = ùìû ‚äî ùì• ; a = Œ± ‚äî œÅ·µÉ ; b = Œ≤ ‚äî œÅ·µá ; c = ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá

 compatible-map-op : (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) ‚Üí ‚à£ ùëÜ ‚à£ ‚Üí Type (ùì• ‚äî Œ± ‚äî œÅ·µá)
 compatible-map-op h f = ‚àÄ {a} ‚Üí h ‚ü®$‚ü© (f ÃÇ ùë®) a ‚âà (f ÃÇ ùë©) Œª x ‚Üí h ‚ü®$‚ü© (a x)
  where open Setoid ùîª[ ùë© ] using ( _‚âà_ )

\end{code}
Generalizing over operation symbols gives the following type of compatible maps
from (the domain of) \ab{ùê¥} to (the domain of) \ab{ùë©}.
\begin{code}

 compatible-map : (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) ‚Üí Type (ov ‚äî Œ± ‚äî œÅ·µá)
 compatible-map h = ‚àÄ {f} ‚Üí compatible-map-op h f

\end{code}
With this we define a record type \ar{IsHom} representing the property of being
a homomorphism, and finally the type \af{hom} of homomorphisms from \ab{ùë®} to \ab{ùêµ}.
\begin{code}

 record IsHom (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ov ‚äî Œ± ‚äî œÅ·µá) where
  constructor mkhom
  field compatible : compatible-map h

 hom : Type c
 hom = Œ£ (ùîª[¬†ùë® ] ‚ü∂ ùîª[ ùë© ]) IsHom
\end{code}

Observe that an inhabitant of \af{hom} is a pair (\ab h , \ab p) whose first component is a setoid function from the domain of \ab{ùë®} to the domain of \ab{ùêµ} and whose second component is a proof, \ab p : \ar{IsHom} \ab h, that \ab h is a homomorphism.

A \defn{monomorphism} (resp. \emph{epimorphism}) is an injective (resp. surjective) homomorphism.  The \agdaalgebras library defines types \ar{IsMon} and \ar{IsEpi} to represent these properties, as well as
\af{mon} and \af{epi}, the types of monomorphisms and epimorphisms, respectively.
         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
 We won't reproduce the formal definitions of these types here, but \seeunabridged.
         %%%
\else    %%% END SHORT VERSION ONLY
         %%% BEGIN LONG VERSION ONLY SECTION
         %%%
\begin{code}

 record IsMon (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ov ‚äî a ‚äî œÅ·µá) where
  field  isHom : IsHom h
         isInjective : IsInjective h

  HomReduct : hom
  HomReduct = h , isHom

 mon : Type c
 mon = Œ£ (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) IsMon

\end{code}
As with \af{hom}, the type \af{mon} is a dependent product type; each inhabitant is a pair consisting of a setoid function, say, \ab h, along with a proof that \ab h is a monomorphism.

\begin{code}

 record IsEpi (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ov ‚äî Œ± ‚äî b) where
  field  isHom : IsHom h
         isSurjective : IsSurjective h

  HomReduct : hom
  HomReduct = h , isHom

 epi : Type c
 epi = Œ£ (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) IsEpi
\end{code}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%
%%%
%%% BEGIN NO VERSION SECTION (the next block of code will appear in neither version of the paper)
%%%
\begin{code}[hide]
open IsHom ; open IsMon ; open IsEpi

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where

 mon‚Üíintohom : mon ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£
 mon‚Üíintohom (hh , hhM) = (hh , isHom hhM) , isInjective hhM

 epi‚Üíontohom : epi ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsSurjective ‚à£ h ‚à£
 epi‚Üíontohom (hh , hhE) = (hh , isHom hhE) , isSurjective hhE
\end{code}
%%%
%%% END NO VERSION SECTION
%%%


%\subsubsection*{Basic properties of homomorphisms}
%Some definitions and theorems extracted from the \ualmodule{Homomorphisms.Func.Properties} module of the \agdaalgebras library.

\paragraph*{Composition of homomorphisms} The composition of homomorphisms is again a homomorphism. Similarly,
the composition of epimorphisms is again an epimorphism.

\begin{code}

module _  {ùë® : Algebra Œ± œÅ·µÉ} {ùë© : Algebra Œ≤ œÅ·µá} {ùë™ : Algebra Œ≥ œÅ·∂ú}
          {g : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]}{h : ùîª[ ùë© ] ‚ü∂ ùîª[ ùë™ ]} where

  open Setoid ùîª[ ùë™ ] using ( trans )

  ‚àò-is-hom : IsHom ùë® ùë© g ‚Üí IsHom ùë© ùë™ h ‚Üí IsHom ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-hom ghom hhom = mkhom c
   where
   c : compatible-map ùë® ùë™ (h ‚ü®‚àò‚ü© g)
   c = trans (cong h (compatible ghom)) (compatible hhom)

  ‚àò-is-epi : IsEpi ùë® ùë© g ‚Üí IsEpi ùë© ùë™ h ‚Üí IsEpi ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-epi gE hE = record  { isHom = ‚àò-is-hom (isHom gE) (isHom hE)
                           ; isSurjective = ‚àò-IsSurjective g h (isSurjective gE) (isSurjective hE) }
\end{code}
\ifshort\else
         %%%
         %%% BEGIN LONG VERSION ONLY SECTION
         %%%
\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ} {ùë© : Algebra Œ≤ œÅ·µá} {ùë™ : Algebra Œ≥ œÅ·∂ú} where

  ‚àò-hom : hom ùë® ùë© ‚Üí hom ùë© ùë™  ‚Üí hom ùë® ùë™
  ‚àò-hom (h , hhom) (g , ghom) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-hom hhom ghom

  ‚àò-epi : epi ùë® ùë© ‚Üí epi ùë© ùë™  ‚Üí epi ùë® ùë™
  ‚àò-epi (h , hepi) (g , gepi) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-epi hepi gepi
\end{code}

\paragraph*{Universe lifting of homomorphisms} First we define the identity homomorphism for setoid algebras and then we prove that the operations of lifting and lowering of a setoid algebra are homomorphisms.

\begin{code}

ùíæùíπ : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí hom ùë® ùë®
ùíæùíπ {ùë® = ùë®} = ùëñùëë , mkhom (reflexive ‚â°.refl) where open Setoid ( Domain ùë® ) using ( reflexive )

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 open Setoid ùîª[ ùë® ]              using ( reflexive )  renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; refl to refl‚ÇÅ )
 open Setoid ùîª[ Lift-AlgÀ° ùë® ‚Ñì ]  using ()             renaming ( _‚âà_ to _‚âàÀ°_ ; refl to reflÀ°)
 open Setoid ùîª[ Lift-Alg ≥ ùë® ‚Ñì ]  using ()             renaming ( _‚âà_ to _‚âà ≥_ ; refl to refl ≥)
 open Level

 ToLiftÀ° : hom ùë® (Lift-AlgÀ° ùë® ‚Ñì)
 ToLiftÀ° = record { f = lift ; cong = id } , mkhom (reflexive ‚â°.refl)

 FromLiftÀ° : hom (Lift-AlgÀ° ùë® ‚Ñì) ùë®
 FromLiftÀ° = record { f = lower ; cong = id } , mkhom reflÀ°

 ToFromLiftÀ° : ‚àÄ b ‚Üí  ‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© b) ‚âàÀ° b
 ToFromLiftÀ° b = refl‚ÇÅ

 FromToLiftÀ° : ‚àÄ a ‚Üí ‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© a) ‚âà‚ÇÅ a
 FromToLiftÀ° a = refl‚ÇÅ

 ToLift ≥ : hom ùë® (Lift-Alg ≥ ùë® ‚Ñì)
 ToLift ≥ = record { f = id ; cong = lift } , mkhom (lift (reflexive ‚â°.refl))

 FromLift ≥ : hom (Lift-Alg ≥ ùë® ‚Ñì) ùë®
 FromLift ≥ = record { f = id ; cong = lower } , mkhom reflÀ°

 ToFromLift ≥ : ‚àÄ b ‚Üí ‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© b) ‚âà ≥ b
 ToFromLift ≥ b = lift refl‚ÇÅ

 FromToLift ≥ : ‚àÄ a ‚Üí ‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© a) ‚âà‚ÇÅ a
 FromToLift ≥ a = refl‚ÇÅ


module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì r : Level} where
 open  Setoid ùîª[ ùë® ]               using ( refl )
 open  Setoid ùîª[ Lift-Alg ùë® ‚Ñì r ]  using ( _‚âà_ )
 open  Level

 ToLift : hom ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift = ‚àò-hom ToLiftÀ° ToLift ≥

 FromLift : hom (Lift-Alg ùë® ‚Ñì r) ùë®
 FromLift = ‚àò-hom FromLift ≥ FromLiftÀ°

 ToFromLift : ‚àÄ b ‚Üí ‚à£ ToLift ‚à£ ‚ü®$‚ü© (‚à£ FromLift ‚à£ ‚ü®$‚ü© b) ‚âà b
 ToFromLift b = lift refl

 ToLift-epi : epi ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift-epi = ‚à£ ToLift ‚à£ ,  record { isHom = ‚à• ToLift ‚à•
                            ; isSurjective = Œª {y} ‚Üí eq (‚à£ FromLift ‚à£ ‚ü®$‚ü© y) (ToFromLift y) }
\end{code}

\paragraph*{Homomorphisms of product algebras}
%\label{homomorphisms-of-product-algebras}
Suppose we have an algebra \ab{ùë®}, a type \ab I : \apr{Type} \ab ùìò, and a family \ab ‚Ñ¨ : \ab I \as ‚Üí \ar{Algebra} \ab Œ≤ \ab{ùëÜ} of algebras.
We sometimes refer to the inhabitants of `I` as \emph{indices}, and call `‚Ñ¨` an \emph{indexed family of algebras}.
If in addition we have a family `ùíΩ : (i : I) ‚Üí hom ùë® (‚Ñ¨ i)` of homomorphisms, then we can construct a homomorphism from `ùë®` to the product `‚®Ö ‚Ñ¨` in the natural way.  Here is how we implement these notions in dependent type theory.\footnote{cf.~the [Homomorphisms.Func.Products][] module of the \agdaalgebras library.}

\begin{code}

module _ {Œπ : Level}{I : Type Œπ}{ùë® : Algebra Œ± œÅ·µÉ}(‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá)  where
 ‚®Ö-hom-co : (‚àÄ(i : I) ‚Üí hom ùë® (‚Ñ¨ i)) ‚Üí hom ùë® (‚®Ö ‚Ñ¨)
 ‚®Ö-hom-co ùíΩ = h , hhom
  where
  h : ùîª[ ùë® ] ‚ü∂ ùîª[ ‚®Ö ‚Ñ¨ ]
  h ‚ü®$‚ü© a = Œª i ‚Üí ‚à£ ùíΩ i ‚à£ ‚ü®$‚ü© a
  cong h xy i = cong ‚à£ ùíΩ i ‚à£ xy
  hhom : IsHom ùë® (‚®Ö ‚Ñ¨) h
  compatible hhom = Œª i ‚Üí compatible ‚à• ùíΩ i ‚à•
\end{code}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

\paragraph*{Factorization of homomorphisms} If \ab g : \af{hom} \ab{ùë®} \ab{ùë©}, \ab h : \af{hom} \ab{ùë®} \ab{ùë™}, \ab h is
surjective, and \af{ker} \ab h \aof{‚äÜ} \af{ker} \ab g, then there exists
\ab{œÜ} : \af{hom} \ab{ùë™} \ab{ùë©} such that \ab g = \ab{œÜ} \aof{‚àò} \ab h.

         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
Here we merely give the formal statement of this theorem, but \seeunabridged or the
\ualmodule{Homomorphisms.Func.Factor} module of the \agdaalgebras library.
         %%%
\else\fi %%% END SHORT VERSION ONLY

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá){ùë™ : Algebra Œ≥ œÅ·∂ú}
         (gh : hom ùë® ùë©)(hh : hom ùë® ùë™) where
 open Setoid ùîª[ ùë© ] using ()         renaming ( _‚âà_ to _‚âà‚ÇÇ_ ; sym to sym‚ÇÇ )
 open Setoid ùîª[ ùë™ ] using ( trans )  renaming ( _‚âà_ to _‚âà‚ÇÉ_ ; sym to sym‚ÇÉ )
 private gfunc = ‚à£ gh ‚à£ ; g = _‚ü®$‚ü©_ gfunc ; hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc

 HomFactor :  kernel _‚âà‚ÇÉ_ h ‚äÜ kernel _‚âà‚ÇÇ_ g ‚Üí IsSurjective hfunc
  ‚Üí           Œ£[ œÜ ‚àà hom ùë™ ùë© ] ‚àÄ a ‚Üí g a ‚âà‚ÇÇ ‚à£ œÜ ‚à£ ‚ü®$‚ü© h a
\end{code}
\ifshort %%%
\else    %%% BEGIN LONG VERSION ONLY
         %%%
\begin{code}
 HomFactor Khg hE = (œÜmap , œÜhom) , gœÜh
  where
  kerpres : ‚àÄ a‚ÇÄ a‚ÇÅ ‚Üí h a‚ÇÄ ‚âà‚ÇÉ h a‚ÇÅ ‚Üí g a‚ÇÄ ‚âà‚ÇÇ g a‚ÇÅ
  kerpres a‚ÇÄ a‚ÇÅ hyp = Khg hyp

  h‚Åª¬π : ùïå[ ùë™ ] ‚Üí ùïå[ ùë® ]
  h‚Åª¬π = SurjInv hfunc hE

  Œ∑ : ‚àÄ {c} ‚Üí h (h‚Åª¬π c) ‚âà‚ÇÉ c
  Œ∑ = InvIsInverse ≥ hE

  Œ∂ : ‚àÄ{x y} ‚Üí x ‚âà‚ÇÉ y ‚Üí h (h‚Åª¬π x) ‚âà‚ÇÉ h (h‚Åª¬π y)
  Œ∂ xy = trans Œ∑ (trans xy (sym‚ÇÉ Œ∑))

  œÜmap : ùîª[ ùë™ ] ‚ü∂ ùîª[ ùë© ]
  _‚ü®$‚ü©_ œÜmap = g ‚àò h‚Åª¬π
  cong œÜmap = Khg ‚àò Œ∂
  open _‚ü∂_ œÜmap using () renaming (cong to œÜcong)

  gœÜh : (a : ùïå[ ùë® ]) ‚Üí g a ‚âà‚ÇÇ œÜmap ‚ü®$‚ü© h a
  gœÜh a = Khg (sym‚ÇÉ Œ∑)

  open SetoidReasoning ùîª[ ùë© ]
  œÜcomp : compatible-map ùë™ ùë© œÜmap
  œÜcomp {f}{c} =
   begin
    œÜmap ‚ü®$‚ü©  (f ÃÇ ùë™)                   c       ‚âàÀò‚ü®  œÜcong (cong (Interp ùë™) (‚â°.refl , Œª _ ‚Üí Œ∑))  ‚ü©
    g(h‚Åª¬π(    (f ÃÇ ùë™)  (h ‚àò    h‚Åª¬π  ‚àò  c  )))   ‚âàÀò‚ü®  œÜcong (compatible ‚à• hh ‚à•)                   ‚ü©
    g(h‚Åª¬π(h(  (f ÃÇ ùë®)  (       h‚Åª¬π  ‚àò  c  ))))  ‚âàÀò‚ü®  gœÜh ((f ÃÇ ùë®)(h‚Åª¬π ‚àò c))                      ‚ü©
    g(        (f ÃÇ ùë®)  (       h‚Åª¬π  ‚àò  c  ))    ‚âà‚ü®   compatible ‚à• gh ‚à•                           ‚ü©
              (f ÃÇ ùë©)  (g ‚àò (  h‚Åª¬π  ‚àò  c  ))    ‚àé

  œÜhom : IsHom ùë™ ùë© œÜmap
  compatible œÜhom = œÜcomp
\end{code}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%


\paragraph*{Isomorphisms}
%\label{isomorphisms}

Two structures are \emph{isomorphic} provided there are homomorphisms going back and forth between them which compose to the identity map.

         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
The \agdaalgebras library's \ar{\au{}‚âÖ\au{}} type codifies the definition of isomorphism, as well as some obvious consequences.  Here we display only the core part of this record type, but \seeunabridged or the \ualmodule{Homomorphisms.Func.Isomorphisms} module of the \agdaalgebras library.
         %%%
\else\fi %%% END SHORT VERSION ONLY
         %%%

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) (ùë© : Algebra Œ≤ œÅ·µá) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; sym ; trans )
 open Setoid ùîª[ ùë© ] using () renaming ( _‚âà_ to _‚âà·¥Æ_ ; sym to sym·µá ; trans to trans·µá)

 record _‚âÖ_ : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî Œ≤ ‚äî œÅ·µÉ ‚äî œÅ·µá ) where
  constructor mkiso
  field
   to : hom ùë® ùë©
   from : hom ùë© ùë®
   to‚àºfrom : ‚àÄ b ‚Üí ‚à£ to ‚à£    ‚ü®$‚ü© (‚à£ from ‚à£  ‚ü®$‚ü© b)  ‚âà·¥Æ b
   from‚àºto : ‚àÄ a ‚Üí ‚à£ from ‚à£  ‚ü®$‚ü© (‚à£ to ‚à£    ‚ü®$‚ü© a)  ‚âà a
\end{code}
\ifshort %%%
\else    %%% BEGIN LONG VERSION ONLY
         %%%
\begin{code}

  toIsSurjective : IsSurjective ‚à£ to ‚à£
  toIsSurjective {y} = eq (‚à£ from ‚à£ ‚ü®$‚ü© y) (sym·µá (to‚àºfrom y))

  toIsInjective : IsInjective ‚à£ to ‚à£
  toIsInjective {x} {y} xy = Goal
   where
   Œæ : ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© x) ‚âà ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© y)
   Œæ = cong ‚à£ from ‚à£ xy
   Goal : x ‚âà y
   Goal = trans (sym (from‚àºto x)) (trans Œæ (from‚àºto y))

  fromIsSurjective : IsSurjective ‚à£ from ‚à£
  fromIsSurjective {y} = eq (‚à£ to ‚à£ ‚ü®$‚ü© y) (sym (from‚àºto y))

  fromIsInjective : IsInjective ‚à£ from ‚à£
  fromIsInjective {x} {y} xy = Goal
   where
   Œæ : ‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© x) ‚âà·¥Æ ‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© y)
   Œæ = cong ‚à£ to ‚à£ xy
   Goal : x ‚âà·¥Æ y
   Goal = trans·µá (sym·µá (to‚àºfrom x)) (trans·µá Œæ (to‚àºfrom y))

open _‚âÖ_
\end{code}

\begin{code}

‚âÖ-refl : Reflexive (_‚âÖ_ {Œ±}{œÅ·µÉ})
‚âÖ-refl {Œ±}{œÅ·µÉ}{ùë®} = mkiso ùíæùíπ ùíæùíπ (Œª b ‚Üí refl) Œª a ‚Üí refl
 where open Setoid ùîª[ ùë® ] using ( refl )

‚âÖ-sym : Sym (_‚âÖ_{Œ≤}{œÅ·µá}) (_‚âÖ_{Œ±}{œÅ·µÉ})
‚âÖ-sym œÜ = mkiso (from œÜ) (to œÜ) (from‚àºto œÜ) (to‚àºfrom œÜ)

‚âÖ-trans : Trans (_‚âÖ_ {Œ±}{œÅ·µÉ})(_‚âÖ_{Œ≤}{œÅ·µá})(_‚âÖ_{Œ±}{œÅ·µÉ}{Œ≥}{œÅ·∂ú})
‚âÖ-trans {œÅ·∂ú = œÅ·∂ú}{ùë®}{ùë©}{ùë™} ab bc = mkiso f g œÑ ŒΩ
 where
  open Setoid ùîª[ ùë® ] using ( _‚âà_ ; trans )
  open Setoid ùîª[ ùë™ ] using () renaming ( _‚âà_ to _‚âà·∂ú_ ; trans to trans·∂ú )
  f : hom ùë® ùë™
  f = ‚àò-hom (to ab) (to bc)
  g : hom ùë™ ùë®
  g = ‚àò-hom (from bc) (from ab)
  œÑ : ‚àÄ b ‚Üí ‚à£ f ‚à£ ‚ü®$‚ü© (‚à£ g ‚à£ ‚ü®$‚ü© b) ‚âà·∂ú b
  œÑ b = trans·∂ú (cong ‚à£ to bc ‚à£ (to‚àºfrom ab (‚à£ from bc ‚à£ ‚ü®$‚ü© b))) (to‚àºfrom bc b)
  ŒΩ : ‚àÄ a ‚Üí ‚à£ g ‚à£ ‚ü®$‚ü© (‚à£ f ‚à£ ‚ü®$‚ü© a) ‚âà a
  ŒΩ a = trans (cong ‚à£ from ab ‚à£ (from‚àºto bc (‚à£ to ab ‚à£ ‚ü®$‚ü© a))) (from‚àºto ab a)

\end{code}

Fortunately, the lift operation preserves isomorphism (i.e., it's an \emph{algebraic invariant}). As our focus is universal algebra, this is important and is what makes the lift operation a workable solution to the technical problems that arise from the noncumulativity of Agda's universe hierarchy.

\begin{code}[hide]
module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 Lift-‚âÖÀ° : ùë® ‚âÖ (Lift-AlgÀ° ùë® ‚Ñì)
 Lift-‚âÖÀ° = mkiso ToLiftÀ° FromLiftÀ° (ToFromLiftÀ°{ùë® = ùë®}) (FromToLiftÀ°{ùë® = ùë®}{‚Ñì})

 Lift-‚âÖ ≥ : ùë® ‚âÖ (Lift-Alg ≥ ùë® ‚Ñì)
 Lift-‚âÖ ≥ = mkiso ToLift ≥ FromLift ≥ (ToFromLift ≥{ùë® = ùë®}) (FromToLift ≥{ùë® = ùë®}{‚Ñì})

Lift-‚âÖ : {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì œÅ : Level} ‚Üí ùë® ‚âÖ (Lift-Alg ùë® ‚Ñì œÅ)
Lift-‚âÖ = ‚âÖ-trans Lift-‚âÖÀ° Lift-‚âÖ ≥
\end{code}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

\paragraph*{Homomorphic Images}
%\label{homomorphic-images}
We begin with what for our purposes is the most useful way to represent the class of \emph{homomorphic images} of an algebra in dependent type theory.\footnote{cf.~the \ualmodule{Homomorphisms.Func.HomomorphicImages} module of the \agdaalgebras library.}

\begin{code}
ov : Level ‚Üí Level
ov Œ± = ùìû ‚äî ùì• ‚äî lsuc Œ±

_IsHomImageOf_ : (ùë© : Algebra Œ≤ œÅ·µá)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî Œ≤ ‚äî œÅ·µÉ ‚äî œÅ·µá)
ùë© IsHomImageOf ùë® = Œ£[ œÜ ‚àà hom ùë® ùë© ] IsSurjective ‚à£ œÜ ‚à£

HomImages : Algebra Œ± œÅ·µÉ ‚Üí Type (Œ± ‚äî œÅ·µÉ ‚äî ov (Œ≤ ‚äî œÅ·µá))
HomImages {Œ≤ = Œ≤}{œÅ·µá = œÅ·µá} ùë® = Œ£[ ùë© ‚àà Algebra Œ≤ œÅ·µá ] ùë© IsHomImageOf ùë®

\end{code}
These types should be self-explanatory, but just to be sure, let's describe the
Sigma type appearing in the second definition. Given an \ab{ùëÜ}-algebra \ab{ùë®} :
\ar{Algebra} \ab{Œ±} \ab{œÅ}, the type \af{HomImages} \ab{ùë®} denotes the class of
algebras \ab{ùë©} : \ar{Algebra} \ab{Œ≤} \ab{œÅ} with a map \ab{œÜ} : \aof{‚à£} \ab{ùë®}
\aof{‚à£} \as{‚Üí} \aof{‚à£} \ab{ùë©} \aof{‚à£} such that \ab{œÜ} is a surjective
homomorphism.

\begin{code}[hide]
module _ {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} where

 Lift-HomImage-lemma : ‚àÄ{Œ≥} ‚Üí (Lift-Alg ùë® Œ≥ Œ≥) IsHomImageOf ùë© ‚Üí ùë® IsHomImageOf ùë©
 Lift-HomImage-lemma {Œ≥} œÜ = ‚àò-hom ‚à£ œÜ ‚à£ (from Lift-‚âÖ) ,
                             ‚àò-IsSurjective _ _ ‚à• œÜ ‚à• (fromIsSurjective (Lift-‚âÖ{ùë® = ùë®}))

module _ {ùë® ùë®' : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} where

 HomImage-‚âÖ : ùë® IsHomImageOf ùë®' ‚Üí ùë® ‚âÖ ùë© ‚Üí ùë© IsHomImageOf ùë®'
 HomImage-‚âÖ œÜ A‚âÖB = ‚àò-hom ‚à£ œÜ ‚à£ (to A‚âÖB) , ‚àò-IsSurjective _ _ ‚à• œÜ ‚à• (toIsSurjective A‚âÖB)
\end{code}




%% -------------------------------------------------------------------------------------

\subsection{Subalgebras}
\label{subalgebras}
\paragraph*{Basic definitions}
%\label{subalgebras-basic-definitions}

\begin{code}

_‚â§_ : Algebra Œ± œÅ·µÉ ‚Üí Algebra Œ≤ œÅ·µá ‚Üí Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá)
ùë® ‚â§ ùë© = Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£
\end{code}

\paragraph*{Basic properties}
%\label{subalgebras-basic-properties}

\begin{code}

‚â§-reflexive : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí ùë® ‚â§ ùë®
‚â§-reflexive {ùë® = ùë®} = ùíæùíπ , id

mon‚Üí‚â§ : {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} ‚Üí mon ùë® ùë© ‚Üí ùë® ‚â§ ùë©
mon‚Üí‚â§ {ùë® = ùë®}{ùë©} x = mon‚Üíintohom ùë® ùë© x

module _ {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{ùë™ : Algebra Œ≥ œÅ·∂ú} where
 ‚â§-trans : ùë® ‚â§ ùë© ‚Üí ùë© ‚â§ ùë™ ‚Üí ùë® ‚â§ ùë™
 ‚â§-trans ( f , finj ) ( g , ginj ) = (‚àò-hom f g ) , ‚àò-IsInjective ‚à£ f ‚à£ ‚à£ g ‚à£ finj ginj

 ‚âÖ-trans-‚â§ : ùë® ‚âÖ ùë© ‚Üí ùë© ‚â§ ùë™ ‚Üí ùë® ‚â§ ùë™
 ‚âÖ-trans-‚â§ A‚âÖB (h , hinj) = (‚àò-hom (to A‚âÖB) h) , (‚àò-IsInjective ‚à£ to A‚âÖB ‚à£ ‚à£ h ‚à£ (toIsInjective A‚âÖB) hinj)
\end{code}

\paragraph*{Products of subalgebras}
%\label{products-of-subalgebras}

\begin{code}

module _ {Œπ : Level} {I : Type Œπ}{ùíú : I ‚Üí Algebra Œ± œÅ·µÉ}{‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá} where

 ‚®Ö-‚â§ : (‚àÄ i ‚Üí ‚Ñ¨ i ‚â§ ùíú i) ‚Üí ‚®Ö ‚Ñ¨ ‚â§ ‚®Ö ùíú
 ‚®Ö-‚â§ B‚â§A = (hfunc , hhom) , hM
  where
  hi : ‚àÄ i ‚Üí hom (‚Ñ¨ i) (ùíú i)
  hi i = ‚à£ B‚â§A i ‚à£

  hfunc : ùîª[ ‚®Ö ‚Ñ¨ ] ‚ü∂ ùîª[ ‚®Ö ùíú ]
  (hfunc ‚ü®$‚ü© x) i = ‚à£ hi i ‚à£ ‚ü®$‚ü© x i
  cong hfunc = Œª xy i ‚Üí cong ‚à£ hi i ‚à£ (xy i)

  hhom : IsHom (‚®Ö ‚Ñ¨) (‚®Ö ùíú) hfunc
  compatible hhom = Œª i ‚Üí compatible ‚à• hi i ‚à•

  hM : IsInjective hfunc
  hM = Œª xy i ‚Üí ‚à• B‚â§A i ‚à• (xy i)
\end{code}




%% -------------------------------------------------------------------------------------

\subsection{Terms}
\label{terms}
\paragraph*{Basic definitions}
Fix a signature \ab{ùëÜ} and let \ab X denote an arbitrary nonempty collection of variable symbols. Assume the symbols in \ab X are distinct from the operation symbols of \ab{ùëÜ}, that is \ab X \aof{‚à©} \aof{‚à£} \ab{ùëÜ} \aof{‚à£} = ‚àÖ.
By a \emph{word} in the language of \ab{ùëÜ}, we mean a nonempty, finite sequence of members of \ab X \aof{‚à™} \aof{‚à£} \ab{ùëÜ} \aof{‚à£}. We denote the concatenation of such sequences by simple juxtaposition.
Let \ab{S‚ÇÄ} denote the set of nullary operation symbols of \ab{ùëÜ}. We define by induction on \ab n the sets \ab{ùëá‚Çô} of \emph{words} over \ab X \aof{‚à™} \aof{‚à£} \ab{ùëÜ} \aof{‚à£} as follows (cf.~\cite[Def. 4.19]{Bergman:2012}):
\begin{enumerate}
\item \ab{ùëá‚ÇÄ} := \ab X \aof{‚à™} \ab{S‚ÇÄ}, and
\item \ab{ùëá‚Çô‚Çä‚ÇÅ} := \ab{ùëá‚Çô} \aof{‚à™} \ab{ùíØ‚Çô}.
\end{enumerate}
where \ab{ùíØ‚Çô} is the collection of all \ab f \ab t such that \ab f : \aof{‚à£} \ab{ùëÜ} \aof{‚à£} and \ab t : \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab f \as{‚Üí} \ab{ùëá‚Çô}. (Recall, \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab f is the arity of the operation symbol \ab f.)

We define the collection of \emph{terms} in the signature \ab{ùëÜ} over \ab X by \ad{Term} \ab X := \aof{‚ãÉ‚Çô} \ab{ùëá‚Çô}. By an ùëÜ-\emph{term} we mean a term in the language of \ab{ùëÜ}.

The definition of \ad{Term} \ab X is recursive, indicating that an inductive type could be used to represent the semantic notion of terms in type theory. Indeed, such a representation is given by the following inductive type.

\begin{code}

data Term (X : Type œá ) : Type (ov œá)  where
 ‚Ñä : X ‚Üí Term X
 node : (f : ‚à£ ùëÜ ‚à£)(t : ‚à• ùëÜ ‚à• f ‚Üí Term X) ‚Üí Term X
open Term

\end{code}

This is a very basic inductive type that represents each term as a tree with an operation symbol at each \aic{node} and a variable symbol at each leaf (\aic{‚Ñä}); hence the constructor names (\aic{‚Ñä} for ``generator'' and \aic{node} for ``node'').

\textbf{Notation}. As usual, the type \ab X represents an arbitrary collection of variable symbols. Recall, \af{ov} \ab{œá} is our shorthand notation for the universe level \ab{ùìû} \aop{‚äî} \ab{ùì•} \aop{‚äî} \ap{lsuc} \ab{œá}.
\paragraph*{Equality of terms}
%\label{equality-of-terms}
We take a different approach here, using Setoids instead of quotient types.
That is, we will define the collection of terms in a signature as a setoid
with a particular equality-of-terms relation, which we must define.
Ultimately we will use this to define the (absolutely free) term algebra
as a Algebra whose carrier is the setoid of terms.

\begin{code}

module _ {X : Type œá } where

 data _‚âê_ : Term X ‚Üí Term X ‚Üí Type (ov œá) where
  rfl : {x y : X} ‚Üí x ‚â° y ‚Üí (‚Ñä x) ‚âê (‚Ñä y)
  gnl : ‚àÄ {f}{s t : ‚à• ùëÜ ‚à• f ‚Üí Term X} ‚Üí (‚àÄ i ‚Üí (s i) ‚âê (t i)) ‚Üí (node f s) ‚âê (node f t)

\end{code}

It is easy to show that the equality-of-terms relation \AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}‚âê\AgdaUnderscore{}}} is an equivalence relation, so we omit the formal proof. (See the \ualmodule{Terms.Func.Basic} module of the \agdaalgebras library for details.)

\begin{code}[hide]
 ‚âê-isRefl : Reflexive _‚âê_
 ‚âê-isRefl {‚Ñä _} = rfl ‚â°.refl
 ‚âê-isRefl {node _ _} = gnl (Œª _ ‚Üí ‚âê-isRefl)

 ‚âê-isSym : Symmetric _‚âê_
 ‚âê-isSym (rfl x) = rfl (‚â°.sym x)
 ‚âê-isSym (gnl x) = gnl (Œª i ‚Üí ‚âê-isSym (x i))

 ‚âê-isTrans : Transitive _‚âê_
 ‚âê-isTrans (rfl x) (rfl y) = rfl (‚â°.trans x y)
 ‚âê-isTrans (gnl x) (gnl y) = gnl (Œª i ‚Üí ‚âê-isTrans (x i) (y i))

 ‚âê-isEquiv : IsEquivalence _‚âê_
 ‚âê-isEquiv = record { refl = ‚âê-isRefl ; sym = ‚âê-isSym ; trans = ‚âê-isTrans }
\end{code}


\paragraph*{The term algebra}
%\label{the-term-algebra}
For a given signature \ab{ùëÜ}, if the type \ad{Term} \ab X is nonempty
(equivalently, if \ab X or \aof{‚à£} \ab{ùëÜ} \aof{‚à£} is nonempty), then we can
define an algebraic structure, denoted by \T{X} and called the \emph{term
  algebra in the signature} \ab{ùëÜ} \emph{over} \ab X.  Terms are viewed as
acting on other terms, so both the domain and basic operations of the algebra
are the terms themselves.


\begin{itemize}
\item For each operation symbol \ab f : \aof{‚à£} \ab{ùëÜ} \aof{‚à£}, denote by \ab f
  \aof{ÃÇ} (\T{X}) the operation on \ad{Term} \ab X that maps a tuple \ab t :
  \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab f \as{‚Üí} \aof{‚à£} \T{X} \aof{‚à£} to the formal term \ab f \ab t.
\item Define \T{X} to be the algebra with universe \aof{‚à£} \T{X} \aof{‚à£} :=
  \ad{Term} \ab X and operations \ab f \aof{ÃÇ} (\T{X}), one for each symbol
  \ab f in \aof{‚à£} \ab{ùëÜ} \aof{‚à£}.
\end{itemize}

In \agda the term algebra can be defined as simply as one might hope.

\begin{code}

TermSetoid : (X : Type œá) ‚Üí Setoid (ov œá) (ov œá)
TermSetoid X = record { Carrier = Term X ; _‚âà_ = _‚âê_ ; isEquivalence = ‚âê-isEquiv }

ùëª : (X : Type œá) ‚Üí Algebra (ov œá) (ov œá)
Algebra.Domain (ùëª X) = TermSetoid X
Algebra.Interp (ùëª X) ‚ü®$‚ü© (f , ts) = node f ts
cong (Algebra.Interp (ùëª X)) (‚â°.refl , ss‚âêts) = gnl ss‚âêts
\end{code}

\paragraph*{Interpretation of terms}
%\label{interpretation-of-terms}

The approach to terms and their interpretation in this module was inspired by
Andreas Abel's formal proof of Birkhoff's completeness theorem.\footnote{See \abel.}

A substitution from \ab X to \ab Y associates a term in \ab X with each variable in \ab Y.  The definition of \af{Sub} given here is essentially the same as the one given by Andreas Abel, as is the recursive definition of the syntax \ab t \af{[} \ab{œÉ} \af{]} , which denotes a term \ab t applied to a substitution \ab{œÉ}.

\begin{code}

Sub : Type œá ‚Üí Type œá ‚Üí Type (ov œá)
Sub X Y = (y : Y) ‚Üí Term X

_[_] : {X Y : Type œá}(t : Term Y) (œÉ : Sub X Y) ‚Üí Term X
(‚Ñä x) [ œÉ ] = œÉ x
(node f ts) [ œÉ ] = node f (Œª i ‚Üí ts i [ œÉ ])

\end{code}

An environment for an algebra \ab{ùë®} in a context \ab X is a map that assigns to each variable \AgdaTyped{x}{X} an element in the domain of \ab{ùë®}, packaged together with an equality of environments, which is simply pointwise equality (relatively to the setoid equality of the underlying domain of \ab{ùë®}).

\begin{code}

module Environment (ùë® : Algebra Œ± ‚Ñì) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; refl ; sym ; trans )
 Env : Type œá ‚Üí Setoid _ _
 Env X = record  { Carrier = X ‚Üí ùïå[ ùë® ]
                 ; _‚âà_ = Œª œÅ œÅ' ‚Üí (x : X) ‚Üí œÅ x ‚âà œÅ' x
                 ; isEquivalence = record  { refl   = Œª _ ‚Üí refl
                                           ; sym    = Œª h x ‚Üí sym (h x)
                                           ; trans  = Œª g h x ‚Üí trans (g x)(h x) }}

\end{code}

Next we define \emph{evaluation of a term} in an environment \ab{œÅ}, interpreted in the algebra \ab{ùë®}.

\begin{code}

 ‚ü¶_‚üß : {X : Type œá}(t : Term X) ‚Üí (Env X) ‚ü∂ ùîª[ ùë® ]
 ‚ü¶ ‚Ñä x ‚üß          ‚ü®$‚ü© œÅ = œÅ x
 ‚ü¶ node f args ‚üß  ‚ü®$‚ü© œÅ = (Interp ùë®) ‚ü®$‚ü© (f , Œª i ‚Üí ‚ü¶ args i ‚üß ‚ü®$‚ü© œÅ)
 cong ‚ü¶ ‚Ñä x ‚üß u‚âàv = u‚âàv x
 cong ‚ü¶ node f args ‚üß x‚âày = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí cong ‚ü¶ args i ‚üß x‚âày )

\end{code}

An equality between two terms holds in a model if the two terms are equal under all valuations of their free variables.\footnote{cf.~Andreas Abel's formal proof of Birkhoff's completeness theorem [reference needed].}

\begin{code}

 Equal : ‚àÄ {X : Type œá} (s t : Term X) ‚Üí Type _
 Equal {X = X} s t = ‚àÄ (œÅ : Carrier (Env X)) ‚Üí  ‚ü¶ s ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ

 ‚âê‚ÜíEqual : {X : Type œá}(s t : Term X) ‚Üí s ‚âê t ‚Üí Equal s t
 ‚âê‚ÜíEqual .(‚Ñä _) .(‚Ñä _) (rfl ‚â°.refl) = Œª _ ‚Üí refl
 ‚âê‚ÜíEqual (node _ s)(node _ t)(gnl x) =
  Œª œÅ ‚Üí cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí ‚âê‚ÜíEqual(s i)(t i)(x i)œÅ )

\end{code}

The proof that \af{Equal} is an equivalence relation is trivial, so we omit it. (See the \ualmodule{Varieties.Func.SoundAndComplete} module of the \agdaalgebras library for details.)

\begin{code}[hide]
 EqualIsEquiv : {Œì : Type œá} ‚Üí IsEquivalence (Equal {X = Œì})
 IsEquivalence.refl  EqualIsEquiv = Œª _ ‚Üí refl
 IsEquivalence.sym   EqualIsEquiv = Œª x=y œÅ ‚Üí sym (x=y œÅ)
 IsEquivalence.trans EqualIsEquiv = Œª ij jk œÅ ‚Üí trans (ij œÅ) (jk œÅ)
\end{code}

Evaluation of a substitution gives an environment.\footnote{cf.~Andreas Abel's formal proof of Birkhoff's completeness theorem [reference needed].}
%(http://www.cse.chalmers.se/~abela/agda/MultiSortedAlgebra.pdf))

\begin{code}

 ‚ü¶_‚üßs : {X Y : Type œá} ‚Üí Sub X Y ‚Üí Carrier(Env X) ‚Üí Carrier (Env Y)
 ‚ü¶ œÉ ‚üßs œÅ x = ‚ü¶ œÉ x ‚üß ‚ü®$‚ü© œÅ

\end{code}

Next we prove that \aof{‚ü¶} \ab{t} \af{[} \ab{œÉ} \af{]} \aof{‚üß} \ab{œÅ} ‚âÉ \aof{‚ü¶} \ab t \aof{‚üß} \aof{‚ü¶} \ab{œÉ} \aof{‚üß} \ab{œÅ}.
%(cf. Andreas Abel's formal proof of Birkhoff's completeness theorem).

\begin{code}

 substitution :  {X Y : Type œá} ‚Üí (t : Term Y) (œÉ : Sub X Y) (œÅ : Carrier( Env X ) )
  ‚Üí              ‚ü¶ t [ œÉ ] ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ t ‚üß ‚ü®$‚ü© ‚ü¶ œÉ ‚üßs œÅ

 substitution (‚Ñä x)        œÉ œÅ = refl
 substitution (node f ts)  œÉ œÅ = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí substitution (ts i) œÉ œÅ)
\end{code}


\paragraph*{Compatibility of terms}
%\label{compatibility-of-terms}
We now prove two important facts about term operations.  The first of these, which is used very often in the sequel, asserts that every term commutes with every homomorphism.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}(hh : hom ùë® ùë©) where
 open Setoid ùîª[ ùë© ] using ( _‚âà_ ; refl )
 open SetoidReasoning ùîª[ ùë© ]
 private hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc
 open Environment ùë® using ( ‚ü¶_‚üß )
 open Environment ùë© using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥Æ )

 comm-hom-term : (t : Term X) (a : X ‚Üí ùïå[ ùë® ]) ‚Üí h (‚ü¶ t ‚üß ‚ü®$‚ü© a) ‚âà ‚ü¶ t ‚üß·¥Æ ‚ü®$‚ü© (h ‚àò a)
 comm-hom-term (‚Ñä x) a = refl
 comm-hom-term (node f t) a = goal
  where
  goal : h (‚ü¶ node f t ‚üß ‚ü®$‚ü© a) ‚âà ‚ü¶ node f t ‚üß·¥Æ ‚ü®$‚ü© (h ‚àò a)
  goal = begin
          h (  ‚ü¶ node f t ‚üß           ‚ü®$‚ü©         a  )  ‚âà‚ü®  compatible ‚à• hh ‚à•                                     ‚ü©
          (f ÃÇ ùë©)( Œª i ‚Üí h(  ‚ü¶ t i ‚üß   ‚ü®$‚ü©         a) )  ‚âà‚ü®  cong(Interp ùë©)(‚â°.refl , Œª i ‚Üí comm-hom-term (t i) a)  ‚ü©
          (f ÃÇ ùë©)( Œª i ‚Üí     ‚ü¶ t i ‚üß·¥Æ  ‚ü®$‚ü©  (h  ‚àò  a) )  ‚âà‚ü®  refl                                                  ‚ü©
               ‚ü¶ node f t ‚üß·¥Æ          ‚ü®$‚ü©  (h  ‚àò  a)    ‚àé
\end{code}

%% \subsection{Interpretation of terms in product algebras}
%% a id="interpretation-of-terms-in-product-algebras">

\begin{code}[hide]
module _ {X : Type œá}{Œπ : Level} {I : Type Œπ} (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) where
 open Setoid ùîª[ ‚®Ö ùíú ]    using ( _‚âà_ )
 open Environment (‚®Ö ùíú)  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
 open Environment        using ( ‚ü¶_‚üß ; ‚âê‚ÜíEqual )

 interp-prod : (p : Term X) ‚Üí ‚àÄ œÅ ‚Üí ‚ü¶ p ‚üß‚ÇÅ ‚ü®$‚ü© œÅ ‚âà Œª i ‚Üí (‚ü¶ ùíú i ‚üß p) ‚ü®$‚ü© Œª x ‚Üí (œÅ x) i
 interp-prod (‚Ñä x) = Œª œÅ i ‚Üí ‚âê‚ÜíEqual (ùíú i) (‚Ñä x) (‚Ñä x) ‚âê-isRefl Œª _ ‚Üí (œÅ x) i
 interp-prod (node f t) = Œª œÅ ‚Üí cong (Interp (‚®Ö ùíú)) ( ‚â°.refl , Œª j k ‚Üí interp-prod (t j) œÅ k )
\end{code}





%% -------------------------------------------------------------------------------------

\section{Model Theory and Equational Logic}
\label{model-theory-and-equational-logic}

(cf. the \ualmodule{Varieties.Func.SoundAndComplete} module of the \agdaalgebras library)

\subsection{Basic definitions}
\label{model-theory-basic-definitions}

Let \ab{ùëÜ} be a signature. By an \emph{identity} or \emph{equation} in \ab{ùëÜ} we mean an ordered pair of terms in a given context.  For instance, if the context happens to be the type \ab X : \ap{Type} \ab{œá}, then an equation will be a pair of inhabitants of the domain of term algebra \af{ùëª} \ab X.

We define an equation in Agda using the following record type with fields denoting the left-hand and right-hand sides of the equation, along with an equation ``context'' representing the underlying collection of variable symbols.\footnote{cf.~Andreas Abel's formal proof of Birkhoff's completeness theorem [reference needed].}

\begin{code}

record Eq : Type (ov œá) where
 constructor _‚âàÃá_
 field  {cxt}  : Type œá
        lhs    : Term cxt
        rhs    : Term cxt

open Eq public

\end{code}

We now define a type representing the notion of an equation \ab p \aoic{‚âàÃá} \ab q holding (when \ab p and \ab q are interpreted) in algebra \ab{ùë®}.

If \ab{ùë®} is an \ab{ùëÜ}-algebra we say that \ab{ùë®} \emph{satisfies} \ab p \aofld{‚âà} \ab q provided for all environments \ab{œÅ} : \ab X \as{‚Üí} \aof{‚à£} \ab{ùë®} \aof{‚à£} (assigning values in the domain of \ab{ùë®} to variable symbols in \ab X) we have \aof{‚ü¶} \ab p \aof{‚üß} \aofld{‚ü®\$‚ü©} \ab{œÅ} \aofld{‚âà} \aof{‚ü¶} \ab q \aof{‚üß} \aofld{‚ü®\$‚ü©} \ab{œÅ}.  In this situation, we write \ab{ùë®} \aof{‚äß} (\ab p \aoic{‚âàÃá} \ab q) and say that \ab{ùë®} \emph{models} the identity \ab p \aofld{‚âà} \ab q.

If \ab{ùí¶} is a class of algebras, all of the same signature, we write \ab{ùí¶} \aof{‚ä´} (\ab p \aoic{‚âàÃá} \ab q) if, for every \ab{ùë®} \aof{‚àà} \ab{ùí¶}, we have \ab{ùë®} \aof{‚äß} (\ab p \aoic{‚âàÃá} \ab q).

Because a class of structures has a different type than a single structure, we must use a slightly different syntax to avoid overloading the relations \aof{‚äß} and \aofld{‚âà}. As a reasonable alternative to what we would normally express informally as \ab{ùí¶} \aof{‚äß} \ab p \aofld{‚âà} \ab q, we have settled on \ab{ùí¶} \aof{‚ä´} (\ab p \aoic{‚âàÃá} \ab q) to denote this relation.  To reiterate, if \ab{ùí¶} is a class of \ab{ùëÜ}-algebras, we write \ab{ùí¶} \aof{‚ä´} (\ab p \aoic{‚âàÃá} \ab q) provided every \ab{ùë®} \aof{‚àà} \ab{ùí¶} satisfies \ab{ùë®} \aof{‚äß} (\ab p \aoic{‚âàÃá} \ab q).

\begin{code}

_‚äß_ : (ùë® : Algebra Œ± œÅ·µÉ)(term-identity : Eq{œá}) ‚Üí Type _
ùë® ‚äß (p ‚âàÃá q) = Equal p q where open Environment ùë®

_‚ä´_ : Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Eq{œá} ‚Üí Type (‚Ñì ‚äî œá ‚äî ov(Œ± ‚äî œÅ·µÉ))
ùí¶ ‚ä´ equ = ‚àÄ ùë® ‚Üí ùí¶ ùë® ‚Üí ùë® ‚äß equ

\end{code}

We denote by \ab{ùë®} \aof{‚ä®} \ab{‚Ñ∞} the assertion that the algebra \ab{ùë®} models every equation in a collection \ab{‚Ñ∞} of equations.

\begin{code}

_‚ä®_ : (ùë® : Algebra Œ± œÅ·µÉ) ‚Üí {Œπ : Level}{I : Type Œπ} ‚Üí (I ‚Üí Eq{œá}) ‚Üí Type _
ùë® ‚ä® ‚Ñ∞ = ‚àÄ i ‚Üí Equal (lhs (‚Ñ∞ i))(rhs (‚Ñ∞ i)) where open Environment ùë®
\end{code}

\subsection{Equational theories and models}
\label{equational-theories-and-models}

If \ab{ùí¶} denotes a class of structures, then \af{Th} \ab{ùí¶} represents the set of identities
modeled by the members of \ab{ùí¶}.

\begin{code}

Th : {X : Type œá} ‚Üí Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Pred(Term X √ó Term X) _
Th ùí¶ = Œª (p , q) ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q)

Mod : {X : Type œá} ‚Üí Pred(Term X √ó Term X) ‚Ñì ‚Üí Pred (Algebra Œ± œÅ·µÉ) _
Mod ‚Ñ∞ ùë® = ‚àÄ {p q} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí Equal p q where open Environment ùë®
\end{code}

\subsection{The entailment relation}
\label{the-entailment-relation}

Based on Andreas Abel's Agda formalization of Birkhoff's completeness theorem.

\begin{code}

module _ {œá Œπ : Level} where

 data _‚ä¢_‚ñπ_‚âà_ {I : Type Œπ}(‚Ñ∞ : I ‚Üí Eq) : (X : Type œá)(p q : Term X) ‚Üí Type (Œπ ‚äî ov œá) where
  hyp : ‚àÄ i ‚Üí let p ‚âàÃá q = ‚Ñ∞ i in ‚Ñ∞ ‚ä¢ _ ‚ñπ p ‚âà q
  app : ‚àÄ {ps qs} ‚Üí (‚àÄ i ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ ps i ‚âà qs i) ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ (node ùëì ps) ‚âà (node ùëì qs)
  sub : ‚àÄ {p q} ‚Üí ‚Ñ∞ ‚ä¢ Œî ‚ñπ p ‚âà q ‚Üí ‚àÄ (œÉ : Sub Œì Œî) ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ (p [ œÉ ]) ‚âà (q [ œÉ ])

  ‚ä¢refl   : ‚àÄ {p}               ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà p
  ‚ä¢sym    : ‚àÄ {p q : Term Œì}    ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ q ‚âà p
  ‚ä¢trans  : ‚àÄ {p q r : Term Œì}  ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ q ‚âà r ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà r

 ‚ä¢‚ñπ‚âàIsEquiv : {X : Type œá}{I : Type Œπ}{‚Ñ∞ : I ‚Üí Eq} ‚Üí IsEquivalence (‚Ñ∞ ‚ä¢ X ‚ñπ_‚âà_)
 ‚ä¢‚ñπ‚âàIsEquiv = record { refl = ‚ä¢refl ; sym = ‚ä¢sym ; trans = ‚ä¢trans }
\end{code}

\subsection{Soundness}
\label{soundness}

In any model \ab{ùë®} of the equations \ab{‚Ñ∞} derived equality is actual equality.\footnote{cf.~Andreas Abel's Agda formalization of Birkhoff's completeness theorem [ref needed].}

\begin{code}

module Soundness  {œá Œ± Œπ : Level}{I : Type Œπ} (‚Ñ∞ : I ‚Üí Eq{œá})
                  (ùë® : Algebra Œ± œÅ·µÉ)     -- We assume an algebra ùë®
                  (V : ùë® ‚ä® ‚Ñ∞)            -- that models all equations in ‚Ñ∞.
                  where

 open SetoidReasoning ùîª[ ùë® ]
 open Environment ùë®
 open IsEquivalence using ( refl ; sym ; trans )

 sound : ‚àÄ {p q} ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ùë® ‚äß (p ‚âàÃá q)
 sound (hyp i) = V i
 sound (app es) œÅ = cong (Interp ùë®) (‚â°.refl , Œª i ‚Üí sound (es i) œÅ)
 sound (sub {p = p}{q} Epq œÉ) œÅ =
  begin
   ‚ü¶ p  [ œÉ ]  ‚üß ‚ü®$‚ü©         œÅ  ‚âà‚ü®   substitution p œÉ œÅ    ‚ü©
   ‚ü¶ p         ‚üß ‚ü®$‚ü© ‚ü¶ œÉ ‚üßs  œÅ  ‚âà‚ü®   sound Epq (‚ü¶ œÉ ‚üßs œÅ)  ‚ü©
   ‚ü¶ q         ‚üß ‚ü®$‚ü© ‚ü¶ œÉ ‚üßs  œÅ  ‚âàÀò‚ü®  substitution q œÉ œÅ    ‚ü©
   ‚ü¶ q  [ œÉ ]  ‚üß ‚ü®$‚ü©         œÅ  ‚àé
 sound (‚ä¢refl   {p = p}                 ) = refl   EqualIsEquiv {x = p}
 sound (‚ä¢sym    {p = p}{q}     Epq      ) = sym    EqualIsEquiv {x = p}{q}     (sound Epq)
 sound (‚ä¢trans  {p = p}{q}{r}  Epq Eqr  ) = trans  EqualIsEquiv {i = p}{q}{r}  (sound Epq)(sound Eqr)
\end{code}


\subsection{The Closure Operators H, S, P and V}
\label{the-closure-operators-h-s-p-and-v}

Fix a signature \ab{ùëÜ}, let \ab{ùí¶} be a class of \ab{ùëÜ}-algebras, and define

\begin{itemize}
\item \af H \ab{ùí¶} = algebras isomorphic to a homomorphic image of a member of \ab{ùí¶};
\item \af S \ab{ùí¶} = algebras isomorphic to a subalgebra of a member of \ab{ùí¶};
\item \af P \ab{ùí¶} = algebras isomorphic to a product of members of \ab{ùí¶}.
\end{itemize}

A straight-forward verification confirms that \af H, \af S, and \ab P are \emph{closure operators} (expansive, monotone, and idempotent).  A class \ab{ùí¶} of \ab{ùëÜ}-algebras is said to be \emph{closed under the taking of homomorphic images} provided \af H \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}. Similarly, \ab{ùí¶} is \emph{closed under the taking of subalgebras} (resp., \emph{arbitrary products}) provided \af S \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶} (resp., \af P \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}). The operators \af H, \af S, and \af P can be composed with one another repeatedly, forming yet more closure operators.

An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class \af H \ab{ùí¶} (resp., \af S \ab{ùí¶}; resp., \af P \ab{ùí¶}) is closed under isomorphism.

A \emph{variety} is a class of \ab{ùëÜ}-algebras that is closed under the taking of
homomorphic images, subalgebras, and arbitrary products.  To represent varieties
we define types for the closure operators \af H, \af S, and \af P that are composable.
Separately, we define a type \af V which represents closure under all three
operators, \af H, \af S, and \af P.  Thus, if \ab{ùí¶} is a class of \ab{ùëÜ}-algebras`, then 
\af V \ab{ùí¶} := \af H (\af S (\af P \ab{ùí¶})), and \ab{ùí¶} is a variety iff \af V \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}.

We now define the type \af H to represent classes of algebras that include all homomorphic images of algebras in the class---i.e., classes that are closed under the taking of homomorphic images---the type \af S to represent classes of algebras that closed under the taking of subalgebras, and the type \af P to represent classes of algebras closed under the taking of arbitrary products.

\begin{code}

module _  {Œ± œÅ·µÉ Œ≤ œÅ·µá : Level} where
 private a = Œ± ‚äî œÅ·µÉ ; b = Œ≤ ‚äî œÅ·µá

 H : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) (b ‚äî ov(a ‚äî ‚Ñì))
 H _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© IsHomImageOf ùë®

 S : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) (b ‚äî ov(a ‚äî ‚Ñì))
 S _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© ‚â§ ùë®

 P : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) (b ‚äî ov(a ‚äî ‚Ñì ‚äî Œπ))
 P _ Œπ ùí¶ ùë© = Œ£[ I ‚àà Type Œπ ] (Œ£[ ùíú ‚àà (I ‚Üí Algebra Œ± œÅ·µÉ) ] (‚àÄ i ‚Üí ùíú i ‚àà ùí¶) √ó (ùë© ‚âÖ ‚®Ö ùíú))

module _  {Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà : Level} where
 private a = Œ± ‚äî œÅ·µÉ ; b = Œ≤ ‚äî œÅ·µá ; c = Œ≥ ‚äî œÅ·∂ú ; d = Œ¥ ‚äî œÅ·µà

 V : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí  Pred(Algebra Œ¥ œÅ·µà) (d ‚äî ov(a ‚äî b ‚äî c ‚äî ‚Ñì ‚äî Œπ))
 V ‚Ñì Œπ ùí¶ = H{Œ≥}{œÅ·∂ú}{Œ¥}{œÅ·µà} (a ‚äî b ‚äî ‚Ñì ‚äî Œπ) (S{Œ≤}{œÅ·µá} (a ‚äî ‚Ñì ‚äî Œπ) (P ‚Ñì Œπ ùí¶))
\end{code}
\begin{code}[hide]
module _ {Œ± œÅ·µÉ ‚Ñì : Level}(ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì))
         (ùë® : Algebra (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)) where
 private Œπ = ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)

 V-‚âÖ-lc : Lift-Alg ùë® Œπ Œπ ‚àà V{Œ≤ = Œπ}{Œπ} ‚Ñì Œπ ùí¶ ‚Üí ùë® ‚àà V{Œ≥ = Œπ}{Œπ} ‚Ñì Œπ ùí¶
 V-‚âÖ-lc (ùë®' , spA' , lAimgA') = ùë®' , (spA' , AimgA')
  where
  AimgA' : ùë® IsHomImageOf ùë®'
  AimgA' = Lift-HomImage-lemma lAimgA'
\end{code}


\paragraph*{Idempotence of S} \af S is a closure operator.  The facts that \af S is monotone and expansive won't be needed, so we omit the proof of these facts.  However, we will make use of idempotence of \af S, so we prove that property as follows.

\begin{code}

S-idem : {ùí¶ : Pred (Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}
 ‚Üí       S{Œ≤ = Œ≥}{œÅ·∂ú} (Œ± ‚äî œÅ·µÉ  ‚äî ‚Ñì) (S{Œ≤ = Œ≤}{œÅ·µá} ‚Ñì ùí¶) ‚äÜ S{Œ≤ = Œ≥}{œÅ·∂ú} ‚Ñì ùí¶

S-idem (ùë® , (ùë© , sB , A‚â§B) , x‚â§A) = ùë© , (sB , ‚â§-trans x‚â§A A‚â§B)
\end{code}

\paragraph*{Algebraic invariance of ‚äß}
The binary relation \aof{‚äß} would be practically useless if it were not an \emph{algebraic invariant} (i.e., invariant under isomorphism). Let us now verify that the models relation we defined above has this essential property.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá)(p q : Term X) where

 ‚äß-I-invar : ùë® ‚äß (p ‚âàÃá q)  ‚Üí  ùë® ‚âÖ ùë©  ‚Üí  ùë© ‚äß (p ‚âàÃá q)
 ‚äß-I-invar Apq (mkiso fh gh f‚àºg g‚àºf) œÅ =
  begin
   ‚ü¶ p ‚üß‚ÇÇ    ‚ü®$‚ü©               œÅ    ‚âàÀò‚ü®  cong ‚ü¶ p ‚üß‚ÇÇ (f‚àºg ‚àò œÅ)       ‚ü©
   ‚ü¶ p ‚üß‚ÇÇ    ‚ü®$‚ü© (f  ‚àò  (g  ‚àò  œÅ))  ‚âàÀò‚ü®  comm-hom-term fh p (g ‚àò œÅ)  ‚ü©
   f(‚ü¶ p ‚üß‚ÇÅ  ‚ü®$‚ü©        (g  ‚àò  œÅ))  ‚âà‚ü®   cong ‚à£ fh ‚à£ (Apq (g ‚àò œÅ))   ‚ü©
   f(‚ü¶ q ‚üß‚ÇÅ  ‚ü®$‚ü©        (g  ‚àò  œÅ))  ‚âà‚ü®   comm-hom-term fh q (g ‚àò œÅ)  ‚ü©
   ‚ü¶ q ‚üß‚ÇÇ    ‚ü®$‚ü© (f  ‚àò  (g  ‚àò  œÅ))  ‚âà‚ü®   cong ‚ü¶ q ‚üß‚ÇÇ (f‚àºg ‚àò œÅ)       ‚ü©
   ‚ü¶ q ‚üß‚ÇÇ    ‚ü®$‚ü©               œÅ    ‚àé
  where
  private f = _‚ü®$‚ü©_ ‚à£ fh ‚à£ ; g = _‚ü®$‚ü©_ ‚à£ gh ‚à£
  open Environment ùë®     using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
  open Environment ùë©     using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÇ )
  open SetoidReasoning ùîª[ ùë© ]
\end{code}

\paragraph*{Subalgebraic invariance of ‚äß}
Identities modeled by an algebra \ab{ùë®} are also modeled by every subalgebra of \ab{ùë®}, which fact can be formalized as follows.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{p q : Term X} where

 ‚äß-S-invar : ùë® ‚äß (p ‚âàÃá q) ‚Üí  ùë© ‚â§ ùë®  ‚Üí  ùë© ‚äß (p ‚âàÃá q)
 ‚äß-S-invar Apq B‚â§A b = goal
  where
  private hh = ‚à£ B‚â§A ‚à£ ; h = _‚ü®$‚ü©_ ‚à£ hh ‚à£
  open Setoid ùîª[ ùë® ]  using ( _‚âà_ )
  open Setoid ùîª[ ùë© ]  using () renaming ( _‚âà_ to _‚âà·¥Æ_ )
  open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨ )
  open Environment ùë©  using ( ‚ü¶_‚üß )
  open SetoidReasoning ùîª[ ùë® ]

  Œæ : ‚àÄ b ‚Üí h (‚ü¶ p ‚üß ‚ü®$‚ü© b) ‚âà h (‚ü¶ q ‚üß ‚ü®$‚ü© b)
  Œæ b = begin
         h (‚ü¶ p ‚üß  ‚ü®$‚ü©         b)  ‚âà‚ü®   comm-hom-term hh p b  ‚ü©
         ‚ü¶ p ‚üß·¥¨    ‚ü®$‚ü©  (h  ‚àò  b)  ‚âà‚ü®   Apq (h ‚àò b)           ‚ü©
         ‚ü¶ q ‚üß·¥¨    ‚ü®$‚ü©  (h  ‚àò  b)  ‚âàÀò‚ü®  comm-hom-term hh q b  ‚ü©
         h (‚ü¶ q ‚üß  ‚ü®$‚ü©         b)  ‚àé

  goal : ‚ü¶ p ‚üß ‚ü®$‚ü© b ‚âà·¥Æ ‚ü¶ q ‚üß ‚ü®$‚ü© b
  goal = ‚à• B‚â§A ‚à• (Œæ b)
\end{code}

\paragraph*{Product invariance of ‚äß}
An identity satisfied by all algebras in an indexed collection is also satisfied by the product of algebras in that collection.

\begin{code}

module _ {X : Type œá}{I : Type ‚Ñì}(ùíú : I ‚Üí Algebra Œ± œÅ·µÉ){p q : Term X} where

 ‚äß-P-invar : (‚àÄ i ‚Üí ùíú i ‚äß (p ‚âàÃá q)) ‚Üí ‚®Ö ùíú ‚äß (p ‚âàÃá q)
 ‚äß-P-invar ùíúpq a =
  begin
   ‚ü¶ p ‚üß‚ÇÅ               ‚ü®$‚ü©  a                ‚âà‚ü®   interp-prod ùíú p a  ‚ü©
   ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß p)  ‚ü®$‚ü©  Œª x ‚Üí (a x) i )  ‚âà‚ü®   Œæ                  ‚ü©
   ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß q)  ‚ü®$‚ü©  Œª x ‚Üí (a x) i )  ‚âàÀò‚ü®  interp-prod ùíú q a  ‚ü©
   ‚ü¶ q ‚üß‚ÇÅ               ‚ü®$‚ü©  a                ‚àé
  where
  open Environment (‚®Ö ùíú)  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
  open Environment        using ( ‚ü¶_‚üß )
  open Setoid ùîª[ ‚®Ö ùíú ]    using ( _‚âà_ )
  open SetoidReasoning ùîª[ ‚®Ö ùíú ]
  Œæ : ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß p) ‚ü®$‚ü© Œª x ‚Üí (a x) i ) ‚âà ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß q) ‚ü®$‚ü© Œª x ‚Üí (a x) i )
  Œæ = Œª i ‚Üí ùíúpq i (Œª x ‚Üí (a x) i)
\end{code}


\paragraph*{PS ‚äÜ SP}
Another important fact we will need about the operators \af S and \af P is that a product of subalgebras of algebras in a class \ab{ùí¶} is a subalgebra of a product of algebras in \ab{ùí¶}. We denote this inclusion by \af{PS‚äÜSP}, which we state and prove as follows.

\begin{code}

module _  {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private
  a = Œ± ‚äî œÅ·µÉ
  oa‚Ñì = ov (a ‚äî ‚Ñì)

 PS‚äÜSP : P (a ‚äî ‚Ñì) oa‚Ñì (S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶) ‚äÜ S oa‚Ñì (P ‚Ñì oa‚Ñì ùí¶)
 PS‚äÜSP {ùë©} (I , ( ùíú , sA , B‚âÖ‚®ÖA )) = Goal
  where
  ‚Ñ¨ : I ‚Üí Algebra Œ± œÅ·µÉ
  ‚Ñ¨ i = ‚à£ sA i ‚à£
  kB : (i : I) ‚Üí ‚Ñ¨ i ‚àà ùí¶
  kB i =  fst ‚à• sA i ‚à•
  ‚®ÖA‚â§‚®ÖB : ‚®Ö ùíú ‚â§ ‚®Ö ‚Ñ¨
  ‚®ÖA‚â§‚®ÖB = ‚®Ö-‚â§ Œª i ‚Üí snd ‚à• sA i ‚à•
  Goal : ùë© ‚àà S{Œ≤ = oa‚Ñì}{oa‚Ñì}oa‚Ñì (P {Œ≤ = oa‚Ñì}{oa‚Ñì} ‚Ñì oa‚Ñì ùí¶)
  Goal = ‚®Ö ‚Ñ¨ , (I , (‚Ñ¨ , (kB , ‚âÖ-refl))) , (‚âÖ-trans-‚â§ B‚âÖ‚®ÖA ‚®ÖA‚â§‚®ÖB)
\end{code}

\paragraph*{Identity preservation}
The classes \af H \ab{ùí¶}, \af S \ab{ùí¶}, \af P \ab{ùí¶}, and \af V \ab{ùí¶} all satisfy the same set of equations.  We will only use a subset of the inclusions used to prove this fact. (For a complete proof, see the
\ualmodule{Varieties.Func.Preservation} module of the \agdaalgebras library.)


\paragraph*{H preserves identities}
First we prove that the closure operator \af H is compatible with identities that hold in the given class.

\begin{code}

module _  {X : Type œá}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where

 H-id1 : ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí (H {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì ùí¶) ‚ä´ (p ‚âàÃá q)
 H-id1 œÉ ùë© (ùë® , kA , BimgOfA) œÅ =
  begin
   ‚ü¶ p ‚üß       ‚ü®$‚ü©                 œÅ     ‚âàÀò‚ü®  cong ‚ü¶ p ‚üß Œ∂                  ‚ü©
   ‚ü¶ p ‚üß       ‚ü®$‚ü©  (œÜ  ‚àò  œÜ‚Åª¬π  ‚àò  œÅ)    ‚âàÀò‚ü®  comm-hom-term œÜh p (œÜ‚Åª¬π ‚àò œÅ)  ‚ü©
   œÜ ( ‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü©  (      œÜ‚Åª¬π  ‚àò  œÅ) )  ‚âà‚ü®   cong ‚à£ œÜh ‚à£ (IH (œÜ‚Åª¬π ‚àò œÅ))    ‚ü©
   œÜ ( ‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü©  (      œÜ‚Åª¬π  ‚àò  œÅ) )  ‚âà‚ü®   comm-hom-term œÜh q (œÜ‚Åª¬π ‚àò œÅ)  ‚ü©
   ‚ü¶ q ‚üß       ‚ü®$‚ü©  (œÜ  ‚àò  œÜ‚Åª¬π  ‚àò  œÅ)    ‚âà‚ü®   cong ‚ü¶ q ‚üß Œ∂                  ‚ü©
   ‚ü¶ q ‚üß       ‚ü®$‚ü©                 œÅ     ‚àé
    where
    open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨)
    open Environment ùë©  using ( ‚ü¶_‚üß )
    open Setoid ùîª[ ùë© ]  using ( _‚âà_ )
    open SetoidReasoning ùîª[ ùë© ]

    IH : ùë® ‚äß (p ‚âàÃá q)
    IH = œÉ ùë® kA

    œÜh : hom ùë® ùë©
    œÜh = ‚à£ BimgOfA ‚à£
    private œÜ = (_‚ü®$‚ü©_ ‚à£ œÜh ‚à£)

    œÜE : IsSurjective ‚à£ œÜh ‚à£
    œÜE = ‚à• BimgOfA ‚à•

    œÜ‚Åª¬π : ùïå[ ùë© ] ‚Üí ùïå[ ùë® ]
    œÜ‚Åª¬π = SurjInv ‚à£ œÜh ‚à£ œÜE

    Œ∂ : ‚àÄ x ‚Üí (œÜ ‚àò œÜ‚Åª¬π ‚àò œÅ) x ‚âà œÅ x
    Œ∂ = Œª _ ‚Üí InvIsInverse ≥ œÜE


\end{code}

\paragraph*{S preserves identities}

\begin{code}

 S-id1 : ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí (S {Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶) ‚ä´ (p ‚âàÃá q)
 S-id1 œÉ ùë© (ùë® , kA , B‚â§A) = ‚äß-S-invar{p = p}{q} (œÉ ùë® kA) B‚â§A

\end{code}

The obvious converse is barely worth the bits needed to formalize it, but we will use it below, so let's prove it now.

\begin{code}

 S-id2 : S ‚Ñì ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q)
 S-id2 Spq ùë® kA = Spq ùë® (ùë® , (kA , ‚â§-reflexive))
\end{code}


\paragraph*{P preserves identities}

\begin{code}

 P-id1 : ‚àÄ{Œπ} ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶ ‚ä´ (p ‚âàÃá q)
 P-id1 œÉ ùë® (I , ùíú , kA , A‚âÖ‚®ÖA) = ‚äß-I-invar ùë® p q IH (‚âÖ-sym A‚âÖ‚®ÖA)
  where
  ih : ‚àÄ i ‚Üí ùíú i ‚äß (p ‚âàÃá q)
  ih i = œÉ (ùíú i) (kA i)
  IH : ‚®Ö ùíú ‚äß (p ‚âàÃá q)
  IH = ‚äß-P-invar ùíú {p}{q} ih
\end{code}


\paragraph*{V preserves identities}
Finally, we prove the analogous preservation lemmas for the closure operator \af V.

\begin{code}

module _ {X : Type œá}{Œπ : Level}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where
 private
  a‚ÑìŒπ = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ‚äî Œπ

 V-id1 : ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí V ‚Ñì Œπ ùí¶ ‚ä´ (p ‚âàÃá q)
 V-id1 œÉ ùë© (ùë® , (‚®ÖA , p‚®ÖA , A‚â§‚®ÖA) , BimgA) =
  H-id1{‚Ñì = a‚ÑìŒπ}{ùí¶ = S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)}{p = p}{q} spK‚äßpq ùë© (ùë® , (spA , BimgA))
   where
   spA : ùë® ‚àà S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)
   spA = ‚®ÖA , (p‚®ÖA , A‚â§‚®ÖA)
   spK‚äßpq : S a‚ÑìŒπ (P ‚Ñì Œπ ùí¶) ‚ä´ (p ‚âàÃá q)
   spK‚äßpq = S-id1{‚Ñì = a‚ÑìŒπ}{p = p}{q} (P-id1{‚Ñì = ‚Ñì} {ùí¶ = ùí¶}{p = p}{q} œÉ)
\end{code}

\paragraph*{Th ùí¶ ‚äÜ Th (V ùí¶)}
From \af{V-id1} it follows that if \ab{ùí¶} is a class of algebras, then the set of identities modeled by the algebras in \ab{ùí¶} is contained in the set of identities modeled by the algebras in \af V \ab{ùí¶}.  In other terms, \af{Th} \ab{ùí¶} \aof{‚äÜ} \af{Th} (\af V \ab{ùí¶}).  We formalize this observation as follows.

\begin{code}

 classIds-‚äÜ-VIds : ùí¶ ‚ä´ (p ‚âàÃá q)  ‚Üí (p , q) ‚àà Th (V ‚Ñì Œπ ùí¶)
 classIds-‚äÜ-VIds pKq ùë® = V-id1 pKq ùë®
\end{code}




%% -------------------------------------------------------------------------------------

\section{Free Algebras and the HSP Theorem}
\label{free-algebras-and-the-hsp-theorem}

\subsection{The absolutely free algebra ùëª X}
\label{the-absolutely-free-algebra-tx}

The term algebra \af{ùëª} \ab X is \emph{absolutely free} (or \emph{universal}, or
\emph{initial}) for algebras in the signature \ab{ùëÜ}. That is, for every
\ab{ùëÜ}-algebra \ab{ùë®}, the following hold.

\begin{itemize}
\item Every function from \ab{ùëã} to \aof{‚à£} \ab{ùë®} \aof{‚à£} lifts to a
  homomorphism from \af{ùëª} \ab{X} to \ab{ùë®}.
\item The homomorphism that exists by item 1 is unique.
\end{itemize}

We now prove this in \agda, starting with the fact that every map from \ab{X} to
\aof{‚à£} \ab{ùë®} \aof{‚à£} lifts to a map from \aof{‚à£} \af{ùëª} \ab{X} \aof{‚à£} to
\aof{‚à£} \ab{ùë®} \aof{‚à£} in a natural way, by induction on the structure of the given term.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(h : X ‚Üí ùïå[ ùë® ]) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; reflexive ; refl ; trans )

 free-lift : ùïå[ ùëª X ] ‚Üí ùïå[ ùë® ]
 free-lift (‚Ñä x) = h x
 free-lift (node f t) = (f ÃÇ ùë®) (Œª i ‚Üí free-lift (t i))

 free-lift-func : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùë® ]
 free-lift-func ‚ü®$‚ü© x = free-lift x
 cong free-lift-func = flcong
  where
  flcong : ‚àÄ {s t} ‚Üí s ‚âê t ‚Üí  free-lift s ‚âà free-lift t
  flcong (_‚âê_.rfl x) = reflexive (‚â°.cong h x)
  flcong (_‚âê_.gnl x) = cong (Interp ùë®) (‚â°.refl , (Œª i ‚Üí flcong (x i)))

\end{code}

Naturally, at the base step of the induction, when the term has the form \aic{‚Ñä}
\ab x, the free lift of \ab h agrees with \ab h.  For the inductive step, when the
given term has the form \aic{node} \ab f \ab t, the free lift is defined as
follows: Assuming (the induction hypothesis) that we know the image of each
subterm \ab t \ab i under the free lift of \ab h, define the free lift at the
full term by applying \ab f \aof{ÃÇ} \ab{ùë®} to the images of the subterms.

The free lift so defined is a homomorphism by construction. Indeed, here is the trivial proof.

\begin{code}

 lift-hom : hom (ùëª X) ùë®
 lift-hom = free-lift-func , hhom
  where
  hfunc : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùë® ]
  hfunc = free-lift-func

  hcomp : compatible-map (ùëª X) ùë® free-lift-func
  hcomp {f}{a} = cong (Interp ùë®) (‚â°.refl , (Œª i ‚Üí (cong free-lift-func){a i} ‚âê-isRefl))

  hhom : IsHom (ùëª X) ùë® hfunc
  hhom = mkhom (Œª{f}{a} ‚Üí hcomp{f}{a})


module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ} where
 open Setoid ùîª[ ùë® ]  using ( _‚âà_ ; refl )
 open Environment ùë®  using ( ‚ü¶_‚üß )

 free-lift-interp : (Œ∑ : X ‚Üí ùïå[ ùë® ])(p : Term X) ‚Üí ‚ü¶ p ‚üß ‚ü®$‚ü© Œ∑ ‚âà (free-lift {ùë® = ùë®} Œ∑) p
 free-lift-interp Œ∑ (‚Ñä x) = refl
 free-lift-interp Œ∑ (node f t) = cong (Interp ùë®) (‚â°.refl , (free-lift-interp Œ∑) ‚àò t)
\end{code}




\subsection{The relatively free algebra ùîΩ[ X ]}
\label{the-relatively-free-algebra-f}

We now define the algebra
\AgdaOperator{\AgdaFunction{ùîΩ[}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}},
which represents the relatively free algebra.
Here, as above, \ab X plays the role of an arbitrary nonempty collection of variables. (It would suffice to take\ab X to be the cardinality of the largest algebra in \ab{ùí¶}, but since we don't know that cardinality, we leave \ab X aribtrary for now.)

\begin{code}

module FreeAlgebra {œá : Level}{Œπ : Level}{I : Type Œπ}(‚Ñ∞ : I ‚Üí Eq) where
 open Algebra

 FreeDomain : Type œá ‚Üí Setoid _ _
 FreeDomain X = record  { Carrier        = Term X
                        ; _‚âà_            = ‚Ñ∞ ‚ä¢ X ‚ñπ_‚âà_
                        ; isEquivalence  = ‚ä¢‚ñπ‚âàIsEquiv }
\end{code}

The interpretation of an operation is simply the operation itself.
This works since
\AgdaBound{‚Ñ∞}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚ä¢}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚ñπ\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}
is a congruence.

\begin{code}

 FreeInterp : ‚àÄ {X} ‚Üí ‚ü® ùëÜ ‚ü© (FreeDomain X) ‚ü∂ FreeDomain X
 FreeInterp ‚ü®$‚ü© (f , ts) = node f ts
 cong FreeInterp (‚â°.refl , h) = app h

 ùîΩ[_] : Type œá ‚Üí Algebra (ov œá) (Œπ ‚äî ov œá)
 Domain ùîΩ[ X ] = FreeDomain X
 Interp ùîΩ[ X ] = FreeInterp
\end{code}

\subsection{Basic properties of free algebras}
\label{basic-properties-of-free-algebras}

\begin{code}

module FreeHom (œá : Level) {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private Œπ = ov(œá ‚äî Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)
 open Eq

 ‚Ñê : Type Œπ -- indexes the collection of equations modeled by ùí¶
 ‚Ñê = Œ£[ eq ‚àà Eq{œá} ] ùí¶ ‚ä´ ((lhs eq) ‚âàÃá (rhs eq))

 ‚Ñ∞ : ‚Ñê ‚Üí Eq
 ‚Ñ∞ (eqv , p) = eqv

 ‚Ñ∞‚ä¢[_]‚ñπThùí¶ : (X : Type œá) ‚Üí ‚àÄ{p q} ‚Üí ‚Ñ∞ ‚ä¢ X ‚ñπ p ‚âà q ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q)
 ‚Ñ∞‚ä¢[ X ]‚ñπThùí¶ x ùë® kA = sound (Œª i œÅ ‚Üí ‚à• i ‚à• ùë® kA œÅ) x where open Soundness ‚Ñ∞ ùë®
 open FreeAlgebra {Œπ = Œπ}{I = ‚Ñê} ‚Ñ∞ using ( ùîΩ[_] )
\end{code}


\paragraph*{The natural epimorphism from ùëª X to ùîΩ[ X ]}
We now define the natural epimorphism from
\T{X} onto the relatively free algebra \Free{X} and prove that 
the kernel of this morphism is the congruence of \T{X}
defined by the identities modeled by (\af S \ab{ùí¶}, hence by) \ab{ùí¶}.

\begin{code}

 epiùîΩ[_] : (X : Type œá) ‚Üí epi (ùëª X) ùîΩ[ X ]
 epiùîΩ[ X ] = h , hepi
  where
  open Algebra (ùëª X)   using () renaming ( Domain  to TX    )
  open Algebra ùîΩ[ X ]  using () renaming ( Domain  to F     )
  open Setoid TX       using () renaming ( _‚âà_     to _‚âà‚ÇÄ_  ; refl to refl‚ÇÄ )
  open Setoid F        using () renaming ( _‚âà_     to _‚âà‚ÇÅ_  ; refl to refl‚ÇÅ )
  open _‚âê_

  c : ‚àÄ {x y} ‚Üí x ‚âà‚ÇÄ y ‚Üí x ‚âà‚ÇÅ y
  c (rfl {x}{y} ‚â°.refl) = refl‚ÇÅ
  c (gnl {f}{s}{t} x) = cong (Interp ùîΩ[ X ]) (‚â°.refl , c ‚àò x)

  h : TX ‚ü∂ F
  h = record { f = id ; cong = c }

  hepi : IsEpi (ùëª X) ùîΩ[ X ] h
  compatible (isHom hepi) = cong h refl‚ÇÄ
  isSurjective hepi {y} = eq y refl‚ÇÅ

 homùîΩ[_] : (X : Type œá) ‚Üí hom (ùëª X) ùîΩ[ X ]
 homùîΩ[ X ] = IsEpi.HomReduct ‚à• epiùîΩ[ X ] ‚à•

 homùîΩ[_]-is-epic : (X : Type œá) ‚Üí IsSurjective ‚à£ homùîΩ[ X ] ‚à£
 homùîΩ[ X ]-is-epic = IsEpi.isSurjective (snd (epiùîΩ[ X ]))
\end{code}

As promised, we prove that the kernel of the natural epimorphism is the congruence defined by the identities modelled by \ab{ùí¶}.

\begin{code}

 class-models-kernel : ‚àÄ{X p q} ‚Üí (p , q) ‚àà ker ‚à£ homùîΩ[ X ] ‚à£ ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q)
 class-models-kernel {X = X}{p}{q} pKq = ‚Ñ∞‚ä¢[ X ]‚ñπThùí¶ pKq

 kernel-in-theory : {X : Type œá} ‚Üí ker ‚à£ homùîΩ[ X ] ‚à£ ‚äÜ Th (V ‚Ñì Œπ ùí¶)
 kernel-in-theory {X = X} {p , q} pKq vkA x = classIds-‚äÜ-VIds {‚Ñì = ‚Ñì}{p = p}{q}
                                               (class-models-kernel pKq) vkA x

 module _ {X : Type œá} {ùë® : Algebra Œ± œÅ·µÉ}{sA : ùë® ‚àà S {Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶} where
  open Environment ùë® using ( Equal )
  kerùîΩ‚äÜEqual : ‚àÄ{p q} ‚Üí (p , q) ‚àà ker ‚à£ homùîΩ[ X ] ‚à£ ‚Üí Equal p q
  kerùîΩ‚äÜEqual{p = p}{q} x = S-id1{‚Ñì = ‚Ñì}{p = p}{q} (‚Ñ∞‚ä¢[ X ]‚ñπThùí¶ x) ùë® sA

 ùí¶‚ä´‚Üí‚Ñ∞‚ä¢ : {X : Type œá} ‚Üí ‚àÄ{p q} ‚Üí ùí¶ ‚ä´ (p ‚âàÃá q) ‚Üí ‚Ñ∞ ‚ä¢ X ‚ñπ p ‚âà q
 ùí¶‚ä´‚Üí‚Ñ∞‚ä¢ {p = p} {q} pKq = hyp ((p ‚âàÃá q) , pKq) where open _‚ä¢_‚ñπ_‚âà_ using (hyp)
\end{code}

\paragraph*{The universal property}

\begin{code}

module _  {ùë® : Algebra (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private Œπ = ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)

 open FreeHom {‚Ñì = ‚Ñì}(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) {ùí¶}
 open FreeAlgebra {Œπ = Œπ}{I = ‚Ñê} ‚Ñ∞  using ( ùîΩ[_] )
 open Setoid ùîª[ ùë® ]                 using ( trans ; sym ; refl ) renaming ( Carrier to A )


 ùîΩ-ModTh-epi : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶))
  ‚Üí            epi ùîΩ[ A ] ùë®
 ùîΩ-ModTh-epi A‚ààModThK = œÜ , isEpi
  where
   œÜ : ùîª[ ùîΩ[ A ] ] ‚ü∂ ùîª[ ùë® ]
   _‚ü®$‚ü©_ œÜ = free-lift{ùë® = ùë®} id
   cong œÜ {p} {q} pq  = trans  ( sym (free-lift-interp{ùë® = ùë®} id p) )
                      ( trans  ( A‚ààModThK{p = p}{q} (kernel-in-theory pq) id )
                               ( free-lift-interp{ùë® = ùë®} id q ) )
   isEpi : IsEpi ùîΩ[ A ] ùë® œÜ
   compatible (isHom isEpi) = cong (Interp ùë®) (‚â°.refl , (Œª _ ‚Üí refl))
   isSurjective isEpi {y} = eq (‚Ñä y) refl

 ùîΩ-ModTh-epi-lift : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí epi ùîΩ[ A ] (Lift-Alg ùë® Œπ Œπ)
 ùîΩ-ModTh-epi-lift A‚ààModThK = ‚àò-epi (ùîΩ-ModTh-epi (Œª {p q} ‚Üí A‚ààModThK{p = p}{q})) ToLift-epi
\end{code}



%% -------------------------------------------------------------------------------------

\subsection{Products of classes of algebras}
\label{products-of-classes-of-algebras}

We want to pair each (\ab{ùë®} , \ab p) (where \ab p : \ab{ùë®} \af{‚àà} \af S \ab{ùí¶}) with an environment
\ab{œÅ} : \ab X \as{‚Üí} \aof{‚à£} \ab{ùë®} \aof{‚à£} so that we can quantify over all algebras \emph{and} all
assignments of values in the domain \aof{‚à£} \ab{ùë®} \aof{‚à£} to variables in \ab X.

\begin{code}

module _ (ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)){X : Type (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} where
 private Œπ = ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)
 open FreeHom {‚Ñì = ‚Ñì} (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì){ùí¶}
 open FreeAlgebra {Œπ = Œπ}{I = ‚Ñê} ‚Ñ∞  using ( ùîΩ[_] )
 open Environment                   using ( Env )

 ‚Ñë‚Å∫ : Type Œπ
 ‚Ñë‚Å∫ = Œ£[ ùë® ‚àà (Algebra Œ± œÅ·µÉ) ] (ùë® ‚àà S ‚Ñì ùí¶) √ó (Carrier (Env ùë® X))

 ùîÑ‚Å∫ : ‚Ñë‚Å∫ ‚Üí Algebra Œ± œÅ·µÉ
 ùîÑ‚Å∫ i = ‚à£ i ‚à£

 ‚Ñ≠ : Algebra Œπ Œπ
 ‚Ñ≠ = ‚®Ö ùîÑ‚Å∫

\end{code}

Next we define a useful type, \af{skEqual}, which we use to represent a term identity \ab p \aic{‚âà} \ab q for any
given \ab i = (\ab{ùë®} , \ab{sA} , \ab{œÅ}) (where \ab{ùë®} is an algebra, \ab{sA} : \ab{ùë®} \af{‚àà} \af{S} \ab{ùí¶} is a proof that \ab{ùë®} belongs to \af{S} \ab{ùí¶}, and \ab{œÅ} is a mapping from \ab X to the domain of \ab{ùë®}). Then we prove \af{AllEqual‚äÜkerùîΩ} which asserts that if the identity \ab{p} \aic{‚âà} \ab q holds in all \ab{ùë®} \aof{‚àà} \af S \ab{ùí¶} (for all environments), then \ab p \aic{‚âà} \ab q
holds in the relatively free algebra
\Free{X}; equivalently, the pair (\ab p , \ab q) belongs to the
kernel of the natural homomorphism from
\T{X} onto \Free{X}. We will use this fact below to prove
that there is a monomorphism from \Free{X} into \ab{‚Ñ≠}, and thus \Free{X} is a subalgebra of \ab{‚Ñ≠},
so belongs to \af S (\af P \ab{ùí¶}).

\begin{code}

 skEqual : (i : ‚Ñë‚Å∫) ‚Üí ‚àÄ{p q} ‚Üí Type œÅ·µÉ
 skEqual i {p}{q} = ‚ü¶ p ‚üß ‚ü®$‚ü© snd ‚à• i ‚à• ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© snd ‚à• i ‚à•
  where
  open Setoid ùîª[ ùîÑ‚Å∫ i ]    using ( _‚âà_ )
  open Environment (ùîÑ‚Å∫ i)  using ( ‚ü¶_‚üß )

 AllEqual‚äÜkerùîΩ : ‚àÄ {p q} ‚Üí (‚àÄ i ‚Üí skEqual i {p}{q}) ‚Üí (p , q) ‚àà ker ‚à£ homùîΩ[ X ] ‚à£
 AllEqual‚äÜkerùîΩ {p} {q} x = Goal
  where
  open Setoid ùîª[ ùîΩ[ X ] ] using ( _‚âà_ )
  Sùí¶‚ä´pq : S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶ ‚ä´ (p ‚âàÃá q)
  Sùí¶‚ä´pq ùë® sA œÅ = x (ùë® , sA , œÅ)
  Goal : p ‚âà q
  Goal = ùí¶‚ä´‚Üí‚Ñ∞‚ä¢ (S-id2{‚Ñì = ‚Ñì}{p = p}{q} Sùí¶‚ä´pq)

 hom‚Ñ≠ : hom (ùëª X) ‚Ñ≠
 hom‚Ñ≠ = ‚®Ö-hom-co ùîÑ‚Å∫ h
  where
  h : ‚àÄ i ‚Üí hom (ùëª X) (ùîÑ‚Å∫ i)
  h i = lift-hom (snd ‚à• i ‚à•)

 kerùîΩ‚äÜker‚Ñ≠ : ker ‚à£ homùîΩ[ X ] ‚à£ ‚äÜ ker ‚à£ hom‚Ñ≠ ‚à£
 kerùîΩ‚äÜker‚Ñ≠ {p , q} pKq (ùë® , sA , œÅ) = Goal
  where
  open Setoid ùîª[ ùë® ]  using ( _‚âà_ ; sym ; trans )
  open Environment ùë®  using ( ‚ü¶_‚üß )
  fl : ‚àÄ t ‚Üí ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ ‚âà free-lift œÅ t
  fl t = free-lift-interp {ùë® = ùë®} œÅ t
  subgoal : ‚ü¶ p ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© œÅ
  subgoal = kerùîΩ‚äÜEqual{ùë® = ùë®}{sA} pKq œÅ
  Goal : (free-lift{ùë® = ùë®} œÅ p) ‚âà (free-lift{ùë® = ùë®} œÅ q)
  Goal = trans (sym (fl p)) (trans subgoal (fl q))


 homùîΩ‚Ñ≠ : hom ùîΩ[ X ] ‚Ñ≠
 homùîΩ‚Ñ≠ = ‚à£ HomFactor ‚Ñ≠ hom‚Ñ≠ homùîΩ[ X ] kerùîΩ‚äÜker‚Ñ≠ homùîΩ[ X ]-is-epic ‚à£

 ker‚Ñ≠‚äÜkerùîΩ : ‚àÄ{p q} ‚Üí (p , q) ‚àà ker ‚à£ hom‚Ñ≠ ‚à£ ‚Üí (p , q) ‚àà ker ‚à£ homùîΩ[ X ] ‚à£
 ker‚Ñ≠‚äÜkerùîΩ {p}{q} pKq = E‚ä¢pq
  where
  pqEqual : ‚àÄ i ‚Üí skEqual i {p}{q}
  pqEqual i = goal
   where
   open Environment (ùîÑ‚Å∫ i)  using ( ‚ü¶_‚üß )
   open Setoid ùîª[ ùîÑ‚Å∫ i ]    using ( _‚âà_ ; sym ; trans )
   goal : ‚ü¶ p ‚üß ‚ü®$‚ü© snd ‚à• i ‚à• ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© snd ‚à• i ‚à•
   goal = trans (free-lift-interp{ùë® = ‚à£ i ‚à£}(snd ‚à• i ‚à•) p)
           (trans (pKq i)(sym (free-lift-interp{ùë® = ‚à£ i ‚à£} (snd ‚à• i ‚à•) q)))
  E‚ä¢pq : ‚Ñ∞ ‚ä¢ X ‚ñπ p ‚âà q
  E‚ä¢pq = AllEqual‚äÜkerùîΩ pqEqual

 monùîΩ‚Ñ≠ : mon ùîΩ[ X ] ‚Ñ≠
 monùîΩ‚Ñ≠ = ‚à£ homùîΩ‚Ñ≠ ‚à£ , isMon
  where
  isMon : IsMon ùîΩ[ X ] ‚Ñ≠ ‚à£ homùîΩ‚Ñ≠ ‚à£
  isHom isMon = ‚à• homùîΩ‚Ñ≠ ‚à•
  isInjective isMon {p} {q} œÜpq = ker‚Ñ≠‚äÜkerùîΩ œÜpq

\end{code}

Now that we have proved the existence of a monomorphism from \Free{X} to \ab{‚Ñ≠} we can
prove that \Free{X} is a subalgebra of \ab{‚Ñ≠}, so belongs to \af S (\af P \ab{ùí¶}).

\begin{code}

 ùîΩ‚â§‚Ñ≠ : ùîΩ[ X ] ‚â§ ‚Ñ≠
 ùîΩ‚â§‚Ñ≠ = mon‚Üí‚â§ monùîΩ‚Ñ≠

 SPùîΩ : ùîΩ[ X ] ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
 SPùîΩ = S-idem SSPùîΩ
  where
  PS‚Ñ≠ : ‚Ñ≠ ‚àà P (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) Œπ (S ‚Ñì ùí¶)
  PS‚Ñ≠ = ‚Ñë‚Å∫ , (ùîÑ‚Å∫ , ((Œª i ‚Üí fst ‚à• i ‚à•) , ‚âÖ-refl))
  SP‚Ñ≠ : ‚Ñ≠ ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
  SP‚Ñ≠ = PS‚äÜSP {‚Ñì = ‚Ñì} PS‚Ñ≠
  SSPùîΩ : ùîΩ[ X ] ‚àà S Œπ (S Œπ (P ‚Ñì Œπ ùí¶))
  SSPùîΩ = ‚Ñ≠ , (SP‚Ñ≠ , ùîΩ‚â§‚Ñ≠)
\end{code}



%% -------------------------------------------------------------------------------------

\subsection{The HSP Theorem}

Finally, we are in a position to prove Birkhoff's celebrated variety theorem.

\begin{code}

module _ {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private Œπ = ov(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)
 open FreeHom {‚Ñì = ‚Ñì}(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì){ùí¶}
 open FreeAlgebra {Œπ = Œπ}{I = ‚Ñê} ‚Ñ∞ using ( ùîΩ[_] )

 Birkhoff : ‚àÄ ùë® ‚Üí ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí ùë® ‚àà V ‚Ñì Œπ ùí¶
 Birkhoff ùë® ModThA = V-‚âÖ-lc{Œ±}{œÅ·µÉ}{‚Ñì} ùí¶ ùë® VlA
  where
  open Setoid ùîª[ ùë® ] using () renaming ( Carrier to A )
  spùîΩA : ùîΩ[ A ] ‚àà S{Œπ} Œπ (P ‚Ñì Œπ ùí¶)
  spùîΩA = SPùîΩ{‚Ñì = ‚Ñì} ùí¶
  epiùîΩlA : epi ùîΩ[ A ] (Lift-Alg ùë® Œπ Œπ)
  epiùîΩlA = ùîΩ-ModTh-epi-lift{‚Ñì = ‚Ñì} (Œª {p q} ‚Üí ModThA{p = p}{q})
  lAimgùîΩA : Lift-Alg ùë® Œπ Œπ IsHomImageOf ùîΩ[ A ]
  lAimgùîΩA = epi‚Üíontohom ùîΩ[ A ] (Lift-Alg ùë® Œπ Œπ) epiùîΩlA
  VlA : Lift-Alg ùë® Œπ Œπ ‚àà V ‚Ñì Œπ ùí¶
  VlA = ùîΩ[ A ] , spùîΩA , lAimgùîΩA

\end{code}

The converse inclusion, \af V \ab{ùí¶} \aof{‚äÜ} \af{Mod} (\af{Th} (\af V \ab{ùí¶})), is a simple consequence of the fact that \af{Mod} \af{Th} is a closure operator. Nonetheless, completeness demands
that we formalize this inclusion as well, however trivial the proof.

\begin{code}

 module _ {ùë® : Algebra Œ± œÅ·µÉ} where
  Birkhoff-converse : ùë® ‚àà V{Œ±}{œÅ·µÉ}{Œ±}{œÅ·µÉ}{Œ±}{œÅ·µÉ} ‚Ñì Œπ ùí¶ ‚Üí ùë® ‚àà Mod{X = ùïå[ ùë® ]} (Th (V ‚Ñì Œπ ùí¶))
  Birkhoff-converse vA pThq = pThq ùë® vA

\end{code}

We have thus proved that every variety is an equational class.

Readers familiar with the classical formulation of the Birkhoff HSP theorem as an
``if and only if'' assertion might worry that the proof is still incomplete. However,
recall that in the \ualmodule{Varieties.Func.Preservation} module we proved the following
identity preservation lemma:\\[4pt]
\ab{V-id1} : \ab{ùí¶} \aof{‚ä´} \ab p \aic{‚âàÃá} \ab q \as{‚Üí} \af{V} \ab{ùí¶} \aof{‚ä´} \ab p \aic{‚âàÃá} \ab q
\\[4pt]
Thus, if \ab{ùí¶} is an equational class---that is, if \ab{ùí¶} is the class of algebras
satisfying all identities in some set---then \af V \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}.  On the other hand, we
proved that \af V is expansive in the \ualmodule{Varieties.Func.Closure} module:

\ab{V-expa} : \ab{ùí¶} \aof{‚äÜ} \af V \ab{ùí¶}

so \ab{ùí¶} (= \af V \ab{ùí¶} = \af H \af S \af P \ab{ùí¶}) is a variety.

Taken together, \af{V-id1} and \af{V-expa} constitute formal proof that every equational
class is a variety. This completes the formal proof of Birkhoff's variety theorem.


