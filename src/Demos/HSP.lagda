\section{Introduction}
The Agda Universal Algebra Library (\agdaalgebras) is a collection of types and programs
(theorems and proofs) formalizing the foundations of universal algebra in dependent type
theory using the \agda programming language and proof assistant.
The agda-algebras library now includes a substantial collection of definitions, theorems, and
proofs from universal algebra and equational logic and as such provides many
examples that exhibit the power of inductive and dependent types for
representing and reasoning about general algebraic and relational structures.

The first major milestone of the \agdaalgebras project is a new formal
proof of \emph{Birkhoff's variety theorem} (also known as the \emph{HSP theorem}), the first version
of which was completed in \href{https://github.com/ualib/ualib.github.io/blob/b968e8af1117fc77700d3a588746cbefbd464835/sandbox/birkhoff-exp-new-new.lagda}{January of 2021}.
To the best of our knowledge, this was the first time Birkhoff's theorem had
been formulated and proved in dependent type theory and verified with a proof
assistant.

In this paper, we present a single Agda module called \ualmodule{Demos.HSP}.
This module extracts only those parts of the library needed to prove
Birkhoff's variety theorem. In order to meet page limit guidelines, and to
reduce strain on the reader, we omit proofs of some routine or technical
lemmas that do not provide much insight into the overall development.
However, a long version of this paper, which includes all code in the
\DemosHSP module, is available on the arXiv. [reference needed]

In the course of our exposition of the proof of the HSP theorem, we discuss some of the
more challenging aspects of formalizing \emph{universal algebra} in type theory and the
issues that arise when attempting to constructively prove some of the basic
results in this area.  We demonstrate that dependent type theory and Agda,
despite the demands they place on the user, are accessible to working
mathematicians who have sufficient patience and a strong enough desire to
constructively codify their work and formally verify the correctness of their
results.  Perhpas our presentation will be viewed as a sobering glimpse of the
painstaking process of doing mathematics in the languages of dependent type theory
using the Agda proof assistant. Nonetheless we hope to make a compelling case for
investing in these technologies. Indeed, we are excited to share the gratifying
rewards that come with some mastery of type theory and interactive theorem proving.

%% -----------------------------------------------------------------------------
\subsection{Prior art}
There have been a number of efforts to formalize parts of universal algebra in
type theory prior to ours, most notably

\begin{enumerate}
\item
In~\cite{Capretta:1999}, Capretta formalized the basics of universal algebra in the
   Calculus of Inductive Constructions using the Coq proof assistant;
\item In~\cite{Spitters:2011}, Spitters and van der Weegen formalized the basics of universal algebra
   and some classical algebraic structures, also in the Calculus of Inductive Constructions using
   the Coq proof assistant and promoting the use of type classes;
\item In~\cite{Gunther:2018} Gunther, et al developed what was (prior to the \agdaalgebras library)
   the most extensive library of formalized universal algebra to date; like \agdaalgebras, that work is based on dependent type theory, is programmed in Agda, and goes beyond the Noether isomorphism theorems to include some basic equational logic; although the coverage is less extensive than that of \agdaalgebras, Gunther et al do treat \emph{multisorted} algebras, whereas \agdaalgebras is currently limited to single sorted structures.
\item Lynge and Spitters [@Lynge:2019] (2019) formalize basic, mutisorted universal algebra, up to the
   Noether isomorphism theorems, in homotopy type theory; in this setting, the authors can avoid using
   setoids by postulating a strong extensionality axiom called \textit{univalence}.
\end{enumerate}

Some other projects aimed at formalizing mathematics generally, and algebra in particular, have developed into very extensive libraries that include definitions, theorems, and proofs about algebraic structures, such as groups, rings, modules, etc.  However, the goals of these efforts seem to be the formalization of special classical algebraic structures, as opposed to the general theory of (universal) algebras. Moreover, the part of universal algebra and equational logic formalized in the \agdaalgebras library extends beyond the scope of prior efforts.

% After completing the formal proof in \agda, we learned about a constructive version of Birkhoff's theorem proved by Carlstr\"om in~\cite{Carlstrom:2008}.  The latter is presented in the informal style of standard mathematical writing, and as far as we know it was never formalized in type theory and type-checked with a proof assistant. Nonetheless, a comparison of Carlstr\"om's proof and the \ualib proof would be interesting.




% <!-- ----------------------------------------------------------------------------------- -->

\section{Preliminaries}

\subsection{Logical foundations}

An Agda program typically begins by setting some language options and by
importing types from existing Agda libraries. The language options are specified
using the \ak{OPTIONS} \emph{pragma} which affect control the way Agda behaves by controlling
the deduction rules that are available to us and the logical axioms 
that are assumed when the program is type-checked by Agda to verify its
correctness. Every Agda program in the agda-algebras library, including the
present module (\DemosHSP), begins with the following line.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

\end{code}
We give only very terse descriptions of these options, and refer the reader to
the accompanying links for more details.

\begin{itemize}
\item
\AgdaPragma{without-K} disables \href{https://ncatlab.org/nlab/show/axiom+K+%28type+theory%29}{Streicher's K axiom}.
See the \href{https://agda.readthedocs.io/en/v2.6.1/language/without-k.html}{section on axiom K} in the \href{https://agda.readthedocs.io/en/v2.6.1.3/language}{Agda Language Reference Manual}~\cite{agdaref-axiomk}.

\item
\AgdaPragma{exact-split} makes Agda accept only those definitions that behave like so-called {\it judgmental} equalities.
See the \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#pattern-matching-and-equality}%
{Pattern matching and equality} section of the \href{https://agda.readthedocs.io/en/v2.6.1.3/tools/}{Agda Tools} documentation~\cite{agdatools-patternmatching}.

\item
\AgdaPragma{safe} ensures that nothing is postulated outright---every non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module).
See the \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#cmdoption-safe}{cmdoption-safe}
section of the \href{https://agda.readthedocs.io/en/v2.6.1.3/tools/}{Agda Tools documentation} and the \href{https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html#safe-agda}{Safe Agda section} of the \href{https://agda.readthedocs.io/en/v2.6.1.3/language}{Agda Language Reference}~\cite{agdaref-safeagda}.
\end{itemize}


The \AgdaKeyword{OPTIONS} pragma is usually followed by the start of a module and a list of import directives.
For example, the collection of imports required for the present module, \DemosHSP, is relatively modest and appears below.

\begin{code}[hide]
{-# OPTIONS --without-K --exact-split --safe #-}
\end{code}
\begin{code}

-- Import 3 definitions from the agda-algebras library.
open import Algebras.Basic using ( ùìû ; ùì• ; Signature )
\end{code}
\begin{code}[hide]
module Demos.HSP {ùëÜ : Signature ùìû ùì•} where
\end{code}
\begin{code}

-- Import 16 definitions from the Agda Standard Library.
open import  Data.Unit.Polymorphic                           using ( ‚ä§ ; tt                        )
open import  Function                                        using ( id ; flip ; _‚àò_               )
open import  Level                                           using ( Level                         )
open import  Relation.Binary                                 using ( Rel ; Setoid ; IsEquivalence  )
open import  Relation.Binary.Definitions                     using ( Reflexive ; Symmetric         )
                                                             using ( Transitive ; Sym ; Trans      )
open import  Relation.Binary.PropositionalEquality           using ( _‚â°_                           )
open import  Relation.Unary                                  using ( Pred ; _‚äÜ_ ; _‚àà_              )

-- Import 23 definitions from the Agda Standard Library and rename 12 of them.
open import  Agda.Primitive  renaming ( Set    to Type    )  using ( _‚äî_ ; lsuc                    )
open import  Data.Product    renaming ( proj‚ÇÅ  to fst     )
                             renaming ( proj‚ÇÇ  to snd     )  using ( _√ó_ ; _,_ ; Œ£ ; Œ£-syntax      )
open import  Function        renaming ( Func   to _‚ü∂_     )  using ( Injection ; Surjection        )
open         _‚ü∂_             renaming ( f      to _‚ü®$‚ü©_   )  using ( cong                          )
open         Setoid          renaming ( refl   to reflÀ¢   )
                             renaming ( sym    to symÀ¢    )
                             renaming ( trans  to transÀ¢  )
                             renaming ( _‚âà_    to _‚âàÀ¢_    )  using ( Carrier ; isEquivalence       )
open         IsEquivalence   renaming ( refl   to refl·µâ   )
                             renaming ( sym    to sym·µâ    )
                             renaming ( trans  to trans·µâ  )  using ()

-- Assign handles to 3 modules of the Agda Standard Library.
import       Function.Definitions                   as FD
import       Relation.Binary.PropositionalEquality  as ‚â°
import       Relation.Binary.Reasoning.Setoid       as SetoidReasoning

\end{code}
\ifshort\else
\begin{code}
private variable
 Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà œÅ œá ‚Ñì : Level
 Œì Œî : Type œá
 ùëì : fst ùëÜ
\end{code}
\fi
Note that the above imports include some of the minor adjustments to ``standard Agda'' syntax to suite our own taste. Take special note of the following conventions used throughout the \agdaalgebras library and this paper: we use \AgdaPrimitive{Type} in place of \AgdaPrimitive{Set}, the infix long arrow symbol,
\AgdaRecord{\AgdaUnderscore{}‚ü∂\AgdaUnderscore{}}, instead of \AgdaRecord{Func} (the type of ``setoid functions'' discussed in ¬ß\ref{setoid-functions} below), and the symbol \aofld{\au{}‚ü®\$‚ü©\au{}} in place of \afld{f} (application of the map of a setoid function); we use
\AgdaField{fst} and \AgdaField{snd}, and sometimes \AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}} and
\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}}, to denote the first and second projections out of the product type \AgdaOperator{\AgdaFunction{\AgdaUnderscore{}√ó\AgdaUnderscore{}}}.
\begin{code}[hide]
module _ {A : Type Œ± }{B : A ‚Üí Type Œ≤} where
 ‚à£_‚à£ : Œ£[ x ‚àà A ] B x ‚Üí A
 ‚à£_‚à£ = fst
 ‚à•_‚à• : (z : Œ£[ a ‚àà A ] B a) ‚Üí B ‚à£ z ‚à£
 ‚à•_‚à• = snd
\end{code}

%% -----------------------------------------------------------------------------
\subsection{Setoids}
\label{setoids}
A \defn{setoid} is a pair (\ab A, \af{‚âà}) where \ab A is a type and \af{‚âà}
is an equivalence relation on \ab A. Setoids seem to have gotten a bad wrap
in some parts of the interactive theorem proving community because of the extra
overhead that their use requires. However, we feel they are ideally suited to
the task of representing the basic objects of informal mathematics (i.e., sets)
in a constructive, type-theoretic way.

A set used informally typically comes equipped with an equivalence relation manifesting
the notion of equality of elements of the set. When working informally, we
often take the equivalence for granted or view it as self-evident; rarely do we
take the time to define it explicitly. While this approach is well-suited to informal
mathematics, formalization using a machine demands that we make nearly everything
explicit, including notions of equality.

Actually, the \agdaalgebras library was first developed without setoids, relying exclusively
on the inductively defined equality type \ad{\au{}‚â°\au{}} from \am{Agda.Builtin.Equality},
along with some experimental, domain-specific types for equivalence classes, quotients, etc.
One notable consequence of this design decision was that our formalization of many
theorem required postulating function extensionality, an axiom that is not provable
in pure Martin-L√∂f type theory (MLTT). [reference needed]

In contrast, our current approach using setoids makes the equality relation
of a given type explicit.  A primary motivation for taking this approach is to make it
clear that the library is fully constructive and confined to pure Martin-L√∂f dependent type theory
(as defined, e.g., in [ref needed]). In particular, there are no appeals to function extensionality in the present work. Finally, we are confident that the current version\footnote{[ref. with version information needed]}  of the \agdaalgebras library is free of hidden assumptions or inconsistencies that could be
used to ``fool'' the type-checker.


%% -----------------------------------------------------------------------------
\subsection{Setoid functions}
\label{setoid-functions}
In addition to the \ar{Setoid} type, much of our code employs the
standard library's \ar{Func} type which represents a function from one
setoid to another and packages such a function with a proof (called \afld{cong}) that
the function respects the underlying setoid equalities. As mentioned above, we renamed
\ar{Func} to the more visually appealing infix long arrow symbol,
\AgdaRecord{\AgdaUnderscore{}‚ü∂\AgdaUnderscore{}}, and  throughout the paper we
refer to inhabitants of this type as ``setoid functions.''

\ifshort\else
An example of a setoid function is the identity function from a setoid to itself.
We define it, along with a binary composition operation for setoid functions,
\AgdaOperator{\AgdaFunction{‚ü®‚àò‚ü©}}, as follows.

\begin{code}

ùëñùëë : {A : Setoid Œ± œÅ·µÉ} ‚Üí A ‚ü∂ A
ùëñùëë {A} = record { f = id ; cong = id }

_‚ü®‚àò‚ü©_ :  {A : Setoid Œ± œÅ·µÉ} {B : Setoid Œ≤ œÅ·µá} {C : Setoid Œ≥ œÅ·∂ú}
 ‚Üí       B ‚ü∂ C  ‚Üí  A ‚ü∂ B  ‚Üí  A ‚ü∂ C

f ‚ü®‚àò‚ü© g = record  { f = (_‚ü®$‚ü©_ f) ‚àò (_‚ü®$‚ü©_ g)
                  ; cong = (cong f) ‚àò (cong g) }
\end{code}
\fi

\paragraph*{Inverses of setoid functions}
We begin by defining an inductive type that represents the semantic concept of the \emph{image} of a function.\footnote{cf.~the \ualmodule{Overture.Func.Inverses} module of the \agdaalgebras library.}

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë© using ( _‚âà_ ; sym ) renaming ( Carrier to B )

 data Image_‚àã_ (f : ùë® ‚ü∂ ùë©) : B ‚Üí Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá) where
  eq : {b : B} ‚Üí ‚àÄ a ‚Üí b ‚âà f ‚ü®$‚ü© a ‚Üí Image f ‚àã b

\end{code}
An inhabitant of \aod{Image} \ab f \aod{‚àã} \ab b is a dependent pair \AgdaPair{a}{p},
where \AgdaTyped{a}{A} and \ab p~\as :~\ab b \af{‚âà} \ab f~\ab a is a proof that
\ab f maps \ab a to \ab b.  Since the proof that \ab b
belongs to the image of \ab f is always accompanied by a witness \AgdaTyped{a}{A}, we can
actually \emph{compute} a range-restricted right-inverse of \ab f. For convenience, we define this
inverse function and give it the name \af{Inv}.

\begin{code}

 Inv : (f : ùë® ‚ü∂ ùë©){b : B} ‚Üí Image f ‚àã b ‚Üí Carrier ùë®
 Inv _ (eq a _) = a

\end{code}
For each \ab b : \afld{B}, given a pair \AgdaPair{a}{p}~\as :~\aod{Image}~\ab f~\aod{‚àã}~\ab b witnessing the fact that \ab b belongs to the image of \ab f, the function \af{Inv} simply returns the witness \ab a, which is a preimage of \ab b under \ab f.
We can formally verify that \af{Inv} \ab f is indeed the (range-restricted) right-inverse of \ab f, as follows.

\begin{code}

 InvIsInverse ≥ : {f : ùë® ‚ü∂ ùë©}{b : B}(q : Image f ‚àã b) ‚Üí f ‚ü®$‚ü© (Inv f q) ‚âà b
 InvIsInverse ≥ (eq _ p) = sym p

\end{code}


\paragraph*{Injective and surjective setoid functions}
If \ab{f} % : \ab{ùë®} \aor{‚ü∂} \ab{ùë©}
is a setoid function from % \ab{ùë®} =
(\ab A, \af{‚âà‚ÇÄ}) to
% \ab{ùë©} =
(\ab B, \af{‚âà‚ÇÅ}), then we call \ab f \defn{injective} provided
\as{‚àÄ} (\ab{a‚ÇÄ} \ab{a‚ÇÅ} \as : \ab{A}), \ab{f} \aofld{‚ü®\$‚ü©} \ab{a‚ÇÄ} \af{‚âà‚ÇÅ} \ab{f} \aofld{‚ü®\$‚ü©} \ab{a‚ÇÅ}
implies \ab{a‚ÇÄ} \af{‚âà‚ÇÄ} \ab{a‚ÇÅ}; we call \ab{f} \defn{surjective} provided
\as{‚àÄ} (\AgdaTyped{b}{B}), \as{‚àÉ}~(\AgdaTyped{a}{A}) such that \ab{f} \aofld{‚ü®\$‚ü©} \ab{a} \af{‚âà‚ÇÅ} \ab{b}.
The \agdastdlib represents injective functions on bare types by the
type \af{Injective}, and uses this to define the \af{IsInjective} type to represent
the property of being an injective setoid function. Similarly, the type \af{IsSurjective}
represents the property of being a surjective setoid function. \af{SurjInv} represents the \emph{right-inverse} of a surjective function.
         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
 We omit the relatively straightforward formal definitions of these types, but \seeunabridged, as well as formal proofs of some of their properties.
         %%%
\else    %%% END SHORT VERSION ONLY
         %%% BEGIN LONG VERSION ONLY SECTION
         %%%
 We reproduce the definitions and prove some of their properties
 inside the next submodule where we first set the stage by declaring two
 setoids \ab{ùë®} and \ab{ùë©}, naming their equality relations, and making some
 definitions from the standard library available.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë® using () renaming ( _‚âà_ to _‚âà‚ÇÅ_ )
 open Setoid ùë© using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ )
 open FD _‚âà‚ÇÅ_ _‚âà‚ÇÇ_

 IsInjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá)
 IsInjective f = Injective (_‚ü®$‚ü©_ f)

 IsSurjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá)
 IsSurjective F = ‚àÄ {y} ‚Üí Image F ‚àã y

 SurjInv : (f : ùë® ‚ü∂ ùë©) ‚Üí IsSurjective f ‚Üí Carrier ùë© ‚Üí Carrier ùë®
 SurjInv f fonto b = Inv f (fonto {b})

\end{code}

Proving that the composition of injective setoid functions is again injective
is simply a matter of composing the two assumed witnesses to injectivity.
Proving that surjectivity is preserved under composition is only slightly more involved.

\begin{code}

module _  {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá}{ùë™ : Setoid Œ≥ œÅ·∂ú}
          (f : ùë® ‚ü∂ ùë©)(g : ùë© ‚ü∂ ùë™) where

 ‚àò-IsInjective : IsInjective f ‚Üí IsInjective g ‚Üí IsInjective (g ‚ü®‚àò‚ü© f)
 ‚àò-IsInjective finj ginj = finj ‚àò ginj

 ‚àò-IsSurjective : IsSurjective f ‚Üí IsSurjective g ‚Üí IsSurjective (g ‚ü®‚àò‚ü© f)
 ‚àò-IsSurjective fonto gonto {y} = Goal
  where
  mp : Image g ‚àã y ‚Üí Image g ‚ü®‚àò‚ü© f ‚àã y
  mp (eq c p) = Œ∑ fonto
   where
   open Setoid ùë™ using ( trans )
   Œ∑ : Image f ‚àã c ‚Üí Image g ‚ü®‚àò‚ü© f ‚àã y
   Œ∑ (eq a q) = eq a (trans p (cong g q))

  Goal : Image g ‚ü®‚àò‚ü© f ‚àã y
  Goal = mp gonto
\end{code}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

\paragraph*{Kernels of setoid functions}
The \defn{kernel} of a function \ab f~\as :~\ab A~\as{‚Üí}~\ab B (where \ab A and \ab B are bare types) is defined
informally by \{\AgdaPair{x}{y} \aod{‚àà} \ab A \aof{√ó} \ab A \as : \ab f \ab x \as{=} \ab f \ab y \}.
This can be represented in Agda in a number of ways, but for our purposes it is most
convenient to define the kernel as an inhabitant of a (unary) predicate over the square of
the function's domain, as follows.

\begin{code}

kernel : {A : Type Œ±}{B : Type Œ≤} ‚Üí Rel B œÅ ‚Üí (A ‚Üí B) ‚Üí Pred (A √ó A) œÅ
kernel _‚âà_ f (x , y) = f x ‚âà f y

\end{code}
The kernel of a \emph{setoid} function \ab f \as : \ab{ùê¥} \aor{‚ü∂} \ab{ùêµ} is \{\AgdaPair{x}{y} \as{‚àà} \ab A \aof{√ó} \ab A \as : \ab f \aofld{‚ü®\$‚ü©} \ab x \aofld{‚âà} \ab f \aofld{‚ü®\$‚ü©} \ab y\},
where \afld{\au{}‚âà\au} denotes equality in \ab{ùêµ}. This can be formalized in Agda as follows.

\begin{code}

module _ {ùê¥ : Setoid Œ± œÅ·µÉ}{ùêµ : Setoid Œ≤ œÅ·µá} where
 open Setoid ùê¥ using () renaming ( Carrier to A )

 ker : (ùê¥ ‚ü∂ ùêµ) ‚Üí Pred (A √ó A) œÅ·µá
 ker g (x , y) = g ‚ü®$‚ü© x ‚âà g ‚ü®$‚ü© y where open Setoid ùêµ using ( _‚âà_ )
\end{code}


%% -------------------------------------------------------------------------------------

\section{Types for Basic Universal Algebra}
\label{types-for-basic-universal-algebra}
In this section we develop a working vocabulary and formal types for classical,
single-sorted, set-based universal algebra.
We cover a number of important concepts, but we limit ourselves to those
concepts required in our formal proof of Birkhoff's HSP theorem.
In each case, we give a type-theoretic version of the informal definition,
followed by a formal implementation of the definition in Martin-L√∂f dependent
type theory using the Agda language.

This section is organized into the following subsections:
¬ß\ref{signatures} defines a general notion of \emph{signature} of a structure and then defines a type that represent signatures;
¬ß\ref{algebras} does the same for \emph{algebraic structures} and \emph{product algebras};
¬ß\ref{homomorphisms} defines \emph{homomorphisms}, \emph{monomorphisms}, and \emph{epimorphisms}, presents types that codify these concepts and formally verifies some of their basic properties;
¬ß¬ß\ref{subalgebras}--\ref{terms} do the same for \emph{subalgebras} and \emph{terms}, respectively.


%% -----------------------------------------------------------------------------
\subsection{Signatures}
\label{signatures}

In model theory, the \defn{signature} \ab{ùëÜ} = (\ab{ùê∂}, \ab{ùêπ}, \ab{ùëÖ}, \ab{œÅ})
of a structure consists of three (possibly empty) sets \ab{ùê∂}, \ab{ùêπ}, and
\ab{ùëÖ}---called \emph{constant}, \emph{function}, and
\emph{relation} symbols, respectively---along with a function \ab{œÅ} : \ab{ùê∂} \as{+}
\ab{ùêπ} \as{+} \ab{ùëÖ} \as{‚Üí} \ab{ùëÅ} that assigns an \emph{arity} to each symbol. Often, but
not always, \ab{ùëÅ} is taken to be the set of natural numbers.

As our focus here is universal algebra, we are more concerned with the
restricted notion of an \defn{algebraic signature}, that is, a signature for
``purely algebraic'' structures, by which is meant a pair \ab{ùëÜ} = \AgdaPair{F}{œÅ}
consisting of a collection \ab{F} of \defn{operation symbols} and an \defn{arity function}
\ab{œÅ} : \ab{F} \as{‚Üí} \ab{N} which maps each operation symbol to its arity.
Here, \ab{ùëÅ} denotes the \emph{arity type}. Heuristically, the arity
\ab{œÅ} \ab{f} of an operation symbol \ab{f} \as{‚àà} \ab{F} may be thought of as
the number of arguments that \ab{f} takes as ``input.''

The \agdaalgebras library represents an (algebraic) signature as an
inhabitant of the following dependent pair type:

\begin{center}

\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Level}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPrimitive{lsuc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{))}\\[4pt]
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£[}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaFunction{‚àà}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{)}

\end{center}

Using special syntax for the first and second
projections---\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}} and
\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}} (resp.)---if
\ab{ùëÜ} \as{:} \af{Signature} \ab{ùìû} \ab{ùì•} is a signature, then
\aof{‚à£} \ab{ùëÜ} \aof{‚à£} denotes the set of operation symbols and \aof{‚à•} \ab{ùëÜ} \aof{‚à•} denotes the arity function.
Thus, if \ab{f} \as{:} \aof{‚à£} \ab{ùëÜ} \aof{‚à£} is an operation symbol in the
signature \ab{ùëÜ}, then \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab{f} is the arity of \ab{f}.

We need to augment the ordinary \af{Signature} type so that it supports algebras over setoid domains.
To do so, we follow Andreas Abel's lead [ref needed] and define an operator that translates an
ordinary signature into a \defn{setoid signature}, that is, a signature over a setoid
domain. This raises a minor technical issue concerning the dependent types
involved in the definition; some readers might find the resolution of this issue instructive, so let's discuss it.

Suppose we are given two operations \ab{f} and \ab{g}, a tuple \ab{u} \as{:} \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab{f} \as{‚Üí}
\ab{A} of arguments for \ab{f}, and a tuple \ab{v} \as{:} \aof{‚à•} \ab{ùëÜ}
\aof{‚à•} \ab{g} \as{‚Üí} \ab{A} of arguments for \ab{g}.  If we know that \ab f is identically equal to
\ab{g}---that is, \ab{f} \aod{‚â°} \ab{g} (intensionally)---then we should be able to
check whether \ab u and \ab v are pointwise equal.  Technically, though, \ab{u} and \ab{v} inhabit different types, so, before comparing them,
we must first convince Agda that \ab u and \ab v inhabit the same type. Of course,
this requires an appeal to the hypothesis \ab f \aod{‚â°} \ab g, as we see in the definition of \af{EqArgs} below
(adapted from Andreas Abel's development [ref needed]), which neatly resolves this minor technicality.

\begin{code}

EqArgs :  {ùëÜ : Signature ùìû ùì•}{Œæ : Setoid Œ± œÅ·µÉ}
 ‚Üí        ‚àÄ {f g} ‚Üí f ‚â° g ‚Üí (‚à• ùëÜ ‚à• f ‚Üí Carrier Œæ) ‚Üí (‚à• ùëÜ ‚à• g ‚Üí Carrier Œæ) ‚Üí Type (ùì• ‚äî œÅ·µÉ)

EqArgs {Œæ = Œæ} ‚â°.refl u v = ‚àÄ i ‚Üí u i ‚âà v i where open Setoid Œæ using ( _‚âà_ )

\end{code}

Finally, we are ready to define an operator which
translates an ordinary (algebraic) signature into a signature of algebras over setoids.
We denote this operator by \aof{‚ü®\AgdaUnderscore{}‚ü©} and define it as follows.

\begin{code}

‚ü®_‚ü© : Signature ùìû ùì• ‚Üí Setoid Œ± œÅ·µÉ ‚Üí Setoid _ _

Carrier  (‚ü® ùëÜ ‚ü© Œæ)                = Œ£[ f ‚àà ‚à£ ùëÜ ‚à£ ] (‚à• ùëÜ ‚à• f ‚Üí Œæ .Carrier)
_‚âàÀ¢_     (‚ü® ùëÜ ‚ü© Œæ)(f , u)(g , v)  = Œ£[ eqv ‚àà f ‚â° g ] EqArgs{Œæ = Œæ} eqv u v

refl·µâ   (isEquivalence (‚ü® ùëÜ ‚ü© Œæ))                           = ‚â°.refl , Œª i ‚Üí reflÀ¢   Œæ
sym·µâ    (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)              = ‚â°.refl , Œª i ‚Üí symÀ¢    Œæ (g i)
trans·µâ  (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)(‚â°.refl , h)  = ‚â°.refl , Œª i ‚Üí transÀ¢  Œæ (g i) (h i)
\end{code}

%% -----------------------------------------------------------------------------
\subsection{Algebras}
\label{algebras}
Informally, an \defn{algebraic structure in the signature} \ab{ùëÜ} = (\ab{F}, \ab{œÅ}) (or \ab{ùëÜ}-\defn{algebra}) is denoted by \ab{ùë®} = (\ab{A}, \ab{F·¥¨}) and consists of
\begin{itemize}
\item a \emph{nonempty} set (or type) \ab A, called the \emph{domain} of the algebra;
\item a collection \ab{F·¥¨} := \{ \ab{f·¥¨} \as{‚à£} \ab f \as{‚àà} \ab F, \ab{f·¥¨} \as : (\ab{œÅ} \ab f \as{‚Üí} \ab A) \as{‚Üí} \ab A \} of \emph{operations} on \ab{A};
\item a (potentially empty) collection of \emph{identities} satisfied by elements and operations of \ab{ùë®}.
\end{itemize}
The \agdaalgebras library represents algebras as the inhabitants of a record type with two fields:
\begin{itemize}
\item \afld{Domain}, representing the domain of the algebra;
\item \afld{Interp}, representing the \emph{interpretation} in the algebra of each operation symbol in \ab{ùëÜ}.
\end{itemize}
The \afld{Domain} is a actually a setoid whose \afld{Carrier} denotes the carrier of the algebra and whose equivalence relation denotes equality of elements of the domain.

Here is the definition of the \ar{Algebra} type followed by an explaination of how the standard library's \ar{Func} type is used to represent the interpretation of operation symbols in an algebra.
%\footnote{We postpone introducing identities until they are needed (e.g., for equational logic); see~¬ß\ref{model-theory-and-equational-logic}.}

\begin{code}

record Algebra Œ± œÅ : Type (ùìû ‚äî ùì• ‚äî lsuc (Œ± ‚äî œÅ)) where
 field  Domain  : Setoid Œ± œÅ
        Interp  : ‚ü® ùëÜ ‚ü© Domain ‚ü∂ Domain

\end{code}
Recall, we renamed Agda's \ar{Func} type, prefering instead the long-arrow symbol \AgdaRecord{‚ü∂}, so
the \afld{Interp} field has type \ar{Func} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©} \afld{Domain}) \afld{Domain}, a record type with two fields:
\begin{itemize}
\item a function  \ab{f} \as : \afld{Carrier} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©} \afld{Domain})
  \as{‚Üí} \afld{Carrier} \afld{Domain} representing the operation;
\item a proof \af{cong} \as : \ab f \aof{Preserves \au{}‚âà‚ÇÅ\au{} ‚ü∂ \au{}‚âà‚ÇÇ\au{}} that the operation preserves the relevant setoid equalities.
\end{itemize}
Thus, for each operation symbol in the signature \ab{ùëÜ}, we have a setoid function \ab f---with domain a power of \afld{Domain} and codomain \afld{Domain}---along with a proof that this function respects the setoid equalities.  The latter means that the operation \ab{f} is accompanied by a proof of the following: ‚àÄ \ab u \ab v in \afld{Carrier} (\aof{‚ü®} \ab{ùëÜ} \aof{‚ü©} \afld{Domain}), if \ab u \af{‚âà‚ÇÅ} \ab v, then \ab{f} \aofld{‚ü®\$‚ü©} \ab{u} \af{‚âà‚ÇÇ} \ab{f} \aofld{‚ü®\$‚ü©} \ab{v}.

In the \agdaalgebras library is defined some syntactic sugar that helps to make our formalizations easier to read and
comprehend.
%\footnote{We omit the formal definitions, but see [reference needed].}
The following are three examples of such syntax that we use below: if \ab{ùë®} is an algebra, then
\begin{itemize}
\item \aof{ùîª[ \ab{ùë®} ]} denotes the setoid \afld{Domain} \ab{ùë®},
\item \aof{ùïå[ \ab{ùë®} ]} is the underlying carrier of the algebra \ab{ùë®}, and
\item \ab f \aof{ÃÇ} \ab{ùë®} denotes the interpretation in the algebra \ab{ùë®} of the operation symbol \ab f.
\end{itemize}
         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
 We omit the straightforward formal definitions of these types, but \seeunabridged.
         %%%
\else    %%% END SHORT VERSION ONLY
         %%% BEGIN LONG VERSION ONLY SECTION
         %%%
\begin{code}
open Algebra
ùîª[_] : Algebra Œ± œÅ·µÉ ‚Üí  Setoid Œ± œÅ·µÉ
ùîª[ ùë® ] = Domain ùë®
ùïå[_] : Algebra Œ± œÅ·µÉ ‚Üí  Type Œ±
ùïå[ ùë® ] = Carrier (Domain ùë®)
_ÃÇ_ : (f : ‚à£ ùëÜ ‚à£)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí (‚à• ùëÜ ‚à• f  ‚Üí  ùïå[ ùë® ]) ‚Üí ùïå[ ùë® ]
f ÃÇ ùë® = Œª a ‚Üí (Interp ùë®) ‚ü®$‚ü© (f , a)
\end{code}

%% -----------------------------------------------------------------------------
\paragraph*{Universe levels of algebra types}
%\paragraph*{Agda's universe hierarchy}\label{agdas-universe-hierarchy}
The hierarchy of type universes in Agda is structured as follows:
\ap{Type} \ab{‚Ñì} : \ap{Type} (\ap{lsuc} \ab{‚Ñì}), \ap{Type} (\ap{lsuc} \ab{‚Ñì}) : \ap{Type} (\ap{lsuc} (\ap{lsuc} \ab{‚Ñì})), ‚Ä¶.
This means that \ap{Type} \ab{‚Ñì} has type \ap{Type} (\ap{lsuc} \ab{‚Ñì}), etc.  However, this does \emph{not} imply that
\ap{Type} \ab{‚Ñì} : \ap{Type} (\ap{lsuc} (\ap{lsuc} \ab{‚Ñì})). In other words, Agda's universe hierarchy is \emph{noncumulative}.
This can be advantageous as it becomes possible to treat universe levels more generally and precisely. On the other hand,
an unfortunate side-effect of this noncumulativity is that it sometimes seems unduly difficult to convince Agda that a program
or proof is correct.

This aspect of the language was one of the few stumbling blocks we encountered while learning how to use Agda for formalizing universal algebra in type theory.
Although some may consider this to be one of the least interesting and most annoying aspects of our work, others might find
this presentation most helpful if we resist the urge to gloss over the more technical and less elegant aspects of the library.
Therefore, we will show how to use the general universe lifting and lowering functions, available in the \agdastdlib,
to develop bespoke, domain-specific tools for dealing with the noncumulative universe hierarchy.

%\paragraph*{Lifting and lowering}
Let us be more concrete about what is at issue here by considering a typical example. Agda frequently encounters errors during the type-checking process and responds by printing an error message. Often the message has the following form.
{\color{red}{\small
\begin{verbatim}
  HSP.lagda:498,20-23
  Œ± != ùìû ‚äî ùì• ‚äî (lsuc Œ±) when checking that... has type...
\end{verbatim}}}
\noindent Here Agda informs us that it encountered universe level \ab{Œ±} on line 498 of the HSP module, where it was expecting level \ab{ùìû}~\aop{‚äî}~\ab{ùì•}~\aop{‚äî}~(\ap{lsuc} \ab{Œ±}).
For example, we may have tried to use an algebra inhabiting the type \ar{Algebra} \ab{Œ±} \ab{œÅ·µÉ} whereas we should have used one inhabiting the type \ar{Algebra} (\ab{ùìû} \aop{‚äî} \ab{ùì•} \aop{‚äî} (\ap{lsuc} \ab{Œ±})) \ab{œÅ·µÉ}.
One resolves such problems using the general \AgdaRecord{Lift} record type, available in the standard library, which takes a type inhabiting some universe and embeds it into a higher universe.
To apply this strategy in our domain of interest, we develop the following utility functions.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; refl ; sym ; trans ) ; open Level

 Lift-AlgÀ° : (‚Ñì : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì) œÅ·µÉ

 Domain (Lift-AlgÀ° ‚Ñì) =
  record  { Carrier        = Lift ‚Ñì ùïå[ ùë® ]
          ; _‚âà_            = Œª x y ‚Üí lower x ‚âà lower y
          ; isEquivalence  = record { refl = refl ; sym = sym ; trans = trans }}

 Interp (Lift-AlgÀ° ‚Ñì) ‚ü®$‚ü© (f , la) = lift ((f ÃÇ ùë®) (lower ‚àò la))
 cong (Interp (Lift-AlgÀ° ‚Ñì)) (‚â°.refl , lab) = cong (Interp ùë®) ((‚â°.refl , lab))


 Lift-Alg ≥ : (‚Ñì : Level) ‚Üí Algebra Œ± (œÅ·µÉ ‚äî ‚Ñì)

 Domain (Lift-Alg ≥ ‚Ñì) =
  record  { Carrier        = ùïå[ ùë® ]
          ; _‚âà_            = Œª x y ‚Üí Lift ‚Ñì (x ‚âà y)
          ; isEquivalence  = record  { refl  = lift refl
                                     ; sym   = lift ‚àò sym ‚àò lower
                                     ; trans = Œª x y ‚Üí lift (trans (lower x)(lower y)) }}

 Interp (Lift-Alg ≥ ‚Ñì ) ‚ü®$‚ü© (f , la) = (f ÃÇ ùë®) la
 cong (Interp (Lift-Alg ≥ ‚Ñì))(‚â°.refl , lab) = lift(cong(Interp ùë®)(‚â°.refl , Œª i ‚Üí lower (lab i)))


Lift-Alg : (ùë® : Algebra Œ± œÅ·µÉ)(‚Ñì‚ÇÄ ‚Ñì‚ÇÅ : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì‚ÇÄ) (œÅ·µÉ ‚äî ‚Ñì‚ÇÅ)
Lift-Alg ùë® ‚Ñì‚ÇÄ ‚Ñì‚ÇÅ = Lift-Alg ≥ (Lift-AlgÀ° ùë® ‚Ñì‚ÇÄ) ‚Ñì‚ÇÅ

\end{code}
To see why these functions are useful, first recall that our definition of the algebra record type uses two universe level parameters corresponding to those of the algebra's underlying domain setoid.
Concretely, an algebra of type \ar{Algebra} \ab{Œ±} \ab{œÅ·µÉ} has a domain setoid (called \afld{Domain}) of type \ar{Setoid} \ab{Œ±} \ab{œÅ·µÉ}. This domain setoid packages a ``carrier set'' (\afld{Carrier}),
inhabiting \ap{Type} \ab{Œ±}, with an equality on \afld{Carrier} of type \af{Rel} \afld{Carrier} \ab{œÅ·µÉ}. Now, examining the \af{Lift-Alg} function, we see that it
takes an algebra---one whose carrier set inhabits \ap{Type \ab{Œ±}} and has an equality of type \af{Rel} \afld{Carrier} \ab{œÅ·µÉ}---and constructs a new algebra with carrier set inhabiting \ap{Type} (\ab{Œ±} \ap{‚äî} \ab{‚Ñì‚ÇÄ}) and having an equality of type \af{Rel} \afld{Carrier} (\ab{œÅ·µÉ} \ap{‚äî} \ab{‚Ñì‚ÇÅ}).
Of course, this lifting operation would be useless if we couldn't establish a connection (beyond universe levels) between the input and output algebras.
Fortunately, we can prove that universe lifting is an \defn{algebraic invariant}, which is to say that the lifted algebra
has the same algebraic properties as the original algebra; more precisely, the input algebra and the lifted algebra are \defn{isomorphic}, as we prove below. (See \af{Lift-‚âÖ}.)
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

\paragraph*{Product Algebras}
We give an informal description of the \defn{product} of a family of \ab{ùëÜ}-algebras and then define a type which formalizes this notion.

Let \ab{Œπ} be a universe and \ab I~:~\ap{Type}~\ab{Œπ} a type (which, in the
present context, we might refer to as the ``indexing type'').
Then the dependent function type \ab{ùíú}~:~\ab
I~\as{‚Üí}~\ab{Algebra}~\ab{Œ±}~\ab{œÅ·µÉ} represents an \defn{indexed family of algebras}.
Denote by \af{‚®Ö}~\ab{ùíú} the \defn{product of algebras} in \ab{ùíú} (or \defn{product algebra}),
by which we mean the algebra whose domain is the Cartesian product \af{Œ†}~\ab
i~Íûâ~\ab I~\af{,}~\aof{ùîª[~\ab{ùíú}~\ab i~]} of the domains of the algebras in
\ab{ùíú}, and whose operations are those arising by point-wise interpretation in the obvious
way: if \ab{f} is a \ab J-ary operation symbol and if \ab a~:~\af{Œ†}~\ab
i~Íûâ~\ab I~\af{,}~\ab J~\as{‚Üí}~\aof{ùîª[~\ab{ùíú}~\ab i~]} is, for each \ab
i~:~\ab I, a \ab J-tuple of elements of the domain \aof{ùîª[~\ab{ùíú}~\ab i~]}, then
we define the interpretation of \ab f in \af{‚®Ö}~\ab{ùíú} by (\ab{f}~\af{ÃÇ}~\af{‚®Ö}~\ab{ùíú}) \ab a := \as{Œª}~(\ab i~:~\ab I)~\as{‚Üí} (\ab{f}~\af{ÃÇ}~\ab{ùíú}~\ab i)(\ab{a}~\ab i).

The \agdaalgebras library defines a function called \af{‚®Ö} which formalizes the foregoing notion of \defn{product algebra} in Martin-L√∂f type theory.
\ifshort
Here we merely display this function's interface, but see the \ualmodule{Algebras.Func.Products} module for the complete definition.

\else
\fi
\begin{code}

module _ {Œπ : Level}{I : Type Œπ } where
 ‚®Ö : (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) ‚Üí Algebra (Œ± ‚äî Œπ) (œÅ·µÉ ‚äî Œπ)
\end{code}
\ifshort\else
\begin{code}
 Domain (‚®Ö ùíú) =
  record { Carrier = ‚àÄ i ‚Üí ùïå[ ùíú i ]
         ; _‚âà_ = Œª a b ‚Üí ‚àÄ i ‚Üí (_‚âàÀ¢_ ùîª[ ùíú i ]) (a i)(b i)
         ; isEquivalence =
            record  { refl   = Œª i ‚Üí      refl·µâ   (isEquivalence ùîª[ ùíú i ])
                    ; sym    = Œª x i ‚Üí    sym·µâ    (isEquivalence ùîª[ ùíú i ])(x i)
                    ; trans  = Œª x y i ‚Üí  trans·µâ  (isEquivalence ùîª[ ùíú i ])(x i)(y i) }}
 Interp (‚®Ö ùíú) ‚ü®$‚ü© (f , a) = Œª i ‚Üí (f ÃÇ (ùíú i)) (flip a i)
 cong (Interp (‚®Ö ùíú)) (‚â°.refl , f=g ) = Œª i ‚Üí cong (Interp (ùíú i)) (‚â°.refl , flip f=g i )
\end{code}
\fi




%% -------------------------------------------------------------------------------------

\subsection{Homomorphisms}
\label{homomorphisms}

%\paragraph*{Basic definitions}
Suppose \ab{ùë®} and \ab{ùë©} are \ab{ùëÜ}-algebras. A \defn{homomorphism} (or
``hom'') from \ab{ùë®} to \ab{ùë©} is a setoid function
\ab{h}~:~\aof{ùîª[ \ab{ùë®} ]} \as{‚Üí} \aof{ùîª[ \ab{ùë©} ]} that is \defn{compatible}
(or \defn{commutes}) with all basic operations; that is,
for every operation symbol \ab{f}~:~\af{‚à£ \ab{ùëÜ} ‚à£} and all tuples
\ab{a}~:~\af{‚à• \ab{ùëÜ} ‚à•}~\ab{f} \as{‚Üí} \aof{ùîª[ \ab{ùë®} ]}, the following
equality holds: \ab{h} \aofld{‚ü®\$‚ü©} (\ab{f}~\af{ÃÇ}~\ab{ùë®}) \ab{a} \af{‚âà}
(\ab{f}~\af{ÃÇ}~\ab{ùë©}) \as{Œª} \ab{x} \as{‚Üí} \ab{h} \aofld{‚ü®\$‚ü©} (\ab{a} \ab{x}).

To formalize this concept in Agda, we first define a type \af{compatible-map-op}
representing the assertion that a given setoid function
\ab{h}~:~\aof{ùîª[ \ab{ùë®} ]} \as{‚Üí} \aof{ùîª[ \ab{ùë©} ]} commutes with a given
basic operation \ab{f}.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where
 compatible-map-op : (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) ‚Üí ‚à£ ùëÜ ‚à£ ‚Üí Type _
 compatible-map-op h f = ‚àÄ {a} ‚Üí h ‚ü®$‚ü© (f ÃÇ ùë®) a ‚âà (f ÃÇ ùë©) Œª x ‚Üí h ‚ü®$‚ü© (a x)
  where open Setoid ùîª[ ùë© ] using ( _‚âà_ )

\end{code}
Generalizing over operation symbols gives the following type of compatible maps
from (the domain of) \ab{ùê¥} to (the domain of) \ab{ùë©}.

\begin{code}

 compatible-map : (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) ‚Üí Type _
 compatible-map h = ‚àÄ {f} ‚Üí compatible-map-op h f

\end{code}
With this we define a record type \ar{IsHom} representing the property of being
a homomorphism, and finally the type \af{hom} of homomorphisms from \ab{ùë®} to \ab{ùêµ}.
\begin{code}

 record IsHom (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µá) where
  constructor mkhom ; field compatible : compatible-map h

 hom : Type _
 hom = Œ£ (ùîª[¬†ùë® ] ‚ü∂ ùîª[ ùë© ]) IsHom

\end{code}
Observe that an inhabitant of \af{hom} is a pair (\ab h , \ab p) whose first component is a setoid function from the domain of \ab{ùë®} to that of \ab{ùë©} and whose second component is \ab p : \ar{IsHom} \ab h, a proof that \ab h is a homomorphism.

A \defn{monomorphism} (resp. \defn{epimorphism}) is an injective (resp. surjective) homomorphism.  The \agdaalgebras library defines types \ar{IsMon} and \ar{IsEpi} to represent these properties, as well as
\af{mon} and \af{epi}, the types of monomorphisms and epimorphisms, respectively.
         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
 We won't reproduce the formal definitions of these types here, but \seeunabridged.
         %%%
\else    %%% END SHORT VERSION ONLY
         %%% BEGIN LONG VERSION ONLY SECTION
         %%%
\begin{code}

 record IsMon (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá) where
  field  isHom : IsHom h
         isInjective : IsInjective h

  HomReduct : hom
  HomReduct = h , isHom

 mon : Type _
 mon = Œ£ (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) IsMon

\end{code}
As with \af{hom}, the type \af{mon} is a dependent product type; each inhabitant is a pair consisting of a setoid function, say, \ab h, along with a proof that \ab h is a monomorphism.

\begin{code}

 record IsEpi (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî Œ≤ ‚äî œÅ·µá) where
  field  isHom : IsHom h
         isSurjective : IsSurjective h

  HomReduct : hom
  HomReduct = h , isHom

 epi : Type _
 epi = Œ£ (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) IsEpi
\end{code}

Here are two mere utilities that are useful for translating between types.

\begin{code}[hide]
open IsHom ; open IsMon ; open IsEpi

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where

 mon‚Üíintohom : mon ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£
 mon‚Üíintohom (hh , hhM) = (hh , isHom hhM) , isInjective hhM

 epi‚Üíontohom : epi ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsSurjective ‚à£ h ‚à£
 epi‚Üíontohom (hh , hhE) = (hh , isHom hhE) , isSurjective hhE
\end{code}

\paragraph*{Composition of homomorphisms}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

The composition of homomorphisms is again a homomorphism, and similarly for epimorphisms (and monomorphisms).
\ifshort
The proofs of these facts are relatively straightforward so we omit them. When applied below, they are called \af{‚àò-hom} and \af{‚àò-epi}.
\else

\begin{code}

module _  {ùë® : Algebra Œ± œÅ·µÉ} {ùë© : Algebra Œ≤ œÅ·µá} {ùë™ : Algebra Œ≥ œÅ·∂ú}
          {g : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]}{h : ùîª[ ùë© ] ‚ü∂ ùîª[ ùë™ ]} where

  open Setoid ùîª[ ùë™ ] using ( trans )

  ‚àò-is-hom : IsHom ùë® ùë© g ‚Üí IsHom ùë© ùë™ h ‚Üí IsHom ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-hom ghom hhom = mkhom c
   where
   c : compatible-map ùë® ùë™ (h ‚ü®‚àò‚ü© g)
   c = trans (cong h (compatible ghom)) (compatible hhom)

  ‚àò-is-epi : IsEpi ùë® ùë© g ‚Üí IsEpi ùë© ùë™ h ‚Üí IsEpi ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-epi gE hE = record  { isHom = ‚àò-is-hom (isHom gE) (isHom hE)
                           ; isSurjective = ‚àò-IsSurjective g h (isSurjective gE) (isSurjective hE) }

module _ {ùë® : Algebra Œ± œÅ·µÉ} {ùë© : Algebra Œ≤ œÅ·µá} {ùë™ : Algebra Œ≥ œÅ·∂ú} where

  ‚àò-hom : hom ùë® ùë© ‚Üí hom ùë© ùë™  ‚Üí hom ùë® ùë™
  ‚àò-hom (h , hhom) (g , ghom) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-hom hhom ghom

  ‚àò-epi : epi ùë® ùë© ‚Üí epi ùë© ùë™  ‚Üí epi ùë® ùë™
  ‚àò-epi (h , hepi) (g , gepi) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-epi hepi gepi
\end{code}

\paragraph*{Universe lifting of homomorphisms}
Here we define the identity homomorphism for setoid algebras. Then we prove that the operations of lifting and lowering of a setoid algebra are homomorphisms.

\begin{code}

ùíæùíπ : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí hom ùë® ùë®
ùíæùíπ {ùë® = ùë®} = ùëñùëë , mkhom (reflexive ‚â°.refl) where open Setoid ( Domain ùë® ) using ( reflexive )

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 open Setoid ùîª[ ùë® ]              using ( reflexive )  renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; refl to refl‚ÇÅ )
 open Setoid ùîª[ Lift-AlgÀ° ùë® ‚Ñì ]  using ()             renaming ( _‚âà_ to _‚âàÀ°_ ; refl to reflÀ°)
 open Setoid ùîª[ Lift-Alg ≥ ùë® ‚Ñì ]  using ()             renaming ( _‚âà_ to _‚âà ≥_ ; refl to refl ≥)
 open Level

 ToLiftÀ° : hom ùë® (Lift-AlgÀ° ùë® ‚Ñì)
 ToLiftÀ° = record { f = lift ; cong = id } , mkhom (reflexive ‚â°.refl)

 FromLiftÀ° : hom (Lift-AlgÀ° ùë® ‚Ñì) ùë®
 FromLiftÀ° = record { f = lower ; cong = id } , mkhom reflÀ°

 ToFromLiftÀ° : ‚àÄ b ‚Üí  ‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© b) ‚âàÀ° b
 ToFromLiftÀ° b = refl‚ÇÅ

 FromToLiftÀ° : ‚àÄ a ‚Üí ‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© a) ‚âà‚ÇÅ a
 FromToLiftÀ° a = refl‚ÇÅ

 ToLift ≥ : hom ùë® (Lift-Alg ≥ ùë® ‚Ñì)
 ToLift ≥ = record { f = id ; cong = lift } , mkhom (lift (reflexive ‚â°.refl))

 FromLift ≥ : hom (Lift-Alg ≥ ùë® ‚Ñì) ùë®
 FromLift ≥ = record { f = id ; cong = lower } , mkhom reflÀ°

 ToFromLift ≥ : ‚àÄ b ‚Üí ‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© b) ‚âà ≥ b
 ToFromLift ≥ b = lift refl‚ÇÅ

 FromToLift ≥ : ‚àÄ a ‚Üí ‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© a) ‚âà‚ÇÅ a
 FromToLift ≥ a = refl‚ÇÅ


module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì r : Level} where
 open  Setoid ùîª[ ùë® ]               using ( refl )
 open  Setoid ùîª[ Lift-Alg ùë® ‚Ñì r ]  using ( _‚âà_ )
 open  Level

 ToLift : hom ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift = ‚àò-hom ToLiftÀ° ToLift ≥

 FromLift : hom (Lift-Alg ùë® ‚Ñì r) ùë®
 FromLift = ‚àò-hom FromLift ≥ FromLiftÀ°

 ToFromLift : ‚àÄ b ‚Üí ‚à£ ToLift ‚à£ ‚ü®$‚ü© (‚à£ FromLift ‚à£ ‚ü®$‚ü© b) ‚âà b
 ToFromLift b = lift refl

 ToLift-epi : epi ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift-epi = ‚à£ ToLift ‚à£ ,  record { isHom = ‚à• ToLift ‚à•
                            ; isSurjective = Œª {y} ‚Üí eq (‚à£ FromLift ‚à£ ‚ü®$‚ü© y) (ToFromLift y) }
\end{code}

\paragraph*{Homomorphisms of product algebras}
%\label{homomorphisms-of-product-algebras}
Suppose we have an algebra \ab{ùë®}, a type \ab I : \ap{Type} \ab{ùìò}, and a family \ab{‚Ñ¨} : \ab I \as{‚Üí} \ar{Algebra} \ab{Œ≤} \ab{œÅ·µá} of algebras.
We sometimes refer to the inhabitants of \ab{I} as \emph{indices}, and call \ab{‚Ñ¨} an \defn{indexed family of algebras}. If in addition we have a family \ab{ùíΩ} : (\ab i : \ab I) ‚Üí \af{hom} \ab{ùë®} (\ab{‚Ñ¨} \ab i) of homomorphisms, then we can construct a homomorphism from \ab{ùë®} to the product \af{‚®Ö} \ab{‚Ñ¨} in the natural way.  The latter is codified in dependent type theory by the function \af{‚®Ö-hom-co} defined below.\footnote{cf.~the \ualmodule{Homomorphisms.Func.Products} module of the \agdaalgebras library.}

\begin{code}

module _ {Œπ : Level}{I : Type Œπ}{ùë® : Algebra Œ± œÅ·µÉ}(‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá)  where
 ‚®Ö-hom-co : (‚àÄ(i : I) ‚Üí hom ùë® (‚Ñ¨ i)) ‚Üí hom ùë® (‚®Ö ‚Ñ¨)
 ‚®Ö-hom-co ùíΩ = h , hhom
  where
  h : ùîª[ ùë® ] ‚ü∂ ùîª[ ‚®Ö ‚Ñ¨ ]
  h ‚ü®$‚ü© a = Œª i ‚Üí ‚à£ ùíΩ i ‚à£ ‚ü®$‚ü© a
  cong h xy i = cong ‚à£ ùíΩ i ‚à£ xy
  hhom : IsHom ùë® (‚®Ö ‚Ñ¨) h
  compatible hhom = Œª i ‚Üí compatible ‚à• ùíΩ i ‚à•
\end{code}

\paragraph*{Factorization of homomorphisms}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

Another basic but important fact about homomorphisms is the following factorization theorem: if \ab g : \af{hom} \ab{ùë®} \ab{ùë©}, \ab h : \af{hom} \ab{ùë®} \ab{ùë™}, \ab h is surjective,
and \af{ker} \ab h \aof{‚äÜ} \af{ker} \ab g, then there exists \ab{œÜ} : \af{hom} \ab{ùë™} \ab{ùë©}
such that \ab g = \ab{œÜ} \aof{‚àò} \ab h.  The type \af{HomFactor}, defined below, formalizes this result in MLTT.
         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
Here we merely give a formal statement of this theorem.
%, but \seeunabridged or the\ualmodule{Homomorphisms.Func.Factor} module of the \agdaalgebras library.
         %%%
\else\fi %%% END SHORT VERSION ONLY

\begin{AgdaAlign}
\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá){ùë™ : Algebra Œ≥ œÅ·∂ú}
         (gh : hom ùë® ùë©)(hh : hom ùë® ùë™) where
 open Setoid ùîª[ ùë© ] using () renaming ( _‚âà_ to _‚âà‚ÇÇ_ )
 open Setoid ùîª[ ùë™ ] using () renaming ( _‚âà_ to _‚âà‚ÇÉ_ )
 private gfunc = ‚à£ gh ‚à£ ; g = _‚ü®$‚ü©_ gfunc ; hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc

 HomFactor :  kernel _‚âà‚ÇÉ_ h ‚äÜ kernel _‚âà‚ÇÇ_ g
  ‚Üí           IsSurjective hfunc
  ‚Üí           Œ£[ œÜ ‚àà hom ùë™ ùë© ] ‚àÄ a ‚Üí g a ‚âà‚ÇÇ ‚à£ œÜ ‚à£ ‚ü®$‚ü© h a
\end{code}
\ifshort %%%
\else    %%% BEGIN LONG VERSION ONLY
         %%%
\begin{code}
 HomFactor Khg hE = (œÜmap , œÜhom) , gœÜh
  where
  kerpres : ‚àÄ a‚ÇÄ a‚ÇÅ ‚Üí h a‚ÇÄ ‚âà‚ÇÉ h a‚ÇÅ ‚Üí g a‚ÇÄ ‚âà‚ÇÇ g a‚ÇÅ
  kerpres a‚ÇÄ a‚ÇÅ hyp = Khg hyp

  h‚Åª¬π : ùïå[ ùë™ ] ‚Üí ùïå[ ùë® ]
  h‚Åª¬π = SurjInv hfunc hE

  Œ∑ : ‚àÄ {c} ‚Üí h (h‚Åª¬π c) ‚âà‚ÇÉ c
  Œ∑ = InvIsInverse ≥ hE

  open Setoid ùîª[ ùë™ ] using ( sym ; trans )
  Œ∂ : ‚àÄ{x y} ‚Üí x ‚âà‚ÇÉ y ‚Üí h (h‚Åª¬π x) ‚âà‚ÇÉ h (h‚Åª¬π y)
  Œ∂ xy = trans Œ∑ (trans xy (sym Œ∑))

  œÜmap : ùîª[ ùë™ ] ‚ü∂ ùîª[ ùë© ]
  _‚ü®$‚ü©_ œÜmap = g ‚àò h‚Åª¬π
  cong œÜmap = Khg ‚àò Œ∂

  open _‚ü∂_ œÜmap using () renaming (cong to œÜcong)

  gœÜh : (a : ùïå[ ùë® ]) ‚Üí g a ‚âà‚ÇÇ œÜmap ‚ü®$‚ü© h a
  gœÜh a = Khg (sym Œ∑)

  œÜcomp : compatible-map ùë™ ùë© œÜmap
  œÜcomp {f}{c} =
   begin
    œÜmap ‚ü®$‚ü©  (f ÃÇ ùë™)                   c       ‚âàÀò‚ü®  œÜcong (cong (Interp ùë™) (‚â°.refl , Œª _ ‚Üí Œ∑))  ‚ü©
    g(h‚Åª¬π(    (f ÃÇ ùë™)  (h ‚àò    h‚Åª¬π  ‚àò  c  )))   ‚âàÀò‚ü®  œÜcong (compatible ‚à• hh ‚à•)                   ‚ü©
    g(h‚Åª¬π(h(  (f ÃÇ ùë®)  (       h‚Åª¬π  ‚àò  c  ))))  ‚âàÀò‚ü®  gœÜh ((f ÃÇ ùë®)(h‚Åª¬π ‚àò c))                      ‚ü©
    g(        (f ÃÇ ùë®)  (       h‚Åª¬π  ‚àò  c  ))    ‚âà‚ü®   compatible ‚à• gh ‚à•                           ‚ü©
              (f ÃÇ ùë©)  (g ‚àò (  h‚Åª¬π  ‚àò  c  ))    ‚àé where open SetoidReasoning ùîª[ ùë© ]

  œÜhom : IsHom ùë™ ùë© œÜmap
  compatible œÜhom = œÜcomp
\end{code}

\paragraph*{Isomorphisms}
%\label{isomorphisms}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%
\end{AgdaAlign}

\ifshort \medskip \else \fi

Two structures are \defn{isomorphic} provided there are homomorphisms going back and forth between them which compose to the identity map.
         %%%
\ifshort %%% BEGIN SHORT VERSION ONLY
         %%%
The \agdaalgebras library's \ar{\au{}‚âÖ\au{}} type codifies the definition of isomorphism, as well as some obvious consequences.  Here we display only the core part of this record type, but \seeunabridged or the \ualmodule{Homomorphisms.Func.Isomorphisms} module of the \agdaalgebras library.
         %%%
\else    %%% BEGIN LONG VERSION ONLY
         %%%
This notion is formalized in the \agdaalgebras library as the record type \ar{\au{}‚âÖ\au{}}, whose definition we present below.  Note that the definition includes statements and proofs of some easy consequences---namely, that the maps back-and-forth are bijective. This makes it easy to apply these facts when they are needed.
\fi %%% END SHORT VERSION ONLY
    %%%
\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) (ùë© : Algebra Œ≤ œÅ·µá) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ )
 open Setoid ùîª[ ùë© ] using () renaming ( _‚âà_ to _‚âà·¥Æ_ )

 record _‚âÖ_ : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá ) where
  constructor  mkiso
  field        to : hom ùë® ùë©
               from : hom ùë© ùë®
               to‚àºfrom : ‚àÄ b ‚Üí ‚à£ to ‚à£    ‚ü®$‚ü© (‚à£ from ‚à£  ‚ü®$‚ü© b)  ‚âà·¥Æ b
               from‚àºto : ‚àÄ a ‚Üí ‚à£ from ‚à£  ‚ü®$‚ü© (‚à£ to ‚à£    ‚ü®$‚ü© a)  ‚âà a

\end{code}
\ifshort %%%
\else    %%% BEGIN LONG VERSION ONLY
         %%%
\begin{code}
  toIsSurjective : IsSurjective ‚à£ to ‚à£
  toIsSurjective {y} = eq (‚à£ from ‚à£ ‚ü®$‚ü© y) (sym (to‚àºfrom y))
   where open Setoid ùîª[ ùë© ] using ( sym )

  toIsInjective : IsInjective ‚à£ to ‚à£
  toIsInjective {x}{y} xy = trans (sym (from‚àºto x)) (trans Œæ (from‚àºto y))
   where
   open Setoid ùîª[ ùë® ] using ( sym ; trans )
   Œæ : ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© x) ‚âà ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© y)
   Œæ = cong ‚à£ from ‚à£ xy

  fromIsSurjective : IsSurjective ‚à£ from ‚à£
  fromIsSurjective {x} = eq (‚à£ to ‚à£ ‚ü®$‚ü© x) (sym (from‚àºto x))
   where open Setoid ùîª[ ùë® ] using ( sym )

  fromIsInjective : IsInjective ‚à£ from ‚à£
  fromIsInjective {x}{y} xy = trans (sym (to‚àºfrom x)) (trans Œæ (to‚àºfrom y))
   where
   open Setoid ùîª[ ùë© ] using ( sym ; trans )
   Œæ : ‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© x) ‚âà·¥Æ ‚à£ to ‚à£ ‚ü®$‚ü© (‚à£ from ‚à£ ‚ü®$‚ü© y)
   Œæ = cong ‚à£ to ‚à£ xy

open _‚âÖ_

‚âÖ-refl : Reflexive (_‚âÖ_ {Œ±}{œÅ·µÉ})
‚âÖ-refl {Œ±}{œÅ·µÉ}{ùë®} = mkiso ùíæùíπ ùíæùíπ (Œª b ‚Üí refl) Œª a ‚Üí refl where open Setoid ùîª[ ùë® ] using ( refl )
‚âÖ-sym : Sym (_‚âÖ_{Œ≤}{œÅ·µá}) (_‚âÖ_{Œ±}{œÅ·µÉ})
‚âÖ-sym œÜ = mkiso (from œÜ) (to œÜ) (from‚àºto œÜ) (to‚àºfrom œÜ)

‚âÖ-trans : Trans (_‚âÖ_ {Œ±}{œÅ·µÉ}) (_‚âÖ_{Œ≤}{œÅ·µá}) (_‚âÖ_{Œ±}{œÅ·µÉ}{Œ≥}{œÅ·∂ú})
‚âÖ-trans {œÅ·∂ú = œÅ·∂ú}{ùë®}{ùë©}{ùë™} ab bc = mkiso f g œÑ ŒΩ
 where
  f : hom ùë® ùë™                ;  g : hom ùë™ ùë®
  f = ‚àò-hom (to ab) (to bc)  ;  g = ‚àò-hom (from bc) (from ab)

  open Setoid ùîª[ ùë® ] using ( _‚âà_ ; trans )
  open Setoid ùîª[ ùë™ ] using () renaming ( _‚âà_ to _‚âà·∂ú_ ; trans to trans·∂ú )

  œÑ : ‚àÄ b ‚Üí ‚à£ f ‚à£ ‚ü®$‚ü© (‚à£ g ‚à£ ‚ü®$‚ü© b) ‚âà·∂ú b
  œÑ b = trans·∂ú (cong ‚à£ to bc ‚à£ (to‚àºfrom ab (‚à£ from bc ‚à£ ‚ü®$‚ü© b))) (to‚àºfrom bc b)

  ŒΩ : ‚àÄ a ‚Üí ‚à£ g ‚à£ ‚ü®$‚ü© (‚à£ f ‚à£ ‚ü®$‚ü© a) ‚âà a
  ŒΩ a = trans (cong ‚à£ from ab ‚à£ (from‚àºto bc (‚à£ to ab ‚à£ ‚ü®$‚ü© a))) (from‚àºto ab a)

\end{code}

Fortunately, the lift operation \af{Lift-Alg} that we defined above is an \emph{algebraic invariant}, by which we mean that isomorphism classes of algebras are closed under \af{Lift-Alg}.
As our focus is universal algebra, this crucial property is why we can use the lift operation
to solve the technical problems arising from the noncumulativity of Agda's universe
hierarchy without changing the algebraic semantics.

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 Lift-‚âÖÀ° : ùë® ‚âÖ (Lift-AlgÀ° ùë® ‚Ñì)
 Lift-‚âÖÀ° = mkiso ToLiftÀ° FromLiftÀ° (ToFromLiftÀ°{ùë® = ùë®}) (FromToLiftÀ°{ùë® = ùë®}{‚Ñì})

 Lift-‚âÖ ≥ : ùë® ‚âÖ (Lift-Alg ≥ ùë® ‚Ñì)
 Lift-‚âÖ ≥ = mkiso ToLift ≥ FromLift ≥ (ToFromLift ≥{ùë® = ùë®}) (FromToLift ≥{ùë® = ùë®}{‚Ñì})

Lift-‚âÖ : {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì œÅ : Level} ‚Üí ùë® ‚âÖ (Lift-Alg ùë® ‚Ñì œÅ)
Lift-‚âÖ = ‚âÖ-trans Lift-‚âÖÀ° Lift-‚âÖ ≥

\end{code}
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

We conclude this section on homomorphisms with what seems, for our purposes, the most useful way to represent the class of \emph{homomorphic images} of an algebra in dependent type theory.
(The first function, \af{ov}, merely provides a handy shorthand for universe levels.)
%\footnote{cf.~the \ualmodule{Homomorphisms.Func.HomomorphicImages} module of the \agdaalgebras library.}

\begin{code}

ov : Level ‚Üí Level
ov Œ± = ùìû ‚äî ùì• ‚äî lsuc Œ±

_IsHomImageOf_ : (ùë© : Algebra Œ≤ œÅ·µá)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí Type _
ùë© IsHomImageOf ùë® = Œ£[ œÜ ‚àà hom ùë® ùë© ] IsSurjective ‚à£ œÜ ‚à£

HomImages : Algebra Œ± œÅ·µÉ ‚Üí Type (Œ± ‚äî œÅ·µÉ ‚äî ov (Œ≤ ‚äî œÅ·µá))
HomImages {Œ≤ = Œ≤}{œÅ·µá = œÅ·µá} ùë® = Œ£[ ùë© ‚àà Algebra Œ≤ œÅ·µá ] ùë© IsHomImageOf ùë®

\end{code}
For future reference we record the fact that an algebra is its own homomorphic image.

\begin{code}

IdHomImage : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí ùë® IsHomImageOf ùë®
IdHomImage {Œ± = Œ±}{ùë® = ùë®} = ùíæùíπ , Œª {y} ‚Üí Image_‚àã_.eq y refl
 where open Setoid (Domain ùë®) using ( refl )
\end{code}
\ifshort %%%
\else    %%% BEGIN LONG VERSION ONLY
         %%%

\medskip

\noindent These types should be self-explanatory, but just to be sure, we pause
to describe the semantics of the Sigma type appearing in the definition of \af{HomImages}.
If \ab{ùë®} : \af{Algebra} \ab{Œ±} \ab{œÅ·µÉ} is an \ab{ùëÜ}-algebra, then \af{HomImages} \ab{ùë®}
denotes the type of pairs (\ab{ùë©} \aic{,} \ab p) such that \ab{ùë©} : \ar{Algebra} \ab{Œ≤} \ab{œÅ·µá}
and \ab p is a proof that there exists a homomorphism from \ab{ùë®} onto \ab{ùë©}.
         %%%
\fi      %%% END LONG VERSION ONLY SECTION
         %%%

%% -------------------------------------------------------------------------------------

\subsection{Subalgebras}
\label{subalgebras}
%\paragraph*{Basic definitions}
%\label{subalgebras-basic-definitions}
Given \ab{ùëÜ}-algebras \ab{ùë®} and \ab{ùë©}, we say that \ab{ùë®} is a \defn{subalgebra} of \ab{ùë®} and write
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚â§}}\AgdaSpace{}%
\AgdaBound{ùë©}
just in case \ab{ùë®} can be \emph{homomorphically embedded} in \ab{ùë©}; in other terms,
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚â§}}\AgdaSpace{}%
\AgdaBound{ùë©}
iff there exists a monomorphism \ab{h} : \af{mon} \ab{ùë®} \ab{ùë©} from \ab{ùë®} to \ab{ùë©}.

The following definition codifies the binary subalgebra relation
\AgdaOperator{\AgdaFunction{\au{}‚â§\au{}}} on the class of \ab{ùëÜ}-algebras in MLTT.

\begin{code}

_‚â§_ : Algebra Œ± œÅ·µÉ ‚Üí Algebra Œ≤ œÅ·µá ‚Üí Type _
ùë® ‚â§ ùë© = Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£
\end{code}

%\paragraph*{Basic properties}
Obviously the subalgebra relation is reflexive by the identity monomorphism, as well as transitive since composition of monomorphisms is a monomorphism.  Here we merely give the formal statements, but omit the easy proofs, of these results.

\begin{code}

‚â§-reflexive   :  {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí ùë® ‚â§ ùë®

‚â§-transitive  :  {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{ùë™ : Algebra Œ≥ œÅ·∂ú}
 ‚Üí               ùë® ‚â§ ùë© ‚Üí ùë© ‚â§ ùë™ ‚Üí ùë® ‚â§ ùë™

\end{code}
\begin{code}[hide]
‚â§-reflexive {ùë® = ùë®} = ùíæùíπ , id

‚â§-transitive ( f , finj ) ( g , ginj ) = (‚àò-hom f g ) , ‚àò-IsInjective ‚à£ f ‚à£ ‚à£ g ‚à£ finj ginj
\end{code}

If \ab{ùíú} : \ab I ‚Üí \af{Algebra} \ab{Œ±} \ab{œÅ·µÉ} and
\ab{‚Ñ¨} : \ab I ‚Üí \af{Algebra} \ab{Œ≤} \ab{œÅ·µá} are families of \ab{ùëÜ}-algebras
such that \ab{‚Ñ¨} \ab i \af{‚â§} \ab{ùíú} \ab i for every \ab i : \ab I, then
\af{‚®Ö} \ab{‚Ñ¨} is a subalgebra of \af{‚®Ö} \ab{ùíú}.
\ifshort
We omit the straightforward proof and merely assign the formalization of this result the name \af{‚®Ö-‚â§} for future reference.
\else
\begin{code}
module _ {Œπ : Level} {I : Type Œπ}{ùíú : I ‚Üí Algebra Œ± œÅ·µÉ}{‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá} where
 ‚®Ö-‚â§ : (‚àÄ i ‚Üí ‚Ñ¨ i ‚â§ ùíú i) ‚Üí ‚®Ö ‚Ñ¨ ‚â§ ‚®Ö ùíú
 ‚®Ö-‚â§ B‚â§A = (hfunc , hhom) , hM
  where
  hi : ‚àÄ i ‚Üí hom (‚Ñ¨ i) (ùíú i)
  hi i = ‚à£ B‚â§A i ‚à£
  hfunc : ùîª[ ‚®Ö ‚Ñ¨ ] ‚ü∂ ùîª[ ‚®Ö ùíú ]
  (hfunc ‚ü®$‚ü© x) i = ‚à£ hi i ‚à£ ‚ü®$‚ü© x i
  cong hfunc = Œª xy i ‚Üí cong ‚à£ hi i ‚à£ (xy i)
  hhom : IsHom (‚®Ö ‚Ñ¨) (‚®Ö ùíú) hfunc
  compatible hhom = Œª i ‚Üí compatible ‚à• hi i ‚à•
  hM : IsInjective hfunc
  hM = Œª xy i ‚Üí ‚à• B‚â§A i ‚à• (xy i)

\end{code}
\fi
We conclude this brief subsection on subalgebras with two easy facts that will be useful later, when we prove the HSP theorem. The first merely converts a monomorphism into a pair in the subalgebra relation
 while the second is an algebraic invariance property of \AgdaOperator{\AgdaFunction{\au{}‚â§\au{}}}.
\ifshort
(Proofs omitted.)
\else\fi

\begin{code}

mon‚Üí‚â§      :  {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} ‚Üí mon ùë® ùë© ‚Üí ùë® ‚â§ ùë©

‚âÖ-trans-‚â§  :  {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{ùë™ : Algebra Œ≥ œÅ·∂ú}
 ‚Üí            ùë® ‚âÖ ùë© ‚Üí ùë© ‚â§ ùë™ ‚Üí ùë® ‚â§ ùë™
\end{code}
\ifshort\else
\begin{code}
‚âÖ-trans-‚â§ A‚âÖB (h , hinj) = (‚àò-hom (to A‚âÖB) h) , (‚àò-IsInjective ‚à£ to A‚âÖB ‚à£ ‚à£ h ‚à£ (toIsInjective A‚âÖB) hinj)

mon‚Üí‚â§ {ùë® = ùë®}{ùë©} x = mon‚Üíintohom ùë® ùë© x
\end{code}
\fi

%% -------------------------------------------------------------------------------------

\subsection{Terms}
\label{terms}
%\paragraph*{Basic definitions}
Fix a signature \ab{ùëÜ} and let \ab X denote an arbitrary nonempty collection of variable symbols.
(The chosen collection of variable symbols is sometimes called the \defn{context}.)
Assume the symbols in \ab X are distinct from the operation symbols of \ab{ùëÜ}, that is \ab X \aof{‚à©} \aof{‚à£} \ab{ùëÜ} \aof{‚à£} = ‚àÖ.

A \defn{word} in the language of \ab{ùëÜ} is a finite sequence of members of \ab X \aof{‚à™} \aof{‚à£} \ab{ùëÜ} \aof{‚à£}. We denote the concatenation of such sequences by simple juxtaposition.
Let \ab{S‚ÇÄ} denote the set of nullary operation symbols of \ab{ùëÜ}. We define by induction on \ab n the sets \ab{ùëá‚Çô} of \emph{words} over \ab X \aof{‚à™} \aof{‚à£} \ab{ùëÜ} \aof{‚à£} as follows (cf.~\cite[Def. 4.19]{Bergman:2012}): \ab{ùëá‚ÇÄ} := \ab X \aof{‚à™} \ab{S‚ÇÄ} and \ab{ùëá‚Çô‚Çä‚ÇÅ} := \ab{ùëá‚Çô} \aof{‚à™} \ab{ùíØ‚Çô},
where \ab{ùíØ‚Çô} is the collection of all \ab f \ab t such that \ab f : \aof{‚à£} \ab{ùëÜ} \aof{‚à£} and \ab t : \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab f \as{‚Üí} \ab{ùëá‚Çô}. (Recall, \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab f is the arity of the operation symbol \ab f.) An \ab{ùëÜ}-\defn{term} is a term in the language of \ab{ùëÜ} and the collection of all \ab{ùëÜ}-\defn{terms} in the context \ab X is given by \ad{Term} \ab X := \aof{‚ãÉ‚Çô} \ab{ùëá‚Çô}.

As even its informal definition of \ad{Term} \ab X is recursive, it should come as no surprise that
the semantics of terms can be faithfully represented in type theory as an inductive type.
Indeed, here is such a representation.

\begin{code}

data Term (X : Type œá ) : Type (ov œá)  where
 ‚Ñä : X ‚Üí Term X
 node : (f : ‚à£ ùëÜ ‚à£)(t : ‚à• ùëÜ ‚à• f ‚Üí Term X) ‚Üí Term X

\end{code}
This is a very basic inductive type that represents each term as a tree with an operation symbol at each \aic{node} and a variable symbol at each leaf (\aic{‚Ñä}); hence the constructor names (\aic{‚Ñä} for ``generator'' and \aic{node} for ``node''). We will enrich this type with an inductive type \ad{\au{}‚âÉ\au{}} representing equality of terms, and then we will package up \ad{Term}, \ad{\au{}‚âÉ\au{}}, and a proof that \ad{\au{}‚âÉ\au{}} is an equivalence relation into a setoid of \ab{ùëÜ}-terms.
Ultimately we will use this term setoid as the domain of an algebra---the (absolutely free) \emph{term algebra} in the signature \ab{ùëÜ}.

First, the equality-of-terms type is defined as follows.

\begin{code}

module _ {X : Type œá } where

 data _‚âÉ_ : Term X ‚Üí Term X ‚Üí Type (ov œá) where
  rfl : {x y : X} ‚Üí x ‚â° y ‚Üí (‚Ñä x) ‚âÉ (‚Ñä y)
  gnl : ‚àÄ {f}{s t : ‚à• ùëÜ ‚à• f ‚Üí Term X} ‚Üí (‚àÄ i ‚Üí (s i) ‚âÉ (t i)) ‚Üí (node f s) ‚âÉ (node f t)

\end{code}
Next, we would show that equality of terms so defined is an equivalence relation, but the proof
of this fact is trivial, so we omit it and merely give the fact a name; call it \af{‚âÉ-isEquiv}.

\begin{code}[hide]

 ‚âÉ-isRefl   : Reflexive      _‚âÉ_
 ‚âÉ-isRefl {‚Ñä _} = rfl ‚â°.refl
 ‚âÉ-isRefl {node _ _} = gnl (Œª _ ‚Üí ‚âÉ-isRefl)

 ‚âÉ-isSym    : Symmetric      _‚âÉ_
 ‚âÉ-isSym (rfl x) = rfl (‚â°.sym x)
 ‚âÉ-isSym (gnl x) = gnl (Œª i ‚Üí ‚âÉ-isSym (x i))

 ‚âÉ-isTrans  : Transitive     _‚âÉ_
 ‚âÉ-isTrans (rfl x) (rfl y) = rfl (‚â°.trans x y)
 ‚âÉ-isTrans (gnl x) (gnl y) = gnl (Œª i ‚Üí ‚âÉ-isTrans (x i) (y i))

 ‚âÉ-isEquiv  : IsEquivalence  _‚âÉ_
 ‚âÉ-isEquiv = record { refl = ‚âÉ-isRefl ; sym = ‚âÉ-isSym ; trans = ‚âÉ-isTrans }
\end{code}


\paragraph*{The term algebra}
%\label{the-term-algebra}
For a given signature \ab{ùëÜ}, if the type \ad{Term} \ab X is nonempty
(equivalently, if \ab X or \aof{‚à£} \ab{ùëÜ} \aof{‚à£} is nonempty), then we can
define an algebraic structure, denoted by \T{X} and called the \defn{term
  algebra in the signature} \ab{ùëÜ} \defn{over} \ab X.  Terms are viewed as
acting on other terms, so both the domain and basic operations of the algebra
are the terms themselves.

For each operation symbol \ab f : \aof{‚à£} \ab{ùëÜ} \aof{‚à£}, we denote by \ab f
\aof{ÃÇ} \T{X} the operation on \ad{Term} \ab X that maps each tuple of terms, say, \ab t :
  \aof{‚à•} \ab{ùëÜ} \aof{‚à•} \ab f \as{‚Üí} \ad{Term} \ab X, to the formal term \ab f \ab t.
We let \T{X} denote the term algebra
 in \ab{ùëÜ} over \ab X; it has universe \ad{Term} \ab X and operations \ab f \aof{ÃÇ} \T{X}, one for each symbol \ab f in \aof{‚à£} \ab{ùëÜ} \aof{‚à£}. Finally, we formalize this notion of term algebra in \agda as follows.

\begin{code}

TermSetoid : (X : Type œá) ‚Üí Setoid _ _
TermSetoid X = record { Carrier = Term X ; _‚âà_ = _‚âÉ_ ; isEquivalence = ‚âÉ-isEquiv }

ùëª : (X : Type œá) ‚Üí Algebra (ov œá) (ov œá)
Algebra.Domain (ùëª X) = TermSetoid X
Algebra.Interp (ùëª X) ‚ü®$‚ü© (f , ts) = node f ts
cong (Algebra.Interp (ùëª X)) (‚â°.refl , ss‚âÉts) = gnl ss‚âÉts
\end{code}

\paragraph*{Environments and the interpretation of terms therein}
In this section, we formalize the notions \emph{environment} and \emph{interpretation of terms} in an algebra, evaluated in an environment. The approach to formalizing these notions, as well as the Agda code presented in this subsection, is based on similar code developed by Andreas Abel to formalize Birkhoff's completeness theorem.\footnote{See \abel.}

\ifshort\else
Recall that the domain of an algebra \ab{ùë®} is a setoid, which we denote by \af{ùîª[ \ab{ùë®} ]}, whose \afld{Carrier} is the universe of the algebra, \af{ùïå[ \ab{ùë®} ]}, and whose equivalence relation represents equality of elements in \af{ùïå[ \ab{ùë®} ]}.
\fi

Fix a signature \ab{ùëÜ}, a context of variable symbols \ab X, and an \ab{ùëÜ}-algebra \ab{ùë®}. An \defn{environment} for these data is a function \ab{œÅ} : \ab X \as{‚Üí} \af{ùïå[ \ab{ùë®} ]} which assigns a value in the universe to each variable symbol in the context.
We represent the notion of environment in Agda using a function, \af{Env}, which takes an algebra \ab{ùë®} and a context \ab{X} and returns a setoid whose \afld{Carrier} has type \ab X \as{‚Üí} \af{ùïå[ \ab{ùë®} ]} and whose equivalence relation is pointwise equality of functions in \ab X \as{‚Üí} \af{ùïå[ \ab{ùë®} ]} (relative to the setoid equality of \af{ùîª[ \ab{ùë®} ]}).

Before defining the \af{Env} function (which will depend on a specific algebra) we first define a substitution from one context, say, \ab X, to another \ab Y, which assigns a term in \ab X to each symbol in \ab Y.  The definition of \af{Sub} (which does not depend on a specific algebra) is a slight modification of the one given by Andreas Abel (\textit{op.~cit.}), as is the recursive definition of the syntax \ab t \af{[} \ab{œÉ} \af{]}, which denotes a term \ab t applied to a substitution \ab{œÉ}.

\begin{code}

Sub : Type œá ‚Üí Type œá ‚Üí Type _
Sub X Y = (y : Y) ‚Üí Term X

_[_] : {X Y : Type œá}(t : Term Y) (œÉ : Sub X Y) ‚Üí Term X
(‚Ñä x) [ œÉ ] = œÉ x
(node f ts) [ œÉ ] = node f (Œª i ‚Üí ts i [ œÉ ])

\end{code}

Now we are ready to define the aforementioned environment function \af{Env}
as well as the recursive function \af{‚ü¶\au{}‚üß} which defines the \defn{interpretation} of a term in a given algebra, \emph{evaluated} in a given environment.  Since the next few definitions are relative to a certain fixed algebra, we put them inside a submodule called \am{Environment} so that later, when we load the environment, we can associate its definitions with different algebras.

\begin{code}

module Environment (ùë® : Algebra Œ± ‚Ñì) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; refl ; sym ; trans )
 Env : Type œá ‚Üí Setoid _ _
 Env X = record  { Carrier = X ‚Üí ùïå[ ùë® ]
                 ; _‚âà_ = Œª œÅ œÑ ‚Üí (x : X) ‚Üí œÅ x ‚âà œÑ x
                 ; isEquivalence = record  { refl   = Œª _      ‚Üí refl
                                           ; sym    = Œª h x    ‚Üí sym (h x)
                                           ; trans  = Œª g h x  ‚Üí trans (g x)(h x) }}

 ‚ü¶_‚üß : {X : Type œá}(t : Term X) ‚Üí (Env X) ‚ü∂ ùîª[ ùë® ]
 ‚ü¶ ‚Ñä x ‚üß          ‚ü®$‚ü© œÅ    = œÅ x
 ‚ü¶ node f args ‚üß  ‚ü®$‚ü© œÅ    = (Interp ùë®) ‚ü®$‚ü© (f , Œª i ‚Üí ‚ü¶ args i ‚üß ‚ü®$‚ü© œÅ)
 cong ‚ü¶ ‚Ñä x ‚üß u‚âàv          = u‚âàv x
 cong ‚ü¶ node f args ‚üß x‚âày  = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí cong ‚ü¶ args i ‚üß x‚âày )

\end{code}

Two terms interpreted in \ab{ùë®} are proclaimed \defn{equal} if they are equal for all environments.  This equivalence of terms%
\ifshort\else
, and proof that it is an equivalence relation,
\fi
 is formalized in Agda as follows.

\begin{code}

 Equal : {X : Type œá}(s t : Term X) ‚Üí Type _
 Equal {X = X} s t = ‚àÄ (œÅ : Carrier (Env X)) ‚Üí ‚ü¶ s ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ

 ‚âÉ‚ÜíEqual : {X : Type œá}(s t : Term X) ‚Üí s ‚âÉ t ‚Üí Equal s t
 ‚âÉ‚ÜíEqual .(‚Ñä _) .(‚Ñä _) (rfl ‚â°.refl) = Œª _ ‚Üí refl
 ‚âÉ‚ÜíEqual (node _ s)(node _ t)(gnl x) =
  Œª œÅ ‚Üí cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí ‚âÉ‚ÜíEqual(s i)(t i)(x i)œÅ )

\end{code}
\ifshort
The proof that \af{Equal} is an equivalence relation is trivial, so we omit it.
\else
\begin{code}
 EqualIsEquiv : {Œì : Type œá} ‚Üí IsEquivalence (Equal {X = Œì})
 refl·µâ   EqualIsEquiv = Œª _        ‚Üí refl
 sym·µâ    EqualIsEquiv = Œª x=y œÅ    ‚Üí sym (x=y œÅ)
 trans·µâ  EqualIsEquiv = Œª ij jk œÅ  ‚Üí trans (ij œÅ) (jk œÅ)

\end{code}
\fi

A substitution from one context \ab X to another \ab Y is used to transport an environment from \ab X to \ab Y and the function \af{‚ü¶\au{}‚üß} defined below carries out this transportation of environments.

\begin{code}

 ‚ü¶_‚üßs : {X Y : Type œá} ‚Üí Sub X Y ‚Üí Carrier(Env X) ‚Üí Carrier (Env Y)
 ‚ü¶ œÉ ‚üßs œÅ x = ‚ü¶ œÉ x ‚üß ‚ü®$‚ü© œÅ

\end{code}

Finally, we have a substitution lemma which says that \aof{‚ü¶} \ab{t} \af{[} \ab{œÉ} \af{]} \aof{‚üß} \aofld{‚ü®\$‚ü©} \ab{œÅ} (= the term \ab{t} applied to a substitution \ab{œÉ} and evaluated in an evironment \ab{œÅ}) is the same as \aof{‚ü¶ \ab{t} ‚üß} \aofld{‚ü®\$‚ü©} \aof{‚ü¶ \ab{œÉ} ‚üßs} \ab{œÅ} (= the term \ab{t} evaluated in the \ab{œÉ}-transported environment). %\aof{‚ü¶} \ab{œÉ} \aof{‚üß} \ab{œÅ}.

\begin{code}

 substitution :  {X Y : Type œá} ‚Üí (t : Term Y) (œÉ : Sub X Y) (œÅ : Carrier( Env X ) )
  ‚Üí              ‚ü¶ t [ œÉ ] ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ t ‚üß ‚ü®$‚ü© ‚ü¶ œÉ ‚üßs œÅ

 substitution (‚Ñä x)        œÉ œÅ = refl
 substitution (node f ts)  œÉ œÅ = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí substitution (ts i) œÉ œÅ)

\end{code}
This concludes the definition of the \am{Environment} module (based on Abel's Agda proof of the completeness theorem; \textit{op.~cit.}).

\ifshort\else
\paragraph*{Compatibility of terms}
%\label{compatibility-of-terms}
\fi
Later we will need two important facts about term operations.  The first, called \af{comm-hom-term}, asserts that every term commutes with every homomorphism.  The second, \af{interp-prod}, shows how to express the interpretation of a term in a product algebra.
\ifshort
We omit the formal definitions and proofs of these types, but see the \ualmodule{Types.Func.Properties} module of the \agdaalgebras library for details.
\else

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}(hh : hom ùë® ùë©) where
 open Environment ùë® using ( ‚ü¶_‚üß )
 open Environment ùë© using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥Æ )
 open Setoid ùîª[ ùë© ] using ( _‚âà_ ; refl )
 private hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc

 comm-hom-term : (t : Term X) (a : X ‚Üí ùïå[ ùë® ]) ‚Üí h (‚ü¶ t ‚üß ‚ü®$‚ü© a) ‚âà ‚ü¶ t ‚üß·¥Æ ‚ü®$‚ü© (h ‚àò a)
 comm-hom-term (‚Ñä x) a       = refl
 comm-hom-term (node f t) a  =
  begin
   h(‚ü¶ node f t ‚üß ‚ü®$‚ü© a)            ‚âà‚ü® compatible ‚à• hh ‚à• ‚ü©
   (f ÃÇ ùë©)(Œª i ‚Üí h(‚ü¶ t i ‚üß ‚ü®$‚ü© a))  ‚âà‚ü® cong(Interp ùë©)(‚â°.refl , Œª i ‚Üí comm-hom-term (t i) a)‚ü©
   ‚ü¶ node f t ‚üß·¥Æ ‚ü®$‚ü© (h ‚àò a)        ‚àé where  open SetoidReasoning ùîª[ ùë© ]

module _ {X : Type œá}{Œπ : Level} {I : Type Œπ} (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) where
 open Setoid ùîª[ ‚®Ö ùíú ]  using ( _‚âà_ )
 open Environment      using ( ‚ü¶_‚üß ; ‚âÉ‚ÜíEqual )

 interp-prod : (p : Term X) ‚Üí ‚àÄ œÅ ‚Üí  (‚ü¶ ‚®Ö ùíú ‚üß p) ‚ü®$‚ü© œÅ   ‚âà   Œª i ‚Üí (‚ü¶ ùíú i ‚üß p) ‚ü®$‚ü© Œª x ‚Üí (œÅ x) i
 interp-prod (‚Ñä x)       = Œª œÅ i  ‚Üí ‚âÉ‚ÜíEqual (ùíú i) (‚Ñä x) (‚Ñä x) ‚âÉ-isRefl Œª _ ‚Üí (œÅ x) i
 interp-prod (node f t)  = Œª œÅ    ‚Üí cong (Interp (‚®Ö ùíú)) ( ‚â°.refl , Œª j k ‚Üí interp-prod (t j) œÅ k )
\end{code}
\fi

%% -------------------------------------------------------------------------------------

\section{Equational Logic}
\label{equational-logic}

\paragraph*{Basic definitions}
%\label{model-theory-basic-definitions}

%\subsubsection*{Term identities and the ‚äß relation}
Given a  signature \ab{ùëÜ} and a context of variable symbols \ab X, a \defn{term equation} or \defn{identity}
(in this signature and context) is an ordered pair (\ab p , \ab q) of ùëÜ-terms.
(Informally, such an equation is often denoted by \ab p \af{‚âà} \ab q.)

For instance, if the context is the type \ab X : \ap{Type} \ab{œá}, then a term equation
is a pair inhabiting the Cartesian product type \ad{Term}~\ab{X} \aof{√ó} \ad{Term}~\ab{X}.

If \ab{ùë®} is an \ab{ùëÜ}-algebra we say that \ab{ùë®} \emph{satisfies} \ab p \af{‚âà} \ab q if
for all environments \ab{œÅ} : \ab X \as{‚Üí} \aof{ùîª[~\ab{ùë®}~]} (assigning values in the domain of
\ab{ùë®} to variable symbols in \ab X) we have \aof{‚ü¶~\ab{p}~‚üß} \aofld{‚ü®\$‚ü©} \ab{œÅ} \af{‚âà}
\aof{‚ü¶~\ab{q}~‚üß} \aofld{‚ü®\$‚ü©} \ab{œÅ}.  In other words, when they are interpreted in the algebra \ab{ùë®},
the terms \ab{p} and \ab{q} are equal (no matter what values in \ab{ùë®} are assigned to variable symbols in \ab{X}).
In this situation, we write
%\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}‚äß\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\ab{ùë®}~\aof{‚äß}~\ab{p}~\aof{‚âà}~\ab{q} and say that \ab{ùë®} \defn{models} the identity \ab{p}~\af{‚âà}~\ab{q}.
If \ab{ùí¶} is a class of algebras, all of the same signature, we write \ab{ùí¶}~\aof{‚ä´}~\ab{p}~\aof{‚âà}~\ab{q}
and say that \ab{ùí¶} \defn{models} the identity \ab{p}~\af{‚âà}~\ab{q} provided for every \ab{ùë®} \aof{‚àà} \ab{ùí¶},
we have \ab{ùë®}~\aof{‚äß}~\ab{p}~\aof{‚âà}~\ab{q}.

\begin{code}

_‚äß_‚âà_ : Algebra Œ± œÅ·µÉ ‚Üí Term Œì ‚Üí Term Œì ‚Üí Type _
ùë® ‚äß p ‚âà q = Equal p q where open Environment ùë®

_‚ä´_‚âà_ : Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Term Œì ‚Üí Term Œì ‚Üí Type _
ùí¶ ‚ä´ p ‚âà q = ‚àÄ ùë® ‚Üí ùí¶ ùë® ‚Üí ùë® ‚äß p ‚âà q

\end{code}
%% \AgdaFunction{Pred}\AgdaSymbol{(}\AgdaDatatype{Term}\AgdaSpace{}%
%% \AgdaBound{X}\AgdaSpace{}%
%% \AgdaOperator{\AgdaFunction{√ó}}\AgdaSpace{}%
%% \AgdaDatatype{Term}\AgdaSpace{}%
%% \AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
%% \AgdaSymbol{\AgdaUnderscore{}}\<%
We represent a collection of identities as a predicate over pairs of terms---for example,
\ab{‚Ñ∞}~:~\af{Pred}(\ad{Term}~\ab{X}~\aof{√ó}~\ad{Term}~\ab{X})~\au---and we denote by
\ab{ùë®}~\aof{‚ä®}~\ab{‚Ñ∞} the assertion that the algebra \ab{ùë®} models every equation
\ab{p}~\afld{‚âà}~\ab{q} % (i.e., every \AgdaPair{p}{q}) in \ab{‚Ñ∞}.

\begin{code}

_‚ä®_ : (ùë® : Algebra Œ± œÅ·µÉ) ‚Üí Pred(Term Œì √ó Term Œì) (ov œá) ‚Üí Type _
ùë® ‚ä® ‚Ñ∞ = ‚àÄ {p q} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí Equal p q where open Environment ùë®

\end{code}

%\subsubsection*{Equational theories and classes}
In (informal) equational logic, if \ab{ùí¶} is a class of structures and \ab{‚Ñ∞} a set of term identities, then
the set of term equations modeled by \ab{ùí¶} is denoted \af{Th}~\ab{ùí¶} and called the \defn{equational theory} of \ab{ùí¶},
while the class of structures modeling \ab{‚Ñ∞} is denoted by \af{Mod}~\ab{‚Ñ∞} and is called the \defn{equational class axiomatized} by \ab{‚Ñ∞}.
These notions may be formalize in type theory as follows.

\begin{code}

Th : {X : Type œá} ‚Üí Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Pred(Term X √ó Term X) _
Th ùí¶ = Œª (p , q) ‚Üí ùí¶ ‚ä´ p ‚âà q

Mod : {X : Type œá} ‚Üí Pred(Term X √ó Term X) ‚Ñì ‚Üí Pred (Algebra Œ± œÅ·µÉ) _
Mod ‚Ñ∞ ùë® = ‚àÄ {p q} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí Equal p q where open Environment ùë®

\end{code}

%\subsubsection*{The entailment relation}
We represent entailment in type theory by defining an inductive type that is similar to the one Andreas Abel defined for formalizing Birkhoff's completeness theorem (\textit{op.~cit.}).

\begin{code}

data _‚ä¢_‚ñπ_‚âà_  (‚Ñ∞ : {Y : Type œá} ‚Üí Pred(Term Y √ó Term Y) (ov œá)) :
              (X : Type œá)(p q : Term X) ‚Üí Type (ov œá) where

 hyp         :  ‚àÄ{Y}{p q : Term Y} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí ‚Ñ∞ ‚ä¢ _ ‚ñπ p ‚âà q
 app         :  ‚àÄ{Y}{ps qs : ‚à• ùëÜ ‚à• ùëì ‚Üí Term Y}
                          ‚Üí (‚àÄ i ‚Üí ‚Ñ∞ ‚ä¢ Y ‚ñπ ps i ‚âà qs i) ‚Üí ‚Ñ∞ ‚ä¢ Y ‚ñπ (node ùëì ps) ‚âà (node ùëì qs)
 sub         :  ‚àÄ{p q}    ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí (œÉ : Sub Œî Œì) ‚Üí ‚Ñ∞ ‚ä¢ Œî ‚ñπ (p [ œÉ ]) ‚âà (q [ œÉ ])
 reflexive   :  ‚àÄ{p}      ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà p
 symmetric   :  ‚àÄ{p q}    ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ q ‚âà p
 transitive  :  ‚àÄ{p q r}  ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ q ‚âà r ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà r

\end{code}

Entailment is \defn{sound} in the following sense: % for every algebra \ab{ùë®} that models the equations in \ab{‚Ñ∞},
if \ab{‚Ñ∞} entails \ab p \aof{‚âà} \ab q and \ab{ùë®} \aof{‚ä®} \ab{‚Ñ∞}, then \ab p \aof{‚âà} \ab q holds in \ab{ùë®}.  In other terms,
the derivation \ab{‚Ñ∞} \aod{‚ä¢} \ab X \aod{‚ñπ} \ab p \aod{‚âà} \ab q implies that \ab p \aof{‚âà} \ab q holds in every model of \ab{‚Ñ∞}.
We will apply this result---called \af{sound} and borrowed from Andreas Abel's proof of Birkhoff's completeness theorem (\textit{op.~cit.})---only once below %(in ¬ß\ref{basic-properties-of-free-algebras})%
\ifshort
, so we omit its straightforward formalization.
\else
; nonetheless, here is the formalization due to Abel.

\begin{code}

module Soundness  (‚Ñ∞ : {Y : Type œá} ‚Üí Pred(Term Y √ó Term Y) (ov œá))
                  (ùë® : Algebra Œ± œÅ·µÉ)                -- We assume an algebra ùë®
                  (V : ‚àÄ{Y} ‚Üí _‚ä®_{œá = œá} ùë® (‚Ñ∞{Y}))  -- that models all equations in ‚Ñ∞.
                  where

 open SetoidReasoning ùîª[ ùë® ]
 open Environment ùë®

 sound : ‚àÄ {p q} ‚Üí ‚Ñ∞ ‚ä¢ Œì ‚ñπ p ‚âà q ‚Üí ùë® ‚äß p ‚âà q
 sound (hyp i) = V i
 sound (app es) œÅ = cong (Interp ùë®) (‚â°.refl , Œª i ‚Üí sound (es i) œÅ)
 sound (sub {p = p}{q} Epq œÉ) œÅ =
  begin
   ‚ü¶ p  [ œÉ ]  ‚üß ‚ü®$‚ü©         œÅ  ‚âà‚ü®   substitution p œÉ œÅ    ‚ü©
   ‚ü¶ p         ‚üß ‚ü®$‚ü© ‚ü¶ œÉ ‚üßs  œÅ  ‚âà‚ü®   sound Epq (‚ü¶ œÉ ‚üßs œÅ)  ‚ü©
   ‚ü¶ q         ‚üß ‚ü®$‚ü© ‚ü¶ œÉ ‚üßs  œÅ  ‚âàÀò‚ü®  substitution q œÉ œÅ    ‚ü©
   ‚ü¶ q  [ œÉ ]  ‚üß ‚ü®$‚ü©         œÅ  ‚àé
 sound (reflexive   {p = p}                 ) = refl·µâ   EqualIsEquiv {x = p}
 sound (symmetric   {p = p}{q}     Epq      ) = sym·µâ    EqualIsEquiv {x = p}{q}     (sound Epq)
 sound (transitive  {p = p}{q}{r}  Epq Eqr  ) = trans·µâ  EqualIsEquiv {i = p}{q}{r}  (sound Epq)(sound Eqr)
\end{code}
\fi


\paragraph*{The Closure Operators H, S, P and V}
%\label{the-closure-operators-h-s-p-and-v}
Fix a signature \ab{ùëÜ}, let \ab{ùí¶} be a class of \ab{ùëÜ}-algebras, and define
\begin{itemize}
\item \af H \ab{ùí¶} = algebras isomorphic to homomorphic images of members of \ab{ùí¶};
\item \af S \ab{ùí¶} = algebras isomorphic to subalgebras of a members of \ab{ùí¶};
\item \af P \ab{ùí¶} = algebras isomorphic to products of members of \ab{ùí¶}.
\end{itemize}
A straight-forward verification confirms that \af H, \af S, and \af P are \emph{closure operators} (expansive, monotone, and idempotent).  A class \ab{ùí¶} of \ab{ùëÜ}-algebras is said to be \emph{closed under the taking of homomorphic images} provided \af H \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}. Similarly, \ab{ùí¶} is \emph{closed under the taking of subalgebras} (resp., \emph{arbitrary products}) provided \af S \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶} (resp., \af P \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}). The operators \af H, \af S, and \af P can be composed with one another repeatedly, forming yet more closure operators.

% An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class \af H \ab{ùí¶} (resp., \af S \ab{ùí¶}; resp., \af P \ab{ùí¶}) is closed under isomorphism.

A \emph{variety} is a class of \ab{ùëÜ}-algebras that is closed under the taking of
homomorphic images, subalgebras, and arbitrary products.  To represent varieties
we define types for the closure operators \af H, \af S, and \af P that are composable.
Separately, we define a type \af V which represents closure under all three
operators, \af H, \af S, and \af P.  Thus, if \ab{ùí¶} is a class of \ab{ùëÜ}-algebras, then
\af V \ab{ùí¶} := \af H (\af S (\af P \ab{ùí¶})), and \ab{ùí¶} is a variety iff \af V \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}.

We now define the type \af H to represent classes of algebras that include all homomorphic images of algebras in the class---i.e., classes that are closed under the taking of homomorphic images---the type \af S to represent classes of algebras that closed under the taking of subalgebras, and the type \af P to represent classes of algebras closed under the taking of arbitrary products.

\begin{code}

module _ {Œ± œÅ·µÉ Œ≤ œÅ·µá : Level} where
 private a = Œ± ‚äî œÅ·µÉ

 H : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 H _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© IsHomImageOf ùë®

 S : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 S _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© ‚â§ ùë®

 P : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 P _ Œπ ùí¶ ùë© = Œ£[ I ‚àà Type Œπ ] (Œ£[ ùíú ‚àà (I ‚Üí Algebra Œ± œÅ·µÉ) ] (‚àÄ i ‚Üí ùíú i ‚àà ùí¶) √ó (ùë© ‚âÖ ‚®Ö ùíú))

\end{code}

As mentioned, \af S is a closure operator.  The facts that \af S is monotone and expansive won't be needed, so we omit their proofs.
However, we do make use of idempotence of \af S, so let us pause to prove that property here.

\begin{code}

S-idem :  {ùí¶ : Pred (Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}
 ‚Üí        S{Œ≤ = Œ≥}{œÅ·∂ú} (Œ± ‚äî œÅ·µÉ  ‚äî ‚Ñì) (S{Œ≤ = Œ≤}{œÅ·µá} ‚Ñì ùí¶) ‚äÜ S{Œ≤ = Œ≥}{œÅ·∂ú} ‚Ñì ùí¶

S-idem (ùë® , (ùë© , sB , A‚â§B) , x‚â§A) = ùë© , (sB , ‚â§-transitive x‚â§A A‚â§B)

\end{code}
Finally, we define the \defn{varietal closure} of a class \ab{ùí¶} to be the class \af{V} \ab{ùí¶} := \af{H} (\af{S} (\af{P} \ab{ùí¶})).
(Recall, \ab{ùí¶} is called a \defn{variety} if \af{V} \ab{ùí¶} = \ab{ùí¶}.)
\begin{code}

module _  {Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà : Level} where
 private a = Œ± ‚äî œÅ·µÉ ; b = Œ≤ ‚äî œÅ·µá

 V : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí  Pred(Algebra Œ¥ œÅ·µà) _
 V ‚Ñì Œπ ùí¶ = H{Œ≥}{œÅ·∂ú}{Œ¥}{œÅ·µà} (a ‚äî b ‚äî ‚Ñì ‚äî Œπ) (S{Œ≤}{œÅ·µá} (a ‚äî ‚Ñì ‚äî Œπ) (P ‚Ñì Œπ ùí¶))

\end{code}

The binary relation \aof{‚äß} would be practically useless if it were not an \emph{algebraic invariant} (i.e., invariant under isomorphism). Let us now verify that the models relation we defined above has this essential property.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá)(p q : Term X) where

 ‚äß-I-invar : ùë® ‚äß p ‚âà q  ‚Üí  ùë® ‚âÖ ùë©  ‚Üí  ùë© ‚äß p ‚âà q
 ‚äß-I-invar Apq (mkiso fh gh f‚àºg g‚àºf) œÅ =
  begin
   ‚ü¶ p ‚üß     ‚ü®$‚ü©            œÅ    ‚âàÀò‚ü®  cong ‚ü¶ p ‚üß (f‚àºg ‚àò œÅ)        ‚ü©
   ‚ü¶ p ‚üß     ‚ü®$‚ü© (f  ‚àò (g ‚àò œÅ))  ‚âàÀò‚ü®  comm-hom-term fh p (g ‚àò œÅ)  ‚ü©
   f(‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü©       (g ‚àò œÅ))  ‚âà‚ü®   cong ‚à£ fh ‚à£ (Apq (g ‚àò œÅ))   ‚ü©
   f(‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü©       (g ‚àò œÅ))  ‚âà‚ü®   comm-hom-term fh q (g ‚àò œÅ)  ‚ü©
   ‚ü¶ q ‚üß     ‚ü®$‚ü© (f  ‚àò (g ‚àò œÅ))  ‚âà‚ü®   cong ‚ü¶ q ‚üß (f‚àºg ‚àò œÅ)        ‚ü©
   ‚ü¶ q ‚üß     ‚ü®$‚ü©            œÅ    ‚àé
  where
  private f = _‚ü®$‚ü©_ ‚à£ fh ‚à£ ; g = _‚ü®$‚ü©_ ‚à£ gh ‚à£
  open Environment ùë®     using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨ )
  open Environment ùë©     using ( ‚ü¶_‚üß )
  open SetoidReasoning ùîª[ ùë© ]

\end{code}
Identities modeled by an algebra \ab{ùë®} are also modeled by every subalgebra of \ab{ùë®}.
\ifshort
We will refer to this fact as \af{‚äß-S-invar}. We omit its proof since it is similar to the proof of
\af{‚äß-I-invar}.
\else
This fact is formalized in Agda as follows.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{p q : Term X} where

 ‚äß-S-invar : ùë® ‚äß p ‚âà q ‚Üí  ùë© ‚â§ ùë®  ‚Üí  ùë© ‚äß p ‚âà q
 ‚äß-S-invar Apq B‚â§A b = ‚à• B‚â§A ‚à• (Œæ b)
  where
  open Setoid ùîª[ ùë® ]  using ( _‚âà_ )
  open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨ )
  open Environment ùë©  using ( ‚ü¶_‚üß )
  private hh = ‚à£ B‚â§A ‚à£ ; h = _‚ü®$‚ü©_ ‚à£ hh ‚à£

  Œæ : ‚àÄ b ‚Üí h (‚ü¶ p ‚üß ‚ü®$‚ü© b) ‚âà h (‚ü¶ q ‚üß ‚ü®$‚ü© b)
  Œæ b = begin
         h (‚ü¶ p ‚üß  ‚ü®$‚ü©         b)  ‚âà‚ü®   comm-hom-term hh p b  ‚ü©
         ‚ü¶ p ‚üß·¥¨    ‚ü®$‚ü©  (h  ‚àò  b)  ‚âà‚ü®   Apq (h ‚àò b)           ‚ü©
         ‚ü¶ q ‚üß·¥¨    ‚ü®$‚ü©  (h  ‚àò  b)  ‚âàÀò‚ü®  comm-hom-term hh q b  ‚ü©
         h (‚ü¶ q ‚üß  ‚ü®$‚ü©         b)  ‚àé where open SetoidReasoning ùîª[ ùë® ]

\end{code}
\fi
Next, an identity satisfied by all algebras in an indexed collection is also satisfied by the product of algebras in that collection.
\ifshort
We omit the formal proof of this fact, and refer to it as \af{‚äß-P-invar} below.
\else

\begin{code}

module _ {X : Type œá}{I : Type ‚Ñì}(ùíú : I ‚Üí Algebra Œ± œÅ·µÉ){p q : Term X} where

 ‚äß-P-invar : (‚àÄ i ‚Üí ùíú i ‚äß p ‚âà q) ‚Üí ‚®Ö ùíú ‚äß p ‚âà q
 ‚äß-P-invar ùíúpq a =
  begin
   ‚ü¶ p ‚üß‚ÇÅ               ‚ü®$‚ü©  a                ‚âà‚ü®   interp-prod ùíú p a  ‚ü©
   ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß p)  ‚ü®$‚ü©  Œª x ‚Üí (a x) i )  ‚âà‚ü® (Œª i ‚Üí ùíúpq i (Œª x ‚Üí (a x) i)) ‚ü©
   ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß q)  ‚ü®$‚ü©  Œª x ‚Üí (a x) i )  ‚âàÀò‚ü®  interp-prod ùíú q a  ‚ü©
   ‚ü¶ q ‚üß‚ÇÅ               ‚ü®$‚ü©  a                ‚àé
  where
  open Environment (‚®Ö ùíú)  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
  open Environment        using ( ‚ü¶_‚üß )
  open Setoid ùîª[ ‚®Ö ùíú ]    using ( _‚âà_ )
  open SetoidReasoning ùîª[ ‚®Ö ùíú ]
\end{code}
\fi

%\paragraph*{Identity preservation}
The classes \af H \ab{ùí¶}, \af S \ab{ùí¶}, \af P \ab{ùí¶}, and \af V \ab{ùí¶} all satisfy the same set of equations.  We will only use a subset of the inclusions used to prove this fact. For complete proofs, see the
\ualmodule{Varieties.Func.Preservation} module of the \agdaalgebras library.
\ifshort
Specifically, we will cite the following facts, whose formal proofs we omit.
\else
First we prove that the closure operator \af H is compatible with identities that hold in the given class.

\begin{code}

module _  {X : Type œá}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where
\end{code}
\fi

\begin{code}

 H-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí (H {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì ùí¶) ‚ä´ p ‚âà q
\end{code}\ifshort\else
\begin{code}
 H-id1 œÉ ùë© (ùë® , kA , BimgOfA) œÅ =
  begin
   ‚ü¶ p ‚üß      ‚ü®$‚ü©             œÅ   ‚âàÀò‚ü®  cong ‚ü¶ p ‚üß(Œª _ ‚Üí InvIsInverse ≥ œÜE)‚ü©
   ‚ü¶ p ‚üß      ‚ü®$‚ü© (œÜ ‚àò œÜ‚Åª¬π  ‚àò œÅ)  ‚âàÀò‚ü®  comm-hom-term œÜh p (œÜ‚Åª¬π ‚àò œÅ)      ‚ü©
   œÜ (‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü© (    œÜ‚Åª¬π  ‚àò œÅ)) ‚âà‚ü®   cong ‚à£ œÜh ‚à£ (IH (œÜ‚Åª¬π ‚àò œÅ))        ‚ü©
   œÜ (‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü© (    œÜ‚Åª¬π  ‚àò œÅ)) ‚âà‚ü®   comm-hom-term œÜh q (œÜ‚Åª¬π ‚àò œÅ)      ‚ü©
   ‚ü¶ q ‚üß      ‚ü®$‚ü© (œÜ ‚àò œÜ‚Åª¬π  ‚àò œÅ)  ‚âà‚ü®   cong ‚ü¶ q ‚üß(Œª _ ‚Üí InvIsInverse ≥ œÜE)‚ü©
   ‚ü¶ q ‚üß      ‚ü®$‚ü©             œÅ   ‚àé
    where
    IH : ùë® ‚äß p ‚âà q
    IH = œÉ ùë® kA
    œÜh : hom ùë® ùë©
    œÜh = ‚à£ BimgOfA ‚à£
    œÜE : IsSurjective ‚à£ œÜh ‚à£
    œÜE = ‚à• BimgOfA ‚à•
    œÜ‚Åª¬π : ùïå[ ùë© ] ‚Üí ùïå[ ùë® ]
    œÜ‚Åª¬π = SurjInv ‚à£ œÜh ‚à£ œÜE
    private œÜ = (_‚ü®$‚ü©_ ‚à£ œÜh ‚à£)
    open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨)
    open Environment ùë©  using ( ‚ü¶_‚üß ) ; open SetoidReasoning ùîª[ ùë© ]

\end{code}

Similarly for \af S and the obvious converse, though barely worth mentioning, must be formally proved as well since we use it below.
\fi
\begin{code}
 S-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí (S {Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶) ‚ä´ p ‚âà q
\end{code}\ifshort\else
\begin{code}
 S-id1 œÉ ùë© (ùë® , kA , B‚â§A) = ‚äß-S-invar{p = p}{q} (œÉ ùë® kA) B‚â§A

\end{code}
\fi
\begin{code}
 S-id2 : S ‚Ñì ùí¶ ‚ä´ p ‚âà q ‚Üí ùí¶ ‚ä´ p ‚âà q
\end{code}\ifshort\else
\begin{code}
 S-id2 Spq ùë® kA = Spq ùë® (ùë® , (kA , ‚â§-reflexive))

\end{code}
Finally, we have analogous pairs of implications for \af P and \af V.  In each case, we will only need the first implication, so we omit the formal proof of the others.

\fi

\begin{code}
 P-id1 : ‚àÄ{Œπ} ‚Üí ùí¶ ‚ä´ p ‚âà q ‚Üí P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶ ‚ä´ p ‚âà q
\end{code}\ifshort\else
\begin{code}
 P-id1 œÉ ùë® (I , ùíú , kA , A‚âÖ‚®ÖA) = ‚äß-I-invar ùë® p q IH (‚âÖ-sym A‚âÖ‚®ÖA)
  where
  ih : ‚àÄ i ‚Üí ùíú i ‚äß p ‚âà q
  ih i = œÉ (ùíú i) (kA i)
  IH : ‚®Ö ùíú ‚äß p ‚âà q
  IH = ‚äß-P-invar ùíú {p}{q} ih

module _ {X : Type œá}{Œπ : Level}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where
 private a‚ÑìŒπ = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ‚äî Œπ

\end{code}
\fi
\begin{code}
 V-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí V ‚Ñì Œπ ùí¶ ‚ä´ p ‚âà q
\end{code}\ifshort\else
\begin{code}
 V-id1 œÉ ùë© (ùë® , (‚®ÖA , p‚®ÖA , A‚â§‚®ÖA) , BimgA) =
  H-id1{‚Ñì = a‚ÑìŒπ}{ùí¶ = S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)}{p = p}{q} spK‚äßpq ùë© (ùë® , (spA , BimgA))
   where
   spA : ùë® ‚àà S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)
   spA = ‚®ÖA , (p‚®ÖA , A‚â§‚®ÖA)
   spK‚äßpq : S a‚ÑìŒπ (P ‚Ñì Œπ ùí¶) ‚ä´ p ‚âà q
   spK‚äßpq = S-id1{‚Ñì = a‚ÑìŒπ}{p = p}{q} (P-id1{‚Ñì = ‚Ñì} {ùí¶ = ùí¶}{p = p}{q} œÉ)
\end{code}
\fi

%% -------------------------------------------------------------------------------------

\section{Free Algebras}
\label{free-algebras}
\paragraph*{The absolutely free algebra}
The term algebra \af{ùëª} \ab X is \emph{absolutely free} (or \emph{universal}, or
\emph{initial}) for algebras in the signature \ab{ùëÜ}. That is, for every
\ab{ùëÜ}-algebra \ab{ùë®}, the following hold.

\begin{itemize}
\item Every function from \ab{X} to \af{ùïå[ \ab{ùë®} ]} lifts to a homomorphism from \af{ùëª} \ab{X} to \ab{ùë®}.
\item The homomorphism that exists by the previous item is unique.
\end{itemize}

We now prove the first of these facts in \agda.\footnote{For the proof of uniqueness, see the \ualmodule{Terms.Func.Properties} module of the \agdaalgebras library.}
%, starting with the fact that every map from \ab{X} to
%\af{ùïå[ \ab{ùë®} ]} lifts to a map from \af{ùïå[ \T{X} ]} (= \af{Term} \ab{X}) to
%\af{ùïå[ \ab{ùë®} ]} in a natural way, by induction on the structure of the given term.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(h : X ‚Üí ùïå[ ùë® ]) where
 free-lift : ùïå[ ùëª X ] ‚Üí ùïå[ ùë® ]
 free-lift (‚Ñä x) = h x
 free-lift (node f t) = (f ÃÇ ùë®) (Œª i ‚Üí free-lift (t i))

 free-lift-func : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùë® ]
 free-lift-func ‚ü®$‚ü© x = free-lift x
 cong free-lift-func = flcong
  where
  open Setoid ùîª[ ùë® ] using ( _‚âà_ ) renaming ( reflexive to reflexive·¥¨ )
  flcong : ‚àÄ {s t} ‚Üí s ‚âÉ t ‚Üí free-lift s ‚âà free-lift t
  flcong (_‚âÉ_.rfl x) = reflexive·¥¨ (‚â°.cong h x)
  flcong (_‚âÉ_.gnl x) = cong (Interp ùë®) (‚â°.refl , (Œª i ‚Üí flcong (x i)))

\end{code}
Naturally, at the base step of the induction, when the term has the form \aic{‚Ñä}
\ab x, the free lift of \ab h agrees with \ab h.  For the inductive step, when the
given term has the form \aic{node} \ab f \ab t, the free lift is defined as
follows: Assuming (the induction hypothesis) that we know the image of each
subterm \ab t \ab i under the free lift of \ab h, define the free lift at the
full term by applying \ab f \aof{ÃÇ} \ab{ùë®} to the images of the subterms.
The free lift so defined is a homomorphism by construction. Indeed, here is the trivial proof.

\begin{code}

 lift-hom : hom (ùëª X) ùë®
 lift-hom = free-lift-func , hhom
  where
  hfunc : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùë® ]
  hfunc = free-lift-func

  hcomp : compatible-map (ùëª X) ùë® free-lift-func
  hcomp {f}{a} = cong (Interp ùë®) (‚â°.refl , (Œª i ‚Üí (cong free-lift-func){a i} ‚âÉ-isRefl))

  hhom : IsHom (ùëª X) ùë® hfunc
  hhom = mkhom (Œª{f}{a} ‚Üí hcomp{f}{a})

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ} where
 open Setoid ùîª[ ùë® ]  using ( _‚âà_ ; refl )
 open Environment ùë®  using ( ‚ü¶_‚üß )

 free-lift-interp : (Œ∑ : X ‚Üí ùïå[ ùë® ])(p : Term X) ‚Üí ‚ü¶ p ‚üß ‚ü®$‚ü© Œ∑ ‚âà (free-lift{ùë® = ùë®} Œ∑) p
 free-lift-interp Œ∑ (‚Ñä x)       = refl
 free-lift-interp Œ∑ (node f t)  = cong (Interp ùë®) (‚â°.refl , (free-lift-interp Œ∑) ‚àò t)
\end{code}

\paragraph*{The relatively free algebra}
We now define the algebra \AgdaOperator{\AgdaFunction{ùîΩ[}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}},
which represents the \defn{relatively free algebra} over \ab X.
The domain of the free algebra is a setoid whose \afld{Carrier} is the type \ad{Term} \ab X of {ùëÜ}-terms
in \ab X. The interpretation of an operation in the free algebra is simply the operation itself.
%This works since \ab{‚Ñ∞} \aod{‚ä¢} \ab X \aod{‚ñπ\au{}‚âà\{}} is a congruence.

\begin{code}

module FreeAlgebra {œá : Level}(‚Ñ∞ : {Y : Type œá} ‚Üí Pred (Term Y √ó Term Y) (ov œá)) where

 FreeDomain : Type œá ‚Üí Setoid _ _
 FreeDomain X =
  record  { Carrier        = Term X
          ; _‚âà_            = ‚Ñ∞ ‚ä¢ X ‚ñπ_‚âà_
          ; isEquivalence  = record { refl = reflexive ; sym = symmetric ; trans = transitive } }

 ùîΩ[_] : Type œá ‚Üí Algebra (ov œá) _
 Domain ùîΩ[ X ] = FreeDomain X
 Interp ùîΩ[ X ] = FreeInterp
  where
  FreeInterp : ‚àÄ {X} ‚Üí ‚ü® ùëÜ ‚ü© (FreeDomain X) ‚ü∂ FreeDomain X
  FreeInterp ‚ü®$‚ü© (f , ts)       = node f ts
  cong FreeInterp (‚â°.refl , h)  = app h
\end{code}

\paragraph*{The natural epimorphism} % from ùëª X to ùîΩ[ X ]}
We now define the natural epimorphism from \T{X} onto the relatively free algebra \Free{X} and prove that
the kernel of this morphism is the congruence of \T{X} defined by the identities modeled by (\af S \ab{ùí¶}, hence by) \ab{ùí¶}.

\begin{code}

module FreeHom {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c

 open FreeAlgebra {œá = c} (Th ùí¶) using ( ùîΩ[_] )

 epiF[_] : (X : Type c) ‚Üí epi (ùëª X) ùîΩ[ X ]
 epiF[ X ] = h , hepi
  where
  open Setoid ùîª[ ùëª X ]     using ()        renaming ( _‚âà_ to _‚âà‚ÇÄ_  ; refl to refl·µÄ )
  open Setoid ùîª[ ùîΩ[ X ] ]  using ( refl )  renaming ( _‚âà_ to _‚âà‚ÇÅ_  )

  con : ‚àÄ {x y} ‚Üí x ‚âà‚ÇÄ y ‚Üí x ‚âà‚ÇÅ y
  con (rfl {x}{y} ‚â°.refl) = refl
  con (gnl {f}{s}{t} x) = cong (Interp ùîΩ[ X ]) (‚â°.refl , con ‚àò x)

  h : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùîΩ[ X ] ]
  h = record { f = id ; cong = con }

  hepi : IsEpi (ùëª X) ùîΩ[ X ] h
  compatible (isHom hepi) = cong h refl·µÄ
  isSurjective hepi {y} = eq y refl

 homF[_] : (X : Type c) ‚Üí hom (ùëª X) ùîΩ[ X ]
 homF[ X ] = IsEpi.HomReduct ‚à• epiF[ X ] ‚à•

\end{code}

As promised, we prove that the kernel of the natural epimorphism is the congruence defined by the identities modelled by \ab{ùí¶}.

\begin{code}

 kernel-in-theory : {X : Type c} ‚Üí ker ‚à£ homF[ X ] ‚à£ ‚äÜ Th (V ‚Ñì Œπ ùí¶)
 kernel-in-theory {X = X} {p , q} pKq ùë® vkA = V-id1{‚Ñì = ‚Ñì}{p = p}{q} (Œ∂ pKq) ùë® vkA
  where
  Œ∂ : ‚àÄ{p q} ‚Üí (Th ùí¶) ‚ä¢ X ‚ñπ p ‚âà q ‚Üí ùí¶ ‚ä´ p ‚âà q
  Œ∂ x ùë® kA = sound (Œª y œÅ ‚Üí y ùë® kA œÅ) x where open Soundness (Th ùí¶) ùë®
\end{code}

\paragraph*{The universal property}

\begin{code}

module _  {ùë® : Algebra (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c
 open FreeHom {‚Ñì = ‚Ñì} {ùí¶}
 open FreeAlgebra {œá = c}(Th ùí¶)  using ( ùîΩ[_] )
 open Setoid ùîª[ ùë® ]              using ( refl ; sym ; trans ) renaming  ( Carrier  to A )

 F-ModTh-epi : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí epi ùîΩ[ A ] ùë®
 F-ModTh-epi A‚ààModThK = œÜ , isEpi
  where
  œÜ : ùîª[ ùîΩ[ A ] ] ‚ü∂ ùîª[ ùë® ]
  _‚ü®$‚ü©_ œÜ = free-lift{ùë® = ùë®} id
  cong œÜ {p} {q} pq  = trans  ( sym (free-lift-interp{ùë® = ùë®} id p) )
                     ( trans  ( A‚ààModThK{p = p}{q} (kernel-in-theory pq) id )
                               ( free-lift-interp{ùë® = ùë®} id q ) )
  isEpi : IsEpi ùîΩ[ A ] ùë® œÜ
  compatible (isHom isEpi) = cong (Interp ùë®) (‚â°.refl , (Œª _ ‚Üí refl))
  isSurjective isEpi {y} = eq (‚Ñä y) refl

 F-ModTh-epi-lift : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí epi ùîΩ[ A ] (Lift-Alg ùë® Œπ Œπ)
 F-ModTh-epi-lift A‚ààModThK = ‚àò-epi (F-ModTh-epi (Œª {p q} ‚Üí A‚ààModThK{p = p}{q})) ToLift-epi
\end{code}



%% -------------------------------------------------------------------------------------

\section{Birkhoff's Variety Theorem}

\subsection{Informal statement and proof}
Let \ab{ùí¶} be a class of algebras. Recall that \ab{ùí¶} is a \emph{variety} provided it is closed under homomorphisms, subalgebras and products; equivalently, \af{H} (\af{S} (\af{P} \ab{ùí¶})) ‚äÜ \ab{ùí¶}.
(As \af{H}, \af{S}, and \af{P} are closure operators, the inclusion \ab{ùí¶} ‚äÜ \af{H} (\af{S} (\af{P} \ab{ùí¶}))
is always valid, for every class \ab{ùí¶}.)
We call \ab{ùí¶} an \emph{equational class} if it is precisely the class of all models of some set of term identities.

It is easy to prove that \emph{every equational class is a variety}.  Indeed, suppose \ab{ùí¶} is an equational
class and suppose the set \ab{‚Ñ∞} of term identities \defn{axiomatizes} \ab{ùí¶}. That is, \ab{ùí¶} \af{‚ä´} \ab{‚Ñ∞} and for all \ab{ùë®} we have \ab{ùë®} \af{‚ä®} \ab{‚Ñ∞} \as{‚Üí} \ab{ùë®} \af{‚àà} \ab{ùí¶}. Then, since the classes \af H \ab{ùí¶}, \af S \ab{ùí¶}, \af P \ab{ùí¶} and \ab{ùí¶} all satisfy the same set of equations, we have \af{H} (\af{S} (\af{P} \ab{ùí¶})) ‚ä´ \ab{‚Ñ∞}, so \af{V} \ab{ùí¶} = \af{H} (\af{S} (\af{P} \ab{ùí¶})) ‚äÜ \ab{ùí¶}; that is, \ab{ùí¶} is a variety. The converse assertion---that \emph{every variety is an equational class}---is more difficult to prove and is known as Birkhoff's variety theorem.

We now describe the standard informal proof of Birkhoff's theorem and then present a formal, constructive, type-theoretic proof of this theorem in Agda.

Let \ab{ùí¶} be an arbitrary variety.  We will describe a set of equations that axiomatizes \ab{ùí¶}, thus showing that \ab{ùí¶} is an equational class.  A natural choice is the set \af{Th} \ab{ùí¶} of all equations that hold in \ab{ùí¶}. We will prove that \ab{ùí¶} is precisely the class of structures
modeling \af{Th} \ab{ùí¶}
.
Define \ab{ùí¶‚Å∫} = \af{Mod} (\af{Th} \ab{ùí¶}).  Clearly, \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶‚Å∫}. We prove the reverse inclusion. Let \ab{ùë®} \af{‚àà} \ab{ùí¶‚Å∫}.
To complete the proof it suffices to find an algebra \ab{ùë≠} belonging to \af{S} (\af{P} \ab{ùí¶}) such that
\ab{ùë®} is the homomorphic image of \ab{ùë≠}. Indeed, this will prove that \ab{ùë®} belongs to
\af{H} (\af{S} (\af{P} \ab{ùí¶})), which is \ab{ùí¶}, since we assumed that \ab{ùí¶} is a variety.

Let \ab{X} be a set of cardinality max(|A|, œâ), and let \ab{œÅ} : \ab{X} \as{‚Üí} \af{ùïå[ \ab{ùë®} ]} be a surjective valuation of variable symbols in the domain of \ab{ùë®}. By the \af{lift-hom} lemma that we formalized above, the map \ab{œÅ} extends to an epimorphism \ab{œÅ‚Å∫} from \T{X} onto \ab{ùïå[ \ab{ùë®} ]}.
Furthermore, since \ab{ùîΩ} := \T{X}/Œò, there is an epimorphism \ab{g} : \T{X} \as{‚Üí} \ab{ùîΩ}.
We claim that \af{ker} \ab g \af{‚äÜ} \af{ker} \ab h. If the claim is true, then there is a map \ab{f} : \ab{ùîΩ} \as{‚Üí} \ab{ùë®} such that \ab f \af{‚àò} \ab g = \ab h.
Since \ab h is epic, so is \ab f. Hence \ab{ùë®} \af{‚àà} \af{ùñß} (\af{ùîΩ} \ab X) \aof{‚äÜ} \ab{ùí¶‚Å∫} completing the proof.


\subsection{Formal statement and proof}

We now show how to formally express and prove the twin assertions that
(i) every equational class is a variety and (ii) every variety is an equational class.

\paragraph*{Every equational class is a variety}
For (i), we need an arbitrary equational class. To obtain one, we start with an arbitrary
collection \ab{‚Ñ∞} of equations and let \ab{ùí¶} = \af{Mod} \ab{‚Ñ∞}, the equational class determined by \ab{‚Ñ∞}.
We prove that \ab{ùí¶} is a variety by showing that \ab{ùí¶} = \af{V} \ab{ùí¶}.
The inclusion \ab{ùí¶} \aof{‚äÜ} \af V \ab{ùí¶}, which holds for all classes \ab{ùí¶}, is called the \defn{expansive} property of \af{V}.
The converse inclusion \af V \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}, on the other hand, requires the hypothesis that \ab{ùí¶} is an equation class.
We now formalize each of these inclusions.


\begin{code}

module _ (ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)){X : Type (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c

 V-expa : ùí¶ ‚äÜ V ‚Ñì Œπ ùí¶
 V-expa {x = ùë®} kA = ùë® , (ùë® , (‚ä§ , (Œª _ ‚Üí ùë®) , (Œª _ ‚Üí kA) , Goal) , ‚â§-reflexive) , IdHomImage
  where
  open Setoid ùîª[ ùë® ] using ( refl )
  open Setoid ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ] using () renaming ( refl to refl‚®Ö )

  to‚®Ö : ùîª[ ùë® ] ‚ü∂ ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ]
  (to‚®Ö ‚ü®$‚ü© x) = Œª _ ‚Üí x
  cong to‚®Ö xy = Œª _ ‚Üí xy

  from‚®Ö : ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ] ‚ü∂ ùîª[ ùë® ]
  (from‚®Ö ‚ü®$‚ü© x) = x tt
  cong from‚®Ö xy = xy tt

  Goal : ùë® ‚âÖ ‚®Ö (Œª x ‚Üí ùë®)
  Goal = mkiso (to‚®Ö , mkhom refl‚®Ö) (from‚®Ö , mkhom refl) (Œª _ _ ‚Üí refl) (Œª _ ‚Üí refl)

\end{code}
Earlier we proved the following identity preservation lemma:
\af{V-id1} : \ab{ùí¶} \aof{‚ä´} \ab p \aof{‚âà} \ab q \as{‚Üí} \af{V} \ab{‚Ñì} \ab{Œπ} \ab{ùí¶} \aof{‚ä´} \ab p \aof{‚âà} \ab q.
Thus, if \ab{ùí¶} is an equational class, then \af V \ab{ùí¶} \aof{‚äÜ} \ab{ùí¶}.  The
\af{Birkhoff|eqcl‚Üívar} lemma below formalizes this fact.

\begin{code}

module _ {‚Ñì : Level}{X : Type ‚Ñì}{‚Ñ∞ : {Y : Type ‚Ñì} ‚Üí Pred (Term Y √ó Term Y) (ov ‚Ñì)} where
 private Œπ = ov ‚Ñì

 private ùí¶ = Mod{Œ± = ‚Ñì}{‚Ñì}{X} ‚Ñ∞     -- an arbitrary equational class

 EqCl‚áíVar : V ‚Ñì Œπ ùí¶ ‚äÜ ùí¶
 EqCl‚áíVar {ùë®}vA{p}{q} p‚Ñ∞q œÅ = V-id1{‚Ñì = ‚Ñì}{ùí¶ = ùí¶}{p}{q}(Œª _ x œÑ ‚Üí x p‚Ñ∞q œÑ) ùë® vA œÅ

\end{code}
Together, \af{V-expa} and \af{Eqcl‚áíVar} prove that every equational class is a variety.


\paragraph*{Every variety is an equational class}
To prove statement (ii), we need an arbitrary variety; to obtain one, we start with an arbitrary class
\ab{ùí¶} of \ab{ùëÜ}-algebras and take its \emph{varietal closure}, \af{V} \ab{ùí¶}.
We prove that \af{V} \ab{ùí¶} is an equational class by showing it is precisely the collection of
algebras that model the equations in \af{Th} (\af{V} \ab{ùí¶}); that is, we prove
\af{V} \ab{ùí¶} = \af{Mod} (\af{Th} (\af{V} \ab{ùí¶})).
The inclusion \af{V} \ab{ùí¶} \aof{‚äÜ} \af{Mod} (\af{Th} (\af{V} \ab{ùí¶})) is a simple consequence of the fact that \af{Mod} \af{Th} is a closure operator. Nonetheless, completeness demands
that we formalize this fact, however trivial is its proof.

\begin{code}

module _ (ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)){X : Type (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c

 ModTh-closure : V{Œ≤ = Œ≤}{œÅ·µá}{Œ≥}{œÅ·∂ú}{Œ¥}{œÅ·µà} ‚Ñì Œπ ùí¶ ‚äÜ Mod{X = X} (Th (V ‚Ñì Œπ ùí¶))
 ModTh-closure {x = ùë®} vA {p} {q} x œÅ = x ùë® vA œÅ

\end{code}

It remains to prove the converse inclusion, \af{Mod} (\af{Th} (V ùí¶)) \aof{‚äÜ} \af{V} \ab{ùí¶},
which is the main focus of the rest of the paper.  We proceed as follows:

\begin{enumerate}
\item Construct an algebra \ab{ùë™} that is a product of algebras in \af{S} \ab{ùí¶}, hence belongs to \af{P} \af{S} \ab{ùí¶} ‚äÜ \af{S} \af{P} \ab{ùí¶}.
\item Prove that \aof{ùîΩ[ \ab{X} ]} is a subalgebra of \ab{ùë™}, which puts \aof{ùîΩ[ \ab{X} ]} in \af{S} (\af{S} (\af{P} \ab{ùí¶})) (= \af{S} (\af{P} \ab{ùí¶})).
\item Prove that every algebra in \af{Mod} (\af{Th} (V ùí¶)) is a homomorphic image of
\aof{ùîΩ[ \ab{X} ]} and thus belongs to \af{H} (\af{S} (\af{P} \ab{ùí¶})) (= \af{V} \ab{ùí¶}).
\end{enumerate}

We will define the algebra \ab{ùë™} to be the product of \emph{all} algebras in \af{S} \ab{ùí¶}, and this requires that we index the algebras in \af{S} \ab{ùí¶}.
In fact, we will need to associate each ``indexing pair'' (\ab{ùë®} , \ab p) (where \ab p : \ab{ùë®} \af{‚àà} \af{S} \ab{ùí¶}) with an arbitrary environment
\ab{œÅ} : \ab X \as{‚Üí} \aof{ùïå[ \ab{ùë®} ]}. Consequently, the indices of the product will be triples (\ab{ùë®} , \ab p, \ab{œÅ}) ranging over all algebras in \af{S} \ab{ùí¶} and all
environments assigning values in the domain of \ab{ùë®} to variables in \ab X.  Here is the construction of \ab{ùë™}.

\begin{code}

 open FreeHom {‚Ñì = ‚Ñì} {ùí¶}
 open FreeAlgebra {œá = c}(Th ùí¶)  using ( ùîΩ[_] )
 open Environment                using ( Env )

 ‚Ñë‚Å∫ : Type Œπ
 ‚Ñë‚Å∫ = Œ£[ ùë® ‚àà (Algebra Œ± œÅ·µÉ) ] (ùë® ‚àà S ‚Ñì ùí¶) √ó (Carrier (Env ùë® X))

 ùîÑ‚Å∫ : ‚Ñë‚Å∫ ‚Üí Algebra Œ± œÅ·µÉ
 ùîÑ‚Å∫ i = ‚à£ i ‚à£

 ùë™ : Algebra Œπ Œπ
 ùë™ = ‚®Ö ùîÑ‚Å∫

 skEqual : (i : ‚Ñë‚Å∫) ‚Üí ‚àÄ{p q} ‚Üí Type œÅ·µÉ
 skEqual i {p}{q} = ‚ü¶ p ‚üß ‚ü®$‚ü© snd ‚à• i ‚à• ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© snd ‚à• i ‚à•
  where open Setoid ùîª[ ùîÑ‚Å∫ i ] using ( _‚âà_ ) ; open Environment (ùîÑ‚Å∫ i) using ( ‚ü¶_‚üß )

\end{code}
The type \af{skEqual} provides a term identity \ab p \af{‚âà} \ab q for each index \ab i = (\ab{ùë®} , \ab{p} , \ab{œÅ}) of the product.
%(here, as above, \ab{ùë®} is an algebra, \ab{sA} is a proof that \ab{ùë®} belongs to \af{S} \ab{ùí¶}, and \ab{œÅ} is an environment).
%map assigning values in the domain of \ab{ùë®} to variable symbols in \ab X).
\ifshort\else
Later we prove that if the identity \ab{p} \af{‚âà} \ab q holds in all \ab{ùë®} \aof{‚àà} \af S \ab{ùí¶} (for all environments), then \ab p \af{‚âà} \ab q
holds in the relatively free algebra \Free{X}; equivalently, the pair (\ab p , \ab q) belongs to the
kernel of the natural homomorphism from \T{X} onto \Free{X}. We will use that fact to prove
that the kernel of the natural hom from \T{X} to \ab{ùë™} is contained in the kernel of the natural hom from \T{X} onto \Free{X},
whence we construct a monomorphism from \Free{X} into \ab{ùë™}, and thus \Free{X} is a subalgebra of \ab{ùë™},
so belongs to \af S (\af P \ab{ùí¶}).
\fi

\begin{code}

 homC : hom (ùëª X) ùë™
 homC = ‚®Ö-hom-co ùîÑ‚Å∫ h
  where
  h : ‚àÄ i ‚Üí hom (ùëª X) (ùîÑ‚Å∫ i)
  h i = lift-hom (snd ‚à• i ‚à•)
\end{code}
\ifshort\else
\begin{code}

 kerF‚äÜkerC : ker ‚à£ homF[ X ] ‚à£ ‚äÜ ker ‚à£ homC ‚à£
 kerF‚äÜkerC {p , q} pKq (ùë® , sA , œÅ) = Goal
  where
  open Setoid ùîª[ ùë® ]  using ( _‚âà_ ; sym ; trans )
  open Environment ùë®  using ( ‚ü¶_‚üß )
  fl : ‚àÄ t ‚Üí ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ ‚âà free-lift œÅ t
  fl t = free-lift-interp {ùë® = ùë®} œÅ t

  Œ∂ : ‚àÄ{p q} ‚Üí (Th ùí¶) ‚ä¢ X ‚ñπ p ‚âà q ‚Üí ùí¶ ‚ä´ p ‚âà q
  Œ∂ x ùë® kA = sound (Œª y œÅ ‚Üí y ùë® kA œÅ) x where open Soundness (Th ùí¶) ùë®

  subgoal : ‚ü¶ p ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© œÅ
  subgoal = S-id1{‚Ñì = ‚Ñì}{p = p}{q} (Œ∂ pKq) ùë® sA œÅ
  Goal : (free-lift{ùë® = ùë®} œÅ p) ‚âà (free-lift{ùë® = ùë®} œÅ q)
  Goal = trans (sym (fl p)) (trans subgoal (fl q))
\end{code}
\fi
\begin{code}

 homFC : hom ùîΩ[ X ] ùë™
 homFC = ‚à£ HomFactor ùë™ homC homF[ X ] kerF‚äÜkerC (isSurjective ‚à• epiF[ X ] ‚à•) ‚à£

\end{code}
If \AgdaPair{p}{q} belongs to the kernel of \af{homùë™}, then
\af{Th} \ab{ùí¶} includes the identity \ab{p} \af{‚âà} \ab{q}---that is,
\af{Th} \ab{ùí¶} \af{‚ä¢} \ab X \af{‚ñπ} \ab{p} \af{‚âà} \ab{q}. Equivalently,
if the kernel of \af{homùë™} is contained in that of \af{homùîΩ[ X ]}.
\ifshort
We omit the formal proof of this lemma and merely display its formal statement, which is the following.
\else
We formalize this fact as follows.

\begin{code}

 kerC‚äÜkerF : ‚àÄ{p q} ‚Üí (p , q) ‚àà ker ‚à£ homC ‚à£ ‚Üí (p , q) ‚àà ker ‚à£ homF[ X ] ‚à£
\end{code}
\ifshortelse
\begin{code}
 kerC‚äÜkerF {p}{q} pKq = Sùí¶‚ä´‚ÜíkerùîΩ (Sùí¶‚ä´ pqEqual)
  where
  Sùí¶‚ä´ : (‚àÄ i ‚Üí skEqual i {p}{q}) ‚Üí S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶ ‚ä´ p ‚âà q
  Sùí¶‚ä´ x ùë® sA œÅ = x (ùë® , sA , œÅ)
  Sùí¶‚ä´‚ÜíkerùîΩ : S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶ ‚ä´ p ‚âà q ‚Üí (p , q) ‚àà ker ‚à£ homF[ X ] ‚à£
  Sùí¶‚ä´‚ÜíkerùîΩ x = hyp (S-id2{‚Ñì = ‚Ñì}{p = p}{q} x)

  pqEqual : ‚àÄ i ‚Üí skEqual i {p}{q}
  pqEqual i = goal
   where
   open Environment (ùîÑ‚Å∫ i)  using ( ‚ü¶_‚üß )
   open Setoid ùîª[ ùîÑ‚Å∫ i ]    using ( _‚âà_ ; sym ; trans )
   goal : ‚ü¶ p ‚üß ‚ü®$‚ü© snd ‚à• i ‚à• ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© snd ‚à• i ‚à•
   goal  = trans (free-lift-interp{ùë® = ‚à£ i ‚à£}(snd ‚à• i ‚à•) p)
         ( trans (pKq i)(sym (free-lift-interp{ùë® = ‚à£ i ‚à£} (snd ‚à• i ‚à•) q)))

\end{code}
\fi
We conclude that the homomorphism from \Free{X} to \af{ùë™} is injective, whence it follows that \Free{X} is (isomorphic to) a subalgebra of \af{ùë™}.

\begin{code}

 monFC : mon ùîΩ[ X ] ùë™
 monFC = ‚à£ homFC ‚à£ , isMon
  where
  isMon : IsMon ùîΩ[ X ] ùë™ ‚à£ homFC ‚à£
  isHom isMon = ‚à• homFC ‚à•
  isInjective isMon {p}{q} œÜpq = kerC‚äÜkerF œÜpq

 F‚â§C : ùîΩ[ X ] ‚â§ ùë™
 F‚â§C = mon‚Üí‚â§ monFC

\end{code}
Using the last result we prove that \Free{X} belongs to \af{S} (\af{P} \ab{ùí¶}). This requires one more technical lemma concerning the classes \af{S} and \af{P};
specifically,
\ifshort
\af{P} (\af{S} \ab{ùí¶}) \aof{‚äÜ} \af{S} (\af{P} \ab{ùí¶}) holds for every class \ab{ùí¶}.
The \ualmodule{Varieties.Func.Preservation.lagda} module contains the formal statement and proof of that result (called \af{PS‚äÜSP}) which we omit.
\else
a product of subalgebras of algebras in a class is a subalgebra of a product of algebras in the class;
in other terms, \af{P} (\af{S} \ab{ùí¶}) \aof{‚äÜ} \af{S} (\af{P} \ab{ùí¶}), for every class \ab{ùí¶}.
We state and prove this in Agda as follows.

\begin{code}

 private a = Œ± ‚äî œÅ·µÉ ; oa‚Ñì = ov (a ‚äî ‚Ñì)

 PS‚äÜSP : P (a ‚äî ‚Ñì) oa‚Ñì (S{Œ≤ = Œ±}{œÅ·µÉ} ‚Ñì ùí¶) ‚äÜ S oa‚Ñì (P ‚Ñì oa‚Ñì ùí¶)
 PS‚äÜSP {ùë©} (I , ( ùíú , sA , B‚âÖ‚®ÖA )) = Goal
  where
  ‚Ñ¨ : I ‚Üí Algebra Œ± œÅ·µÉ
  ‚Ñ¨ i = ‚à£ sA i ‚à£
  kB : (i : I) ‚Üí ‚Ñ¨ i ‚àà ùí¶
  kB i =  fst ‚à• sA i ‚à•
  ‚®ÖA‚â§‚®ÖB : ‚®Ö ùíú ‚â§ ‚®Ö ‚Ñ¨
  ‚®ÖA‚â§‚®ÖB = ‚®Ö-‚â§ Œª i ‚Üí snd ‚à• sA i ‚à•
  Goal : ùë© ‚àà S{Œ≤ = oa‚Ñì}{oa‚Ñì}oa‚Ñì (P {Œ≤ = oa‚Ñì}{oa‚Ñì} ‚Ñì oa‚Ñì ùí¶)
  Goal = ‚®Ö ‚Ñ¨ , (I , (‚Ñ¨ , (kB , ‚âÖ-refl))) , (‚âÖ-trans-‚â§ B‚âÖ‚®ÖA ‚®ÖA‚â§‚®ÖB)
\end{code}
\fi

%We conclude this subsection with the proof that \Free{X} belongs to \af{S} (\af{P} \ab{ùí¶}).

\begin{code}

 SPF : ùîΩ[ X ] ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
 SPF = S-idem (ùë™ , (spC , F‚â§C))
  where
  psC : ùë™ ‚àà P (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì) Œπ (S ‚Ñì ùí¶)
  psC = ‚Ñë‚Å∫ , (ùîÑ‚Å∫ , ((Œª i ‚Üí fst ‚à• i ‚à•) , ‚âÖ-refl))
  spC : ùë™ ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
  spC = PS‚äÜSP psC

\end{code}
Finally, we prove that every algebra in \af{Mod} (\af{Th} (\af{V} \ab{ùí¶})) is a homomorphic image of \af{ùîΩ[ \ab{X} ]}, for some \ab{X}.

\begin{code}

module _ {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c
 open FreeAlgebra {œá = c}(Th ùí¶) using ( ùîΩ[_] )

 Var‚áíEqCl : ‚àÄ ùë® ‚Üí ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí ùë® ‚àà V ‚Ñì Œπ ùí¶
 Var‚áíEqCl ùë® ModThA = ùîΩ[ ùïå[ ùë® ] ] , (spFA , AimgF)
  where
  spFA : ùîΩ[ ùïå[ ùë® ] ] ‚àà S{Œπ} Œπ (P ‚Ñì Œπ ùí¶)
  spFA = SPF{‚Ñì = ‚Ñì} ùí¶

  epiFlA : epi ùîΩ[ ùïå[ ùë® ] ] (Lift-Alg ùë® Œπ Œπ)
  epiFlA = F-ModTh-epi-lift{‚Ñì = ‚Ñì} (Œª {p q} ‚Üí ModThA{p = p}{q})

  œÜ : Lift-Alg ùë® Œπ Œπ IsHomImageOf ùîΩ[ ùïå[ ùë® ] ]
  œÜ = epi‚Üíontohom ùîΩ[ ùïå[ ùë® ] ] (Lift-Alg ùë® Œπ Œπ) epiFlA

  AimgF : ùë® IsHomImageOf ùîΩ[ ùïå[ ùë® ] ]
  AimgF = ‚àò-hom ‚à£ œÜ ‚à£ (from Lift-‚âÖ) ,
          ‚àò-IsSurjective _ _ ‚à• œÜ ‚à• (fromIsSurjective (Lift-‚âÖ{ùë® = ùë®}))

\end{code}

It follows immediately from \af{ModTh-closure} and \af{Var‚áíEqCl} that
\af{V} \ab{ùí¶} = \af{Mod} (\af{Th} (\af{V} \ab{ùí¶})) holds for every class \ab{ùí¶} of \ab{ùëÜ}-algebras.
Thus, every variety is an equational class. This completes the formal proof of Birkhoff's variety theorem.


%% \paragraph*{Th ùí¶ ‚äÜ Th (V ùí¶)}
%% From \af{V-id1} it follows that if \ab{ùí¶} is a class of algebras, then the set of identities
%% modeled by the algebras in \ab{ùí¶} is contained in the set of identities modeled by the algebras
%% in \af V \ab{ùí¶}.  In other terms, \af{Th} \ab{ùí¶} \aof{‚äÜ} \af{Th} (\af V \ab{ùí¶}).  We formalize
%% this observation as follows.
%% begin{code}[hide]
%% classIds-‚äÜ-VIds : ùí¶ ‚ä´ p ‚âà q  ‚Üí (p , q) ‚àà Th (V ‚Ñì Œπ ùí¶)
%% classIds-‚äÜ-VIds pKq ùë® = V-id1 pKq ùë®
%% end{code}


