.. include:: _static/math_macros.rst

.. _inductively-defined-things:

=====================
Inductive Definitions
=====================

One of the primary motivations for the `lean-ualib`_ project was our observation that, on the one hand, many important constructs in universal algebra can be defined inductively, and on the other hand, type theory in general, and Lean in particular, offers excellent support for defining inductive types and powerful tactics for proving their properties.

These two facts suggest that there is much to be gained from implementing universal algebra in an expressive type system that offers powerful tools for proving theorems about inductively defined types. Examples demonstrating how this vision manifests in our Lean library are presented in :numref:`subalgebras-in-lean`, :numref:`terms-in-lean`, and :numref:`clones-in-lean`.

.. In particular, our Lean_ implementation of the notion of :term:`subuniverse` illustrates one of these underlying themes motivating our work.

To exhibit the efficiency and ease with which we can formalize and work with basic but important mathematical objects in Lean_, we will present some fundamental theorems about subalgebras, terms and clones---first in this chapter using the informal language of universal algebra, and then in the next chapter using the formal language of Lean.

The idea is to demonstrate the power and utility of implementing the theory in a formal language that supports dependent and inductively defined types, which are essential for expressing and working with infinite objects in a constructive and computable way, and for proving (by induction) properties of these objects.

-----------------------------------------

.. index:: ! subuniverse, ! subalgebra

.. _subuniverses:

Subuniverses
------------

We inductively define the **subuniverse generated by a set** and prove that this new definition is equivalent to the one we gave in :numref:`subalgebras` (cf. :cite:`Bergman:2012` Thm. 1.14).

.. _thm-1-14:

.. proof:theorem:: Subuniverse generation

   Let :math:`𝔸 = ⟨A, F^{𝔸}⟩`  be  an  algebra in the signature :math:`σ = (F, ρ)` and let :math:`X ⊆ A`.

   Define, by recursion on :math:`n`, the sets :math:`X_n` as follows:

   .. math:: X_0  &=  X \\
          X_{n+1} &=  X_n ∪ \{ f\, a ∣ f ∈ F, \ a ∈ X_n^{ρf}\}.
      :label: subalgebra-inductive

   Then  :math:`\Sg^𝔸(X) = ⋃ X_n`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Let :math:`Y = ⋃_{n < ω} X_n`. Clearly :math:`X_n ⊆ Y ⊆ A`, for every :math:`n ∈ ℕ`. In particular :math:`X = X_0 ⊆ Y`.

      Let us show that :math:`Y` is a subuniverse of 𝔸.
   
      Let :math:`f` be a basic :math:`k`-ary operation and :math:`a ∈ Y^k`.
    
      From the construction of :math:`Y`, there is an :math:`n < ω` such that :math:`∀ i,\ a,\ i ∈ X_n`.
    
      From its definition, :math:`f a ∈ X_{n+1} ⊆ Y`.
    
      Thus :math:`Y` is a subuniverse of 𝔸 containing :math:`X`.
    
      By :eq:`SgDef`, :math:`\Sg^𝔸(X) ⊆ Y`.
    
      For the opposite inclusion, it is enough to check, by induction on :math:`n`, that :math:`X_n ⊆ \Sg^𝔸(X)`.
    
      By definition, :math:`X_0 = X ⊆ \Sg^𝔸(X)`.
      
      Assume :math:`X_n ⊆ \Sg^𝔸(X)`.  We show :math:`X_{n+1} ⊆ \Sg^𝔸(X)`.
      
      If :math:`b ∈ X_{n+1} - X_n`, then :math:`b = f a` for a basic :math:`k`-ary operation :math:`f` and some :math:`a ∈ X_n^k`.
      
      But :math:`∀ i, \ a i ∈ \Sg^𝔸(X)` and since this latter object is a subuniverse, :math:`b ∈ \Sg^𝔸(X)` as well.
    
      Therefore, :math:`X_{n+1} ⊆ \Sg^𝔸(X)`, as desired. ☐ 

The argument in the proof of :numref:`Theorem %s <thm-1-14>` is of a type that one encounters frequently throughout algebra. It has two parts.

  #. Some set :math:`Y` is shown to be a subuniverse of 𝔸 that contains :math:`X`.

  #. Every subuniverse containing :math:`X` is shown to contain :math:`Y` as well.

  #. One concludes that :math:`Y = \Sg^𝔸 (X)`.

-----------------------------------------------

.. index:: ! Taylor term, ! term

.. _terms:

Terms
-----

Fix a signature :math:`σ = (F, ρ)`, let :math:`X` be a set of **variables** and assume :math:`X ∩ F = ∅`.

Let :math:`F_0` denote the set of nullary operation symbols.

By a **word** on :math:`X ∪ F` we mean a nonempty, finite sequence of members of :math:`X ∪ F`, and we will denote the concatenation of such sequences by simple juxtaposition.

We *define* by induction on :math:`n` the set :math:`T_n` of words on :math:`X ∪ F` as follows:

.. math::      T_0 &= X ∪ F_0;\\
           T_{n+1} &= T_n ∪ \{ f\, s ∣ f ∈  F, \ s: ρf → T_n \},

and we *define* the collection of **terms of signature** σ **over** :math:`X` by :math:`T_σ(X) = ⋃_{n < ω}T_n`.

The definition of :math:`T_σ (X)` is recursive, indicating that

  *the terms of a given signature can be implemented (in Lean, for example) as an inductive type*.

We will confirm this in :numref:`Chapter %s <inductively-defined-types>`, but before doing so we impose an algebraic structure on :math:`T_σ (X)`, and then state and prove some basic but important facts about this algebra. These will be formalized in :numref:`Chapter %s <inductively-defined-types>`, giving us a chance to show off inductively defined types in Lean and to compare informal language proofs to their formal Lean counterparts.

If :math:`w` is a term, then the **height** of :math:`w` is denoted by :math:`|w|` and defined to be the least :math:`n` such that :math:`w ∈ T_n`. The height is a useful index for recursion and induction.

Notice that :math:`T_σ (X)` is nonempty iff either :math:`X` or :math:`F_0` is nonempty. As long as :math:`T_σ (X)` is nonempty, we can impose upon it an algebraic structure, as follows:

For every basic operation symbol :math:`f ∈ F` let :math:`f^{𝕋_σ (X)}` be the operation on :math:`T_σ (X)` that maps each tuple :math:`s: ρ f → T_σ (X)` to the formal term :math:`f\,s`.

We define :math:`𝕋_σ (X)` to be the algebra with universe :math:`T_σ (X)` and with basic operations :math:`\{f^{𝕋_σ (X)} | f ∈ F\}`. [4]_

Here are some important facts about this algebra.

.. _obs-six:

.. proof:observation::

   Let :math:`σ = (F, ρ)` be a signature.
 
   #. :math:`𝕋_σ(X)` is generated by :math:`X`.
 
   #. For every algebra :math:`𝔸 = ⟨A, F^𝔸⟩` of type :math:`σ` and every function :math:`g: X → A` there is a unique homomorphism :math:`h: 𝕋_σ(X) → 𝔸` such that :math:`h|_X = g`.
 
   .. container:: toggle
    
      .. container:: header
     
         *Proof*.
     
      The definition of :math:`𝕋_σ(X)` exactly parallels the construction in :numref:`Theorem %s <thm-1-14>`. That accounts for the first assertion.
     
      For the second assertion, define :math:`h\,t` by induction on the :term:`height` of :math:`|t|`.
     
      Suppose :math:`|t| = 0`.  Then :math:`t ∈ X ∪ F_0`. If :math:`t ∈ X`, then define :math:`h\,t = g\,t`. If :math:`t ∈ F_0`, then let :math:`h\,t = t^𝔸`.
     
      For the inductive step, assume :math:`|t| = n + 1`. Then :math:`t = f\,s` for some :math:`f ∈ F` and :math:`s: ρ f → T_n`, where for each :math:`0 ≤ i< ρ f` the term :math:`s\, i` has height at most :math:`n`. We define :math:`h\,t = f^{𝔸}(h ∘ s) = f^{𝔸}(h\,s_1, \dots, h\,s_k)`.
     
      It is easy to see that, by its very definition, :math:`h` is a homomorphism that agrees with :math:`g` on :math:`X`.
      
      Finally, the uniqueness of :math:`h` follows from :numref:`Obs %s <obs-two>`. ☐

.. _thm-4-32:

.. _obs-seven:

.. proof:observation::

   Let :math:`𝔸 = ⟨A, F^𝔸⟩` and :math:`𝔹 = ⟨B, F^𝔹⟩` be algebras of signature :math:`σ = (F, ρ)`. Let :math:`X_ω := \{x_0, x_1, \dots\}` be a collection of variables and define :math:`X_n:=\{x_0, x_1, \dots, x_{n-1}\}`.
 
   #. If :math:`t ∈ T_σ (X_ω)` is an :math:`n`-ary term, if :math:`g: 𝔸 → 𝔹` is a homomorphism, and if :math:`a: n → A` is an :math:`n`-tuple over :math:`A`, then
    
      .. math:: g(t^{𝔸} a) = t^{𝔹}(g ∘ a).

      where, recall, :math:`t^𝔸 a = t^𝔸 (a_0, a_1, \dots, a_{n-1})` and :math:`(g ∘ a)(i) = g(a_i)`.

   #. If :math:`t ∈ T_σ (X_ω)` is an :math:`n`-ary term, if :math:`θ` is a congruence of 𝔸, and if :math:`a, a': n → A` are :math:`n`-tuples over :math:`A`, then
    
      .. math:: (a, a') ∈ θ \; ⟹  \; (t^𝔸\,a, t^𝔸\,a') ∈ θ.

   #. If :math:`Y` is a subset of :math:`A`, then

      .. math:: \Sg^{𝔸}(Y) = \{ t^𝔸 \, a ∣ t ∈ T_σ(X_n), a: ρ t → Y, n ∈ ℕ\}.

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      The first assertion is an easy induction on :math:`|t|`.
    
      The second assertion follows from the first by taking :math:`⟨B, F^𝔹⟩ = ⟨A, F^𝔸⟩/θ = ⟨A/θ, F^{𝔸/θ}⟩` and :math:`g` the canonical homomorphism.
    
      To prove the third assertion, again by induction on the height of :math:`t`, every subalgebra must be closed under the action of :math:`t^𝔸`.
    
      Thus the right-hand side is contained in the left. On the other hand, the right-hand side is clearly a subalgebra containing the elements of :math:`Y` (take :math:`t = x_1`) from which the reverse inclusion follows. ☐

**Formalization**. Our formal implementation (in `Lean`_) of the concepts and results of this section is described in :numref:`terms-in-lean`, and is included in the `term.lean`_ and `birkhoff.lean`_ files of the `lean-ualib`_ library.

.. todo:: complete this section (include material on free algebras)

-----------------------------------------------

.. index:: ! clone
.. index:: ! clone of projections
.. index:: ! clone of polynomial operations
.. index:: ! clone of term operations

.. _clones:

Clones
------

An **operational clone** (or just **clone**) on a nonempty set :math:`A` is a set of operations on :math:`A` that contains the projection operations and is closed under general composition.

Let :math:`𝖢 A` denote the collection of all clones on :math:`A`.

The smallest clone on :math:`A` is the **clone of projections**, which we denote and define as follows:

.. math:: \Proj  A = ⋃_{i < n < ω}  \{π^n_i : ∀ a ∈ A^n,\ π^n_i\, a = a(i)\}.

Let us set down some conventions that will help simplify notation.  Recall, the natural number :math:`k< ω` may be constructed as (or at least identified with) the set :math:`\{0,1,\dots, k-1\}`, and this will be helpful here.

For each :math:`k< ω`, denote and define the tuple :math:`\pi^k: k → ((k → A) → A)` of all :math:`k`-ary projections on :math:`A` as follows: for each :math:`0≤ i < k`,  :math:`π^k(i)` is the :math:`i`-th :math:`k`-ary projection operation that takes each :math:`k`-tuple :math:`a: k → A` to its entry at index :math:`i`:

.. math:: π^k (i) a = a(i).

Observe that if :math:`f: (k → A) → A` is a :math:`k`-ary operation on :math:`A`, then 

The **clone of term operations** of a σ-algebra 𝔸 is the smallest clone on :math:`A` containing the basic operations of 𝔸; this is
denoted and defined by

.. math:: \Clo (F^𝔸) = ⋂ \{ U ∈ 𝖢 A ∣ F^𝔸 ⊆ U\}.

The set of :math:`n`-ary members of :math:`\Clo (F^𝔸)` is sometimes denoted by :math:`\Clo _n (F^𝔸)` (despite the fact that the latter is clearly not a clone).

The **clone of polynomial operations** (or **polynomial clone**) of a σ-algebra 𝔸 is denoted by :math:`\Pol (F^𝔸)` and is defined to be the clone generated by the collection consisting of the basic operations (i.e., :math:`F^𝔸`) of 𝔸 along with the **constants** on :math:`A`. [2]_

The set of :math:`n`-ary members of :math:`\Pol (F^𝔸)` is sometimes denoted by :math:`\Pol _n (F^𝔸)`. 

.. .. [9] Lean's built-in sigma type is defined as follows: :math:`structure sigma {α : Type u} (β : α → Type v) := mk :: (fst : α) (snd : β fst)`

The clone :math:`\Clo (F^𝔸)` is associated with the algebra :math:`𝔸` only insofar as the former is constructed out of the basic operations of 𝔸 and the set :math:`A` on which those operations are defined.  However, all that is required when defining a clone is a set :math:`A` and some collection :math:`F` of operations defined on :math:`A`; from only these ingredients, we can construct the clone generated by :math:`F`, which we denote by :math:`\Clo (F)`.

Thus

  *the clone of terms operations can be implemented (e.g., in Lean) as an inductive type*.
  
The following theorem makes this more precise (cf. Theorem 4.32 of :cite:`Bergman:2012`). (See also :numref:`Chapter %s <inductively-defined-types>`, where we formalize this in Lean.)

.. We seek a "bottom-up," inductive description of the members of :math:`\Clo (F)`.  By thinking of the clone itself as a kind of algebra, a description analogous to :numref:`Obs %s <thm-1-14>` ought to be possible.  In fact, since function composition is associative, a slightly slicker formulation is available.

..  Theorem  4.3. of Bergman [1].

.. _obs-five:

.. proof:observation::

   Let :math:`A` be a set and let :math:`F ⊆ \Op (A):= ⋃_{n<ω} A^{A^n}` be a collection of operations on :math:`A`.
   
   Define :math:`F_0 := \Proj (A)` (the set of projections on :math:`A`) and for all :math:`0 ≤ n < ω` let
 
   .. math:: F_{n+1} := F_n ∪ \{ f g \mid f ∈ F, g : ρf → (F_n ∩ (ρg → A)) \}.
 
   Then :math:`\Clo (F) = ⋃_n F_n`.
 
   .. container:: toggle
    
      .. container:: header
  
         *Proof*.

      Let :math:`F̄ = ⋃_n F_n`. It is easy to argue by induction that every :math:`F_n` is a subset of :math:`\Clo (F)`. Thus, :math:`F ⊆ \Clo (F)`.
    
      For the converse, we must show that :math:`F̄` is a clone that contains :math:`F`.
    
      Obviously :math:`F̄` contains the projection operations, :math:`F_0 ⊆ F̄`.

      For every :math:`f ∈ F`, we have :math:`f π^k ∈ F_1 ⊆ F̄`, where :math:`k:= ρ f`.
 
      We are reduced to showing that :math:`F̄` is closed under generalized composition. This follows from the following claim.
 
      **Claim**. If :math:`f ∈ F_n` and :math:`g_0, \dots, g_{ρ f-1} ∈ F_m` are all :math:`k`-ary, then :math:`f g \in F_{n+m}`, where we have defined :math:`g: ρ f → (k → A) → A` to be the tuple given by :math:`g\,i = g_i` for each :math:`0 ≤ i < ρ f`.

      Note that the types match up; indeed, for each :math:`a: (k → A) → A`, we have

      .. math:: f (g ∘ a) = f(g_0(a_0, \dots, a_{k-1}), 
 
      We prove the claim by induction on :math:`n`.
      
      If :math:`n = 0` then :math:`f` is a projection, so :math:`f g = g_i ∈ F_{0+m}` for some :math:`0≤ i < ρ f`.

      Assume the claim holds for :math:`n` and that :math:`f ∈ F_{n+1} - F_n`.
      
      From the definition, there is a :math:`t`-ary operation :math:`f_i ∈ F` and a :math:`t`-tuple :math:`h = (h_0, \dots, h_{t-1}) ∈ t → F_n`, such that :math:`f = f_i h`. (Note that :math:`h: t → (ρ f → A) → A` is given by :math:`h(j) = h_j`, and that the arity of each :math:`h_i` must be equal to that of :math:`f`, namely :math:`ρ f`.)
      
      By the induction hypothesis, for each :math:`i ≤ k`, :math:`h_i' = h_i g \in F_{n+m}` (where, as above, :math:`g = (g_0, \dots, g_{k-1})`).
      
      Applying the definition, :math:`f_1 h' ∈ F_{n+m+1} = F_{(n+1)+m}`. Since 
      
      .. math:: f_1 h' = f_1 ∘ (h_1 g, \dots, h_t g) = f g,

      the claim is proved. □

**Formalization**. Our formal implementation (in `Lean`_) of the concepts and results of this section is described in :numref:`clones-in-lean`, and is included in the `clone.lean`_ and `birkhoff.lean`_ files of the `lean-ualib`_ library.

------------------------

Special terms
-------------
.. .. _thm-4-3:

.. .. proof:theorem::

..    Let :math:`X` be a set and :math:`σ = (F, ρ)` a signature. Define

..    .. math:: F_0 &= X;\\
..          F_{n+1} &= F_n ∪ \{ f g ∣ f ∈ F, g : ρf → (F_n ∩ (ρ g → X)) \}, \quad n < ω.

..    Then :math:`\Clo ^X(F) = ⋃_n F_n`.


.. For a nonempty set :math:`A`, we let :math:`𝖮_A` denote the set of all finitary operations on :math:`A`. That is, :math:`𝖮_A = ⋃_{n∈ ℕ} A^{A^n}` on :math:`A` is a subset of :math:`𝖮_A` that contains all projection operations and is closed under the (partial) operation of :ref:`general composition <general-composition>`.

.. If :math:`𝔸 = ⟨ A, F^𝔸 ⟩` denotes the algebra with universe :math:`A` and set of basic operations :math:`F`, then :math:`\Clo  (𝔸)` denotes the clone generated by :math:`F`, which is also known as the **clone of term operations** of :math:`𝔸`.

.. proof:example::

   We will discuss varieties in more detail later, but for now a variety is a collection of algebras of the same signature that is defined by a certain set of identities. [3]_ 
   
   In 1977, Walter Taylor showed in :cite:`Taylor:1977` that a variety :math:`𝕍` satisfies some nontrivial idempotent Malcev condition if and only if it satisfies one of the following form: for some :math:`n`, 𝕍 has an idempotent :math:`n`-ary term  :math:`t` such that for each :math:`i < n` there is an identity of the form 

   .. math:: t(∗, \cdots, ∗, x, ∗, \cdots, ∗) ≈ t(∗, \cdots, ∗, y, ∗, \cdots, ∗)

   true in 𝕍 where distinct variables :math:`x` and :math:`y` appear in the :math:`i`-th position on each side of the identity. Such a term :math:`t` now goes by the name **Taylor term**.

------------------------

.. rubric:: Footnotes

.. [2]
   By "the constants on :math:`A`" we mean the **constant operations**; i.e., functions :math:`f: A → A` such that :math:`∀ a ∈ A, f(a) = c`, for some :math:`c ∈ A`.

.. [3]
   We will also have much to say about Malcev conditions, but for now we ask the reader to trust us when we say that such conditions play an important role in many deep results in universal algebra.

.. [4]
   The construction of :math:`𝕋_ρ (X)` may seem to be making something out of nothing, but it plays a crucial role in the theory.

.. include:: hyperlink_references.rst
