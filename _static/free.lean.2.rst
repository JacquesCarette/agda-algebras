.. code-block:: lean

    import data.set  -- the set.lean file from mathlib
    definition op (β α) := (β → α) → α
    definition π {β α} (i) : op β α := λ a, a i
    structure signature := mk :: (F : Type*) (ρ : F → Type*)
    definition algebra_on (σ : signature) (α : Type*) := Π (f : σ.F), op (σ.ρ f) α   
    definition algebra (σ : signature) := sigma (algebra_on σ)
    instance alg_carrier (σ : signature) : has_coe_to_sort (algebra σ) := ⟨_, sigma.fst⟩
    instance alg_operations (σ : signature) : has_coe_to_fun (algebra σ) := ⟨_, sigma.snd⟩
 
    namespace subuniverse
      section sub
        parameters {σ : signature} {α : Type*} {I : Type*}
        def F := σ.F
        def ρ := σ.ρ 
        def Sub {𝔸: algebra σ} (B₀: set 𝔸): Prop:= ∀ (f: F) (a: ρ f → 𝔸), (∀ x, a x ∈ B₀) → (𝔸 f a) ∈ B₀
        def is_subalgebra (𝔸: algebra σ) (B₀: set 𝔸) (𝔹: algebra_on σ B₀): Prop:= ∀ f b, ↑(𝔹 f b) = 𝔸 f ↑b
        def Sg (A : algebra_on σ α) (X : set α) : set α := ⋂₀ {U | Sub A U ∧ X ⊆ U}
        theorem Inter.intro {𝔸: algebra σ} {s: I → set 𝔸}: ∀ (x: 𝔸), (∀ i, x ∈ s i) → (x ∈ ⋂ i, s i) :=
        assume x h t ⟨j, (eq: t = s j)⟩, eq.symm ▸ h j
        theorem Inter.elim {𝔸: algebra σ} {x: 𝔸} {C: I → set 𝔸}: (x ∈ ⋂ i, C i) →  (∀ i, x ∈ C i):= assume h: x ∈ ⋂ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {𝔸: algebra σ} (C: I → set 𝔸): (∀ i, Sub (C i)) → Sub (⋂i, C i):= 
        assume h: (∀ i, Sub (C i)), show Sub (⋂i, C i), from
        assume (f: F) (a: ρ f → 𝔸) (h₁: ∀ x, a x ∈ ⋂i, C i),
        show 𝔸 f a ∈ ⋂i, C i, from Inter.intro (𝔸 f a) (λ j, (h j) f a (λ x, Inter.elim (h₁ x) j))
        lemma subset_X_of_SgX {𝔸: algebra σ} (X : set 𝔸): X ⊆ Sg X:=                                   -- Fact 1.
        assume x (h: x ∈ X), 
          show x ∈ ⋂₀ {U | Sub U ∧ X ⊆ U}, from 
            assume W (h₁: W ∈ {U | Sub U ∧ X ⊆ U}),  
            show x ∈ W, from 
              have h₂: Sub W ∧ X ⊆ W, from h₁, 
            h₂.right h
        lemma sInter_mem {𝔸: algebra σ} {X: set 𝔸}:                                                     -- Fact 2.
        ∀ R, Sub R → X ⊆ R → (Sg X ⊆ R) := 
        assume R (h₁: Sub R) (h₂: X ⊆ R),
        show Sg X ⊆ R, from 
          assume x (h: x ∈ Sg X), show x ∈ R, from 
            h R (and.intro h₁ h₂)
        lemma sInter_mem' {𝔸: algebra σ} {X: set 𝔸}:                               -- An alternative proof of Fact 2.
        ∀ R, Sub R ∧ X ⊆ R → (Sg X ⊆ R):= 
        assume R (hc : Sub R ∧ X ⊆ R),
        have h₁: Sub R, from hc.left,
        have h₂: X ⊆ R, from hc.right,
        show Sg X ⊆ R, from 
          assume x (h: x ∈ Sg X), show x ∈ R, from 
            h R (and.intro h₁ h₂)
        lemma sInter_mem'' {𝔸: algebra σ} {X: set 𝔸}:                          -- Yet another derivation of Fact 2.
        ∀ x, x ∈ Sg X → ∀ R, Sub R → X ⊆ R → x ∈ R:= 
        assume x (h₁: x ∈ Sg X) (R: set 𝔸) (h₂: Sub R) (h₃: X ⊆ R), 
        show x ∈ R, from h₁ R (and.intro h₂ h₃)
        lemma SgX_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Sg X):=               -- Sgᴬ X is a subuniverse of A
        assume (f: F) (a: ρ f → 𝔸) (h₀: ∀ i, a i ∈ Sg X), 
        show 𝔸 f a ∈ Sg X, from 
          assume W (h: Sub W ∧ X ⊆ W), show 𝔸 f a ∈ W, from 
            have h₁: Sg X ⊆ W, from 
              sInter_mem' W h,
            have h': ∀ i, a i ∈ W, from assume i, h₁ (h₀ i),
            (h.left f a h')
        inductive Y {𝔸: algebra σ} (X: set 𝔸): set 𝔸
        | var (x : 𝔸) : x ∈ X → Y x
        | app (f : F) (a : ρ f → 𝔸) : (∀ i, Y (a i)) → Y (𝔸 f a)

        -- Y X is a subuniverse
        lemma Y_is_Sub {𝔸: algebra σ} (X: set 𝔸): Sub (Y X):= 
        assume f a (h: ∀ i, Y X (a i)), show Y X (𝔸 f a), from 
        Y.app f a h 
    
        -- Y X is the subuniverse generated by X
        theorem sg_inductive {𝔸: algebra σ} (X: set 𝔸): Sg X = Y X :=
        have h₀: X ⊆ Y X, from assume x (h: x ∈ X), 
          show x  ∈ Y X, from Y.var x h,
        have h₁: Sub (Y X), from assume f a (h : ∀ x, Y X (a x)), 
          show Y X (𝔸 f a), from Y.app f a h,
        have inc_l: Sg X ⊆ Y X, from sInter_mem (Y X) h₁ h₀, 
        have inc_r: Y X ⊆ Sg X, from assume a (h: a ∈ Y X), 
          show a ∈ Sg X, from
            have h₂: a ∈ Y X → a ∈ Sg X, from 
              Y.rec
              ( --base: a = x ∈ X
                assume x (hr₁: x ∈ X), 
                show x ∈ Sg X, from subset_X_of_SgX X hr₁ 
              )
              ( --inductive: a = A f b for some b with ∀ i, b i ∈ Sg X
                assume f b (hr₂: ∀ i, b i ∈ Y X) (hr₃: ∀ i, b i ∈ Sg X),
                show 𝔸 f b ∈ Sg X, from SgX_is_Sub X f b hr₃ 
              ),
            h₂ h,
        set.subset.antisymm inc_l inc_r

    definition index_of_sub_above_X {𝔸: algebra σ} 
    (X: set 𝔸) (C: I → set 𝔸): I → Prop:= 
    λ i, Sub (C i) ∧ X ⊆ (C i) 

    lemma sInter_mem_of_mem {𝔸: algebra σ} {X: set 𝔸} (x: 𝔸): 
    x ∈ Sg X ↔ ∀ {R: set 𝔸}, Sub R → X ⊆ R → x ∈ R:= 
    iff.intro
      (assume (h: x ∈ Sg X) (R: set 𝔸) (h₁: Sub R) (h₂: X ⊆ R), 
        show x ∈ R, from h R (and.intro h₁ h₂))
      (assume (h: ∀ {R: set 𝔸}, Sub R → X ⊆ R → x ∈ R), 
        show x ∈ Sg X, from h (SgX_is_Sub X) (subset_X_of_SgX X))

    -- Y is the smallest Sub containing X
    lemma Y_is_min_Sub {𝔸: algebra σ} (U X: set 𝔸): 
    Sub U → X ⊆ U → Y X ⊆ U:=
    assume (h₁: Sub U) (h₂ : X ⊆ U),
    assume (y: 𝔸)  (p: Y X y), show U y, from 
      have q: Y X y → Y X y → U y, from 
        Y.rec

        --base step: y = x ∈ X
        ( assume y (h: X y) (h': Y X y), h₂ h )

        --induction step: y = A f a for some a with ∀ i, a i ∈ Y
        ( assume f a,
          assume h₃: ∀ i, Y X (a i), 
          assume h₄: ∀ i, Y X (a i) → U (a i),
          assume h₅: Y X (𝔸 f a),
          have h₆: ∀ i, a i ∈ U, from 
            assume i, h₄ i (h₃ i), show U (𝔸 f a), from h₁ f a h₆ ),
      q p p

      end sub
    end subuniverse

    section terms

      parameters {σ : signature} (X :Type*)
      local notation `F` := σ.F
      local notation `ρ` := σ.ρ 
    
      inductive term
      | var         : X → term
      | app (f : F) : (ρ f → term) → term
    
      def Term : algebra σ := ⟨term, term.app⟩
    
    end terms

    section
    -- BEGIN
      open term
      parameters {σ : signature} (X :Type*) {f : σ.F} 
      definition F := σ.F
      definition ρ := σ.ρ
      definition 𝕋 := @Term σ
      definition 𝕏 := @var σ X
    -- END
      
      -- To prove that the free algebra is absolutely free, we show that
      -- the lift of an arbitrary function h : X → A is a homomorphism
      -- and that it is the unique homomorphism extending h.
    
      -- Definition of the lift of a function.
      -- Given an arbitrary map h : X → A, define a function on terms as follows:
      -- ``term`` has two constructors:
      --            var : X → term
      --            app (f : F) : (ρ f → term) → term
      -- We must say what ``lift_of h`` does in each case.
      -- if the given term is ``var x`` then ``h (var x) = h x``
      -- if the given term is ``app f ts``, then ``h (app f ts) = (A f) lift_of h``
      -- ts ↦ 
      definition lift_of {𝔸: algebra σ} (h: X → 𝔸): 𝕋(X) → 𝔸
      | (var x):= h x
      | (app f ts):= 𝔸 f (λ (i : ρ f), lift_of (ts i))
    
      open homomorphism
    
      -- The lift of a function is a homomorphism.
      lemma lift_is_hom {𝔸: algebra σ} (h : X → 𝔸): 
      homomorphic (lift_of h) :=
      λ f as, show lift_of h (app f as) = 𝔸 f (lift_of h ∘ as), from rfl
    
      -- The lift of a function is unique among homomorphic lifts.
      lemma lift_is_unique {𝔸: algebra σ}: ∀ {g h : 𝕋(X) → 𝔸},
      homomorphic g → homomorphic h → g ∘ 𝕏 = h ∘ 𝕏 → g = h :=
      assume (g h: 𝕋(X) → 𝔸) 
             (h₁ : homomorphic g)
             (h₂ : homomorphic h)
             (h₃ : g ∘ 𝕏 = h ∘ 𝕏),
    
        show g = h, from 
    
          have h₀: ∀ t: 𝕋(X), g t = h t, from 
    
            assume t: 𝕋(X), 
            begin
              induction t with t f a ih₁ ,
              show g (𝕏 t) = h (𝕏 t),
              {apply congr_fun h₃ t},
    
              show g (app f a) = h (app f a),
              { have ih₂  : g ∘ a = h ∘ a, from funext ih₁,
                calc g (app f a) = 𝔸 f (g ∘ a) : h₁ f a
                             ... = 𝔸 f (h ∘ a) : congr_arg (𝔸 f) ih₂ 
                             ... = h (app f a) : (h₂ f a).symm }
            end,
          funext h₀ 
    end
