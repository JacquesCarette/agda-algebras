%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigplan')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigplan,screen]{acmart}
%\usepackage{amsmath,amscd,amssymb,amsthm}
%\usepackage{amsfonts}
%\usepackage{latexsym,enumerate,scalefnt,ifthen}
%\usepackage{mathtools}
%\usepackage{stmaryrd}

%% \usepackage[colorlinks=true,urlcolor=black,linkcolor=black,citecolor=black]{hyperref}
%% \usepackage{url}
%\usepackage{scalefnt}
%% \usepackage{tikz}
%% \usetikzlibrary{math} %needed tikz library
%% \usepackage{color}
%% \usepackage[margin=4cm]{geometry}
%% \usepackage{scrextend}
\usepackage{agda}
\usepackage{bbm}
\usepackage{unixode}
%\newcommand\mathscr[1]{\ensuremath{\mathcal{#1}}}
%% \usepackage{newunicodechar}
%% \newunicodechar{ùë®}{\ensuremath{\mathbf{A}}}
%% \usepackage{pdfcomment}
%% \usepackage{color}
%% \usepackage{todonotes}
%% \usepackage[yyyymmdd,hhmmss]{datetime}
%% \usepackage{background}
%% \backgroundsetup{
%%   position=current page.east,
%%   angle=-90,
%%   nodeanchor=east,
%%   vshift=-1cm,
%%   hshift=8cm,
%%   opacity=1,
%%   scale=1,
%%   contents={\textcolor{gray!80}{WORK IN PROGRESS.  DO NOT DISTRIBUTE. (compiled on \today\ at \currenttime)}}
%% }

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2020}
\acmYear{2020}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[CPP '21]{CPP 2021}{January, 2021}{online}
\acmBooktitle{}
\acmPrice{}
\acmISBN{XXX-X-XXXX-XXXX-X/XX/XX}

\usepackage[mathcal]{euscript}
%\usepackage{amsfonts}

\newcommand{\alg}[1]{\ensuremath{\mathbf{#1}}}  % algebraic structures
\newcommand{\var}[1]{\ensuremath{\mathscr{#1}}}  % algebraic structures

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{A Constructive, Machine-checked Proof\break of Birkhoff's Theorem}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{\protect{\href{https://williamdemeo.gitlab.io/}{William DeMeo}}}
\author{}
%% \author{William DeMeo}
%% \email{williamdemeo@gmail.com}
%% \affiliation{% \\
%%   \institution{\href{https://www.mff.cuni.cz/en/ka}{Department of Algebra}\\Charles University} %\\ Katedra Algebry, Univerzita Karlova\\
%%   \streetaddress{Sokolovska 83}
%%   \city{Prague}
%%   \state{Czech Republic} %186 00 Praha 8, 186 00 Praha 8, \v{C}esk\'{a} Republika}
%%   \postcode{186 00} % Prague 8, Czech Republic}
%% }
%% %\author{\href{https://hyeyoungshin.github.io/}{Hyeyoung Shin}}
%% \author{Hyeyoung Shin}
%% \email{hyeyoungshinw@gmail.com}
%% \affiliation{
%%   \institution{\href{https://prl-prg.github.io/}{Faculty of Information Technology}\\Czech Technical University}
%%   \streetaddress{Th√°kurova 9}
%%   \city{Prague} % 6
%%   \state{Czech Republic}
%%   \postcode{160 00} 
%% }

%% %\author{\href{http://www.cs.cmu.edu/~ssomayya/}{Siva Somayyajula}}
%% \author{Siva Somayyajula}
%% \email{ssomayya@andrew.cmu.edu}
%% \affiliation{%
%%   \institution{\href{https://www.cs.cmu.edu/}{Department of Computer Science}\\
%%   Carnegie Mellon University}
%%   \streetaddress{}
%%   \city{Pittsburgh}
%%   \state{PA}
%%   \postcode{}
%% }
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%% \renewcommand{\shortauthors}{DeMeo, Shin and Somayyajula}
%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
We introduce the Agda Universal Algebra Library (agda-ualib), a project for the formalization of universal algebra in the Agda functional programming language. The primary aim of the project is to develop a usable library that makes Agda more accessible as a tool for producing new mathematics and for formally verifying "known" results.  The authors have implemented a collection of fundamental definitions and theorems from universal algebra in Agda, exhibiting the power of inductive and dependent types for this purpose.  To demonstrate the effectiveness of the library, we describe a major milestone of the project---a formal proof of Birkhoff's HSP Theorem.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10003796</concept_id>
       <concept_desc>Theory of computation~Constructive mathematics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10002990</concept_id>
       <concept_desc>Theory of computation~Logic and verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10010147.10010148.10010164</concept_id>
       <concept_desc>Computing methodologies~Representation of mathematical objects</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010125.10010130</concept_id>
       <concept_desc>Theory of computation~Type structures</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Constructive mathematics}
\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Logic and verification}
\ccsdesc[300]{Computing methodologies~Representation of mathematical objects}
\ccsdesc[300]{Theory of computation~Type structures}


\keywords{universal algebra, formalization of mathematics, equational logic, type theory}

\maketitle

\section{Introduction}\label{introduction}
To support formalization in type theory of research level mathematics in universal algebra and related fields, the authors are contributing to the development of the \href{https://ualib.org}{Agda Universal Algebra Library} (\href{https://ualib.org}{agda-ualib}), a software library containing formal statements and proofs of the core definitions and results of universal algebra.

The library and is written in \href{https://wiki.portal.chalmers.se/agda/pmwiki.php}{Agda}~\cite{Norell:2009}, a programming language and proof assistant based on Martin-L\"of Type Theory that not only supports dependent and inductive types, but also provides powerful \emph{proof tactics} for proving things about the objects that inhabit these types.

\subsection{Vision and Goals}\label{vision-and-goals}
The idea for the the Agda Universal Algebra Library originated with the observation that, on the one hand a number of basic and important constructs in universal algebra can be defined recursively, and theorems about them proved inductively, while on the other hand the \emph{types}---in particular, dependent and inductive types---make possible precise formal representations of recursively defined objects as well as constructive proofs of their properties, proofs that are computable and composable. These observations suggest that there is much to gain from implementing universal algebra in a language that supports dependent and inductive types.

\subsubsection{Primary Goals}\label{primary-goals}
The first goal of the \href{https://ualib.org}{agda-ualib} project is to demonstrate that it is possible to express the foundations of universal algebra in type theory and to formalize (and formally verify) the foundations in the
Agda programming language. We formalize a substantial portion of the edifice on which our own mathematical research depends, and demonstrate that our research can also be expressed in type theory and formally implemented in such a way that we and other working mathematicians can understand and verify the results. The library also serves to educate our peers and encourage them to formally verify their own mathematics research.

Our field is deep and broad, so codifying all of its foundations may seem like a daunting task and possibly risky investment of time and resources. However, we believe the subject is well served by a new, modern, \emph{constructive} presentation of its foundations. Our new presentation expresses the foundations of universal algebra in the language of type theory, and uses the Agda proof assistant to codify and formally verify all aspects of the presentation.

\subsubsection{Secondary Goals}\label{secondary-goals}
We wish to emphasize that our ultimate objective is not merely to translate existing results into a more modern and formal language. Indeed, one important goal is to develop a system that is useful for conducting research in mathematics, and that is how we intend to use our library once we have achieved our immediate objective of implementing
the basic foundational core of universal algebra in Agda.

To this end, our intermediate-term objectives include
\begin{itemize}
\item developing domain specific ``proof tactics'' to express the idioms of universal algebra,
\item incorporating automated proof search for universal algebra, and
\item formalizing theorems emerging from our own mathematics research,
\item documenting the resulting software libraries so they are usable by other working mathematicians.
\end{itemize}

For our own mathematics research, our experience taught us very quickly that a proof assistant equipped with specialized libraries for universal algebra, as well as domain-specific tactics to automate proof idioms of our field, is extremely useful. Thus, a second goal of the agda-ualib project is to demonstrate the utility of such libraries and tactics for proving new theorems.

%% \subsection{Intended audience}\label{intended-audience}
%% This paper describes the Agda Universal Algebra Library (\href{https://ualib.org}{agda-ualib}) in enough detail so that working mathematicians (and possibly some normal people, too) might be able to learn enough about Agda and its libraries to put them to use when creating, formalizing, and verifying new mathematics.

%% While there are no strict prerequisites, we expect anyone with an interest in this work will have been motivated by prior exposure to universal algebra, as presented in, say, \cite{Bergman:2012} or \cite{McKenzie:1987}, and to a lesser extent category theory, as presented in \cite{Riehl:2017}.

%% Some prior exposure to type theory and Agda would be helpful, but even without this background one should be able to gain something from reading article, by referring to the appendix and glossary, while simultaneously consulting one or more of the references mentioned in the references to fill in gaps as needed.

%% Finally, readers of this paper will benefit most from actively experimenting with Agda and the agda-ualib.

%% \subsection{Installing the library}\label{installing-the-library}
%% The main repository for the \href{https://ualib.org}{agda-ualib} is \url{https://gitlab.com/ualib/ualib.gitlab.io}.

%% There are installation instructions in the main README.md file in that repository, but really all one needs is a working Agda installation and a clone of the \href{https://ualib.org}{agda-ualib} repository.


%% \section{Acknowledgments}\label{acknowledgments}
%% Besides the main authors and developers of \href{https://ualib.org}{agda-ualib}, a number of other people have contributed to the project in one way or another.

%% Special thanks go to Clifford Bergman, Venanzio Capretta, Andrej Bauer, Mikl√≥s Mar√≥ti, and Ralph Freese, for many helpful discussions, as well as the invaluable instruction, advice, and encouragement that they continue to lend to this project, often without even knowing it.

%% The first author would also like to thank his postdoctoral advisors and their institutions for supporting work on this project. These include Peter Mayr and University of Colorado in Boulder (Aug 2017--May 2019), Ralph Freese and the University of Hawaii in Honolulu (Aug 2016--May 2017), and Cliff Bergman and Iowa State University in Ames (Aug 2014--May 2016).

%% \subsubsection{Attributions and citations}\label{attributions-and-citations}
%% Regarding the mathematical results that are implemented in the \href{https://ualib.org}{agda-ualib} library, as well as the presentation and informal statements of these results in the documentation, The Authors makes no claims to originality.

%% Regarding the Agda source code in the \href{https://ualib.org}{agda-ualib} library, this is mainly due to The Authors.

We have benefited enormously from the outstanding lecture notes on \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes}{Univalent Foundations and Homotopy Type Theory} and the \href{https://github.com/martinescardo/TypeTopology}{Type Topology} Agda Library, both by \href{https://www.cs.bham.ac.uk/~mhe}{Martin H√∂tzel Escardo}.

%% The first author is greatly indebted to Martin for teaching him about type theory in Agda at the \href{http://events.cs.bham.ac.uk/mgs2019/}{Midlands Graduate School in the Foundations of Computing Science} in Birmingham in 2019.

%% The development of the \href{https://ualib.org}{agda-ualib} and its documentation is informed by and benefits from the references listed in the references section below.

%% \subsection{References}\label{references}
%% The following Agda documentation and tutorials are excellent. They have been quite helpful to The Author of \href{https://ualib.org}{agda-ualib}, and have informed the development of the latter and its documentation.

%% \begin{itemize}
%% \tightlist
%% \item Altenkirk, \href{}{Computer Aided Formal Reasoning}
%% \item Bove and Dybjer, \href{}{Dependent Types at Work}
%% \item Escardo, \href{}{Introduction to Univalent Foundations of Mathematics with Agda}
%% \item Gunther, Gadea, Pagano, \href{}{Formalization of Universal Algebra in Agda}
%% \item J√°nos, \href{}{Agda Tutorial}
%% \item Norell and Chapman, \href{}{Dependently Typed Programming in Agda}
%% \item Wadler, \href{}{Programming Language Foundations in Agda}
%% \end{itemize}

%% Finally, the official \href{}{Agda Wiki}, \href{}{Agda User's Manual}, \href{}{Agda Language Reference}, and the (open source) \href{}{Agda Standard Library} source code are also quite useful.


\section{Algebras}\label{algebras}
In this chapter we use the informal language of universal algebra to present foundational definitions and theorems about subalgebras, terms, and clones. In Section XX we show how the definitions and results presented in this section can be formalized (or ``implemented'') in type theory using Agda.

The idea is to demonstrate the power and utility of implementing our mathematical are of expertise in a formal language that supports dependent and inductive types, which are essential for expressing and working with infinite objects in a constructive and computable way, and for proving properties of these objects.

One goal of our project is to provide, as a ``proof of concept'' a formal implementation of a deep result in universal algebra. As the focus of this goal, we have chosen what was among the first major results of the theory of universal algebras---namely, Garrett Birkhoff's celebrated HSP Theorem~\cite{Birkhoff:1935}.

A nice (informal) proof of the HSP Theorem appears on pages 106 and 107 of Cliff Bergman's book~\cite{Bergman:2012}. Naturally, the proof relies on many defeinitions and results developed in earlier chapters of the book. Nonetheless, Professor Bergman's path to a proof of the HSP theorem is the most straightforward and efficient one we know, and we will follow his presentation quite closely.

On the other hand, in order to get as directly as possible to a formal proof of the HSP Theorem, we will extract all the ingredients we need from~\cite{Bergman:2012}, and present them as a list of results at the end of this section, and then later, in Section XX, we will formalize each of these results in Agda.

Whenever we quote or paraphrase a result from~\cite{Bergman:2012}, we will include a citation that indicates where the corresponding result is found in the book.

\subsection{Operations}\label{operations}
The symbols ‚Ñï, œâ, and \texttt{nat} are used interchangeably; they all denote the set of natural numbers. If ùëö is a natural number, we write ùëö : ‚Ñï and say that ùëö \emph{has type} ‚Ñï.\footnote{Viewing ùëö : ‚Ñï as roughly equivalent to ùëö ‚àà ‚Ñï is not totally unreasonable at this point.} We typically denote and define natural numbers by ùëö := \{0, 1, \ldots, ùëö-1\}, and we sometimes formally identify a function with its graph when convenient. For example, the function ùëé : ùëö ‚Üí ùê¥ may be viewed as the tuple \((ùëé\,0, ùëé\,1, ‚Ä¶, ùëé\,(ùëö-1)) : ùê¥^m\).
%% If ‚Ñé : ùê¥ ‚Üí ùê¥ and ùëé : ùëö ‚Üí ùê¥ are functions, then ‚Ñé ‚àò ùëé : ùëö ‚Üí ùê¥ denotes the composition of ‚Ñé with ùëé; this is the function that maps each ùëñ \textless{} ùëö to the element (‚Ñé ‚àò ùëé)(ùëñ) = ‚Ñé(ùëé ùëñ) of ùê¥. We may formally identify the function ‚Ñé ‚àò ùëé : ùëö ‚Üí ùê¥ with its graph, which of course is the ùëö-tuple, (‚Ñé(ùëé 0), ‚Ñé(ùëé 1), ‚Ä¶, ‚Ñé(ùëé (ùëö-1))).

If ùê¥ is a nonempty set and ùëõ ‚àà ‚Ñï, then an ùëõ-\textbf{ary operation} on ùê¥ is a function ùëì : \ensuremath{ùê¥^n} ‚Üí ùê¥ which (for \(ùëõ > 0\)) maps each ùëõ-tuple \((ùëé‚ÇÄ, ùëé‚ÇÅ, ‚Ä¶, ùëé_{n-1})\) in \ensuremath{ùê¥^n} to a particular element \(ùëì(ùëé‚ÇÄ, ùëé‚ÇÅ, ‚Ä¶, ùëé_{n-1})\) in ùê¥. If \(ùëõ = 0\), then ùëì : () ‚Üí ùê¥ may be viewed as a function that takes no arguments and returns an element of ùê¥, in which case ùëì is merely notation for a particular element of ùê¥, denoted ùëì : ùê¥.
An operation is called \textbf{nullary} (or constant) if its arity is zero. \textbf{Unary}, \textbf{binary}, and \textbf{ternary} operations have arities 1, 2, and 3, respectively.
%% An operation gives rise to a special kind of (ùëõ+1)-ary relation, namely
%% \[Gf := \{(a_0, a_1, \dots, a_{n-1}, b) \in A^{n+1} ‚à£ b = f(a_0, a_1, \dots, a_{n-1})\},\]
%% which is sometimes called the \textbf{graph} of ùëì.

For two sets ùê¥, ùêµ, the collection of functions ùëì : ùêµ ‚Üí ùê¥ is denoted by \(A^B\). Taking ùêµ = \ensuremath{ùê¥^n}, we have \(A^{A^n}\), which is the collection of ùëõ-ary operations on ùê¥; as noted above, this can be represented by the function type (ùëõ ‚Üí ùê¥) ‚Üí ùê¥.

If we let Op(ùê¥) denote the collection of all finitary operations on ùê¥, then,
\[\mathrm{Op}(ùê¥) = ‚ãÉ_{n ‚àà ‚Ñï} A^{A^n} = ‚ãÉ_{n<œâ} ((ùëõ ‚Üí A) ‚Üí A).\]

If ùêπ ‚äÜ Op(ùê¥) is a set of operations on ùê¥, let us denote by \(ùêπ_n\) the ùëõ-ary operations in ùêπ. Clearly, \(F_n = F ‚à© A^{A^n}\).

Given an ùëõ-tuple \(a = (a_0, a_1, \dots, a_{n-1}) ‚àà A^n\), it helps to be able to refer to the set \(\{a_i : 0 ‚â§ i < n\}\) of elements that occur in the tuple without explicitly naming each element in this set. In fact, we already have notation for this, since an ùëõ-tuple is truly a function, with domain ùëõ := \{0, 1, ‚Ä¶, ùëõ-1\}, and image the set of
elements occuring in the tuple. Thus, im ùëé is \(\{ùëé‚ÇÄ, ùëé‚ÇÅ, ‚Ä¶, ùëé_{n-1}\}\), where each value is included in the set only once (no repeats). In particular, ‚à£im ùëé‚à£ is a convenient way to write the number of distinct elements that occur in the tuple ùëé. For example, if ùëé = (1, 1, 3), then im ùëé = \{1, 3\}, and ‚à£im ùëé‚à£ = 2.

\subsection{Signatures}\label{signatures}
Recall (from model theory) that a \textbf{signature} ùëÜ = (ùê∂, ùêπ, ùëÖ, œÅ) consists of three (possibly empty) sets ùê∂, ùêπ, and ùëÖ (the \emph{constant symbols}, \emph{function symbols}, and \emph{relation symbols}, respectively), along with a function œÅ : ùê∂ + ùêπ + ùëÖ ‚Üí ùëÅ that assigns an arity to each symbol. Often (but not always), ùëÅ = ‚Ñï.

As our focus here is universal algebra, we are more concerned with the restricted notion of an \textbf{algebraic signature}, by which we mean a pair ùëÜ = (ùêπ, œÅ) consisting of a collection ùêπ of \emph{operation symbols} and an arity function \(œÅ : ùêπ ‚Üí ùëÅ\) that maps each operation symbol to its arity; here, ùëÅ denotes the ``arity type'' (which is sometimes taken to be ‚Ñï). (Intuitively, the arity œÅ ùëì of an operation symbol ùëì ‚àà ùêπ may be thought of as the ``number of arguments'' that ùëì takes as ``input''.)

If ùê¥ is a set and ùëì is a (œÅ ùëì)-ary operation on ùê¥, we often indicate this by writing \(f : A^{œÅ f} ‚Üí A\). On the other hand, the arguments of such an operation form a (œÅ ùëì)-tuple, say, \((ùëé‚ÇÄ, ùëé‚ÇÅ, ‚Ä¶, a_{œÅf-1})\), which may be viewed as the graph of the function ùëé : œÅùëì ‚Üí ùê¥, where \(ùëé\, ùëñ = ùëé_i\).

(When the codomain of œÅ is ‚Ñï, we may view œÅùëì as the finite set \{0, 1, ‚Ä¶, œÅùëì - 1\}. Thus, by identifying the œÅùëì-th power \(A^{œÅf}\) with the type œÅùëì ‚Üí ùê¥ of functions from \{0, 1, ‚Ä¶, œÅùëì - 1\} to ùê¥, we identify the function type \(A^{œÅf} ‚Üí A\) with the function (or ``functional'') type (œÅùëì ‚Üí ùê¥) ‚Üí ùê¥.

Our formal implementation of the concept of signature in Agda is described in Section XX.

\subsection{Algebraic Structures}\label{algebraic-structures}
Our first goal is to develop a working vocabulary and formal library for classical (single-sorted, set-based) universal algebra. In this section we define the main objects of study.


An \textbf{algebraic structure} (or \textbf{algebra}) in the signature ùëÜ = (ùêπ, œÅ) is denoted by ùë® = \( ‚ü®A, F^{\mathbf A}‚ü©\) and consists of

\begin{itemize}
\item ùê¥ := a set (or type), called the \textbf{carrier} (or \textbf{universe}) of the algebra,
\item \(F^ùë® := \{ f^ùë® ‚à£ f ‚àà F, \ f^ùë® : (œÅùëì ‚Üí A) ‚Üí A \}\), a collection of \textbf{operations} on ùê¥, and
\item a collection of identities satisfied by elements of ùê¥ and the operations in \(F^ùë®\).
\end{itemize}

Note that to each operation symbol ùëì ‚àà ùêπ corresponds an operation \(f^ùë®\) on ùê¥ of arity œÅùëì; we call such \(f^ùë®\) an
\textbf{interpretation} of the symbol ùëì in the algebra ùë®. We call an algebra in the signature ùëÜ an ùëÜ-\textbf{algebra}. An algebra is called \textbf{finite} if it has a finite universe, and is called \textbf{trivial} if its universe is a singleton.
%% Given two algebras ùë® and ùë©, we say that ùë© is a \textbf{reduct} of ùë® if both algebras have the same universe and ùë© can be obtained from ùë® by removing some operations.

Our formal implementation of the concept of algebraic structure is described in Section XX.

\subsection{Subalgebras}\label{subalgebras}
This section introduces two important concepts in universal algebra, \textbf{subuniverse} and \textbf{subalgebra}. Suppose \(ùë® = ‚ü®A, F^ùë®‚ü©\) is an algebra. Recall, the (nonempty) set ùê¥ is called the \textbf{universe} of ùë®. We call a subset ùêµ ‚äÜ ùê¥ \textbf{closed under} (the operations in) \(F^ùë®\) if for each ùëì ‚àà ùêπ and all ùëè : œÅùëì ‚Üí ùêµ we have \(f^ùë® \, b ‚àà B\). If a subset ùêµ ‚äÜ ùê¥ is closed under \(F^ùë®\), then we call ùêµ a \textbf{subuniverse} of ùë®.

If ùêµ ‚â† ‚àÖ is a subuniverse of ùë®, and if we let \(F^ùë© = \{ f^ùë® ‚Üæ B : f ‚àà F \}\), then \(ùë© = ‚ü® B, F^ùë© ‚ü©\) is an algebra,
called a \textbf{subalgebra} of ùë®. Conversely, all subalgebras are of this form.

If ùë© is a subalgebra of ùë®, we denote this fact by ùë© ‚â§ ùë®. Similarly, we write ùêµ ‚â§ ùë® if ùêµ is a subuniverse of ùë® (relying on context and notation to disambiguate).

%% It helps to keep in mind the following consequence of the definitions:
%% \begin{quote}\emph{The empty set is a subuniverse of every algebra, but the universe of an algebra is never empty}.\end{quote} In other terms, if S(ùë®) denotes the collection of all subalgebras of ùë®, then \[\mathrm S(ùë®) = \{‚ü®B, F^ùë©‚ü© : ‚àÖ ‚â† B ‚â§ ùë®\}.\]

If ùí¶ is a class of ùëÜ-algebras, then the class of all subalgebras of algebras in ùí¶ is denoted by S(ùí¶).

It is obvious that the intersection of subuniverses is again a subuniverse. Nevertheless, we will record this fact below (see Obs XX of Sec XX). %%\%s \textless{}obs 5\textgreater{}).
We will also formalize the statement and proof of this fact in Agda; see Section XX. %% (obs 5 in Agda).

\subsubsection{Subuniverse generation}\label{subuniverse-generation}
As above S(ùë®) denotes the collection of all subalgebras of ùë®. If ùë® is an algebra and ùê¥‚ÇÄ ‚äÜ ùê¥ a subset of the universe of ùë®, then the \textbf{subuniverse of} ùë® \textbf{generated by} ùê¥‚ÇÄ is denoted by \(\mathrm{Sg}^ùë®(A_0)\) and defined to be the smallest subuniverse of ùë® containing ùê¥‚ÇÄ. Equivalently,
\[\mathrm{Sg}^{ùë®}(A_0)  =  ‚ãÇ \{ U ‚àà \mathrm S(ùë®) ‚à£ A_0 ‚äÜ U \}.\]

We can also use recursion to define the \textbf{subuniverse of} ùë® \textbf{generated by a set} and prove that this new definition is equivalent to the one given above. We will do this below in Obs. XX of Sec XX. % (obs 7)

%% \subsection{Subdirect products}\label{subdirect-products}
%% If ùëò, ùëõ ‚àà ‚Ñï, if \(A = (A_0, A_1, \dots, A_{n-1})\) is a list of sets, and if œÉ : ùëò ‚Üí ùëõ is a ùëò-tuple, then a relation ùëÖ over ùê¥ with scope œÉ is a subset of the Cartesian product \(A_{œÉ(0)} √ó A_{œÉ(1)} √ó \cdots √ó A_{œÉ(k-1)}\).

%% Let ùëÜ = (ùêπ, œÅ) be a signature and for each ùëñ \textless{} ùëõ let \(ùë®_i = ‚ü® A_i, F ‚ü©\) be an ùëÜ-algebra. If \(ùë® = ‚àè_{i<n}ùë®_i\) is the product of these algebras, then a relation ùëÖ over ùê¥ with scope œÉ is called \textbf{compatible with} ùê¥ if it is closed under the basic operations in ùêπ. In other words, ùëÖ is compatible if the induced algebra ùëπ = ‚ü®ùëÖ, ùêπ‚ü© is a subalgebra of \(\prod_{j<k} ùë®_{œÉ(j)}\).

%% If ùëÖ is compatible with the product algebra and if the projection of ùëÖ onto each factor is surjective, then ùëπ is called a \textbf{subdirect product} of the algebras in the list \((ùë®_{œÉ(0)}, ùë®_{œÉ(1)}, \dots, ùë®_{œÉ(k-1)})\); we denote this situation by writing \(ùëπ ‚â§_{\mathrm{sd}} \prod_{j< k} ùë®_{œÉ(j)}\).
%% \textbf{Formalization}. (not yet implemented)

\subsection{Homomorphisms}\label{homomorphisms}
Let \(ùë© = ‚ü®B, F^ùë©‚ü©\) and \(ùë™ = ‚ü®C, F^ùë™‚ü©\) be algebras of the same signature, and let ‚Ñé : ùêµ ‚Üí ùê∂ be a function (e.g., on sets).

Take an operation symbol ùëì ‚àà ùêπ, and suppose that for all \(œÅ f\)-tuples ùëè : œÅùëì ‚Üí ùêµ of ùêµ the following equation holds:
\[h (f^ùë© \, b) = f^ùë™ (h ‚àò b).\]

Then ‚Ñé is said to \textbf{respect the interpretation of} ùëì.

If ‚Ñé respects the interpretation of every ùëì ‚àà ùêπ, then we call ‚Ñé a \textbf{homomorphism} from ùë© to ùë™, and we write ‚Ñé ‚àà Hom(ùë©, ùë™), or simply, ‚Ñé : ùë© ‚Üí ùë™. (Later, in Agda, we will typically use notation like \texttt{h\ :\ hom\ B\ C}, or sometimes \texttt{h\ :\ Hom\ ùë©\ ùë™}.)

A homomorphism ‚Ñé : ùë© ‚Üí ùë™ is called an \textbf{epimorphism} if for every algebra ùë´ and pair \(g_1, g_2: ùë™ ‚Üí ùë´\) of homomorphisms, the equation \(g_1 ‚àò h = g_2 ‚àò h\) implies \(g_1 = g_2\). We often write ‚Ñé : ùë© ‚Ü† ùë™, and say that ``‚Ñé is \textbf{epi}'' and ``‚Ñé maps ùë© \textbf{homomorphically onto} ùë™'' in this case.

A homomorphism ‚Ñé : ùë© ‚Üí ùë™ is called a \textbf{monomorphism} if for every algebra ùë® and every pair \(g_1, g_2: ùë® ‚Üí ùë©\) of homomorphisms, the equation \(h ‚àò g_1 = h ‚àò g_2\) implies \(g_1 = g_2\). We sometimes write ‚Ñé : ùë® ‚Ü£ ùë©, and say that ``‚Ñé is \textbf{mono}'' and ``‚Ñé maps ùë© \textbf{homomorphically into} ùë™'' in this case.
‚Ü£
If ùë®, ùë© are ùëÜ-algebras and ‚Ñé : ùë® ‚Üí ùë© is a homomorphism, then the image ‚Ñé(ùê¥) of ùê¥ under ‚Ñé is called a \textbf{homomorphic image} of ùë®. The collection of all homomorphic images of an ùëÜ-algebra ùë® is the class denoted and defined by
\[\mathrm H(ùë®) := \{h(ùê¥) : h \text{ is a hom from ùë® to some ùëÜ-algebra}\}.\]

If ùí¶ is a class of ùëÜ-algebras, then the class of all homomorphic images of algebras in ùí¶ is denoted by H(ùí¶).

\subsection{Clones}\label{clones}
An \textbf{operational clone} (or just \textbf{clone}) on a nonempty set ùê¥ is a collection of operations on ùê¥ that contains the projection operations and is closed under general composition.
%% Let \(ùìí‚Ñì(ùê¥)\) denote the collection of all clones on ùê¥.

The smallest clone on ùê¥ is the \textbf{clone of projections}, which we denote and define as follows:
\[\mathrm{Proj}  A = ‚ãÉ_{i < n < œâ}  \{œÄ^n_i : ‚àÄ a ‚àà A^n,\ œÄ^n_i\, a = a(i)\}.\]

Recall, the natural number ùëò \textless{} œâ can be constructed as (or at least identified with) the set \{0, 1, ‚Ä¶, ùëò-1\}. For each ùëò \textless{} œâ, denote and define the tuple œÄ·µè : (ùëò ‚Üí ùê¥) ‚Üí ùê¥ of all ùëò-ary projections on ùê¥ as follows: for each 0 ‚â§ ùëñ \textless{} ùëò, œÄ·µè(ùëñ) is the ùëñ-th ùëò-ary projection operation that takes each ùëò-tuple \(ùëé : ùëò ‚Üí ùê¥\) to its
entry at index ùëñ, \[œÄ^k (i) a = a(i).\]
The \textbf{clone of term operations} of an ùëÜ-algebra ùë® is the smallest clone on ùê¥ containing the basic operations of ùë®; this is denoted and defined by \[\mathrm{Clo}(F^ùë®) = ‚ãÇ \{ U ‚àà ùìíùìµ A ‚à£ F^ùë® ‚äÜ U\}.\]

The set of ùëõ-ary members of \(\mathrm{Clo}(F^ùë®)\) is sometimes denoted by \(\mathrm{Clo}_n (F^ùë®)\) (despite the fact that the latter is obviously not a clone).

The \textbf{clone of polynomial operations} (or \textbf{polynomial clone}) of an ùëÜ-algebra ùë® is denoted by \(\mathrm{Pol} (F^ùë®)\) and is defined to be the clone generated by the collection consisting of the basic operations (i.e., \(F^ùë®\)) of ùë® along with the \textbf{constants} on ùê¥.\footnote{By ``the constants on \(A\)'' we mean the \textbf{constant operations}; i.e., functions \(f: A ‚Üí A\) such that \(‚àÄ a ‚àà A, f(a) = c\), for some \(c ‚àà A\).} The set of ùëõ-ary members of \(\mathrm{Pol} (F^ùë®)\) is sometimes denoted by \(\mathrm{Pol}_n (F^ùë®)\).

The clone \(\mathrm{Clo}(F^ùë®)\) is associated with the algebra ùë® only insofar as the former is constructed out of the basic operations of ùë® and the set ùê¥ on which those operations are defined. However, all that is required when defining a clone is a set ùê¥ and some collection ùêπ of operations defined on \(A\); from only these ingredients, we can construct the clone generated by ùêπ, which we denote by Clo(ùêπ). Thus \emph{the clone of terms operations can be implemented as an inductive type}. We will make this precise below (see Obs XX). %(obs 7)

\subsection{Terms and free algebras}\label{terms-and-free-algebras}
This section is based on the section of the same title in Cliff Bergman's excellent textbook (\cite{Bergman:2012}). Apart from notation, our presentation is quite similar in style and content to Cliff's, but we have attempted to give a more compact, abridged treatment in order to get more quickly to our ultimate goal (in the next chapter), which is to show how it is possible to express the concepts and theorems of universal algebra in type theory and to formalize them in the Agda language. We refer the reader to Section 4.3 of \cite{Bergman:2012} for more details and examples about ``classical'' (informal) universal algebra than we present here.

\subsubsection{Terms}\label{terms}
Fix a signature ùëÜ = (ùêπ, œÅ), let ùëã be a set of \textbf{variables}, and assume ùëã ‚à© ùêπ = ‚àÖ.

By a \textbf{word} on ùëã ‚à™ ùêπ we mean a nonempty, finite sequence of members of ùëã ‚à™ ùêπ, and we will denote the concatenation of such sequences by simple juxtaposition.

Let ùêπ‚ÇÄ denote the set of nullary operation symbols of ùëÜ. We define by induction on ùëõ the sets ùëá‚Çô of \textbf{terms on} ùëã ‚à™ ùêπ as follows (cf.~\cite{Bergman:2012} Def.~4.19):
\[\begin{array}{rl}
  T_0 &= X ‚à™ F_0;\\
  T_{n+1} &= T_n ‚à™ \{ f\, s ‚à£ f ‚àà  F, \ s: œÅf ‚Üí T_n \},
  \end{array}\]
and we define the collection of \textbf{terms of signature} ùëÜ \textbf{over} ùëã by ùëá(ùëã) = \(‚ãÉ_{n < œâ}T_n\).

By an ùëÜ-\textbf{term} we mean a term in the signature ùëÜ.

The definition of ùëá(ùëã) is recursive, indicating that \emph{terms could be implemented as an inductive type}. We will confirm this in types for terms when we implement terms in Agda. Moreover, we will formalize an algebraic structure on ùëá(ùëã), called the \textbf{term algebra} in the signature ùëÜ. We describe it here and then state and prove some basic facts about this important algebra. These will be formalized in types for terms and birkhoffs theorem in agda, giving us a chance to show off inductively defined types in Agda.

If ùë° is a term, then the \textbf{height} of ùë° is denoted by ‚à£ùë°‚à£ and defined to be the least ùëõ such that ùë° ‚àà ùëá‚Çô. The height is a useful index for recursion and induction.

If ùëá(ùëã) is nonempty (equivalently, ùëã ‚à™ ùêπ‚ÇÄ is nonempty), then we can impose upon it an algebraic structure, which we will denote by ùëª(ùëã). We call ùëª(ùëã) the \textbf{term algebra in the signature} ùëÜ \textbf{over} ùëã; it is constructed as follows:
\begin{itemize}
\item for each operation symbol ùëì ‚àà ùêπ, let \(f^{ùëª(X)}\) be the operation on ùëá(ùëã) that maps each tuple \(ùë† : œÅùëì ‚Üí ùëá(ùëã)\) to the formal term ùëì ùë†;
\item define ùëª(ùëã) to be the algebra with universe ùëá(ùëã) and operations \(\{f^{ùëª(X)} | f ‚àà F\}\).
\end{itemize}

\subsubsection{Free algebras}\label{free-algebras}
Fix a signature ùëÜ = (ùêπ, œÅ), let ùí¶ be a class of ùëÜ-algebras, let \(ùëº = ‚ü®ùëà, ùêπ^ùëº‚ü©\) be an ùëÜ-algebra, and let ùëã be a subset of ùëà. We say that
\begin{itemize}
\item ùëº has the universal mapping property for ùí¶ over ùëã if for every ùë® ‚àà ùí¶ and every function ‚Ñé : ùëã ‚Üí ùê¥, there is a homomorphism \(h' : ùëº ‚Üí ùë®\) that agrees with ‚Ñé on ùëã;
\item ùëº is free for ùí¶ over ùëã if it has the universal mapping property and is generated by ùëã;
\item ùëº is free in ùí¶ over ùëã if it is free for ùí¶ over ùëã and belongs to ùí¶.
\end{itemize}
We use the next definition to take a free algebra \emph{for} a class ùí¶ and produce the free algebra \emph{in} ùí¶. Let ùí¶ be a class of ùëÜ-algebras and ùë® an ùëÜ-algebra. Define \(œà(ùí¶, ùë®) := \{Œ∏ ‚àà Con ùë® : ùë®/Œ∏ ‚àà S(ùí¶)\}\) and \(Œ®(ùí¶, ùë®) := ‚ãÄ œà(ùí¶, ùë®)\). Notice that \(œà(ùí¶, ùë®)\) may be empty, in which case \(Œ®(ùí¶, ùë®) = 1_A\) and \(ùë®/Œ®(ùí¶, ùë®)\) is trivial.

The free algebra is constructed using the above definitions for the special case in which ùë® is the algebra ùëª(ùëã) of ùëÜ-terms over ùëã.

Since ùëª(ùëã) is free for the class ùìö(ùëÜ) of all ùëÜ-algebras, it follows that ùëª(ùëã) is free for every subclass ùí¶ of ùìö(ùëÜ).

Of course, ùëª(ùëã) is not necessarily a member of ùí¶, but we can form the quotient of ùëª(ùëã) modulo the congruence Œ®(ùí¶, ùëª(ùëã)), which we denote by \(ùîΩ(ùí¶, ùëã) := ùëª(ùëã)/Œ®(ùí¶, ùëª(ùëã))\).

The algebra ùîΩ(ùí¶, ùëã) is called the \textbf{free algebra over} ùí¶ \textbf{generated by} ùëã.

It should be clear that ùîΩ(ùí¶, ùëã) is a subdirect product of the algebras \{ùëª(ùëã)/Œ∏\}, where Œ∏ ranges over œà(ùí¶, ùëª(ùëã))\}, so it belongs to SP(ùí¶). Therefore, we say that ùîΩ(ùí¶, ùëã) is free \emph{in} SP(ùí¶).

We formalize the free algebra in the free algebra in agda.

\subsection{Arity}\label{arity}
We denote and define the set \(X := \{x_0,x_1,\dots \}\) of variable symbols, and for each natural number \(n\) we let \(X_n:=\{x_0,x_1,\dots, x_{n-1}\}\).

Let ùëÜ = (ùêπ, œÅ) be a signature, ùë® an ùëÜ-algebra, and ùëª(X) the term algebra over ùëã; that is,
\[ùë® := ‚ü®A, F^ùë®‚ü© \quad \text{ and } \quad ùëª(X) := ‚ü®T(X), F^{ùëª(X)}‚ü©.\]
Each operation symbol ùëì ‚àà ùêπ gives rise to
\begin{itemize}
\item a œÅùëì-ary operation on ùëá(ùëã), denoted by \(f^{ùëª(X)}\), which maps each tuple \(ùë† : œÅùëì ‚Üí ùëá(ùëã)\) to the formal term ùëì ùë† in ùëá(ùëã), and
\item a œÅùëì-ary operation on ùê¥, denoted by \(f^ùë®\), which maps each tuple \(ùëé : œÅùëì ‚Üí ùê¥\) to the element \(f^ùë® \,a\) in ùê¥. The operation \(f^ùë®\) is called the \textbf{interpretation of} ùëì \textbf{in the algebra} \(ùë®\).
\end{itemize}

\begin{comment}
\subsubsection{Essential arity}\label{essential-arity}
The definition of arity of an operation or term is a bit nuanced as the next example demonstrates.
\textbf{Example}.
\begin{quote}
Suppose ùëì is a binary term, and ùëù and ùëû are ternary terms. What is the arity of the following term?
\[ùë°(ùë¢, ùë£, ùë§, ùë•, ùë¶, ùëß) = ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))\]
On the face of it, it seems safe to say that ùë° has arity 6, since it is expressible as a function of 6 variables.

But what if we decided to throw in some useless (or ``dummy'') variables, like so,
\[t'(ùë¢', ùë£', ùë¢, ùë£, ùë§, ùë•, ùë¶, ùëß, ùëß') = ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))?\]

And what happens if \(ùëù(ùë•, ùë¶, ùëß) = ùëß\), so that ùëù depends on just one of its arguments? Then we could replace it with \(ùëù'(ùëß) = ùëù(ùë•, ùë¶, ùëß)\), and ùë° could be expressed as,
\[ùë°''(ùë¢, ùë£, ùë§, ùë•, ùëß) = ùëì(ùëù'(ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))).\]

The respective arities of \(ùë°, ùë°'\) and \(ùë°''\) are 6, 9, and 5, yet arity1--arity3 merely give three different ways to present the term \(ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))\).
\end{quote}

As the example demonstrates, the notion of arity of a term is not uniquely defined (modulo equivalence of terms). As such, it is sometimes useful to speak of the \textbf{essential arity} of a term, which is defined to be the minimum number of variables required to express that term; it should be clear that this is equal to the number of arguments
with respect to which the term is not constant.
\textbf{Example}.
\begin{quote} It is impossible to know the essential arity of a term until we know
that of each of its subterms. Picking up where we left off in the previous example, suppose ùëì depends on both of its arguments and \(ùëû(ùë¢, ùë£, ùë§) = ùëì(ùë£, ùë§)\). Then ùë° is expressible as
\[s(ùë£, ùë§, ùë•, ùëß) = ùëì(ùëù'(ùëß), ùëì(ùë§, ùë•), ùëì(ùë£, ùë§))\]
and we finally see the lower bound on the number of variables required to express ùë°, namely 4. Therefore, ùë° has essential arity 4.
\end{quote}
\end{comment}

\subsection{Term Operations}\label{term-operations}
In terms we defined a term in a given signature. When we interpret such a term in a particular algebraic structure, we get what is known as a term operation. In this section we explain how one defines the interpretation of an ùëÜ-term in an ùëÜ-algebra, and thus how one obtains a term \emph{operation}.

%% As usual, for each 0 \textless{} ùëõ \textless{} œâ we identify the ùëõ-tuple \((x_0, x_1, \dots, x_{n-1})\) with the function \(x:  ùëõ ‚Üí X_n\) defined by \(x\, i = x_i\) (0 ‚â§ ùëñ \textless{} ùëõ).

Recall, a term ùë° is either a variable, say, ùë° = ùë•, or has the form ùë° = ùëì ùë† for some operation symbol ùëì ‚àà ùêπ, and some œÅùëì-tuple ùë† : œÅùëì ‚Üí ùëá(ùëã) of terms.

Let ùë° ‚àà ùëá(ùëã) be an ùëÜ-term. Given an arbitrary ùëÜ-algebra ùë®, we will define a \textbf{term operation} on ùë® by giving ùë° an \emph{interpretation} in ùë®. Diverging from standard notation slightly, we will denote this operation by ùë° Ãá ùë® for reasons that will hopefully be clear when (in interpretation) we define term operations in Agda. Similarly, ùë° Ãá ùë© will denote the interpretation of the term ùë° in the algebra ùë©.

The \textbf{term operation} ùë° Ãá ùë® is defined by recursion on the height ‚à£ùë°‚à£ of ùë° as follows: for each assignment ùëé : ùëã ‚Üí ùê¥ (of values in ùê¥ to variables in ùëã),
\begin{itemize}
\item (‚à£ùë°‚à£ = 0) if ùë° is the variable ùë•, then (ùë° Ãá ùë®) ùëé = ùëé ùë•,
\item (‚à£ùë°‚à£ = ùëõ+1) if ùë° = ùëì ùë† where ùëì is an operation symbol and ùë† : œÅùëì ‚Üí ùëá(X) is a tuple of terms whose heights are at most ùëõ (i.e., ‚àÄ ùëñ, ‚à£ùë† ùëñ‚à£ ‚â§ ùëõ), then ùë° Ãá ùë® = \(f^ùë® \, s^ùë®\).
\end{itemize}

\subsection{Models and theories}\label{models-and-theories}
Let ùëÜ = (ùêπ, œÅ) be a signature and \(X := \{x_0, x_1, \dots\}\) a countable collection of variable symbols.

An \textbf{identity in the signature} ùëÜ (or ``ùëÜ-identity'') is an ordered pair of terms (ùëù, ùëû) ‚àà ùëá(ùëã) √ó ùëá(ùëã). We usually write ùëù ‚âà ùëû to indicate such an identity. Although, when we have a collection of identities, say, Œ£, we could indicate that ùëù ‚âà ùëû is among the identities in Œ£ by writing (ùëù, ùëû) ‚àà Œ£. We sometimes refer to an identity as an \textbf{equation}; for us, the words ``identity'' and ``equation'' are synonyms.

Let ùìö(ùëÜ) and ùìî(ùëÜ) denote the classes of all ùëÜ-algebras and ùëÜ-identities, respectively. For \(ùë® ‚àà ùí¶ ‚äÜ ùìö(ùëÜ)\) and \((ùëù, ùëû) ‚àà ‚Ñ∞ ‚äÜ ùìî(ùëÜ)\), we say that
\begin{itemize}
\item ùë® \textbf{models} ùëù ‚âà ùëû, denoted ùë® ‚äß ùëù ‚âà ùëû, just in case ùëù Ãá ùë® = ùëû Ãá ùë® extensionally (i.e., ‚àÄ ùëé : ùëã ‚Üí ùê¥, (ùëù Ãá ùë®) ùëé = (ùëû Ãá ùë®) ùëé);
\item ùë® \textbf{models} ‚Ñ∞, denoted ùë® ‚äß ‚Ñ∞, just in case ùë® ‚äß ùëù ‚âà ùëû holds for every (ùëù, ùëû) ‚àà ‚Ñ∞;
\item ùí¶ \textbf{models} ùëù ‚âà ùëû just in case ùë® ‚äß ùëù ‚âà ùëû holds for every ùë® in ùí¶;
\item ùí¶ \textbf{models} ‚Ñ∞ just in case ùë® ‚äß ‚Ñ∞ for every ùë® ‚àà ùí¶.
\end{itemize}

\noindent \textbf{Notation}. To produce the symbols ‚âà and ‚äß in Emacs \texttt{agda2-mode}, type \texttt{\textbackslash{}\textasciitilde{}\textasciitilde{}} and \texttt{\textbackslash{}models} (resp.). To denote ``ùí¶ models ùëù ‚âà ùëû'' we will use ùí¶ ‚äß ùëù ‚âã ùëû instead of the more standard ùí¶ ‚äß ùëù ‚âà ùëû because we distinguish it from ùë® ‚äß ùëù ‚âà ùëû in our Agda implementation. The symbol ‚âã is produced in Emacs \texttt{agda2-mode} with \texttt{\textbackslash{}\textasciitilde{}\textasciitilde{}\textasciitilde{}}.

The binary relation \(‚äß\) induces an obvious Galois connection. Indeed, the Galois pair (Mod, Th) is defined as follows: for all ‚Ñ∞ ‚äÜ ùìî(ùëÜ) and ùí¶ ‚äÜ ùìö(ùëÜ),
\[Mod ‚Ñ∞ := \{ ùë® ‚àà ùìö(ùëÜ) : ùë® ‚äß ‚Ñ∞ \} and Th ùí¶ := \{‚ÑØ ‚àà ùìî(ùëÜ) : ùí¶ ‚äß ‚ÑØ \}.\]
The first of these, the class of \textbf{models} of ‚Ñ∞, contains those and only those algebras modeling every identity in ‚Ñ∞. It is called an \textbf{equational class}, and ‚Ñ∞ is called an \textbf{equational base} for, or an \textbf{axiomatization} of, the class. Dually, Th ùí¶ is the class of identities modeled by every algebra in ùí¶. Such a class of identities is called an \textbf{equational theory}.

Alternatively and equivalently we could define ``equational class'' and ``equational theory'' in terms of the two
closure operators \textless{}closure operator\textgreater{} induced by the Galois pair (Mod, Th). Indeed, Mod Th : ùí´ ùìö(ùëÜ) ‚Üí ùí´ ùìö(ùëÜ) is a closure operator on ùìö(ùëÜ) and Th Mod : ùí´ ùìî(ùëÜ) ‚Üí ùí´ ùìî(ùëÜ) is a closure operator on ùìî(ùëÜ), and

\begin{itemize}
\item an \textbf{equational class} is a Mod Th-closed class \textless{}closed set\textgreater{} of ùëÜ-algebras;
\item an \textbf{equational theory} is a Th Mod-closed set of ùëÜ-identities
\end{itemize}
(Here, ùí´ denotes the powerset functor.)

\noindent \textbf{N.B.} An equational class is sometimes referred to as a \textbf{variety}; this is because of the celebrated Birkhoff theorem which states that a class of algebraic structures is an equational class if and only if it is closed under the taking of homomorphic images (H), subalgebras (S), and products (P). A formal Agda proof of Birkhoff's
theorem is one of our main goals which we achieve in the \href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/birkhoff.lagda.rst}{birkhoff module} described in Section XX.

\subsection{Basic facts}\label{basic-facts}
We conclude this chapter with a list of basic facts and their (informal) proofs. These results are classical, straightforward consequences of the definitions above. We will need them below and when we cite them later, we will refer to them as, e.g, Obs 1, Obs 2, etc. Each of these observations is formalized in Agda in the \href{https://ualib.org}{agda-ualib}.

Throughout this section, \(ùë® = ‚ü®A, F^ùë®‚ü©, \ ùë© = ‚ü®B, F^ùë©‚ü©, \ ùë™ = ‚ü®C, F^ùë™‚ü©\ \) are algebras in the same signature ùëÜ = (ùêπ, œÅ).

\subsubsection{Equalizers}\label{equalizers}
We start with the simple observation that equalizers of homomorphisms are subuniverses. The Agda formalization of this result and its proof is presented in obs 1 in agda.

\subsubsection{Homomorphisms}\label{homomorphisms-1}
Another easy fact is that composing homomorphisms results in a homomorphism. The easy proof of this fact is formalized in obs 2 in agda .

Another elementary result is that homomorphisms are uniquely determined by the values they take on generating sets. Our Agda proof of Obs \%s \textless{}obs 3\textgreater{} is called
\texttt{HomUnique}. It is presented obs 3 in agda.

%A corollary of the last result is an easily proved bound on the cardinality of \(|\mathrm{Hom}(ùë®, ùë©)|\).

Here is an elementary result about factorability of homomorphisms. The informal proof is presented below and its formalization in obs 5 in agda.

We formalize Obs \%s \textless{}obs 5\textgreater{} in the \href{}{homomorphisms module} of the \href{}{agda-ualib}; see
obs 5 in agda.

Next we observe that the intersection of subuniverses is again a subuniverse, a fact that we prove formally in the \href{}{subuniverses module} of the \href{}{agda-ualib}; see obs 6 in agda.

Next is a theorem that provides a means of generating subuniverses recursively.

We formally implement the concept of subalgebra in the \href{}{subuniverses module} of the \href{}{agda-ualib}, which we describe in subuniverses in agda. In particular, we describe the formalization of Obs \%s \textless{}obs 7\textgreater{} in obs 7 in agda.

Our formalization of Obs \%s \textless{}obs 7.1\textgreater{} is presented in obs 7.1 in agda.

We implement terms and the term algebra in Agda in the \href{}{terms module}, as described in terms. Also in the \href{}{terms module} is a formal proof of the next result; see obs 9 in agda.

Let ùí¶ be the class of ùëÜ-algebras. Then Obs \%s \textless{}obs 9\textgreater{} can be restated as: ùëª(ùëã) is free
in ùí¶ over ùëã. This is sometimes expressed by saying that ùëª(ùëã) is \textbf{absolutely free} over ùëã.

It follows from Obs \%s \textless{}obs 9.2\textgreater{} that, up to isomorphism, a free algebra is determined by the cardinality of a free generating set.

Next we observe that freeness extends from a class ùí¶ to the variety it generates.

As Bergman notes (see the remark after Def 4.29 in~\cite{Bergman:2012}), ``strictly speaking, ùëã is not a subset of ùîΩ(ùí¶, X), so it doesn't make sense to talk about ùëã generating ùîΩ(ùí¶, X), {[}but{]} as long as ùí¶ contains a nontrivial algebra, \(Œ®(ùí¶, ùëã) ‚à© ùëã¬≤ = 0_X\). In light of {[}Obs \%s \textless{}obs 9.2\textgreater{}{]}, we can identify ùëã with ùëã/Œ®(ùí¶, ùëã) in ùîΩ(ùí¶, ùëã). All of these considerations are accounted for in the following corollary.''

In the next observation, assume ùë® = \(‚ü®A, F^ùë®‚ü©\) and ùë© = \(‚ü®B, F^ùë©‚ü©\) are ùëÜ-algebras , and let ùë° ‚àà ùëá(ùëã) be a term in the language of ùëÜ. In particular, as explained in term operations, ùë° has an interpretation in ùë®, which (for reasons that will become clear when we define term operations in Agda) we will denote by ùë° Ãá ùë® and we call a \textbf{term operation}. Similarly, \(t^ùë©\) is the interpretation of ùë° in ùë©.

We formalize Obs \%s \textless{}obs 10\textgreater{} and its proof in the \href{}{terms module} of the \href{}{agda-ualib}, as described in obs 10 in agda.

We formalize Obs \%s \textless{}obs 11\textgreater{} and its proof in the \href{}{terms module} of the \href{}{agda-ualib}, as described in obs 11 in agda.

We formalize Obs. \%s \textless{}obs 12\textgreater{} and its proof in the \href{}{subuniverses module} of the \href{}{agda-ualib}, as described in obs 12 in agda.

%% \emph{Proof}.
%% We prove the result for H(ùí¶). ùí¶ ‚äÜ H(ùí¶), so Th H (ùí¶) ‚äÜ Th ùí¶ ‚Ä¶

We present a formalization of this result and its proof in obs 13 in agda.

We formalize Obs \%s \textless{}obs 14\textgreater{} and its proof in the \href{}{birkhoff module} of the \href{}{agda-ualib}, as described in obs 14 in agda.

The last result tells us that we can determine whether an identity is true in a variety ùí± by consulting a particular algebra, namely ùîΩ(ùí±, ùëã), the free algebra in ùí±.

\subsection{Birkhoff's theorem}\label{birkhoffs-theorem}
It follows from Obs 13 that every equational class is a variety. The converse is the celebrated HSP Theorem of Birkhoff.

\noindent \textbf{Theorem}~\cite{Birkhoff:1935}. Every class of algebraic structures that is closed under the taking of homomorphisms, subalgebras, and arbitrary products is an equational class.

In other terms, if a class ùí¶ of algebras is closed under H, S, P, then there exists a set ‚Ñ∞ of identities such that ùí¶ is the class of all algebras that model ‚Ñ∞.

%% The statement and proof we give here is essentially the same as that given in Theorem 4.41 of Cliff Bergman's textbook~\cite{Bergman:2012}. It is this statement and proof that we will formalize in Agda in the \href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/birkhoff.lagda.rst}{birkhoff module} of the \href{https://ualib.org}{agda-ualib}; see birkhoffs theorem in agda.

\section{Algebras in Agda}
This chapter describes the basic module of the agda-ualib, which begins our Agda formalization of the basic concepts and theorems of universal algebra. In this module we will codify such notions as operation, signature, and algebraic structure.

\subsection{Preliminaries}
Like most Agda programs, this one begins with some Agda options specifying the foundational choices we wish to make, as explained above.

\begin{code}%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\<%
\end{code}

We begin the basic module by invoking Agda's module directive, and then we import some dependencies that we make public so they are available to all modules that import the basic module.

\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{basic}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{prelude}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{Universe}\AgdaSymbol{;}\AgdaSpace{}%
%\AgdaGeneralizable{ùìò}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùìû}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSymbol{;}\AgdaSpace{}%
%% \AgdaPrimitive{ùì§‚ÇÄ}\AgdaSymbol{;}
\AgdaGeneralizable{ùì•}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùì¶}\AgdaSymbol{;}\AgdaSpace{}%
%% \AgdaGeneralizable{ùì£}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùìß}\AgdaSymbol{;}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPrimitive{\AgdaUnderscore{}‚Å∫}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}Ãá}}\AgdaSymbol{;}\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}‚äî\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{Œ£}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{-Œ£}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ùüò}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ùüö}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}√ó\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Œ†}\AgdaSymbol{;}\<%
\\
%
\>[2]\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}‚â°\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\end{code}

This is the second module of the agda-ualib, coming after the prelude module described in the previous chapter.

\subsection{Operation type}

We define the type of **operations**, and give an example (the projections).

\begin{code}%
\>[0]\AgdaComment{--The type of operations}\<%
\\
\>[0]\AgdaFunction{Op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{--Example. the projections}\<%
\\
\>[0]\AgdaFunction{œÄ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{œÄ}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\<%
\end{code}

The type Op encodes the arity of an operation as an arbitrary type I : ùì• Ãá, which gives us a completely general way to represent an operation as a function type with domain I ‚Üí A (the type of "tuples") and codomain A.

The last two lines of the code block above codify the i-th I-ary projection operation on A.

\subsection{Signature type}

We define the signature of an algebraic structure in Agda like this.

\begin{code}%
\>[0]\AgdaComment{--ùìû: level at which operation symbol types live}\<%
\\
\>[0]\AgdaComment{--ùì•: level at which arity types live}\<%
\\
\>[0]\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}%
\>[27]\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\end{code}

In the prelude module we defined the syntax ‚à£\_‚à£ and ‚à•\_‚à• for the first and second projections, resp.  Consequently, if ùëÜ : Signature ùìû ùì• is a signature, then

‚à£ ùëÜ ‚à£ denotes the set of operation symbols (which is often called ùêπ), and

‚à• ùëÜ ‚à• denotes the arity function (which is often called œÅ).

Thus, if  ùëì : ‚à£ ùëÜ ‚à£  is an operation symbol in the signature ùëÜ, then ‚à• ùëÜ ‚à• ùëì is the arity of ùëì.

\subsection{Algebra type}

Finally, we are ready to define the type of algebras in the signature ``S`` (which we also call "S-algebras").

\begin{code}%
\>[0]\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[98I]\AgdaSymbol{(}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)\{}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[98I]%
\>[10]\AgdaSymbol{(}\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}%
\>[33]\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùìû}\AgdaSymbol{\}\{}\AgdaBound{ùì•}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}\<%
\\
\>[.][@{}l@{}]\<[98I]%
\>[10]
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Op}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëì}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\end{code}

Thus, algebras---in the signature ùëÜ (or ùëÜ-algebras) and with carrier types in the universe ùì§---inhabit the type Algebra ùì§ {ùìû}{ùì•} ùëÜ.  (We may also write Algebra ùì§ ùëÜ since ùìû and ùì• can be infered from the given signature ùëÜ.)

In other words,

  *the type* Algebra ùì§ ùëÜ \emph{collects all the algebras of a particular signature ùëÜ and carrier type ùì§, and this collection of algebras has type ùìû ‚äî ùì• ‚äî  ùì§ ‚Å∫ Ãá}.

Recall, ùìû ‚äî ùì• ‚äî  ùì§ ‚Å∫ denotes the smallest universe containing ùìû, ùì•, and the successor of ùì§.

The type Algebra ùì§ ùëÜ doesn't define what an algebra *is* as a property. It defines a type of algebras; certain algebras inhabit this type---namely, the algebras consisting of a universe (say, A) of type ùì§ Ãá , and a collection (ùëì : ‚à£ ùëÜ ‚à£) ‚Üí Op (‚à• ùëÜ ‚à• ùëì) A of operations on A.

Here's an alternative syntax that might seem more familiar to readers of the standard universal algebra literature.

  Algebra ùì§ (F , œÅ) = Œ£ A Íûâ ùì§ Ãá ,  ((ùëì : F )  ‚Üí Op (œÅ ùëì) A )

Here ùëÜ = (F , œÅ) is the signature, F the type of operation symbols, and œÅ the arity function.

Although this syntax would work equally well, we mention it merely for comparison and to demonstrate the flexibility of Agda. Throughout the library we stick to the syntax ùëì : ‚à£ ùëÜ ‚à£ for an operation symbol of the signature ùëÜ, and ‚à• ùëÜ ‚à• ùëì for the arity of that symbol. We find these conventions a bit more convenient for programming.

\subsubsection{Example}
A monoid signature has two operation symbols, say, e  and ¬∑, of arities 0 and 2 (thus, of types (ùüò ‚Üí A) ‚Üí A and (ùüö ‚Üí A) ‚Üí A), resp.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{ùì§‚ÇÄ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaInductiveConstructor{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\<%
\\
%
\>[1]\AgdaInductiveConstructor{¬∑}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{monoid-sig}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaFunction{monoid-sig}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{e}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{ùüò}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{¬∑}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{ùüö}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

The types indicate that e is nullary (i.e., takes no arguments, equivalently, takes args of type ùüò ‚Üí A), while ¬∑ is binary (as indicated  by argument type ùüö ‚Üí A).

We will have more to say about the type of algebras later.  For now, we continue defining the syntax used in the agda-ualib to represent the basic objects of universal algebra.

\subsubsection{Syntactic sugar for operation interpretation}
Before proceding, we define syntax that allows us to replace ‚à• ùë® ‚à• ùëì with the slightly more standard-looking ùëì ÃÇ ùë®, where ùëì is an operation symbol of the signature ùëÜ of ùë®.

\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaGeneralizable{ùìû}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSymbol{\}}%
\>[30]\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}ÃÇ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{‚Üí}%
\>[6]\AgdaSymbol{(}\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{‚Üí}%
\>[6]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëì}%
\>[16]\AgdaSymbol{‚Üí}%
\>[19]\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ÃÇ}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëì}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{40}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}ÃÇ\AgdaUnderscore{}}}\<%
\end{code}

Now we can use ùëì ÃÇ ùë® to represent the interpretation of the basic operation symbol ùëì in the algebra ùë®.

N.B. Below, we will need slightly different notation, namely, ùë° Ãá ùë®, to represent the interpretation of a :term:`term` ùë° in the algebra ùë®. (In future releases of the agda-ualib we may reconsider making it possible to use the same notation interpretations of operation symbols and terms.)

\subsection{Products of algebras}

The (indexed) product of a collection of algebras is also an algebra if we define such a product as follows:

\begin{code}%
%
\>[1]\AgdaFunction{‚®Ö}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùìò}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}(}\AgdaBound{ùíú}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùìò}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ùëÜ}\<%
\\
%
\>[1]\AgdaFunction{‚®Ö}\AgdaSpace{}%
\AgdaBound{ùíú}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[8]\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùíú}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}%
\>[31]\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ÃÇ}}\AgdaSpace{}%
\AgdaBound{ùíú}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{-1}\AgdaSpace{}%
\AgdaFunction{‚®Ö}\<%
\end{code}

(In agda2-mode ‚®Ö is typed as \textbackslash Glb.)

\subsection{Arbitrarily many variable symbols}

Finally, since we typically want to assume that we have an arbitrary large collection X of variable symbols at our disposal (so that, in particular, given an algebra ùë® we can always find a surjective map h‚ÇÄ : X ‚Üí ‚à£ ùë® ‚à£ from X to the universe of ùë®), we define a type for use when making this assumption.

\begin{code}%
%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}‚Ü†\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùìß}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùìß}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚Ü†}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{h}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSpace{}%
\AgdaBound{h}\<%
\end{code}

\begin{comment}
\section{Algebras in Agda}\label{algebras-in-agda}
This section describes the \href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/basic.lagda.rst}{basic
module} of the \href{https://ualib.org}{agda-ualib}, which begins our \href{https://wiki.portal.chalmers.se/agda/pmwiki.php}{Agda} formalization of the basic concepts and theorems of universal algebra.
In this module we will codify such notions as operation, signature, and algebraic structure.

\subsection{Preliminaries}\label{preliminaries}
Like most Agda programs, this one begins with some Agda options specifying the foundational choices we wish to make.

\begin{verbatim}
  {-# OPTIONS --without-K --exact-split --safe #-}
\end{verbatim}

We begin the
\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/basic.lagda.rst}{basic
module} by invoking Agda's \texttt{module} directive, and then we import
some dependencies that we make \texttt{public} so they are available to
all modules that import the
\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/basic.lagda.rst}{basic
module}.

\begin{code}
module basic where

open import prelude using (Universe; ùìò; ùìû; ùì§; ùì§‚ÇÄ;ùì•; ùì¶; ùì£; ùìß;
  _‚Å∫; _Ãá;_‚äî_; _,_; Œ£; -Œ£; ‚à£_‚à£; ‚à•_‚à•; ùüò; ùüö; _√ó_; Œ†;
  _‚â°_; Epic) public
\end{code}

This is the second module of the \href{https://ualib.org}{agda-ualib} ,
coming after the
\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/prelude.lagda.rst}{prelude
module} described in the previous chapter (agda preliminaries).

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Operation type}\label{operation-type}

We define the type of \textbf{operations}, and give an example (the
projections).

\begin{code}
--The type of operations
Op : ùì• Ãá ‚Üí ùì§ Ãá ‚Üí ùì§ ‚äî ùì• Ãá
Op I A = (I ‚Üí A) ‚Üí A

--Example. the projections
œÄ : {I : ùì• Ãá } {A : ùì§ Ãá } ‚Üí I ‚Üí Op I A
œÄ i x = x i
\end{code}

The type \texttt{Op} encodes the arity of an operation as an arbitrary
type \texttt{I\ :\ ùì•\ Ãá}, which gives us a very general way to represent
an operation as a function type with domain \texttt{I\ ‚Üí\ A} (the type
of ``tuples'') and codomain \texttt{A}.

The last two lines of the code block above codify the \texttt{i}-th
\texttt{I}-ary projection operation on \texttt{A}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Signature type}\label{signature-type}

We define the signature of an algebraic structure in Agda like this.

\begin{code}
--ùìû is the universe in which operation symbols live
--ùì• is the universe in which arities live
Signature : (ùìû ùì• : Universe) ‚Üí ùìû ‚Å∫ ‚äî ùì• ‚Å∫ Ãá
Signature ùìû ùì• = Œ£ F Íûâ ùìû Ãá  , ( F ‚Üí ùì• Ãá )
\end{code}

In the
\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/prelude.lagda.rst}{prelude
module} we defined the syntax ‚à£\_‚à£ and ‚à•\_‚à• for the first and second
projections, resp. Consequently, if \texttt{ùëÜ\ :\ Signature\ ùìû\ ùì•} is a
signature, then

\begin{quote}
‚à£ ùëÜ ‚à£ denotes the set of operation symbols (which is often called ùêπ),
and

‚à• ùëÜ ‚à• denotes the arity function (which is often called œÅ).
\end{quote}

Thus, if ùëì : ‚à£ ùëÜ ‚à£ is an operation symbol in the signature ùëÜ, then ‚à• ùëÜ ‚à•
ùëì is the arity of ùëì.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Algebra type}\label{algebra-type}

Finally, we are ready to define the type of algebras in the signature
\texttt{S} (which we also call ``S-algebras'').

\begin{code}
Algebra : (ùì§ : Universe){ùìû ùì• : Universe}
          (ùëÜ : Signature ùìû ùì•) ‚Üí  ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ Ãá

Algebra ùì§ {ùìû}{ùì•} ùëÜ = Œ£ A Íûâ ùì§ Ãá , ((ùëì : ‚à£ ùëÜ ‚à£) ‚Üí Op (‚à• ùëÜ ‚à• ùëì) A)
\end{code}

Thus, algebras---in the signature ùëÜ (or ùëÜ-algebras) and with carrier
types in the universe ùì§---inhabit the type
\texttt{Algebra\ ùì§\ \{ùìû\}\{ùì•\}\ ùëÜ}. (We may also write
\texttt{Algebra\ ùì§\ ùëÜ} since ùìû and ùì• can be infered from the given
signature \texttt{ùëÜ}.)

In other words,

\begin{quote}
\emph{the type} \texttt{Algebra\ ùì§\ ùëÜ} \emph{collects all the algebras
of a particular signature} ùëÜ \emph{and carrier type} ùì§, \emph{and this
collection of algebras has type} ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ Ãá .
\end{quote}

Recall, ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ denotes the smallest universe containing ùìû, ùì•, and
the successor of ùì§.

\begin{description}
\item[NB]
The type \texttt{Algebra\ ùì§\ ùëÜ} doesn't define what an algebra \emph{is}
as a property. It defines a type of algebras; certain algebras inhabit
this type---namely, the algebras consisting of a universe (say,
\texttt{A}) of type ùì§ Ãá , and a collection
\texttt{(ùëì\ :\ ‚à£\ ùëÜ\ ‚à£)\ ‚Üí\ Op\ (‚à•\ ùëÜ\ ‚à•\ ùëì)\ A} of operations on
\texttt{A}.
\end{description}

Here's an alternative syntax that might seem more familiar to readers of
the standard universal algebra literature.

\begin{code}
Algebra ùì§ (F , œÅ) = Œ£ A Íûâ ùì§ Ãá ,  ((ùëì : F )  ‚Üí Op (œÅ ùëì) A )
\end{code}

Here \texttt{ùëÜ\ =\ (F\ ,\ œÅ)} is the signature, \texttt{F} the type of
operation symbols, and œÅ the arity function.

Although this syntax would work equally well, we mention it merely for
comparison and to demonstrate the flexibility of Agda. Throughout the
library we stick to the syntax \texttt{ùëì\ :\ ‚à£\ ùëÜ\ ‚à£} for an operation
symbol of the signature ùëÜ, and \texttt{‚à•\ ùëÜ\ ‚à•\ ùëì} for the arity of that
symbol. We find these conventions a bit more convenient for programming.

\subsubsection{Example}\label{example}

A monoid signature has two operation symbols, say, \texttt{e} and
\texttt{¬∑}, of arities 0 and 2 (thus, of types \texttt{(ùüò\ ‚Üí\ A)\ ‚Üí\ A}
and \texttt{(}ùüö\texttt{\ ‚Üí\ A)\ ‚Üí\ A}), resp.

\(\mathbb{2}\)

\begin{code}
data monoid-op : ùì§‚ÇÄ Ãá where
 e : monoid-op
 ¬∑ : monoid-op

monoid-sig : Signature _ _
monoid-sig = monoid-op , Œª { e ‚Üí ùüò; ¬∑ ‚Üí ùüö }
\end{code}

The types indicate that \texttt{e} is nullary (i.e., takes no arguments,
equivalently, takes args of type \texttt{ùüò\ ‚Üí\ A}), while \texttt{¬∑} is
binary (as indicated by argument type \texttt{ùüö\ ‚Üí\ A}).

We will have more to say about the type of algebras later. For now, we
continue defining the syntax used in the \texttt{agda-ualib} to
represent the basic objects of universal algebra.

\subsubsection{Syntactic sugar for operation
interpretation}\label{syntactic-sugar-for-operation-interpretation}

Before proceding, we define syntax that allows us to replace
\texttt{‚à•\ ùë®\ ‚à•\ ùëì} with the slightly more standard-looking
\texttt{ùëì\ ÃÇ\ ùë®}, where ùëì is an operation symbol of the signature ùëÜ of ùë®.

\begin{code}
module _ {ùëÜ : Signature ùìû ùì•}  where

 _ÃÇ_ : (ùëì : ‚à£ ùëÜ ‚à£)
  ‚Üí   (ùë® : Algebra ùì§ ùëÜ)
  ‚Üí   (‚à• ùëÜ ‚à• ùëì  ‚Üí  ‚à£ ùë® ‚à£) ‚Üí ‚à£ ùë® ‚à£

 ùëì ÃÇ ùë® = Œª x ‚Üí (‚à• ùë® ‚à• ùëì) x

 infix 40 _ÃÇ_
\end{code}

Now we can use \texttt{ùëì\ ÃÇ\ ùë®} to represent the interpretation of the
basic operation symbol ùëì in the algebra ùë®.

\begin{description}
\item[NB]
Below, we will need slightly different notation, namely, ùë° Ãá ùë®, to
represent the interpretation of a term ùë° in the algebra ùë®. (In future
releases of the \href{https://ualib.org}{agda-ualib} we may reconsider
making it possible to use the same notation interpretations of operation
symbols and terms.)
\end{description}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Products of algebras}\label{products-of-algebras}

The (indexed) product of a collection of algebras is also an algebra if
we define such a product as follows:

\begin{code}
‚®Ö : {I : ùìò Ãá }(ùíú : I ‚Üí Algebra ùì§ ùëÜ ) ‚Üí Algebra (ùì§ ‚äî ùìò) ùëÜ
‚®Ö ùíú =  ((i : _) ‚Üí ‚à£ ùíú i ‚à£) ,  Œª ùëì x i ‚Üí (ùëì ÃÇ ùíú i) Œª ùì• ‚Üí x ùì• i

infixr -1 ‚®Ö
\end{code}

(In \texttt{agda2-mode} ‚®Ö is typed as \texttt{\textbackslash{}Glb}.)

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Arbitrarily many variable
symbols}\label{arbitrarily-many-variable-symbols}

Finally, since we typically want to assume that we have an arbitrary
large collection \texttt{X} of variable symbols at our disposal (so
that, in particular, given an algebra ùë® we can always find a surjective
map h‚ÇÄ : X ‚Üí ‚à£ ùë® ‚à£ from X to the universe of ùë®), we define a type for
use when making this assumption.

\begin{code}
_‚Ü†_ : ùìß Ãá ‚Üí Algebra ùì§ ùëÜ ‚Üí ùìß ‚äî ùì§ Ãá
X ‚Ü† ùë® = Œ£ h Íûâ (X ‚Üí ‚à£ ùë® ‚à£) , Epic h
\end{code}
\end{comment}

\bibliographystyle{ACM-Reference-Format}
\bibliography{ualib_refs}
\end{document}
% \endinput
%%
%% End of file `sample-sigplan.tex'.
