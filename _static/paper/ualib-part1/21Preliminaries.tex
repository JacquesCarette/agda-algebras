% -*- TeX-master: "ualib-part1.tex" -*-
%%% Local Variables: 
%%% mode: latex
%%% TeX-engine: 'xetex
%%% End:
We begin by highlighting some of the key parts of the module, which lists everything we need from Martin Escard\'o's \typetopology library~\cite{MHE}, defines some basic types, and proves some of their properties.  We do not cover the entire \ualibhtml{Prelude.Preliminaries} module here, but instead call attention to aspects that differ from standard Agda syntax.\footnote{For more details, see \ualiburl{Prelude.Preliminaries}.}

\subsubsection{Logical foundations}\label{sec:logical-foundations}
% For the benefit of readers who are not proficient in Agda or type theory, we briefly describe the type theoretic foundations of the \ualib, as well as the most important basic types and features that are used throughout the library.

The \agdaualib is based on a minimal version of \defn{Martin-LoÃàf dependent type theory} (MLTT) that is the same or very close to the type theory on which \MartinEscardo's \TypeTopology Agda library is based.\footnote{This is also the type theory that \escardo taught us in the short course \ufcourse at the Midlands Graduate School in the Foundations of Computing Science at University of Birmingham in 2019.} We won't go into great detail here because there are already other very nice resources available, such as the section \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#mlttinagda}{A spartan Martin-L√∂f type theory} of the lecture notes by \escardo just mentioned, the \href{https://ncatlab.org/nlab/show/Martin-L\%C3\%B6f+dependent+type+theory}{ncatlab entry on Martin-LoÃàf dependent type theory}, as well as the HoTT Book~\cite{HoTT}.

We will have much more to say about types and type theory as we progress. For now, suffice it to recall the handful of objects that are assumed at the jumping-off point for MLTT: ``primitive'' \defn{types} (\ad ùüò, \ad ùüô, and \ad ‚Ñï, denoting the empty type, one-element type, and natural numbers), \defn{type formers} (\ad +, \ad Œ†, \ad Œ£, \ad{Id}, denoting \defn{binary sum}, \defn{product}, \defn{sum}, and the \defn{identity} type), and an infinite collection of \defn{universes} (types of types) and universe variables to denote them (for which we will use upper-case caligraphic letters like \ab ùì§, \ab ùì•, \ab ùì¶, etc., typically from the latter half of the English alphabet).

\subsubsection{Specifying logical foundations in Agda}\label{sec:preliminaries}
An Agda program typically begins by setting some options and by importing types from existing Agda libraries.
Options are specified with the \AgdaKeyword{OPTIONS} \emph{pragma} and control the way Agda behaves by, for example, specifying the logical axioms and deduction rules we wish to assume when the program is type-checked to verify its correctness. Every Agda program in the \ualib begins with the following line.
\ccpad
\begin{code}[number=code:options]
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\end{code}
\ccpad
These options control certain foundational assumptions that Agda makes when type-checking the program to verify its correctness.
\begin{itemize}
\item \AgdaPragma{--without-K} disables \axiomk; see~\cite{agdaref-axiomk};
\item \AgdaPragma{--exact-split} makes Agda accept only definitions that are \emph{judgmental} equalities; see~\cite{agdatools-patternmatching};
\item \AgdaPragma{--safe} ensures that nothing is postulated outright---every non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module); see~\cite{agdaref-safeagda} and~\cite{agdatools-patternmatching}.
\end{itemize}
%% \end{enumerate}
Throughout this paper we take assumptions 1--3 for granted without mentioning them explicitly.


\subsubsection{Agda Modules}
The \ak{OPTIONS} pragma is usually followed by the start of a module.  For example, the \ualibhtml{Prelude.Preliminaries} module begins with the following line.
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Prelude.Preliminaries}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\ccpad
Sometimes we want to declare parameters that will be assumed throughout the module.  For instance, when working with algebras, we often assume they come from a particular fixed signature, and this signature is something we could fix as a parameter at the start of a module. Thus, we might start an \defn{anonymous submodule} of the main module with a line like\footnote{The \af{Signature} type will be defined in Section~\ref{sec:oper-sign}.}
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaUnderscore\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\ccpad
Such a module is called \emph{anonymous} because an underscore appears in place of a module name. Agda determines where a submodule ends by indentation.  This can take some getting used to, but after a short time it will feel very natural. The main module of a file must have the same name as the file, without the \texttt{.agda} or \texttt{.lagda} file extension.  The code inside the main module is not indented. Submodules are declared inside the main module and code inside these submodules must be indented to a fixed column.  As long as the code is indented, Agda considers it part of the submodule.  A submodule is exited as soon as nonindented code appears.





\subsubsection{Agda's universe hierarchy}\label{ssec:agdas-universe-hierarchy}
The \agdaualib adopts the notation of Martin Escardo's \typetopology library~\cite{MHE}. In particular, \emph{universe levels}%
\footnote{See \url{https://agda.readthedocs.io/en/v2.6.1.2/language/universe-levels.html}.}
are denoted by capitalized script letters from the second half of the alphabet, e.g., \ab ùì§, \ab ùì•, \ab ùì¶, etc.  Also defined in \typetopology are the operators~\af Ãá~and~\af ‚Å∫. These map a universe level \ab ùì§ to the universe \ab ùì§\af Ãá := \Set \ab ùì§ and the level \ab ùì§ \af ‚Å∫ \aod := \lsuc \ab ùì§, respectively.  Thus, \ab ùì§\af Ãá is simply an alias for the universe \Set \ab ùì§, and we have \ab ùì§\af Ãá \as : \ab ùì§ \af ‚Å∫\af Ãá.
%% Table~\ref{tab:dictionary} translates between standard \agda syntax and \typetopology/\ualib notation.

The hierarchy of universes in Agda is structured as \ab{ùì§}\af Ãá \as : \ab ùì§ \af ‚Å∫\af Ãá, \hskip3mm
\ab{ùì§} \af ‚Å∫\af Ãá \as : \ab ùì§ \af ‚Å∫\af ‚Å∫\af Ãá, etc. This means that the universe \ab ùì§\af Ãá has type \ab ùì§  \af ‚Å∫\af Ãá, and ùì§ \af ‚Å∫\af Ãá has type \ab ùì§ \af ‚Å∫\af ‚Å∫\af Ãá, and so on.  It is important to note, however, this does \emph{not} imply that \ab ùì§\af Ãá \as : \ab ùì§ \af ‚Å∫\af ‚Å∫\af Ãá. In other words, Agda's universe hierarchy is \emph{noncummulative}. This makes it possible to treat universe levels more generally and precisely, which is nice. On the other hand, a noncummulative hierarchy can sometimes make for a nonfun proof assistant. Luckily, there are ways to circumvent noncummulativity without introducing logical inconsistencies into the type theory. Section~\ref{lifts-of-algebras} describes some domain-specific tools that we developed for this purpose.








\subsubsection{Sigma and Pi types}\label{ssec:dependent-pairs}
Given universes \ab ùì§ and \ab ùì•, a type \ab X \as : \ab ùì§\aof Ãá, and a type family \ab Y \as : X \as ‚Üí \ab ùì•\aof Ãá, the \defn{Sigma type} (or \defn{dependent pair type}), denoted by \AgdaRecord{Œ£}(\ab x \as Íûâ \ab X)\as ,\ab Y \ab x, generalizes the Cartesian product \ab X~\as √ó~\ab Y by allowing the type \ab Y \ab x of the second argument of the ordered pair (\ab x\as , \ab y) to depend on the value \ab x of the first.  That is, \AgdaRecord{Œ£}(\ab x \as Íûâ \ab X)\as ,\ab Y \ab x is inhabited by the pairs (\ab x\as , \ab y) such that \ab x \as : \ab X and \ab y \as : \ab Y \ab x.

Agda's default syntax for a Sigma type is \AgdaRecord{Œ£}\sP{3}\AgdaSymbol{Œª}(\ab x\sP{3}Íûâ\sP{3}\ab X)\sP{3}\as ‚Üí\sP{3}\ab Y, but we prefer the notation \AgdaRecord{Œ£}~\ab x~Íûâ~\ab X~,~\ab Y, which is closer to the standard syntax described in the preceding paragraph. Fortunately, this preferred notation is available in the \typetopology library (see~\cite[Œ£ types]{MHE}).\footnote{The symbol \as Íûâ in the expression \AgdaRecord{Œ£}\sP{3}\ab x\sP{3}\as Íûâ\sP{3}\ab X\sP{3}\AgdaComma\sP{3}\ab Y is not the ordinary colon; rather, it is the symbol obtained by typing \texttt{\textbackslash{}:4} in \agdatwomode.} 

\newcommand\FstUnder{\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}}\xspace}
\newcommand\SndUnder{\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}}\xspace}
Convenient notations for the first and second projections out of a product are \FstUnder and \SndUnder, respectively. However, to improve readability or to avoid notation clashes with other modules, we sometimes use more standard alternatives, such as \AgdaFunction{pr‚ÇÅ} and \AgdaFunction{pr‚ÇÇ}, or \AgdaFunction{fst} and \AgdaFunction{snd}, or some combination of these. The definitions are standard so we omit them (see~\cite{DeMeo:2021} for details).

