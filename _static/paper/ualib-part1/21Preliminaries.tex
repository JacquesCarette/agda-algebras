% -*- TeX-master: "ualib-part1.tex" -*-
%%% Local Variables: 
%%% mode: latex
%%% TeX-engine: 'xetex
%%% End:
This module defines (or imports) the most basic and important types of \defn{Martin-LoÃàf dependent type theory} (MLTT).  Although this is standard, we take this opportunity to highlight aspects of the \ualib syntax that may differ from that of ``standard Agda.''  Although we don't discuss all of the types on which the library depends here, Appendix Section~\ref{sec:imports-from-type} provides a comprehensive list of the components from \MartinEscardo's \typetopology library~\cite{MHE} that are imported at one place or another in the \ualib.

\subsubsection{Logical foundations}\label{sec:logical-foundations}
% Mainly for the benefit of readers who are not yet proficient in Agda or type theory, we briefly describe the type theoretic foundations of the \ualib, including the most important basic types and features that are used throughout the library. 
The \ualib is based on a minimal version of \mltt that is the same or very close to the type theory on which \MartinEscardo's \TypeTopology Agda library is based.
% This is also the type theory that \escardo taught us in the short course \ufcourse at the Midlands Graduate School in the Foundations of Computing Science at University of Birmingham in 2019.}
We won't go into great detail here because there are already other very nice resources available, such as the section \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#mlttinagda}{A spartan Martin-L√∂f type theory} of the lecture notes by \escardo just mentioned, the \href{https://ncatlab.org/nlab/show/Martin-L\%C3\%B6f+dependent+type+theory}{ncatlab entry on Martin-LoÃàf dependent type theory}, as well as the HoTT Book~\cite{HoTT}.

We begin by noting that only a very small collection of objects is assumed at the jumping-off point for MLTT. We have the \defn{primitive types} (\ad ùüò, \ad ùüô, and \ad ‚Ñï, denoting the empty type, one-element type, and natural numbers), the \defn{type formers} (\ad +, \ad Œ†, \ad Œ£, \ad{Id}, denoting \defn{binary sum}, \defn{product}, \defn{sum}, and the \defn{identity} type), and an infinite collection of \defn{type universes} (types of types) and universe variables to denote them.  Like Escard\'o's, our universe variables are typically upper-case caligraphic letters from the latter half of the English alphabet (e.g., \ab ùì§, \ab ùì•, \ab ùì¶, etc.).

\paragraph*{Specifying logical foundations in Agda}
An Agda program typically begins by setting some options and by importing types from existing Agda libraries.
Options are specified with the \AgdaKeyword{OPTIONS} \emph{pragma} and control the way Agda behaves by, for example, specifying the logical axioms and deduction rules we wish to assume when the program is type-checked to verify its correctness. Every Agda program in the \ualib begins with the following line.
\ccpad
\begin{code}[number=code:options]
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\end{code}
\ccpad
These options control certain foundational assumptions that Agda makes when type-checking the program to verify its correctness.
\begin{itemize}
\item \AgdaPragma{--without-K} disables \axiomk; see~\cite{agdaref-axiomk};
\item \AgdaPragma{--exact-split} makes Agda accept only definitions that are \emph{judgmental} equalities; see~\cite{agdatools-patternmatching};
\item \AgdaPragma{--safe} ensures that nothing is postulated outright---every non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module); see~\cite{agdaref-safeagda} and~\cite{agdatools-patternmatching}.
\end{itemize}
%% \end{enumerate}
Throughout this paper we take assumptions 1--3 for granted without mentioning them explicitly.


\paragraph*{Agda Modules}
The \ak{OPTIONS} pragma is usually followed by the start of a module.  For example, the \ualibhtml{Prelude.Preliminaries} module begins with the following line.
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Prelude.Preliminaries}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\ccpad
Sometimes we want to declare parameters that will be assumed throughout the module.  For instance, when working with algebras, we often assume they come from a particular fixed signature, and this signature is something we could fix as a parameter at the start of a module. Thus, we might start an \defn{anonymous submodule} of the main module with a line like\footnote{The \af{Signature} type will be defined in Section~\ref{sec:oper-sign}.}
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaUnderscore\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\ccpad
Such a module is called \emph{anonymous} because an underscore appears in place of a module name. Agda determines where a submodule ends by indentation.  This can take some getting used to, but after a short time it will feel very natural. The main module of a file must have the same name as the file, without the \texttt{.agda} or \texttt{.lagda} file extension.  The code inside the main module is not indented. Submodules are declared inside the main module and code inside these submodules must be indented to a fixed column.  As long as the code is indented, Agda considers it part of the submodule.  A submodule is exited as soon as a nonindented line of code appears.




\paragraph*{Agda's universe hierarchy}\label{ssec:agdas-universe-hierarchy}
The \agdaualib adopts the notation of Martin Escardo's \typetopology library~\cite{MHE}. In particular, \emph{universe levels}%
\footnote{See \url{https://agda.readthedocs.io/en/v2.6.1.2/language/universe-levels.html}.}
are denoted by capitalized script letters from the second half of the alphabet, e.g., \ab ùì§, \ab ùì•, \ab ùì¶, etc.  Also defined in \typetopology are the operators~\af Ãá~and~\af ‚Å∫. These map a universe level \ab ùì§ to the universe \ab ùì§\af Ãá := \Set \ab ùì§ and the level \ab ùì§ \af ‚Å∫ \aod := \lsuc \ab ùì§, respectively.  Thus, \ab ùì§\af Ãá is simply an alias for the universe \Set \ab ùì§, and we have \ab ùì§\af Ãá \as : \ab ùì§ \af ‚Å∫\af Ãá.
%% Table~\ref{tab:dictionary} translates between standard \agda syntax and \typetopology/\ualib notation.

To justify the introduction of this somewhat nonstandard notation for universe levels, \escardo points out that the Agda library uses \ak{Level} for universes (so what we write as \ab ùì§\af Ãá is written \ak{Set}~\ab ùì§ in standard Agda), but in univalent mathematics the types in \ab ùì§\af Ãá need not be sets, so the standard Agda notation can be a bit confusing, especially to new users.


The hierarchy of universes in Agda is structured as \ab{ùì§}\af Ãá \as : \ab ùì§ \af ‚Å∫\af Ãá, \hskip3mm
\ab{ùì§} \af ‚Å∫\af Ãá \as : \ab ùì§ \af ‚Å∫\af ‚Å∫\af Ãá, etc. This means that the universe \ab ùì§\af Ãá has type \ab ùì§  \af ‚Å∫\af Ãá, and ùì§ \af ‚Å∫\af Ãá has type \ab ùì§ \af ‚Å∫\af ‚Å∫\af Ãá, and so on.  It is important to note, however, this does \emph{not} imply that \ab ùì§\af Ãá \as : \ab ùì§ \af ‚Å∫\af ‚Å∫\af Ãá. In other words, Agda's universe hierarchy is \emph{noncummulative}. This makes it possible to treat universe levels more generally and precisely, which is nice. On the other hand, a noncummulative hierarchy can sometimes make for a nonfun proof assistant. Luckily, there are ways to circumvent noncummulativity without introducing logical inconsistencies into the type theory. Section~\ref{lifts-of-algebras} describes some domain-specific tools that we developed for this purpose.








\subsubsection{Dependent types}\label{sec:dependent-types}

\newcommand\FstUnder{\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}}\xspace}
\newcommand\SndUnder{\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}}\xspace}
% Convenient notations for the first and second projections out of a product are \FstUnder and \SndUnder, respectively. However, to improve readability or to avoid notation clashes with other modules, we sometimes use more standard alternatives, such as \AgdaFunction{pr‚ÇÅ} and \AgdaFunction{pr‚ÇÇ}, or \AgdaFunction{fst} and \AgdaFunction{snd}, or some combination of these. The definitions are standard so we omit them.\footnote{For details see~\cite{DeMeo:2021} or \ualiburl{Prelude.Preliminaries}.}








\paragraph*{Sigma types (dependent pairs)} %\label{ssec:dependent-pairs}

Given universes \ab ùì§ and \ab ùì•, a type \ab{X} \as : \ab ùì§\af Ãá, and a type family \ab{Y}~\as :~\ab X~\as ‚Üí~\ab ùì•\af Ãá, the \defn{Sigma type} (aka \defn{dependent pair type}, aka \defn{dependent product type}) is denoted by \ar{Œ£}(\ab x~\af Íûâ~\ab X),~\ab Y~\ab x and generalizes the Cartesian product \ab{X} \af √ó \ab Y by allowing the type \ab{Y x} of the second argument of the ordered pair (\ab x \af , \ab y) to depend on the value \ab{x} of the first. That is, an inhabitant of the type \ar{Œ£}(\ab x~\af Íûâ~\ab X),~\ab Y~\ab x is a pair (\ab{x}~\af ,~\ab y) such that \abt{x}{X}
and \abt{y}{Y x}.

Agda's default syntax for a Sigma type is \AgdaRecord{Œ£}\sP{3}\AgdaSymbol{Œª}(\ab x\sP{3}Íûâ\sP{3}\ab X)\sP{3}\as ‚Üí\sP{3}\ab Y, but we prefer the notation \AgdaRecord{Œ£}~\ab x~Íûâ~\ab X~,~\ab Y, which is closer to the standard syntax described in the preceding paragraph. Fortunately, this preferred notation is available in the \typetopology library (see~\cite[Œ£ types]{MHE}).\footnote{\textbf{WARNING!} The symbol \as Íûâ in the expression \AgdaRecord{Œ£}\sP{3}\ab x\sP{3}\as Íûâ\sP{3}\ab X\sP{3}\AgdaComma\sP{3}\ab Y is not the ordinary colon; rather, it is the symbol obtained by typing \texttt{\textbackslash{}:4} in \agdatwomode.} For pedagogical purposes we repeat this definition here, inside a \defn{hidden module} so that it doesn't conflict with the original definition that we will import later.\footnote{To hide code from the rest of the development, we enclose it in a named module.  For example, the code inside the \af{hide-sigma} module will not conflict with the original definitions from the \typetopology library, even though we import the latter right after presenting the definition.  As long as we don't invoke \ak{open} \af{hide-sigma}, the code inside the \af{hide-sigma} module remains essentially hidden (though Agda will type-check the code for us). It may seem odd to both define things in the hidden module only to immediately import the definition that we actually use, but we do this in an attempt to exhibit all of the types on which the \ualib depends, in a clear and self-contained way, while also ensuring that this cannot be misinterpreted as a claim to originality.}
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{hide-sigma}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Œ£}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}%
\>[53]\AgdaKeyword{where}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaField{pr‚ÇÅ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
%
\>[3]\AgdaField{pr‚ÇÇ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaField{pr‚ÇÅ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{50}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\<%
\end{code}
\scpad
% For this dependent pair type, we prefer the notation \ar{Œ£}~\ab x~\af Íûâ~\ab X~\af ,~\ab y, which is more pleasing and more standard than Agda's default syntax, \ar{Œ£}~\as Œª(\ab x~\as Íûâ~\ab X)~\as ‚Üí~\ab y. Escard√≥ makes this preferred notation available in the \typetopology library by making the index type explicit, as follows.
\ccpad
\begin{code}%
\>[1]\AgdaFunction{-Œ£}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{-Œ£}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{Œ£}\AgdaSpace{}%
\AgdaBound{Y}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{syntax}\AgdaSpace{}%
\AgdaFunction{-Œ£}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{(Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{Y}\<%
\end{code}
\scpad
% \textbf{WARNING!} The symbol \af Íûâ is not the same as \as : despite how similar they may look. The correct colon in the expression \ar{Œ£}~\ab x~\af Íûâ~\ab X~\af ,~\ab y, above is obtained by typing \texttt{\textbackslash{}:4} in \agdamode.

A special case of the Sigma type is the one in which the type \ab{Y} doesn't depend on \ab{X}. This is the usual Cartesian product, defined in Agda as follows.
\ccpad
\begin{code}%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}√ó\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{√ó}}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{Y}\<%
\end{code}
\ccpad
Now that we have repeated these definitions from the \ualib for illustration purposes, let us import the original
definitions that we will use throughout the \ualib.
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Sigma-Type}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{50}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{MGS-MLTT}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{pr‚ÇÅ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{pr‚ÇÇ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}√ó\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{-Œ£}\AgdaSymbol{)}\<%
\end{code}
\ccpad
The definition of \ar Œ£ (and thus, of \af √ó) includes the fields  \af{pr‚ÇÅ} and \af{pr‚ÇÇ} representing the first and second projections out of the product.  Sometimes we prefer to denote these projections with the notation \af{‚à£\_‚à£} and \af{‚à•\_‚à•}, respectively. However, for emphasis or readability we alternate between these and the following standard notations: \af{pr‚ÇÅ} and \af{fst} for the first projection, \af{pr‚ÇÇ} and \af{snd} for the second.  We define these alternative notations for projections out of pairs as follows.
% \footnote{We have made a concerted effort to avoid duplicating types that are already provided elsewhere, such as the \typetopology library.  We occasionally repeat the definitions of such types for pedagogical purposes, but we always import and work with the original definitions in order to make the sources known and to credit the original authors.}
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}}\AgdaSpace{}%
\AgdaFunction{fst}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}\{}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaRecord{Œ£}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
%
\>[1]\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[1]\AgdaFunction{fst}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}}\AgdaSpace{}%
\AgdaFunction{snd}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}\{}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Œ£}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{pr‚ÇÅ}\AgdaSpace{}%
\AgdaBound{z}\AgdaSymbol{)}\<%
\\
%
\>[1]\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[1]\AgdaFunction{snd}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}
\ccpad
Note that we put the definitions above inside an \defn{anonymous module}, which starts with the \ak{module} keyword followed by an underscore (instead of a module name). The purpose is simply to move the postulated typing judgments---the ``parameters'' of the module (e.g., `ùì§ : Universe`)---out of the way so they don't obfuscate the definitions inside the module.





\paragraph*{Pi types (dependent functions)} %\label{ssec:dependent-functions}
Given universes \ab ùì§ and \ab ùì•, a type \ab{X} \as : \ab ùì§\af Ãá, and a type family \ab{Y}~\as :~\ab X~\as ‚Üí~\ab ùì•\af Ãá, the \defn{Pi type} (aka \defn{dependent function type}) is denoted by \ar Œ†(\ab x~\af :~\ab X),~\ab Y~\ab x and generalizes the function type \ab X \as ‚Üí \ab Y by letting the type \ab Y~\ab x of the codomain depend on the value \ab x of the domain type. The dependent function type is defined in the \typetopology in a standard way.  For the reader's benefit, however, we repeat the definition here inside a hidden module.
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{hide-pi}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaFunction{Œ†}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{Œ†}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
\ccpad
To make the syntax for \af{Œ†} conform to the standard notation for Pi types, \escardo uses the same trick as the one used above for Sigma types.\footnote{\textbf{WARNING!} The symbol \af Íûâ is not the same as \as : despite how similar they may look. The correct colon in the expression \af{Œ†}~\ab x~\as Íûâ~\ab X~\af ,~\ab y above is obtained by typing \texttt{\textbackslash{}:4} in \agdamode.}
\ccpad
\begin{code}
\>[1]\AgdaFunction{-Œ†}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{)(}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{-Œ†}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ†}\AgdaSpace{}%
\AgdaBound{Y}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{-1}\AgdaSpace{}%
\AgdaFunction{-Œ†}\<%
\\
%
\>[1]\AgdaKeyword{syntax}\AgdaSpace{}%
\AgdaFunction{-Œ†}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{(Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{b}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ†}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{b}\<%
\end{code}


