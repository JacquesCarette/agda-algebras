% -*- TeX-master: "ualib-part1.tex" -*-
%%% Local Variables: 
%%% mode: latex
%%% TeX-engine: 'xetex
%%% End:
Here we discuss \defn{truncation} and \defn{h-sets} (which we just call \defn{sets}). We first give a brief discussion of standard notions of \emph{truncation} from a viewpoint that seems useful for formalizing mathematics in Agda.\footnote{Readers wishing to learn more about truncation may wish to consult~\cite[\S34]{MHE},~\cite{Brunerie:2012}, or~\cite[\S7.1]{HoTT}.}

\subsubsection*{Uniqueness of identity proofs} %\label{sec:uniq-ident-proofs}
This brief introduction is intended for novices; those already familiar with the concept of \emph{truncation} and \emph{uniqueness of identity proofs} may want to skip to the next subsection.

In general, we may have multiple inhabitants of a given type, hence (via Curry-Howard) multiple proofs of a given proposition. For instance, suppose we have a type \ab{X} and an identity relation \aod{\_‚â°‚ÇÄ\_} on \ab{X} so that, given two inhabitants of \ab{X}, say, \ab{a} \ab b \as : \ab X, we can form the type \ab{a} \aod{‚â°‚ÇÄ} \ab b. Suppose \ab{p} and \ab{q} inhabit the type \ab{a} \aod{‚â°‚ÇÄ} \ab b; that is, \ab{p} and \ab{q} are proofs of \ab{a} \aod{‚â°‚ÇÄ} \ab b, in which case we write \ab{p} \ab q \as : \ab a \aod{‚â°‚ÇÄ} \ab b. We might then wonder whether the two proofs \ab{p} and \ab{q} are equivalent.

We are asking about an identity type on the identity type \aod{‚â°‚ÇÄ}, and whether there is some inhabitant, say, \ab{r} of this type; i.e., whether there is a proof \ab{r} \as : \ab p \aod{‚â°‚ÇÅ} \ab q that the proofs of \ab{a} \aod{‚â°‚ÇÄ} \ab{b} are the same. If such a proof exists for all \ab{p} \ab q \as : \ab{a} \aod{‚â°‚ÇÄ} \ab b, then the proof of \ab a \aod{‚â°‚ÇÄ} \ab b is unique; as a property of the types \ab{X} and \ad{‚â°‚ÇÄ}, this is sometimes called \defn{uniqueness of identity proofs}.

Now, perhaps we have two proofs, say, \ab{r} \ab s \as : \ab p \aod{‚â°‚ÇÅ} \ab q that the proofs \ab{p} and \ab{q} are equivalent. Then of course we wonder whether \ab{r} \aod{‚â°‚ÇÇ} \ab s has a proof!  But at some level we may decide that the potential to distinguish two proofs of an identity in a meaningful way (so-called \emph{proof-relevance}) is not useful or desirable. At that point, say, at level \ab{k}, we would be naturally inclined to assume that there is at most one proof of any identity of the form \ab{p} \aod{‚â°‚Çñ} \ab q. This is called \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#truncation}{truncation} (at level \ab{k}).

\paragraph*{Sets} %\label{sec:sets}
In \href{https://homotopytypetheory.org}{homotopy type theory}, a type \ab{X} with an identity relation \ad{‚â°‚ÇÄ} is called a \defn{set} (or \defn{0-groupoid}) if for every pair \ab{x} \abt{y}{X} there is at most one proof of \ab{x} \aod{‚â°‚ÇÄ} \ab y. In other words, the type \ab{X}, along with it's equality type \ad{‚â°‚Çì}, form a \emph{set} if for all \ab{x} \abt{y}{X} there is at most one proof of \ab{x} \aod{‚â°‚ÇÄ} \ab y.

This notion is formalized in \typtop using the type \af{is-set} which is defined using the \af{is-subsingleton} type (\S\ref{sec:inverse-image-invers}) as follows.
\ccpad
\begin{code}%
\>[1]\AgdaFunction{is-set}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{is-set}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{is-subsingleton}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\end{code}
\ccpad
Thus, the pair (\ab{X} , \ad{‚â°‚ÇÄ}) forms a set iff it satisfies \as{‚àÄ} \ab x \abt{y}{X} \as ‚Üí \af{is-subsingleton} (\ab x \aod{‚â°‚ÇÄ} \ab y).

We will also need the function
\href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#sigmaequality}{to-Œ£-‚â°},
which is part of Escard√≥'s characterization of \emph{equality in Sigma types} in~\cite{MHE} and is defined as follows.
\ccpad
\begin{code}%
\>[1]\AgdaFunction{to-Œ£-‚â°}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\>[111I]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{œÉ}\AgdaSpace{}%
\AgdaBound{œÑ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Œ£}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{‚Üí}%
\>[.][@{}l@{}]\<[111I]%
\>[10]\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{œÉ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{œÑ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{transport}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{œÉ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{œÑ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\<%
\\
% \>[.][@{}l@{}]\<[111I]%
% \>[10]\AgdaComment{--------------------------------------------------------------}\<%
% \\
\>[2]\AgdaSymbol{‚Üí}%
\>[10]\AgdaBound{œÉ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{œÑ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{to-Œ£-‚â°}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)\}}\<%
\end{code}
\ccpad
We will use \af{is-embedding}, \af{is-set}, and \af{to-Œ£-‚â°} in the next subsection to prove that a monic function into a set is an embedding.

\paragraph*{Injective functions are set embeddings} %\label{injective-functions-are-set-embeddings}
Before moving on to define propositions, we discharge an obligation mentioned but left unfulfilled in the
\href{https://ualib.gitlab.io/Overture.Inverses.html\#embeddings}{embeddings} section of the \ualibhtml{Overture.Inverses} module. Recall, we described and imported the \af{is-embedding} type, and we remarked that an embedding is not simply a monic function. However, if we assume that the codomain is truncated so as to have unique identity proofs, then we can prove that every monic function into that codomain will be an embedding. On the other hand, embeddings are always monic, so we will end up with an equivalence.
% Assume the context contains the following typing judgments: \AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}\AgdaBound{ùì¶}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{ùì§}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}\{}\AgdaBound{B}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{ùì¶}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}}.
\ccpad
\begin{code}%
\>[1]\AgdaFunction{monic-is-embedding|Set}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[143I]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{is-set}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Monic}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{is-embedding}\AgdaSpace{}%
\AgdaBound{f}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{monic-is-embedding|Set}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{Bset}\AgdaSpace{}%
\AgdaBound{fmon}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{fu‚â°b}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{fv‚â°b}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ≥}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\<%
\\
%
\>[2]\AgdaFunction{fuv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{v}\<%
\\
%
\>[2]\AgdaFunction{fuv}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{‚â°-trans}\AgdaSpace{}%
\AgdaBound{fu‚â°b}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{fv‚â°b}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚Åª¬π}}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{uv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{v}\<%
\\
%
\>[2]\AgdaFunction{uv}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{fmon}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaFunction{fuv}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{arg1}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{transport}\AgdaSpace{}%
\AgdaSymbol{(Œª}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{fu‚â°b}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{fv‚â°b}\<%
\\
%
\>[2]\AgdaFunction{arg1}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{uv}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Bset}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{transport}\AgdaSpace{}%
\AgdaSymbol{(Œª}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{uv}\AgdaSpace{}%
\AgdaBound{fu‚â°b}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{fv‚â°b}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{Œ≥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{fu‚â°b}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{fv‚â°b}\<%
\\
%
\>[2]\AgdaFunction{Œ≥}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{to-Œ£-‚â°}\AgdaSpace{}%
\AgdaFunction{arg1}\<%
\end{code}
\ccpad
In stating the previous result, we introduce a new convention to which we will try to adhere. If the antecedent of a theorem includes the assumption that one of the types involved is a set, then we add to the name of the theorem the suffix \af{\textbar{}sets}, which calls to mind the standard notation for the restriction of a function to a subset of its domain.

Embeddings are always monic, so we conclude that when a function's codomain is a set, then that function is an embedding if and only if it is monic.
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{embedding-iff-monic|Set}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[234I]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{is-set}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{is-embedding}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚áî}}\AgdaSpace{}%
\AgdaFunction{Monic}\AgdaSpace{}%
\AgdaBound{f}\<%
\\
\>[1]\AgdaFunction{embedding-iff-monic|Set}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{Bset}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{embedding-is-monic}\AgdaSpace{}%
\AgdaBound{f}\AgdaSymbol{)}\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{monic-is-embedding|Set}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{Bset}\AgdaSymbol{)}\<%
\end{code}
