% -*- TeX-master: "ualib-part1.tex" -*-
%%% Local Variables: 
%%% mode: latex
%%% TeX-engine: 'xetex
%%% End:
Here we present the submodules of the \agdaualib's \ualibhtml{Relations} module. In \S\ref{sec:discrete-relations} we define types that represent \emph{unary} and \emph{binary relations}, which we refer to as ``discrete relations'' to contrast them with the (``continuous'') \emph{general} and \emph{dependent relations} that we introduce in \S\ref{sec:continuous-relations}. We call the latter ``continuous relations'' because they can have arbitrary arity (general relations) and they can be defined over arbitrary families of types (dependent relations).




\subsubsection{Unary relations}

In set theory, given two sets \ab A and \ab P, we say that \ab P is a \defn{subset} of \ab A, and we write \ab P \af ⊆ \ab A, just in case \as ∀~\ab x~(\ab x~\af ∈~\ab P~\as →~\ab x~\af ∈~\ab A). We need a mechanism for representing this notion in Agda. A typical approach is to use a \emph{predicate} type, denoted by \af{Pred}.

Given two universes \ab 𝓤 \ab 𝓦 and a type \ab A~\as :~\ab 𝓤\af ̇, the type \af{Pred}~\ab A~\ab 𝓦 represents \emph{properties} that inhabitants of \ab A may or may not satisfy.  We write \ab P~\as :~\af{Pred}~\ab A~\ab 𝓤 to represent the semantic concept of the collection of inhabitants of \ab A that satisfy (or belong to) \ab P. Here is the definition.\footnote{\label{relunary}cf.~\texttt{Relation/Unary.agda} in the \agdastdlib.}
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓤}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓦}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓦}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓦}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓦}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\end{code}
\ccpad
% To reiterate, given a type \ab A \as : \ab 𝓤\af ̇, we think of \af{Pred} \ab A \ab 𝓦 as the type of a property that inhabitants of \ab A may or may not satisfy. If \ab P \as : \af{Pred} \ab A \ab 𝓦, then we view \ab P as a collection of inhabitants of type \ab A that ``satisfy property \ab P,'' or that ``belong to the subset \ab P of \ab A.''
Later we consider predicates over the class of algebras in a given signature. In the \ualibhtml{Algebras} module we will define the type \af{Algebra} \ab 𝓤 \ab 𝑆 of \ab 𝑆-algebras with domain type \ab 𝓤\af ̇, and the type \af{Pred} (\af{Algebra} \ab 𝓤 \ab 𝑆) \ab 𝓦 will represent classes of \ab 𝑆-algebras with certain properties.





\subsubsection{Membership and inclusion relations}\label{membership-and-inclusion-relations}

Like the \agdastdlib, the \ualib includes types that represent the \emph{element inclusion} and \emph{subset inclusion} relations from set theory. For example, given a predicate \af P, we may represent that  ``\ab x belongs to \af P'' or that ``\ab x has property \af{P},'' by writing either \ab x \af ∈ \af P or \af P \ab x.  The definition of \af ∈ is standard. Nonetheless, here it is.\cref{relunary}
\ccpad
\begin{code}%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
% \AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓧}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
% \AgdaSymbol{\}}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓨}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
\ccpad
The \textit{subset} relation is denoted, as usual, with the \af{⊆} symbol and is defined as follows.\cref{relunary}
\ccpad
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊆\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
% \AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓧}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
% \AgdaSymbol{\}}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓩}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊆}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{x}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaBound{Q}\<%
\end{code}

\subsubsection{The axiom of extensionality}\label{sec:axiom-ext}
In type theory everything is represented as a type and, as we have just seen, this includes subsets.  Equality of types is a nontrivial matter, and thus so is equality of subsets when represented as unary predicates.  Fortunately, it is straightforward to write down a type that represents what it typically means in informal mathematics to say that two subsets are (extensionally) equal---namely, they contain the same elements. In the \ualib we denote this type by \af{≐} and define it as follows.\footnote{\label{uhints}%
  \textbf{Unicode Hints}. In \agdamode, \texttt{\textbackslash{}.=} ↝ \af{≐}, \texttt{\textbackslash{}u+} ↝ \af{⊎}, \texttt{\textbackslash{}b0} ↝ \af 𝟘, \texttt{\textbackslash{}B0} ↝ \af 𝟎, \texttt{\textbackslash{}b1} ↝ \af 𝟙, \texttt{\textbackslash{}B1} ↝ \af 𝟏.}
\ccpad
\begin{code}
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≐\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
% \AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaBound{𝓨}\AgdaSpace{}%
% \AgdaBound{𝓩}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
% \AgdaSymbol{\}}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≐}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊆}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊆}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\<%
\end{code}
\ccpad
A proof of \ab P \aof{≐} Q is a pair (\ab p , \ab q) where \ab p~\as :~\ab P~\aof ⊆~\ab Q and \ab q :~\ab Q~\aof ⊆~\ab P are proofs of the first and second inclusions, respectively. If \ab P and \ab Q are definitionally equal (i.e., \ab P \aod ≡ \ab Q), then both \ab P~\aof ⊆~\ab Q and \ab Q~\aof ⊆~\ab P hold, so \ab P \aof ≐ \ab Q also holds, as we now confirm.
\ccpad
\begin{code}%
\>[0]\AgdaFunction{Pred-≡}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
% \AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaBound{𝓨}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}}
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≐}}\AgdaSpace{}%
\AgdaBound{Q}\<%
\\
\>[0]\AgdaFunction{Pred-≡}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{z}\AgdaSymbol{)}\<%
\end{code}
\ccpad
The converse of \af{Pred-≡} is not provable in Martin-L\"of Type Theory. However, we can postulate it axiomatically if we wish. This is called the \defn{axiom of extensionality} and a type that represents this axiom is the following.
\ccpad
\begin{code}%
\>[0]\AgdaFunction{ext-axiom}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
% \AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaFunction{ext-axiom}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≐}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{Q}\<%
\end{code}
\ccpad
Note that the type \af{ext-axiom} does not itself postulate the axiom of extensionality.  It merely defines the axiom.  If we want to postulate it, we must assume we have a witness, or inhabitant of the type. We could do this in Agda in a number of ways, but probably the easiest is to simply add the witness as a parameter to a module, like so.\footnote{Agda also has a \ak{postulate} mechanism that we could use, but this would require omitting the \AgdaPragma{--safe} pragma from the \ak{OPTIONS} directive at the start of the module.}
\ccpad
\begin{code}
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{ext-axiom-postulated}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ea}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{ext-axiom}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\ccpad
We treat other notions of extensionality in \S\ref{function-extensionality} and \S\ref{sec:trunc-sets-prop}.

\paragraph*{Predicates toolbox}
Here is a small collection of tools that will come in handy later. The first provides convenient notation for asserting that the image of a function (the first argument) is contained in a predicate (the second argument).
\ccpad
\begin{code}
\>[1]\AgdaOperator{\AgdaFunction{Im\AgdaUnderscore{}⊆\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaOperator{\AgdaFunction{Im}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaFunction{⊆}\AgdaSpace{}%
\AgdaBound{S}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaBound{S}\<%
\end{code}
\ccpad
The following inductive type represents \defn{disjoint union}.\cref{uhints}
\ccpad
\begin{code}
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊎\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\>[1]\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{B}\<%
\end{code}
\ccpad
And this can be used to represent \defn{union}, as follows.
\ccpad
\begin{code}
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∪\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaBound{Q}\<%
\end{code}
\ccpad
The \defn{empty set} is naturally represented by the \defn{empty type}, \af 𝟘, and the latter is defined in \typetopology's \am{Empty-Type} module.\cref{uhints}$^, $\footnote{%
The empty type is defined in \typetopology's \am{Empty-Type} module as an inductive type with no constructors; that is, \AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{𝟘}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝓤}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaKeyword{where}\AgdaSpace{}%
\AgdaComment{-- (empty body)}.}
\ccpad
\begin{code}
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Empty-Type}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{𝟘}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{∅}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaPrimitive{𝓤₀}\<%
\\
\>[0]\AgdaFunction{∅}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{𝟘}\<%
\end{code}
\ccpad
Before closing our little predicates toolbox, let's insert a type that provides a natural way to represent \defn{singletons}.
\ccpad
\begin{code}
\>[0]\AgdaOperator{\AgdaFunction{｛\AgdaUnderscore{}｝}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{｛}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{｝}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡\AgdaUnderscore{}}}\<%
\end{code}





\subsubsection{Binary Relations}\label{sec:binary-relations}

In set theory, a binary relation on a set \ab{A} is simply a subset of the Cartesian product \ab A × \ab A. As such, we could model such a relation as a (unary) predicate over the product type \ab A \af × \ab A, or as an inhabitant of the function type \ab A \as → \ab A \as → \ab 𝓡\af ̇ (for some universe \ab 𝓡).  Note, however, this is not the same as a unary predicate over the function type \ab A \as → \ab A since the latter has type  (\ab A~\as →~\ab A)~\as →~\ab 𝓡\af ̇, while a binary relation should have type \ab A~\as →~(\ab A~\as →~\ab 𝓡\af ̇). 
% \footnote{Note that a binary relation from \ab A to \ab B is not simply a unary predicate over the type \ab A~\as →~\ab B.  The binary relation has type \ab A~\as →~(\ab B~\as →~\ab 𝓝\af ̇) whereas a unary predicate over \ab A~\as →~\ab B has type (\ab A~\as →~\ab B)~\as →~\ab 𝓝\af ̇.}

A generalization of the notion of binary relation is a \emph{relation from} \ab{A} \emph{to} \ab{B}, which we define first and treat binary relations on a single \ab{A} as a special case.
\ccpad
\begin{code}
\>[1]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓤}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓡}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓡}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}\AgdaSymbol{)}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓝}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓤}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓝}\<%
\end{code}

\paragraph*{The kernel of a function}
The \defn{kernel} of a function \ab f \as : \ab A \AgdaSymbol{→} \ab B is defined informally by \{(\ab x , \ab y) ∈ \ab A × \ab A : \ab f \ab x = \ab f \ab y\}. This can be represented in type theory in a number of ways, each of which may be useful in a particular context. For example, we could define the kernel to be an inhabitant of a (binary) relation type, a (unary) predicate type, a (curried) Sigma type, or an (uncurried) Sigma type. The alternatives are defined in the \ualib as follows.
\ccpad
\begin{code}%
\>[1]\AgdaFunction{ker}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓡}\<%
\\
%
\>[1]\AgdaFunction{ker}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{kernel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{𝓡}\<%
\\
%
\>[1]\AgdaFunction{kernel}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{ker-sigma}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{ker-sigma}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{ker-sigma'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{ker-sigma'}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{(x}\AgdaSpace{}%
\AgdaBound{,}\AgdaSpace{}%
\AgdaBound{y)}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}
\ccpad
Similarly, the \defn{identity relation} (which is equivalent to the kernel of an injective function) can be represented using any one of the following types.\cref{uhints}
\ccpad
\begin{code}%
\>[1]\AgdaFunction{𝟎}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓤}\<%
\\
%
\>[1]\AgdaFunction{𝟎}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{b}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{𝟎-pred}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{𝓤}\<%
\\
%
\>[1]\AgdaFunction{𝟎-pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{a'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{a'}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{𝟎-sigma}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{𝟎-sigma}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{b}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{𝟎-sigma'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{𝟎-sigma'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{(x}\AgdaSpace{}%
\AgdaBound{,}\AgdaSpace{}%
\AgdaBound{y)}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}
\ccpad
Finally, the \defn{total relation} over \ab A, which in set theory is the full Cartesian product \ab A~\af ×~\ab A, can be represented using the one-element type from \typetopology's \am{Unit-Type} module, as follows.\cref{uhints}$^, $\footnote{%
The one-element type is defined in \typetopology's \am{Unit-Type} module as an inductive type with a single constructor, denoted \AgdaInductiveConstructor{⋆}, as follows: \AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{𝟙}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝓤}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaKeyword{where}\AgdaSpace{}\AgdaInductiveConstructor{⋆}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{𝟙}.}
\ccpad
\begin{code}%
\>[1]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Unit-Type}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{𝟙}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{𝟏}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaPrimitive{𝓤₀}\<%
\\
%
\>[1]\AgdaFunction{𝟏}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{𝟙}\<%
\end{code}


\paragraph*{The implication relation}

We define the following types representing \defn{implication} for binary relations. (These are borrowed from the \agdastdlib; we merely translate them into \typetopology/\ualib notation.)
\ccpad
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}on\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
% \>[100I]\AgdaSymbol{\{}\AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaBound{𝓨}\AgdaSpace{}%
% \AgdaBound{𝓩}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}\{}\AgdaBound{B}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓨}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}\{}\AgdaBound{C}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓩}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}}\<%
% \\
% \>[0][@{}l@{\AgdaIndent{0}}]%
% \>[1]
% \AgdaSymbol{→}%
% \>[.][@{}l@{}]\<[100I]%
% \>[7]
\AgdaSymbol{(}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{C}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{C}\AgdaSymbol{)}\<%
\\
%
% \\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaBound{R}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{on}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
% \\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
% \>[101I]\AgdaSymbol{\{}\AgdaBound{𝓦}\AgdaSpace{}%
% \AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaBound{𝓨}\AgdaSpace{}%
% \AgdaBound{𝓩}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓦}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
% \AgdaSymbol{\}}\AgdaSpace{}%
% \AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
% \AgdaSymbol{\}}\<%
% \\
% \>[0][@{}l@{\AgdaIndent{0}}]%
% \>[1]
% \AgdaSymbol{→}%
% \>[.][@{}l@{}]\<[101I]%
% \>[6]
\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓦}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
% \\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⇒}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\<%
\end{code}
\ccpad
These combine to give a nice, general implication operation (also borrowed from the \agdastdlib).
\ccpad
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}=[\AgdaUnderscore{}]⇒\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
% \>[102I]\AgdaSymbol{\{}\AgdaBound{𝓦}\AgdaSpace{}%
% \AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaBound{𝓨}\AgdaSpace{}%
% \AgdaBound{𝓩}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓦}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
% \AgdaSymbol{\}}\AgdaSpace{}%
% \AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓧}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
% \AgdaSymbol{\}}\<%
% \\
% \>[0][@{}l@{\AgdaIndent{0}}]%
% \>[1]\AgdaSymbol{→}%
% \>[.][@{}l@{}]\<[102I]%
% \>[10]
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓦}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓨}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓩}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
% \\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{=[}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]⇒}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⇒}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{on}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSymbol{)}\<%
\end{code}

\paragraph*{Compatibility of functions and binary relations}%\label{compatibility-of-functions-and-binary-relations}

Before discussing general and dependent relations, we pause to define some types that are useful for asserting and proving facts about \emph{compatibility} of functions with binary relations. The first definition simply lifts a binary relation on \ab A to a binary relation on tuples of type \ab I \as → \ab A.\footnote{N.B. This \emph{relation} lifting is not to be confused with the sort of \emph{universe} lifting that we defined in the \ualibhtml{Prelude.Lifts} module.}
\ccpad
\begin{code}%
% \>[0]\AgdaKeyword{module}\AgdaSpace{}%
% \AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
% \AgdaSymbol{\{}\AgdaBound{𝓤}\AgdaSpace{}%
% \AgdaBound{𝓥}\AgdaSpace{}%
% \AgdaBound{𝓦}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{I}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓥}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaBound{𝓤}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\AgdaSymbol{\}}\AgdaSpace{}%
% \AgdaKeyword{where}\<%
% \\
% %
% \\[\AgdaEmptyExtraSkip]%
% \>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓦}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓦}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}
\scpad
% \\
% %
% \\[\AgdaEmptyExtraSkip]%
% %
\begin{code}
\>[1]\AgdaFunction{compatible-fun}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)(}\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓦}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓦}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaFunction{compatible-fun}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{R}%
\>[21]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaBound{R}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{=[}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]⇒}}\AgdaSpace{}%
\AgdaBound{R}\<%
\end{code}
% \ccpad
% We used the slick implication notation in the definition of \af{compatible-fun}, but we could have defined it more explicitly, like so.
% \ccpad
% \begin{code}%
% \>[0][@{}l@{\AgdaIndent{1}}]%
% \>[1]\AgdaFunction{compatible-fun'}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
% \AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
% \AgdaBound{A}\AgdaSymbol{)(}\AgdaBound{R}\AgdaSpace{}%
% \AgdaSymbol{:}\AgdaSpace{}%
% \AgdaFunction{Rel}\AgdaSpace{}%
% \AgdaBound{A}\AgdaSpace{}%
% \AgdaBound{𝓦}\AgdaSymbol{)}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
% \AgdaBound{𝓥}\AgdaSpace{}%
% \AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
% \AgdaBound{𝓤}\AgdaSpace{}%
% \AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
% \AgdaBound{𝓦}\AgdaSpace{}%
% \AgdaOperator{\AgdaFunction{̇}}\<%
% \\
% %
% \>[1]\AgdaFunction{compatible-fun'}\AgdaSpace{}%
% \AgdaBound{f}\AgdaSpace{}%
% \AgdaBound{R}%
% \>[22]\AgdaSymbol{=}\AgdaSpace{}%
% \AgdaSymbol{∀}\AgdaSpace{}%
% \AgdaBound{x}\AgdaSpace{}%
% \AgdaBound{y}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
% \AgdaSymbol{(}\AgdaFunction{lift-rel}\AgdaSpace{}%
% \AgdaBound{R}\AgdaSymbol{)}\AgdaSpace{}%
% \AgdaBound{x}\AgdaSpace{}%
% \AgdaBound{y}\AgdaSpace{}%
% \AgdaSymbol{→}\AgdaSpace{}%
% \AgdaBound{R}\AgdaSpace{}%
% \AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
% \AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
% \AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
% \AgdaBound{y}\AgdaSymbol{)}\<%
% \end{code}
% \ccpad
% However, this is a rare case in which the more elegant syntax may result in simpler proofs when applying the definition. (See, for example, \af{compatible-term} in the \ualibhtml{Terms.Operations} module.)
