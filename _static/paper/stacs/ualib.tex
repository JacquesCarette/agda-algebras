\documentclass[a4paper,USenglish,cleveref,autoref,thm-restate]{lipics-v2019}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory
\usepackage{mymacros}
\usepackage{todonotes}
\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Universal Algebra in Martin-L\"of Type Theory\\ with Agda} %TODO Please add
\titlerunning{Universal Algebra in MLTT with Agda} %TODO optional, please use if title is longer than one line

\author{William DeMeo}{Department of Algebra, Faculty of Mathematics and Physics, Charles University, Czech Republic}{williamdemeo@gmail.com}{https://orcid.org/0000-0003-1832-5690}{}
\author{Hyeyoung Shin}{Faculty of Information Technology, Czech Technical University, Czech Republic}{hyeyoungshinw@gmail.com}{}{}
\author{Siva Somayyajula}{Department of Computer Science, Carnegie Mellon University, USA}{ssomayya@andrew.cmu.edu}{}{}

\authorrunning{W.~DeMeo, H.~Shin, S.~Somayyajula}
\Copyright{William DeMeo, Hyeyoung Shin, Siva Somayyajula}
%
%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm
\ccsdesc[500]{Theory of computation~Logic and verification}
\ccsdesc[300]{Theory of computation~Constructive mathematics}
\ccsdesc[300]{Theory of computation~Type theory}
\ccsdesc[300]{Computing methodologies~Representation of mathematical objects}

\keywords{universal algebra, formalization of mathematics, equational logic, type theory, constructive mathematics}
%% \category{} %optional, e.g. invited paper

%% \relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%% \relatedversion{An extended version of the paper is available at \url{...}.}

\supplement{\agdaualib source code: \href{https://gitlab.com/ualib/ualib.gitlab.io/}{https://gitlab.com/ualib/ualib.gitlab.io/}\\\phantom{\textbf{Supplementary Mater}}\agdaualib documentation: \href{https://ualib.org}{https://ualib.org}}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{The authors thank Clifford Bergman, Venanzio Capretta, Andrej Bauer, Miklós Maróti, and Ralph Freese, for helpful discussions and encouragement.  The \agdaualib has also benefited substantially from \href{https://www.cs.bham.ac.uk/~mhe}{Martin Escardo's} outstanding \typetopology Agda library and his notes on \hottufinagda in which that library is so lucidly described.  Finally, we thank Ulf Norell and his collaborators for creating the wonderful Agda language~\cite{Norell:2009}.}

\nolinenumbers %uncomment to disable line numbering

\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \EventEditors{John Q. Open and Joan R. Access}
%% \EventNoEds{2}
%% \EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
%% \EventShortTitle{CVIT 2016}
%% \EventAcronym{CVIT}
%% \EventYear{2016}
%% \EventDate{December 24--27, 2016}
%% \EventLocation{Little Whinging, United Kingdom}
%% \EventLogo{}
%% \SeriesVolume{42}
%% \ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
We present the \AgdaUALib (or \agdaualib for short), the result of our effort to formalize universal algebra, model theory, and equational logic in Martin-L\"of type theory using the \agda functional programming language.
The latest version of the \agdaualib formalizes a substantial number of definitions and theorems from general algebra and logic, and the implementation of these foundations in Agda makes essential use of inductive and dependent types. Indeed, the \agdaualib showcases the expressive power of these types, and the ease and precision with which they can be used to formalize mathematics.  To demonstrate, we highlight some of the significant theorems that are already formalized in the \agdaualib, most notably the theorem of Garrett Birkhoff asserting that a class of algebraic structures is closed under homomorphic images, substructures, and arbitrary products if and only if it is the class of models of some set of equations. Ours is the first formal proof of this theorem that we know of.
\end{abstract}

\newpage

\section{Introduction}\label{sec:introduction}
To support formalization in type theory of research level mathematics in general algebra, model theory, and equational logic, we present the Agda Universal Algebra Library (\agdaualib), a software library of formal definitions, theorems and their proofs comprising a substantial part of the foundational core of these mathematical theories.
The \agdaualib is written in \agda~\cite{Norell:2009}, a programming language and proof assistant based on \textit{Martin-L\"of type theory} (MLTT) that not only supports dependent and inductive types, but also provides powerful \emph{proof tactics} for proving things about the objects that inhabit these types.

The project was only recently initiated (in 2017), yet for some parts of the theory the \agdaualib already breaks new ground and extends beyond what was covered by prior efforts to formalize universal algebra in type theory (e.g.,~\cite{Capretta:1999},~\cite{Gunther:2018},~\cite{Spitters:2011}). In particular, the first formal proof of Birkhoff's variety theorem in type theory was recently added to the library. We remark that to our knowledge every previously published proof of Birkhoff's theorem is informal and nonconstructive (see Section~\ref{sec:}); thus, the formal, constructive proof of the theorem in the \agdaualib actually proves a slightly stronger result. (See Section~\ref{sec:} for a justification of this claim.)

\subsection{Vision and goals}\label{sec:vision-and-goals}
The idea for the the Agda Universal Algebra Library originated with the observation that, on the one hand a number of fundamental notions of universal algebra can be defined recursively, and theorems about them proved inductively, while on the other hand inductive types make possible formal representations of recursively defined objects as well as constructive proofs of their properties, proofs that are computable and composable. As these observations suggested, and our experience confirmed, there is much to gain from implementing universal algebra in type theory using a language (such as Agda) that supports dependent and inductive types.

We wish to emphasize that our ultimate objective is not merely to translate existing mathematics into a more modern and formal language, although that is an important part of this effort.  Another equally important goal is to develop a library that facilitates new research in mathematics. In our own work, experience has taught us that a proof assistant equipped with specialized libraries for our areas of expertise, as well as domain-specific tactics to automate the proof idioms of our field, can be extremely powerful.  Thus, one of our aims is to demonstrate the prominent role that the \agdaualib can play in proving new theorems, and discovering and exploring new mathematical theories.

\subsection{Outline of the paper}
The sections that follow highlight certain key components of the \agdaualib. Some of the formal proofs are long and not very interesting, and these will be relegated to the appendix of this paper, unless they are \emph{really} uninteresting, in which case they will be omitted entirely.  Rest assured, however, the full code listings and complete formal implementations and proof objects that accompany the code we discuss here is available in the \agdaualib Gitlab repository at \ualibgitlabio.  Moreover, the entire \agdaualib is fully documented on the website at \agdaualibdoc.

In Section~\ref{sec:agda-prelude} we briefly describe the necessary boilerplate code that we require in the sequel.
Section~\ref{sec:algebras-in-agda} presents the codification in type theory of the most basic concepts universal algebra, namely, operation, signature, algebraic structures and products thereof. Then, in Section~\ref{sec:cons-in-agda}, we describe type theoretic formalizations of relations, congruences, and quotient structures. Section~\ref{sec:homs-in-agda} covers homomorphisms and homomorphic images, and Section~\ref{sec:terms-in-agda} shows how terms and term algebras are represented in the \agdaualib. This is also where we formalize the proofs of the universal property of the term algebra and the compatibility properties of terms, congruences, and homomorphisms. Section~\ref{sec:subs-in-agda} presents subalgebras demonstrates how subalgebra generation is formally represented as a recursive type.
Finally, Section~\ref{sec:equational-logic-in-agda} shows how we represent the basic notions of equational logic in Agda, and this paves the way to the penultimate section of the paper in which we present the formal proof of Birkhoff's theorem.  We conclude the paper with some remarks about open problems and outstanding goals for the project.

\section{Prelude}\label{sec:prelude}
Here we describe the code that gets us up and running with Agda.  The code resides in the \preludemodule of the \agdaualib. As with all the Agda code mentioned in this paper, the full source code of the \preludemodule is available in the \href{https://gitlab.com/ualib/ualib.gitlab.io}{gitlab repository of the \textsf{UALib}}, available at \ualibgitlabio.

\subsection{Options}\label{sec:options}
All but the most trivial Agda programs begin by setting some options that effect the foundations that Agda takes as a starting point, and by importing from existing libraries. The \agdaualib is no different. All imports in the \agdaualib come exclusively from Martin Escardo's \typetopology library.\footnote{Besides being an excellent foundation on which to build, Martin's library is based on a very terse Martin-L\"of type theory, and each addition to this skeleton frame is very deliberate and carefully explained in the Martin's excellent set of notes, \hottufinagda.  The latter describes the \typetopology library in great detail, and is available on \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes}{Escardo's website}.} To wit, each file in the \agdaualib (and the \typetopology library) begins with the line \AgdaSymbol{\{-\#}\AgdaSpace{}\AgdaKeyword{OPTIONS}\AgdaSpace{}\AgdaPragma{--without-K}\AgdaSpace{}\AgdaPragma{--exact-split}\AgdaSpace{}\AgdaPragma{--safe}\AgdaSpace{}\AgdaSymbol{\#-\}}, 
%% \begin{code}
%% \>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
%% \AgdaKeyword{OPTIONS}\AgdaSpace{}%
%% \AgdaPragma{--without-K}\AgdaSpace{}%
%% \AgdaPragma{--exact-split}\AgdaSpace{}%
%% \AgdaPragma{--safe}\AgdaSpace{}%
%% \AgdaSymbol{\#-\}}\<%
%% \end{code}
which contrains the foundational assumptions Agda makes as follows:
\begin{itemize}
\item \texttt{without-K} disables \href{https://ncatlab.org/nlab/show/axiom+K+\%28type+theory\%29}{Streicher's K axiom};\footnote{See the \href{https://agda.readthedocs.io/en/v2.6.1/language/without-k.html}{section on axiom K} in the \agdalangref manual.}
\item \texttt{exact-split} instructs Agda to accept only definitions that behave like \emph{judgmental} or \emph{definitional} equalities.\footnote{Escardo explains this by saying that ``pattern matching corresponds to Martin-Löf eliminators;'' see the \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html\#pattern-matching-and-equality}{Pattern matching and equality section} of the \agdatools documentation.}
\item \texttt{safe} ensures that nothing is postulated outright---every non-MLTT axiom must be an explicit assumption (e.g., an argument to a function or module).\footnote{See \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html\#cmdoption-safe}{cmdoption-safe section} of the \agdatools documentation and the \href{https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html\#safe-agda}{Safe Agda section} of the \agdalangref manual.}
\end{itemize}
Since every file in the \agdaualib begins with the same first line, we won't mention the \AgdaKeyword{OPTIONS} directive again in this paper.%
\footnote{See also the OPTIONS Section of the \agdalangref manual.}
  %% \href{https://agda.readthedocs.io/en/v2.6.1.1/language/pragmas.html#options-pragma}{} 

\subsection{Imports}\label{sec:imports}
\paragraph*{Universes}
The first module of the \agdaualib is the \preludemodule which begins by importing the \universesmodule from the \typetopology library with the line \AgdaKeyword{open}\AgdaSpace{}\AgdaKeyword{import}\AgdaSpace{}\AgdaModule{Universes}\AgdaSpace{}\AgdaKeyword{public}.

The \universesmodule provides, among other things, an elegant notation for type universes (also known as \texttt{Level}s) adopted throughout the \agdaualib.
%% \begin{code}
%% \>[0]\AgdaKeyword{open}\AgdaSpace{}%
%% \AgdaKeyword{import}\AgdaSpace{}%
%% \AgdaModule{Universes}\AgdaSpace{}%
%% \AgdaKeyword{public}\<%
%% \end{code}
Following Martin Escardo, we use capital script letters (e.g., \ab 𝓤, \ab 𝓥, \ab 𝓦, \ab 𝓣) to denote universes. The \universesmodule also defines the ̇ operator mapping a universe \ab 𝓤 to \texttt{Set}\ \ab 𝓤, the latter having type \texttt{Set (lsuc}\ \ab 𝓤\texttt{)}.
%% The level \texttt{lzero} is renamed \ab{𝓤₀}, so \ab{𝓤₀}\ ̇ is an alias for \texttt{Set\ lzero}.

We won't describe other features of the \universesmodule as it suffices to highlight the main notational conventions established therein and adopted in the \agdaualib. In particular,
\begin{itemize}
  \item \texttt{Set\ (lsuc\ lzero)} is denoted by \texttt{Set}\ \ab 𝓤₀\ ⁺ which is denoted by \ab 𝓤₀\ ⁺\ ̇;
  \item if \ab 𝓤 and \ab 𝓥 are universes, then the least upper bound of the types \ab 𝓤~ ̇ and \ab 𝓥\ ̇ is denoted by \ab 𝓤~⊔~\ab 𝓥~ ̇.
\end{itemize}

Besides notations for universes, a fair number of other components are imported from the \typetopology library into the \agdaualib. A full list of these appears in Appendix~\ref{sec:imports-from-type-topology}.

\section{Algebras in Agda}\label{sec:algebras-in-agda}
The \basicmodule of \agdaualib begins our Agda formalization of the basic components of universal algebra. It is here that such notions as operation, signature, and algebraic structure are codified in the language of MLTT.

\subsection{Operation type}
The type of an \textbf{operation} is defined as follows.
\begin{code}%
\>[0]\AgdaFunction{Op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaGeneralizable{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\<%
\end{code}
Here the arity of an operation is represented as an arbitrary type \ab 𝐼 : \ab 𝓥 ̇, yielding a completely general representation of an operation as a function type with domain \ab 𝐼 → \ab 𝐴 (heuristically, the type of ``tuples of length~|~\ab 𝐼~|'') and codomain \ab 𝐴. For example, here is how the usual \emph{projection operations} are defined as inhabitants of the type \AgdaFunction{Op}\AgdaSpace{}\AgdaBound{I}\AgdaSpace{}\AgdaBound{A}.
\begin{code}%
\>[0]\AgdaFunction{π}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{π}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\<%
\end{code}
Thus, \AgdaFunction{π}\AgdaSpace{}\AgdaBound{i} is the 𝑖th projection mapping. Indeed, for each\AgdaSpace{}\AgdaBound{i}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaBound{I}\AgdaSpace{} the operation
\AgdaFunction{π}\AgdaSpace{}\AgdaBound{i}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A} maps a function
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}
to its 𝑖th component \AgdaBound{x}\AgdaSpace{}\AgdaBound{i}.

\subsection{Signature type}
The \agdaualib defines the signature of an algebraic structure in Agda as follows:
\begin{code}%
\>[0]\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓞}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓞}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{𝓞}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{𝓞}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}%
\>[27]\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\end{code}
Here \AgdaBound{𝓞} represents the universe that operation symbol types inhabit, while \AgdaBound{𝓥} is the universe inhabited by arity types.

The \preludemodule of \agdaualib defines the syntax ∣\_∣ and ∥\_∥ for the first and second projections, respectively, so if \AgdaBound{𝑆}\AgdaSpace{}\AgdaFunction{꞉}\AgdaSpace{}\signatureOV is a signature, then \AgdaFunction{∣}\AgdaSpace{}\AgdaBound{𝑆}\AgdaSpace{}\AgdaFunction{∣} denotes the set of operation symbols, and \AgdaFunction{∥}\AgdaSpace{}\AgdaBound{𝑆}\AgdaSpace{}\AgdaFunction{∥} denotes the arity function. Thus, we write \AgdaFunction{𝑓}\AgdaSpace{}\AgdaFunction{꞉}\AgdaSpace{}\AgdaFunction{∣}\AgdaSpace{}\AgdaBound{𝑆}\AgdaSpace{}\AgdaFunction{∣} to mean that \AgdaFunction{𝑓} is an operation symbol in the signature \AgdaBound{𝑆}, and \AgdaFunction{∥}\AgdaSpace{}\AgdaBound{𝑆}\AgdaSpace{}\AgdaFunction{∥}\AgdaSpace{}\AgdaFunction{𝑓} gives the arity of \AgdaFunction{𝑓}.

\subsection{Algebra type}
In \agdaualib, the type of algebras in the signature 𝑆, also known as 𝑆-\textbf{algebras}, is
\begin{code}%
\>[0]\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)\{}\AgdaBound{𝓞}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{𝓞}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓞}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝓞}\AgdaSymbol{\}\{}\AgdaBound{𝓥}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{𝑓}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Op}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{𝑓}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\end{code}
Thus an 𝑆-algebra with carrier type in \AgdaBound{𝓤}~̇ has type \algebraUS.  (Notice that we may leave off the implicits \AgdaBound{𝓞} and \AgdaBound{𝓥} if they can be inferred from the context.)

Let us emphasize, \algebraUS \emph{is the type inhabited by all algebras of signature} \ab{𝑆} \emph{and carrier type} \ab 𝓤\ ̇.\footnote{In MLTT, everything has a type, even types have types, and apparently the type \algebraUS of algebras happens to be of type \ab 𝓞 ⊔ \ab 𝓥 ⊔  \ab 𝓤\ ⁺\ ̇.}

The type \algebraUS doesn't define what an algebra \emph{is}; it merely defines a type of algebras. Certain algebras inhabit this type---namely, the algebras consisting of a universe (say, \AgdaBound{A}) of type \ab 𝓤 ̇, and a collection \AgdaSymbol{(}\AgdaBound{𝑓}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∣}}\AgdaSymbol{)}\AgdaSpace{}\AgdaSymbol{→}\AgdaSpace{}\AgdaFunction{Op}\AgdaSpace{}\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}\AgdaBound{𝑆}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}\AgdaBound{𝑓}\AgdaSymbol{)}\AgdaSpace{}\AgdaBound{A} of operations on \AgdaBound{A}.

\paragraph*{Example} A monoid signature has two operation symbols, say, \AgdaInductiveConstructor{e} and \AgdaInductiveConstructor{∗}; the first is nullary and the second binary. Thus, the respective types are (𝟘 → A) → A and (𝟚 → A) → A.
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{𝓤₀}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaInductiveConstructor{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\<%
\\
%
\>[1]\AgdaInductiveConstructor{∗}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{monoid-sig}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaFunction{monoid-sig}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{e}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{𝟘}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{∗}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{𝟚}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
%% We will have more to say about the type of algebras later.  For now we continue describing the key definitions and syntax used in \agdaualib to represent the basic objects of universal algebra.

\paragraph*{Syntactic sugar for interpretation of operation symbols}
The \agdaualib allows us to replace \AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}\AgdaBound{𝑨}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}\AgdaBound{𝑓}\AgdaSpace{} with the slightly more intuitive \AgdaBound{𝑓}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}\AgdaBound{𝑨}.%
\footnote{\AgdaBound{𝑓}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}\AgdaBound{𝑨} is a metaphor for \(f^\mathbf{A}\), which is the standard notation for the interpretation of 𝑓 in 𝑨.}
\begin{code}%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}̂\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝑓}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{𝑓}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[1]\AgdaBound{𝑓}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{𝑓}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
Thus, from now on \AgdaBound{𝑓}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}\AgdaBound{𝑨}\AgdaSpace{} will denote the interpretation of the operation symbol \AgdaBound{𝑓} in the algebra \AgdaBound{𝑨}.  (Later we introduce a slightly different notation, \AgdaBound{𝑡}\AgdaSpace{}\AgdaOperator{\AgdaFunction{ ̇ }}\AgdaSpace{}\AgdaBound{𝑨}, when representing the interpretation of a \emph{term} \AgdaBound{𝑡} in the algebra \AgdaBound{𝑨}).

\subsection{Product type}
The type of (indexed) product of a collection of algebras (of the same type) is also a type of algebras; it is defined as follows:\footnote{In \agdamode ⨅ is typed as \textbackslash Glb.}
\begin{code}%
\>[1]\AgdaFunction{⨅}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓘}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{\}(}\AgdaBound{𝒜}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaGeneralizable{𝓘}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{𝑆}\<%
\\
%
\>[1]\AgdaFunction{⨅}\AgdaSpace{}%
\AgdaBound{𝒜}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[8]\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝒜}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}%
\>[31]\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{𝑓}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝑓}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}%
\AgdaBound{𝒜}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{𝓥}\AgdaSpace{}%
\AgdaBound{i}\<%
\end{code}

\subsection{Arbitrarily many variable symbols}
To round out this section we show how the \agdaualib represents the standard assumption that we always have an arbitrarily large collection \AgdaBound{X} of variable symbols at our disposal, so that, given an algebra \AgdaBound{𝑨}, we always have a surjective mapping from \AgdaBound{X} to the universe \AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}\AgdaBound{𝑨}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∣}} of \AgdaBound{𝑨}. The type that makes such a map available is the following:

\begin{code}%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}↠\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓧}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
%
\>[1]\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{↠}}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{h}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSpace{}%
\AgdaBound{h}\<%
\end{code}



%% \input{prelude.tex}
%% \input{basic.tex}
\section{Congruences in Agda}\label{sec:cons-in-agda}
It's no secret that congruences play a central role in mathematics, and nowhere is this more true than in universal algebra.  Before defining a type for congruences, however, we first need a type for binary relations and, in particular, equivalence relations.

\subsection{Binary relations}\label{sec:binary-relations-kernels}
A standard definition of binary relation from one type to another is found in the \texttt{Binary/Core.agda} module of the \agdastdlib). When translated into Escardo's notation, the definition is as follows:
\begin{code}%
\>[0]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaGeneralizable{𝓥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\end{code}
However, the more commonly used definition is of a binary relation over a single type, which is simply the special case of \AgdaFunction{REL} in which the domain and codomain are the same.
%% There is also a ``homogeneous'' version where \AgdaGeneralizable{𝓦} is assumed to be \AgdaGeneralizable{𝓤}.
\begin{code}%
\>[0]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓝}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{𝓝}\<%
\end{code}
For example the ``trivial'' relation could be defined as an inhabitant of the \AgdaFunction{Rel}\AgdaSpace{}\AgdaBound{A}\AgdaSpace{}\AgdaGeneralizable{𝓤} type,
\begin{code}
\>[0]\AgdaFunction{𝟎-rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\<%
\\
\>[0]\AgdaFunction{𝟎-rel}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{b}\<%
\end{code}
but it could alternatively be defined as a more general type,
\begin{code}
\>[0]\AgdaFunction{𝟎}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaFunction{𝟎}\AgdaSymbol{\{}\AgdaBound{𝓤}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{b}\<%
\end{code}

\paragraph*{Kernel types}
Three natural and essentially equivalent ways to define the kernel of a function in type theory are as a general type, a relation, or a predicate.
\begin{code}\input{congruences/kernel.tex}\end{code}

\paragraph*{Properties of binary relations}\label{sec:properties-of-binary-relations}
Reflexivity, symmetry, and transitivity of a binary relation (say, \texttt{\Aapprox }) on \texttt{X}, are defined in the obvious way. For instance, here is reflexivity.
\begin{code}
\>[0]\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaGeneralizable{𝓡}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaGeneralizable{𝓡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}\Aapprox \AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\Aapprox }}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
Symmetry and transitivity are defined similarly.

\paragraph*{Classes of a binary relation}
If \AgdaBound{A}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaGeneralizable{𝓤} is a type,
\AgdaBound{\Aapprox } a binary relation on \AgdaBound{A}, and \AgdaBound{a}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaBound{A},
then the \AgdaBound{\Aapprox }-class containing \AgdaBound{𝑎} is denoted in \agdaualib by
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}\AgdaBound{\Aapprox }.
\begin{code}
\>[0]\AgdaOperator{\AgdaFunction{[\AgdaUnderscore{}]\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[8]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}%
\>[22]\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{𝓡}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaGeneralizable{𝓡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaBound{\Aapprox }\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaFunction{,}%
\>[21]\AgdaBound{\Aapprox }\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
In set theory, the quotient of a set 𝐴 modulo an equivalence relation \Aapprox  is the set of \Aapprox -classes of 𝐴, where two elements 𝑥, 𝑦 are in the same class iff 𝑥 \Aapprox  𝑦. In the \agdaualib the type that captures this notion is the quotient of a type \AgdaBound{A} modulo an equivalence relation type \AgdaBound{\Aapprox }. We denote such quotients by \AgdaBound{A}\AgdaSpace{}\AgdaOperator{\AgdaFunction{//}}\AgdaSpace{}\AgdaBound{\Aapprox }, and we define \AgdaOperator{\AgdaFunction{\AgdaUnderscore{}//\AgdaUnderscore{}}}\AgdaSpace{} as an infix operation, as shown below.
\begin{code}
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}//\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[8]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{𝓡}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⊔}}\AgdaSpace{}%
\AgdaGeneralizable{𝓡}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{//}}\AgdaSpace{}%
\AgdaBound{\Aapprox }\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaFunction{,}%
\>[21]\AgdaFunction{Σ}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaFunction{꞉}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}%
\>[32]\AgdaBound{C}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaBound{\Aapprox }\AgdaSpace{}%
\AgdaSymbol{)}\<%
\end{code}
%\AgdaSpace{}\AgdaFunction{꞉}\AgdaSpace{}
It is important to observe that, unlike the elements of a quotient in set theory, the inhabitants of the quotient type defined above are not mere \AgdaBound{\Aapprox }-classes.  Instead, each inhabitant of the type \AgdaBound{A}\AgdaSpace{}\AgdaOperator{\AgdaFunction{//}}\AgdaSpace{}\AgdaBound{\Aapprox } is by definition a triple, \AgdaSymbol{(}\AgdaSpace{}\AgdaBound{C}\AgdaSpace{},\AgdaSpace{}\AgdaBound{𝑎}\AgdaSpace{},\AgdaSpace{}\AgdaFunction{𝑝}\AgdaSpace{}\AgdaSymbol{)}, where \AgdaBound{C} is a \AgdaBound{\Aapprox }-class, \AgdaBound{𝑎} has type \AgdaBound{A}\AgdaSpace{}, and \AgdaFunction{𝑝} is a proof that \AgdaBound{C} is the \AgdaBound{\Aapprox }-class containing \AgdaBound{𝑎}; that is, \AgdaBound{C}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaBound{\Aapprox }\AgdaSpace{}%
\AgdaSymbol{)}.
Thus, given an element \AgdaBound{a}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaBound{A} and an equivalence relation \AgdaBound{\Aapprox } we form the \AgdaBound{\Aapprox }-class containing \AgdaBound{a} as the triple, \AgdaSymbol{(}\AgdaSpace{}\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}\AgdaBound{\Aapprox }\AgdaSpace{}\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}\AgdaInductiveConstructor{𝓇ℯ𝒻𝓁}\AgdaSpace{}\AgdaSymbol{)}. In fact the \agdaualib defines a function for that.  It uses infix notation and is defined as follows.
\begin{code}\input{congruences/relationClassesIntro.tex}\end{code}

Those who have experience with quotients should be able to appreciate the ramifications of the above definitions.  Since a quotient class always comes equipped with a representative element (as well as a proof that the representative belongs to the class), we never have to worry about choosing representatives. This is important because we often want to get our hands on quotient class representatives, and to do so constructively we must avoid the Axiom of Choice.

In \agdaualib this is easy since, given a quotient class, say, \AgdaBound{𝒞}\AgdaSpace{}\AgdaSymbol{=}\AgdaSpace{}\AgdaSymbol{(}\AgdaSpace{}\AgdaBound{C}\AgdaSpace{},\AgdaSpace{}\AgdaBound{𝑎}\AgdaSpace{},\AgdaSpace{}\AgdaFunction{𝑝}\AgdaSpace{}\AgdaSymbol{)}, we can extract the representative \AgdaBound{𝑎} of the class simply by applying the second and then first projections, an operation denoted and defined in the \agdaualib as follows:
\begin{code}\input{congruences/relationClasses.tex}\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \subsection{Singletons and subsingletons}
%% \todo{next say something about is-subsingleton-valued}
%% \begin{code}\input{congruences/singletons.tex}\end{code}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Types for equivalences}\label{sec:types-for-equivalences}
A common way to represent an equivalence relation in Agda is as a record.
\begin{code}\input{congruences/equiv1.tex}\end{code}
Here's an alternative that is sometimes useful.
\begin{code}\input{congruences/equiv2.tex}\end{code}
As an example application of the first version, we can prove that 𝟎 is an equivalence relation.
\begin{code}\input{congruences/zeroIsEquiv.tex}\end{code}

The lift of functions and relations will play a role in some proofs in the sequel. The \textbf{lift} takes a binary relation from pairs to pairs of tuples.
\begin{code}\input{congruences/lift-rel.tex}\end{code}
Of course, the notion of \textbf{compatibility} of function-relation pairs plays an major role in universal algebra. Here is how this concept is codified in \agdaualib.
\begin{code}\input{congruences/compatible-fun.tex}\end{code}

\subsection{Types for congruences}\label{sec:types-for-congruences}
We finally arrive at the definition of congruence, which the \agdaualib defines inside an anonymous module in order to fix an ambient signature \ab 𝑆.
\begin{code}\input{congruences/TypesForCongruences.tex}\end{code}
%% For example, one constructs the ``trivial'' congruence relation as follows:
%% \begin{code}\input{congruences/TrivialCongruence.tex}\end{code}

\subsection{Quotient algebras}
An important type for algebraic work is that of a quotient algebra, which the \agdaualib defines as follows:%
\footnote{In \emacs \agdamode one types \texttt{\textbackslash ---} and then \texttt{C-f} or the right-arrow key a number of times to produce the special ╱ symbol that we use for quotients.}
\begin{code}\input{congruences/quotient.tex}\end{code}


We would like to round out this section with a formalization of the trivial congruence of the free algebra 𝔽(𝒦, 𝑋), which we denoted by Ψ(𝒦, 𝑻(𝑋)). This will have to wait until we have formalized the concepts of subalgebra and closure on which this congruence depends, so Ψ(𝒦, 𝑻(𝑋)) is defined later in the \closuremodule, described in Section~\ref{sec:closure}.

%% -----------------------------------------------------
%% \input{homomorphisms.tex}
\section{Homomorphisms in Agda}\label{sec:homs-in-agda}
This section describes the \homsmodule of the \agdaualib.

\subsection{Types for homomorphisms}\label{sec:types-for-homomorphisms}
%% We begin the \homsmodule by declaring a fixed signature \texttt{𝑆} an importing the
%% required dependencies.
%% \begin{code}\input{homomorphisms/homprelude.tex}\end{code}
%% \subsection{Homomorphisms, intensionally}
%% Here is what we mean when we say that an operation 𝑓 (interpreted in algebras, say, 𝑨 and 𝑩) is \emph{intensionally compatible} (or \emph{commutes intensionally}) with a function \(g : A → B\) .
%% \begin{code}\input{homomorphisms/commutes.tex}\end{code}
%% The type of homomorphism that corresponds to this notion of compatibility is defined in the \agdaualib as follows:
%% \begin{code}\input{homomorphisms/hom.tex}\end{code}
%% \subsection{Homomorphisms, extensionally}
A \emph{homomorphism} from an algebra \alg A to an algebra \alg B is a function from \m A to \m B that ``is compatible,'' or ``commutes,'' or  with all the operations of \alg A and \alg B. What this means will be clear from the following \agda formulation of this notion:
\begin{code}\input{homomorphisms/commext.tex}\end{code}
Thus, an operation 𝑓 (interpreted in algebras, say, 𝑨 and 𝑩) is \emph{extensionally compatible} (or \emph{commutes extensionally}) with a function \(g : A → B\) provided for all
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
we have 
%% \begin{code}
%% \AgdaSymbol{∀(}\AgdaSpace{}%
%% \AgdaBound{a}\AgdaSpace{}%
%% \AgdaSymbol{:}\AgdaSpace{}%
%% \AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
%% \AgdaBound{𝑆}\AgdaSpace{}%
%% \AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
%% \AgdaBound{f}\AgdaSpace{}%
%% \AgdaSymbol{→}\AgdaSpace{}%
%% \AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
%% \AgdaBound{A}\AgdaSpace{}%
%% \AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
%% \AgdaSymbol{)}\AgdaSpace{}%
%% \AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}. This notion of compatibility is an extensional one, which is easily observed by comparing it to the ``intensional'' analog of the concept, defined in the \agdaualib as follows:
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)(}\AgdaBound{g}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{))}.
%% \end{code}

Commuting (extensionally) with all operations is captured in \agda by the following defintion:
\begin{code}\input{homomorphisms/allopscomm.tex}\end{code}
With this we are finally ready to define the type of homomorphisms.
\begin{code}\input{homomorphisms/homext.tex}\end{code}
An example inhabitant of this type is of course the identity map.
\begin{code}
\>[0]\AgdaFunction{𝒾𝒹}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[6]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{hom}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{𝒾𝒹}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{𝓇ℯ𝒻𝓁}\<%
\end{code}
\subsection{Composing homomorphisms}
To give an example of how one applies the definition of (extensional) homomorphism in proofs, let us show that the composition of such homomorphisms is again a homomorphism.
\begin{code}\input{homomorphisms/homcomp.tex}\end{code}

\subsection{Factoring homomorphisms}
As another example, we prove that if \AB g is a homomorphism from \AB 𝑨 to \AB 𝑩, if \AB ℎ is a homomorphism from \AB 𝑨 to \AB 𝑪, if \AB ℎ is surjective, and if ker \AB ℎ ⊆ ker \AB g, then there exists a homomorphism \AB ϕ from \AB 𝑪 to \AB 𝑩 such that \AB 𝑔 \AS\AgdaSymbol{=}\ASϕ\AS\AgdaFunction{∘}\AS\AB ℎ.  This claim is formalized in the \agdaualib as follows:
%% , that is, such that the following diagram commutes:
%% \begin{verbatim}
%%    𝑨---- ℎ -->>𝑪
%%     \         .
%%      \       .
%%       𝑔     ∃ϕ
%%        \   .
%%         \ .
%%          V
%%          𝑩
%% \end{verbatim}
%% The proof of this fact is a bit longer than the previous one, so we will just give the theorem statement here.
%% However, we note that the \agdaualib proves this result, and the proof is constructive. (See \homsmodule for the full program listing.)
\begin{code}\input{homomorphisms/homfactorthm.tex}\end{code}
So as to not interrupt the flow of our exposition, we relegate the proof of this theorem to Appendix Section~\ref{sec:appendix-homfactor}.

\subsection{Isomorphisms in Agda}\label{sec:isomorphism}
The notion of isomorphism between two algebras is represented in the \agdaualib, using the (extensional) definition of homomorphism, as follows.
\begin{code}\input{homomorphisms/iso.tex}\end{code}

\subsection{Homomorphic images}\label{sec:homomorphic-images}
The image of an algebra \AgdaBound{𝑨} under a homomorphism, or ``homomorphic image'' of \AgdaBound 𝑨, plays a significant role in universal algebra, and the types below give two useful ways of representing homomomrphic images in \agda.\footnote{See the \preludemodule for the definition of \AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}\AgdaUnderscore{}}}.}
\begin{code}\input{homomorphisms/homimage.tex}\end{code}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Terms in Agda}\label{sec:terms-in-agda}
Here we describe the \termsmodule of the \agdaualib which defines the \AgdaDatatype{Term} datatype that represents the type of terms. (Here, as usual, the type \ab 𝑋 : \ab 𝒰 ̇ represents an arbitrary collection of variables symbols.)\\[-5mm]
\begin{code}\input{terms/term.tex}\end{code}
Using the \AgdaDatatype{Term} type, we define the \textbf{term algebra} type as follows:
%% , denoted here by \AgdaFunction{𝑻}\AgdaSymbol{(}\AgdaBound{X}\AgdaSymbol{)}.
\begin{code}\input{terms/termalg.tex}\end{code}
The universe is the collection of terms over \AgdaBound{X} and the operations are those given by the \AgdaInductiveConstructor{node} constructor of the \AgdaDatatype{Term} datatype.

\subsection{The universal property}\label{sec:the-universal-property}
What we have developed so far is already enough to formalize the proofs of some important facts. Indeed, we can now formally prove that the term algebra \AgdaFunction{𝑻}\AgdaSymbol{(}\AgdaBound{X}\AgdaSymbol{)} is absolutely free.  In other words,
\begin{enumerate}
\item every map \AgdaBound{h}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}} lifts to a homomorphism from \TX to \AB 𝑨, and
\item the induced homomorphism is unique.
\end{enumerate}
Here's proof of the first item. %First we show that every map \texttt{X\ →\ ∣\ 𝑨\ ∣} lifts to a homomorphism.
\begin{code}\input{terms/freelift.tex}\end{code}
The proof that this lift to \AgdaFunction{𝑻}\AgdaSymbol{(}\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}\AgdaBound{𝑨} is unique is formalized as follows:
\begin{code}\input{terms/uniquelift.tex}\end{code}
%% This is not worth showing:
%% Next we note the easy fact that the lift induced by \texttt{h₀} agrees with \texttt{h₀} on \texttt{X} and that the lift is surjective if the \texttt{h₀} is.
%%   \begin{code}\input{terms/liftagreement.tex}\end{code}

\subsection{Interpretation of terms}\label{sec:interpretation-of-terms}
Let \AgdaBound{𝑡} be an 𝑆-term and \AgdaBound{𝑨} an 𝑆-algebra. The induced 𝑛-ary operation \AgdaBound{𝑡}\ ̇\ 𝑨 is defined by structural recursion on 𝑡 as follows:
\begin{itemize}
\item If \AB 𝑡\AS\AgdaSymbol{=}\AS\AB 𝑥\AS\ASy{∈}\AS\AB 𝑋 is a variable and \AB 𝒂\AS\AgdaSymbol{:}\AS\AB 𝑋\AS\AgdaSymbol{→}\AS\univA is a tuple of elements of \univA, then
\begin{quote}
  \tA\AgdaSpace{}\AgdaBound{𝒂}\AgdaSpace{}\AgdaSymbol{=}\AS\AB 𝒂\AS\AB 𝑥.
\end{quote}
\item If \AB 𝑡\AS\AgdaSymbol{=}\AS\AB 𝑓\AS\AB 𝒔, where \AB 𝑓\AS\AgdaSymbol{∈}\AS\univS is an operation symbol, \AB 𝒔\AS\AgdaSymbol{:}\AS\arityS\AS\AB 𝑓\AS\AgdaSymbol{→}\AS\AB \TX is a tuple of terms, and \AB 𝒂\AS\AgdaSymbol{:}\AS\AB 𝑋\ASy →\AS\univA is a tuple of elements of \univA, then
  \begin{quote}
    \tA\AgdaSpace{}\AgdaBound{𝒂}\AgdaSpace{}\AgdaSymbol{=}\AS\fsA\AS\AB 𝒂\AS\ASy{=}\AS\fA\ASy{(λ}\AS\AB 𝑖\AS\ASy{→}\AS\siA\AS\AB 𝒂\AgdaSymbol{)}.
    \end{quote}
\end{itemize}
Here is the Agda implementation of this recursive definition.
\begin{code}\input{terms/interpretation.tex}\end{code}


\begin{comment}
  Next we show that if 𝑝 : 𝑇(𝑋) is a term, then there exists 𝓅 : 𝑇(𝑋) and 𝒕 : 𝑋 → 𝑇(𝑋) such that 𝑝 ≡ (𝓅\ ̇\ 𝑻(𝑋))\ 𝒕. We prove this fact in the following module:
  \begin{code}\input{terms/termagreement.tex}\end{code}
  Next we have some definitions that are sometimes useful when dealing with the interpretations of terms in a product structure.
  \begin{code}\input{terms/interpprod.tex}\end{code}
  \subsection{Compatibility of terms}\label{sec:compatibility-of-terms}
  Here we present the formal proof of the fact that homomorphisms and terms are compatible.  That is, if 𝑨 and 𝑩 are 𝑆-algebras, h : 𝑨 → 𝑩 a homomorphism, and 𝑡 a term in the language of 𝑆, then for all a : X → ∣ 𝑨 ∣ we have \(h (t^{𝑨} a) = t^{𝑩} (h ∘ a)\).
\end{comment}

\subsection{Compatibility of terms}
We next formalize the proofs of two important compatibility results. The first asserts that homomorphisms commute with terms; the second, that congruences commute with terms.  Both proofs are by induction, and structural recursion does most of the heavy lifting.
\paragraph*{Homomorphisms commute with terms}\label{sec:homomorphisms-commute-with-terms}
\begin{code}\input{terms/commhom.tex}\end{code}

\paragraph*{Congruences commute with terms}\label{sec:congruences-commute-with-terms}
Here's the formal proof that terms respect congruences.
\begin{code}\input{terms/commcon.tex}\end{code}
%% More precisely, we show that for every term \texttt{t}, every \texttt{θ\ ∈\ Con(𝑨)}, and all tuples \texttt{a,\ b\ :\ 𝑋\ →\ A}, we have...
%% \>[0]\AgdaComment{-- Proof of 2. (If t : Term, θ : Con 𝑨, then a θ b → t(a) θ t(b))}\<%
%% \\



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{Subalgebras in Agda}\label{sec:sec:subs-in-agda}
This section describes the \subsmodule of the \agdaualib where subuniverses and subalgebras are defined and some basic facts about them proved. The module begins with a straightforward definition of the collection of subuniverses of an algebra \algA. Since a subuniverse is a subset of the domain \univA of \algA, it is defined as a predicate on this domain. Thus, a collection of subuniverses is a predicate on predicates on \univA.%
\footnote{The syntax \AgdaOperator{\AgdaDatatype{Im}}\AgdaSpace{}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}\AgdaOperator{\AgdaDatatype{⊆}}\AgdaSpace{}\AgdaUnderscore{}}} is defined in the \preludemodule.}
\begin{code}\input{subuniverses/sub.tex}\end{code}
%% Next we wish to describing how one generates subuniverses, but to do so we first need to dispense with a few more technicalities.\begin{code}\input{subuniverses/technical.tex}\end{code}

\subsection{Subuniverse generation}\label{sec:subuniverse-generation}
Next we demonstrate how to formalize an important theorem about subuniverse generation. Recall, if \AB𝑨\AS\ASy{=}\AS⟨\AB 𝐴, …⟩ is an 𝑆-algebra, \ASy ∅\AS\ASy ≠\AS\AB 𝐴\(_0\)\AS\ASy ⊆\AS\AB 𝐴, and if we define by recursion the sets
\begin{quote}
  \AgdaBound{A}\(_{n+1}\)\AS\ASy{=}\AS\AB A\(_n\)\AS\ASy{∪}\AS \{ \fA\AS\AB a\AS|\AS\AB f\AS\ASy :\AS\univS\ASy ,\AS\AB a\ASy :\AS\arityS\AS\AB f\ASy →\AS\AB Aₙ \},
\end{quote}
then the subuniverse of A generated by 𝐴₀ is \(\mathrm{Sg}^A(A₀) = ⋃ₙ Aₙ\).
\begin{code}\input{subuniverses/sg.tex}\end{code}
We now verify that this definition of the subalgebra generated by \AB X is correct; that is, it's the smallest subalgebra containing \AB X.
\begin{code}\input{subuniverses/sgsmallest.tex}\end{code}

\subsection{Homomorphic images are subuniverses}\label{sec:homomorphic-images-are-subuniverses}
In this subsection we show that the image of a homomorphism is a subuniverse of the codomain algebra. Before implementing the result formally in Agda, let us recall the informal proof.  Assume we have a homomorphism
\AgdaBound{ϕ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{hom}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaBound{𝑩} from \AgdaBound{𝑨} to \AgdaBound{𝑩},
let \AgdaBound{𝑓} be an arbitrary operation symbol from \AgdaBound{𝑆}, let
\AgdaBound{𝑏}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑩}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}
be a tuple of elements of \AgdaOperator{\AgdaFunction{∣}}~\AgdaBound{𝑩}~\AgdaOperator{\AgdaFunction{∣}}, and assume that the elements of \AgdaBound{𝑏} belong to the range of \AgdaBound{ϕ}. We must show that \AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}\AgdaBound{𝑩}\AgdaSymbol{)}\AgdaSpace{}\AgdaBound{b} also belongs to the range of \AgdaBound{ϕ}. In other words, we must prove that the image of \univA under \AgdaBound ϕ is closed under the operations of \AgdaBound 𝑩. Of course, this is obvious because the assumption that all elements of \AgdaBound{𝑏} belong to the range of \AgdaBound{ϕ} implies that there exists a tuple
\AgdaBound{a}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}\AgdaBound{𝑆}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}\AgdaBound{f}\AgdaSpace{}\AgdaSymbol{→}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}\AgdaBound{𝑨}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∣}}
such that
\AgdaBound{ϕ}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaSymbol{=}\AgdaSpace{}\AgdaBound{𝑏}, and since \AgdaBound{ϕ} is a homomorphism, we have the desired result:
\begin{quote}
  \AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}\AgdaBound{𝑩}\AgdaSymbol{)}\AgdaSpace{}\AgdaBound{b}\AgdaSpace{}\AgdaSymbol{=}\AgdaSpace{}\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}\AgdaBound{𝑩}\AgdaSymbol{)}\AgdaSymbol{(}\AgdaBound{ϕ}\AgdaSpace{}\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}\AgdaSymbol{=}\AgdaSpace{}\AgdaBound{ϕ}\AgdaSpace{}\AgdaSymbol{(}\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̂}}\AgdaSpace{}\AgdaBound{𝑨}\AgdaSymbol{)}\AgdaSpace{}\AgdaBound{a}\AgdaSymbol{)}
\end{quote}
%% \(f^𝑩 𝑏  = f^𝑩 (\AgdaBound{ϕ} ∘ 𝑎) = \AgdaBound{ϕ} (f^𝑨 𝑎) ∈\) Image \AgdaBound{ϕ}.

Now, once we recall the definition of \AgdaFunction{HomImage} from the \homsmodule, described above in Section~\ref{sec:homomorphic-images},\footnote{See the \preludemodule for the definition of \AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}\AgdaUnderscore{}}}.}
\begin{code}
\>[0]\AgdaFunction{HomImage}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSymbol{\}(}\AgdaBound{𝑩}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaBound{𝑆}\AgdaSymbol{)(}\AgdaBound{ϕ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{hom}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaBound{𝑩}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑩}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{𝓤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{̇}}\<%
\\
\>[0]\AgdaFunction{HomImage}\AgdaSpace{}%
\AgdaBound{𝑩}\AgdaSpace{}%
\AgdaBound{ϕ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{ϕ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{b}\<%
\end{code}
we are finally ready to formalize the proof that homomorphic images are subuniverses.
\begin{code}\input{subuniverses/homimagesub.tex}\end{code}
\subsection{Generation with terms}\label{sec:generation-with-terms}
Subuniverse generation can be described using the images of terms as follows: If \AgdaBound{𝑌} is a subset of \AgdaBound{𝐴}, then the subuniverse of \AgdaBound{𝑨} generated by \AgdaBound{𝑌} is given by
\begin{quote}
  \AgdaDatatype{Sg}\AgdaSpace{}\AgdaBound{Y}\AgdaSpace{}\AgdaSymbol{=}\AgdaSpace{}\AgdaSymbol{\{(}\AgdaBound{t}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}\AgdaBound{𝑨}\AgdaSymbol{)}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaSymbol{|}\AgdaSpace{}\AgdaBound{t}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaFunction{𝑻}\AgdaSymbol{(}\AgdaBound{X}\AgdaSymbol{)}\AgdaSymbol{,}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaBound{X}\AgdaSpace{}\AgdaSymbol{→}\AgdaBound{Y}\AgdaSymbol{\}}.%
\footnote{See, e.g.,~\cite{Bergman:2012} for more details.}
\end{quote}
To formalize this in Agda, we first prove that subuniverses are closed under the action of term operations.
\begin{code}\input{subuniverses/subtermclosed.tex}\end{code}
This proves \AgdaDatatype{Sg}\AgdaSpace{}\AgdaBound{Y}\AgdaSpace{}\AgdaSymbol{⊇}\AgdaSpace{}\AgdaSymbol{\{(}\AgdaBound{t}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}\AgdaBound{𝑨}\AgdaSymbol{)}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaSymbol{|}\AgdaSpace{}\AgdaBound{t}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaFunction{𝑻}\AgdaSymbol{(}\AgdaBound{X}\AgdaSymbol{)}\AgdaSymbol{,}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaBound{X}\AgdaSpace{}\AgdaSymbol{→}\AgdaBound{Y}\AgdaSymbol{\}}. Proof of the ⊆  direction follows from the three facts listed below, the third of which was already proved in Section~\ref{sec:subuniverse-generation} (see \AgdaFunction{sgIsSmallest}).
\begin{enumerate}
\item The image of 𝑌 under all terms, which we call \AgdaDatatype{TermImage}~\AgdaBound{Y}, is a subuniverse of \AgdaBound{𝑨}; i.e., \AgdaDatatype{TermImage}~\AgdaBound{Y}\AgdaSpace{}\AgdaSymbol{:=}\AgdaSpace{}\AgdaSymbol{\{(}\AgdaBound{t}\AgdaSpace{}\AgdaOperator{\AgdaFunction{̇}}\AgdaSpace{}\AgdaBound{𝑨}\AgdaSymbol{)}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaSymbol{|}\AgdaSpace{}\AgdaBound{t}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaFunction{𝑻}\AgdaSymbol{(}\AgdaBound{X}\AgdaSymbol{)}\AgdaSymbol{,}\AgdaSpace{}\AgdaBound{a}\AgdaSpace{}\AgdaSymbol{:}\AgdaSpace{}\AgdaBound{X}\AgdaSpace{}\AgdaSymbol{→}\AgdaBound{Y}\AgdaSymbol{\}}\AgdaSpace{}\AgdaSymbol{∈}\AgdaSpace{}\AgdaFunction{Subuniverses}\AgdaSpace{}\AgdaBound{𝑨}.
%
\item \AgdaBound{Y}\AgdaSpace{}\AgdaOperator{\AgdaFunction{⊆}}\AgdaSpace{}\AgdaDatatype{TermImage}\AgdaSpace{}\AgdaBound{Y}.
%
\item \AgdaDatatype{Sg}\AgdaSpace{}\AgdaBound{Y} is the smallest subuniverse containing \AgdaBound{Y} so \AgdaDatatype{Sg}\AgdaSpace{}\AgdaBound{Y}\AgdaSpace{}\AgdaOperator{\AgdaFunction{⊆}}\AgdaSpace{}\AgdaDatatype{TermImage}\AgdaSpace{}\AgdaBound{Y}.
\end{enumerate}
\begin{code}\input{subuniverses/termimagesub.tex}\end{code}
Finally, we can prove the desired inclusion.
\begin{code}
\>[1]\AgdaFunction{SgY⊆TermImageY}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝑨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∣}}\AgdaSpace{}%
\AgdaBound{𝓤}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sg}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊆}}\AgdaSpace{}%
\AgdaDatatype{TermImage}\AgdaSpace{}%
\AgdaBound{Y}\<%
\\
\>[1]\AgdaFunction{SgY⊆TermImageY}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sgIsSmallest}%
\>[775I]\AgdaSymbol{(}\AgdaFunction{TermImageIsSub}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Y⊆TermImageY}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\<%
\end{code}

%% \textbf{Exercise}. Prove the following by generalizing the relation ≃ to predicates:
%% \begin{Shaded}
%% \begin{Highlighting}[]
%% \NormalTok{SgY≃TermImageY }\OtherTok{:} \OtherTok{(}\NormalTok{Y }\OtherTok{:}\NormalTok{ Pred ∣ 𝑨 ∣ k}\OtherTok{)} \OtherTok{→} \OtherTok{(}\NormalTok{TermImage Y}\OtherTok{)}\NormalTok{ ≃ }\OtherTok{(}\NormalTok{Sg Y}\OtherTok{)}
%% \NormalTok{SgY≃TermImageY }\OtherTok{\{}\NormalTok{x}\OtherTok{\}}\NormalTok{ Y }\OtherTok{=}\NormalTok{ ?}
%% \end{Highlighting}
%% \end{Shaded}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The type of Subalgebras in Agda}\label{sec:the-type-of-subalgebras-in-agda}
We conclude this section with a useful definition that describes the type of a subalgebra of an algebra, and similarly the type of a subalgebra of some algebra in a class of algebras.
\begin{code}\input{subuniverses/newsub.tex}\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\subsection{Types for subalgebras}\label{sec:types-for-subalgebras}
The next submodule is a generalization of MHE's implementation of subgroups. We consider the subalgebras of an single arbitrary(but fixed) algebra 𝑨 and we present a module that generalizes \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#subgroups-sip}{MHE's ambient module} . It does for subuniverses what MHE does for subgroups.
\begin{code}\input{subuniverses/mheprelude.tex}\end{code}

Note that we introduce a new definition of the \texttt{subuniverse} type here. In cotrast to our earlier definition of \texttt{Subuniverses}, which uses a predicate on \texttt{∣\ 𝑨\ ∣} to represent the underlying set of the subuniverse, here we use the type \texttt{𝓟\ ∣\ 𝑨\ ∣}, the powerset of the universe of \texttt{𝑨}.
\begin{code}\input{subuniverses/mhepart1.tex}\end{code}

For a subuniverse B of 𝑨, we want to form a subalgebra 𝑩 = ⟨B, \ldots{}⟩ of 𝑨 such that the operations of 𝑩 are those of 𝑨 restricted to B. Here are some useful lemmas extracted from MHE's proof of subgroup-equality. The first is called f in MHE's proof.
\begin{code}\input{subuniverses/mhepart2.tex}\end{code}

So, two subuniverses are equal if and only if they have the same elements (cf.~\href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#371022}{MHE's notes on subgroup-equality}):
\begin{code}\input{subuniverses/mhepart3.tex}\end{code}

The converse of membership-equiv-gives-carrier-equality is obvious.
\begin{code}\input{subuniverses/mhepart4.tex}\end{code}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Equational logic in Agda}\label{sec:equational-logic-in-agda}
We begin this section by defining the notation \AF{Th} for the identities satisfied by all structures in a given class, and \AF{Mod} for all structures that satisfy a given collection of identities. Then we define the closure operators \AF H, \AF S, \AF P, and \emph{variety}. In Section~\ref{sec:types-for-identities}, we describe the \closuremodule of the \agdaualib in which we formalize these basic notions of equational logic in type theory. In particular, we will present inductive types that define \AF H-, \AF S-, and \AF P-closed classes recursively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Models and theories}\label{sec:models-and-theories}
Let \AB 𝑆 be a signature and \AB X an infinite collection of variable symbols. An \textbf{identity in the signature} \AB 𝑆 (or ``\AB 𝑆-identity'') is an ordered pair of terms (\AB 𝑝\AS\ASy ,\AS\AB 𝑞) in \TX\AS\ASy{×}\AS\TX. We often write \AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞 to indicate such an identity, but when we have a collection \AB Σ of identities, we write (\AB 𝑝\AS\ASy ,\AS\AB 𝑞)\AS\Ain \AS\AB Σ to denote that \AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞 belongs to \AB Σ.  We sometimes refer to an identity as an \textbf{equation}; for us, the words ``identity'' and ``equation'' are synonyms.

Let \AB 𝓚(\AB 𝑆) and \AB 𝓔(\AB 𝑆) denote the classes of all \AB 𝑆-algebras and \AB 𝑆-identities, respectively. If \AB 𝒦\AS\ASy ⊆\AS\AB 𝓚(\AB 𝑆) is a subclass and if \AB 𝑨\AS\Ain \AS\AB 𝒦, and (\AB 𝑝\AS\ASy ,\AS\AB 𝑞)\AS\Ain \AS\AB ℰ\AS\ASy ⊆\AS\AB 𝓔(\AB 𝑆), we say that%
\footnote{To produce the symbols \Aapprox  and \Amodels  in \emacs \agdamode, type \texttt{\textbackslash{}\textasciitilde{}\textasciitilde{}} and \texttt{\textbackslash{}models}, respectively.}
\begin{romanenumerate}
\item \AB 𝑨 \textbf{models} \AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞, denoted \AB 𝑨\AS\ASy \Amodels \AS\AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞, just in case \termA 𝑝\AS\ASy =\AS\termA 𝑞 extensionally, that is, \ASy ∀\AS\AB 𝑎\AS\ASy :\AS\AB 𝑋\AS\ASy →\AS\AB 𝐴\AS\ASy ,\AS\termA 𝑝\AS\AB 𝑎\AS\ASy =\AS\termA q\AS\AB 𝑎;
\item \AB 𝑨 \textbf{models} \AB ℰ, denoted \AB 𝑨\AS\ASy \Amodels \AS\AB ℰ, just in case \AB 𝑨\AS\ASy \Amodels \AS\AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞 holds for every (\AB 𝑝\AS\ASy ,\AS\AB 𝑞)\AS\Ain \AS\AB ℰ;
\item \AB 𝒦 \textbf{models} \AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞 just in case \AB 𝑨\AS\ASy \Amodels \AS\AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞 holds for every \AB 𝑨 in \AB 𝒦;
\item \AB 𝒦 \textbf{models} \AB ℰ just in case \AB 𝑨\AS\ASy \Amodels \AS\AB ℰ for every \AB 𝑨\AS\Ain \AS\AB 𝒦.
\end{romanenumerate}

\noindent \textbf{Notation}.  To denote ``\AB 𝒦 models \AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞'' we will use \AB 𝒦\AS\ASy \Amodels \AS\AB 𝑝\AS \Aapproxxx \AS\AB 𝑞 instead of the more standard \AB 𝒦\AS\ASy \Amodels \AS\AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞 to distinguish it from \AB 𝑨\AS\ASy \Amodels \AS\AB 𝑝\AS\ASy \Aapprox \AS\AB 𝑞 in our Agda implementation, since these must be represented by distinct types.%
\footnote{The symbol \Aapproxxx is produced in \emacs \agdamode with \texttt{\textbackslash{}\textasciitilde{}\textasciitilde{}\textasciitilde{}}.}

The binary relation \AS \Amodels  induces an obvious \textbf{Galois connection}. Indeed, the Galois pair (\AF{Mod}, \AF{Th}) is defined as follows: for all \AB ℰ\AS\ASy ⊆\AS\AB 𝓔(\AB 𝑆) and \AB 𝒦\AS\ASy ⊆\AS\AB 𝓚(\AB 𝑆),
\begin{quote}
\AF{Mod} \AB ℰ := \{ \AB 𝑨\AS\Ain \AS\AB 𝓚(\AB 𝑆)\AS\ASy :\AS\AB 𝑨\AS\ASy \Amodels \AS\AB ℰ \} and
\AF{Th} \AB 𝒦 := \{\AB ℯ\AS\Ain \AS\AB 𝓔(\AB𝑆)\AS\ASy :\AS\AB 𝒦\AS\ASy \Amodels \AS\AB ℯ \}.
\end{quote}
The first of these, the class of \textbf{models} of \AB ℰ, contains those and only those algebras modeling every identity in \AB ℰ. It is called an \textbf{equational class}, and \AB ℰ is called an \textbf{equational base} for, or an \textbf{axiomatization} of, the class. Dually, \AF{Th} \AB 𝒦 is the class of identities modeled by every algebra in \AB 𝒦. Such a class of identities is called an \textbf{equational theory}.

Equivalently equational classes and theories can be defined in terms of the two closure operators induced by the Galois pair (\AF{Mod}, \AF{Th}). Indeed, \AF{Mod} \AF{Th} and \AF{Th} \AF{Mod} are closure operators on \AB 𝓚(\AB 𝑆) and \AB 𝓔(\AB 𝑆), respectively, and
\begin{itemize}
\item an \textbf{equational class} is a \AF{Mod} \AF{Th}-closed class of \AB 𝑆-algebras;
\item an \textbf{equational theory} is a \AF{Th} \AF{Mod}-closed set of \AB 𝑆-identities.
\end{itemize}
%% (Here, \AB 𝒫 denotes the powerset functor.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{H S P}\label{sec:closure-operators}
An equational class is sometimes referred to as a \textbf{variety}, due to the celebrated Birkhoff theorem which states that a class of algebraic structures is an equational class if and only if it is closed under the taking of homomorphic images (\AF H), subalgebras (\AF S), and products (\AF P). A formal \agda proof of Birkhoff's theorem is one of our main goals which we achieve in the \birkhoffmodule presented in Section~\ref{sec:the-birkhoff-module}.

To make these notions precise, fix a signature \AB 𝑆, let \AB 𝒦 be a class of \AB 𝑆-algebras, and define
\begin{itemize}
\item \AF H(\AB 𝒦) = homomorphic images of members of \AB 𝒦;
\item \AF S(\AB 𝒦) = algebras isomorphic to a subalgebra of a member of \AB 𝒦;
\item \AF P(\AB 𝒦) = algebras isomorphic to a direct product of members of \AB 𝒦.
\end{itemize}
As a straight-forward verification confirms, \AF H, \AF S, and \AF P are closure operators. A class \AB 𝒦 of \AB 𝑆-algebras is said to be \emph{closed under the formation of homomorphic images} if \AF H(\AB 𝒦)\AS\ASy ⊆\AS\AB 𝒦. Similarly, \AB 𝒦 is \emph{closed under the formation of subalgebras} (resp., \emph{products}) provided \AF S(\AB 𝒦)\AS\ASy ⊆\AS\AB 𝒦 (resp., \AF P(\AB 𝒦)\AS\ASy ⊆\AS\AB 𝒦).

%% An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class \AF H(\AB 𝒦) (resp., \AF S(\AB 𝒦); resp., \AF P(\AB 𝒦)) is closed under isomorphism.

%% The operators \AF H, \AF S, and \AF P can be composed with one another repeatedly, forming yet more closure operators.
%% If C₁ and C₂ are closure operators on classes of structures, let us say that C₁ ≤ C₂ if for every class 𝒦 we have C₁(𝒦) ⊆ C₂(𝒦).

%% \subsection{Equational classes}\label{sec:equational-classes}
A class \AB 𝒦 of \AB 𝑆-algebras is called a \textbf{variety} if it is closed under each of the closure operators \AF H, \AF S, and \AF P. The corresponding closure operator---that is, the composition \AF H \AF S \AF P---is often denoted \AF 𝕍. Thus, if \AB 𝒦 is a class of similar algebras, then the \textbf{variety generated by} \AB 𝒦 is denoted by \AF 𝕍(\AB 𝒦) (= \AF H \AF S \AF P(\AB 𝒦)) and defined to be the smallest class that contains \AF 𝒦 and is closed under \AF H, \AF S, and \AF P.

To construct \AF 𝕍(\AB 𝒦) from \AB 𝒦, it's not obvious how many times the operators \AF H, \AF S, \AF P must be applied before the result stabilizes to form the variety generated by \AB 𝒦. Fortunately, Garrett Birkhoff proved in~\cite{Birkhoff:1935} that if they are applied in the correct order---namely, \AF P followed by \AF S followed by \AF H---then it suffices to apply each operator only once.

\subsection{Types for identities}\label{sec:types-for-identities}
%% In his treatment of Birhoff's HSP theorem, Cliff Bergman (at the start of Section 4.4 of his universal algebra textbook Bergman:2012) proclaims, ``Now, finally, we can formalize the idea we have been using since the first page of this text.'' He then proceeds to define \textbf{identities of terms} as follows (paraphrasing for notational consistency):

%% Let \AB 𝑆 be a signature. An \textbf{identity} or \textbf{equation} in \AB 𝑆 is an ordered pair of terms, written \AB 𝑝 \Aapprox \AB 𝑞, from the term algebra \TX. If \AB 𝑨 is an \AB 𝑆-algebra we say that \AB 𝑨 \textbf{satisfies} 𝑝 \Aapprox  𝑞 if 𝑝~̇~A~≡~𝑞~̇~A. In this situation, we write A \Amodels  𝑝 \Aapprox  𝑞.
%% If 𝒦 is a class of 𝑆-algebras, we write 𝒦 \Amodels  𝑝 ≋ 𝑞 if, for every A ∈ 𝒦, A \Amodels  𝑝 \Aapprox  𝑞. Finally, if 𝓔 is a set of equations, we write 𝒦 \Amodels  𝓔 if every member of 𝒦 satisfies every member of 𝓔.

We now describe the \closuremodule, which formalizes the notions of equational logic that we introduced above.
%% Thereafter, the module begins in earnest with
%% as follows. (Note the imports that were postponed until after the start of the closure module so that the imports share the same signature 𝑆 with the \closuremodule).
%% \begin{code}\input{closure/clo1.tex}\end{code}
%% Our first definition in the \closuremodule is 
%% notation that represents the satisfaction of equations. The standard notation is \texttt{𝑨\ \Amodels \ p\ \Aapprox \ q}, which means that the identity \texttt{p\ \Aapprox \ q} is satisfied in 𝑨. In otherwords, for all assignments \texttt{a\ :\ X\ →\ ∣\ 𝑨\ ∣} of values to variables, we have \texttt{(p\ ̇\ 𝑨)\ a\ ≡\ (q\ ̇\ 𝑨)\ a}.
%% If 𝒦 is a class of structures, it is standard to write \texttt{𝒦\ \Amodels \ p\ \Aapprox \ q} just in case all structures in the class 𝒦 model the identity p \Aapprox  q. However, because a class of structures has a different type than a single structure, we will need different notation, so we have settled on writing \texttt{𝒦\ \Amodels \ p\ ≋\ q} to denote this concept.
In particular, we will also formalize the notions of closure under the taking of products, subalgebras, and homomorphic images, and later prove that each of these closure operations preserves identities.

\paragraph*{Equations and models}
First the notation for modeling of equations is defined.
\begin{code}\input{closure/clomod.tex}\end{code}
The operators \AF{Th} and \AF{Mod} are defined as follows:
\begin{code}\input{closure/ModTh.tex}\end{code}

\paragraph*{H, S, P, and V}
Next, for each operator \AF H, \AF S, and \AF P, we formalize the closure under that operator as an inductive type.
\begin{code}\input{closure/clHSP.tex}\end{code}
Finally, the closure under the composition \AF H \AF S \AF P is also defined by recursion using the following inductive type.
\begin{code}\input{closure/clvar.tex}\end{code}

\subsection{Compatibility of H, S, and P with identities}\label{sec:compatibility-of-identities}
Identities are compatible with the formation of subalgebras, homomorphic images and products. More precisely, for every class 𝒦 of structures, each of the classes S(𝒦), H(𝒦), P(𝒦) (hence, 𝕍(𝒦)) satisfies the same set of identities as does 𝒦.

\paragraph*{Compatibility of products}
We prove that identities satisfied by all factors of a product are also satisfied by the product.
\begin{code}\input{closure/prodcomp.tex}\end{code}

\paragraph*{Compatibility of subalgebras}
Above we define a datatype SClo that represents a class of algebraic structures that is closed under the taking of subalgebras.

Let S(𝒦) denote the class of algebras isomorphic to a subalgebra of a member of 𝒦. With our new formal definition of Subalgebra, we will show that every term equation, \texttt{p\ \Aapprox \ q}, that is satisfied by all \texttt{𝑨\ ∈\ 𝒦} is also satisfied by all \texttt{B\ ∈\ S(𝒦)}. In other words, the collection of identities modeled by a given class of algebras is also modeled by all of the subalgebras of that class.
\begin{code}\input{closure/subcomp.tex}\end{code}

\paragraph*{Compatibility of homomorphisms}
An identity \AB p\AS \Aapprox\AS\AB q is satisfied by all algebras in a class if and only if \AB p\AS \Aapprox\AS\AB q is compatible with all homomorphisms from \TX into algebras of the class.

More precisely, if \AB 𝒦 is a class of \AB 𝑆-algebras and \AB 𝑝, \AB 𝑞 terms in the language of \AB 𝑆, then,
\begin{quote}
\AB 𝒦\AS\Amodels\AS\AB p\AS\Aapprox\AS\AB  q\AS\AS ↔\AS\AS\ASy ∀\AS\AB 𝑨\AS\ASy ∈\AS\AB 𝒦\AS\ASy ,\AS\ASy ∀\AS\AB h\AS\ASy ∈\AS\AF{Hom}\AS\TX\AS \AB 𝑨\AS\ASy ,\AB h\AS\ASy ∘\AS\termTX p\AS\ASy =\AS\AB h\AS\ASy ∘\AS\termTX q.
\end{quote}
We now formalize this result in Agda. Similarly, we define a datatype that represents classes of algebras that include all homomorphic images of algebras in the class, and we prove that identities satisfied by all algberas in a class are also satsified by all homomorphic images of algebras in the class.
\begin{code}\input{closure/homcomp.tex}\end{code}

Finally, here's a useful result about compatibility of identities and interpretation of terms.
\begin{code}\input{closure/homidcomp.tex}\end{code}



\subsection{Closure under H, S, and P}\label{sec:closure-under-hsp}
\subsubsection{Identities for product closure}\label{sec:identities-for-product-closure}
\begin{code}\input{closure/pclo-id.tex}\end{code}

\subsubsection{Identities for subalgebra closure}\label{sec:identities-for-subalgebra-closure}
\begin{code}\input{closure/sclo-id.tex}\end{code}

\subsubsection{Identities for hom image closure}\label{sec:identities-for-hom-image-closure}
\begin{code}\input{closure/hclo-id.tex}\end{code}

\subsubsection{Identities for HSP closure}\label{sec:identities-for-hsp-closure}
Finally, we have a datatype that represents classes of algebras that are close under the taking of homomorphic images, subalgebras, and products of algebras in the class.
\begin{code}\input{closure/vclo-id.tex}\end{code}


\subsection{Axiomatization of a class}\label{sec:axiomatization-of-a-class}
We now prove that a class \AB 𝒦 of structures is axiomatized by \AB{Th}\AS (\AB{VClo}\AS\AB 𝒦), which is the set of equations satisfied by all members of the varietal closure of \AB 𝒦.
\begin{code}\input{closure/vclo-th.tex}\end{code}

%% \begin{verbatim}
%% Th : Pred (Algebra 𝓤 𝑆)(𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ ) →   Pred (Term{X = X} × Term) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺)
%% Th 𝒦 = λ (p , q) → 𝒦 \Amodels  p ≋ q
%% Mod : Pred (Term{X = X} × Term) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺) →    Pred (Algebra 𝓤 𝑆)(𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ )
%% Mod ℰ = λ A → ∀ p q → (p , q) ∈ ℰ → A \Amodels  p \Aapprox  q
%% \end{verbatim}

\subsection{The free algebra in Agda}\label{sec:the-free-algebra-in-agda}
We proved in Section~\ref{sec:the-universal-property} above that term algebra \TX is absolutely free in the class \AB 𝓚(\AB 𝑆) of all \AB 𝑆-structures. In this section, we formalize, for a given class \AB 𝒦 of \AB 𝑆-algebras, the (relatively) free algebra in SP(\AB 𝒦) over \AB 𝑋. Recall, this is defined as follows:
\begin{quote}
𝔽(\AB 𝒦, \AB 𝑋) := \TX/\AB Ψ(\AB 𝒦, \TX).
\end{quote}
Thus, we must first formalize the congruence \AB Ψ(\AB 𝒦, \TX) which is defined by
\begin{quote}
Ψ(\AB 𝒦, \TX) := ⋀ ψ(\AB 𝒦, \TX),
\end{quote}
where ψ(\AB 𝒦, \TX) := \{θ ∈ Con \TX : \AB 𝑨/θ ∈ S(\AB 𝒦)\}.
%% Strictly speaking, 𝑋 is not a subset of 𝔽(𝒦, 𝑋) so it doesn't make sense to say that ``𝑋 generates 𝔽(𝒦, 𝑋).'' But as long as 𝒦 contains a nontrivial algebra, we will have Ψ(𝒦, 𝑻(𝑋)) ∩ 𝑋² ≠ ∅, and we can identify 𝑋 with 𝑋/Ψ(𝒦, 𝑻(𝑋)) in 𝔽(𝒦, 𝑋). (See Obs \%s \textless{}obs 9.6\textgreater{}.)
\begin{code}\input{closure/free.tex}\end{code}

N.B. Ψ is the kernel of \TX → 𝔽(\AB 𝒦, \TX). Therefore, to prove \AB 𝑨 is a homomorphic image of 𝔽(\AB 𝒦, \TX), it suffices to show that the kernel of the lift \AB h : \TX → \AB 𝑨 contains Ψ. (See figure below.)

\begin{verbatim}
   𝑻---- 𝑔 --->>𝔽  (ker 𝑔 = Ψ)
    \         .
     \       .
      ℎ     ∃ϕ     (want: Ψ ⊆ ker ℎ)
       \   .
        \ .
         V
         𝑨
\end{verbatim}

\subsection{More tools for Birkhoff's theorem}\label{sec:more-tools-for-birkhoffs-theorem}
Here are some of the key facts and identities we need to complete the proof of Birkhoff's HSP theorem.
\begin{code}\input{closure/birkhofftools.tex}\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%   Birkhoff's Theorem   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HSP Theorem in Agda}\label{sec:hsp-theorem-in-agda}
Here we give a formal proof in Agda of Birkhoff's theorem, which says that a variety is an equational class. In other terms, if a class 𝒦 of algebras is closed under the operators 𝑯, 𝑺, 𝑷, then 𝒦 is an equational class (i.e., 𝒦 is the class of algebras that model a particular set of identities).

\subsection{The birkhoff module}\label{sec:the-birkhoff-module}
In addition to the usual importing of dependencies, We start the \birkhoffmodule with a fixed signature and a type \AB X. As in the previous modules, \AB X represents an arbitrary (infinite) collection of ``variables,'' which will serve as the generators of the term algebra \TX.
%% \begin{code}\input{birkhoff/birkprelude.tex}\end{code}

\subsection{Equalizers in Agda}\label{sec:equalizers-in-agda}
The equalizer of two functions (resp., homomorphisms) \AB g\AS,\AS\AB h\AS\ASy :\AS\AB A\AS\ASy →\AS\AB B is the subset of \AB A on which the values of the functions \AB g and \AB h agree. We formalize this notion in Agda as follows.
\begin{code}\input{birkhoff/equalizers.tex}\end{code}
It turns out that the equalizer of two homomorphisms is closed under the operations of \AB 𝑨 and is therefore a subalgebra of the common domain, as we now prove.
\begin{code}\input{birkhoff/equalizersClosed.tex}\end{code}
Thus, \AF{𝑬𝑯} is a subuniverse of \AB 𝑨.

\subsection{Hom determination}\label{sec:hom-determination}
The \homsmodule formalizes the notion of homomorphism and proves some basic facts about them. Here we show that homomorphisms are determined by their values on a generating set, as stated and proved informally in Obs 3. This is proved here, and not in the \homsmodule because we need \texttt{Sg} from the \texttt{subuniverses} module. See Section~\ref{sec:}.
\begin{code}\input{birkhoff/homUnique.tex}\end{code}

\subsection{The Agda proof of Birkhoff's theorem}\label{sec:the-agda-proof-of-birkhoffs-theorem}
The proof is quite lengthy and uses all of the formalized definitions and results described above and more.  We do not reproduce the proof here, but refer the reader to the full listing of the \birkhoffmodule.  Suffice it to see how the statement of the theorem is formulated in Agda.
\begin{code}\input{birkhoff/birkhoffsTheoremStatement.tex}\end{code}

(TODO: Explain why this statement captures the full extend of the informal statement of the theorem.)

\section{Future work}
Some of our intermediate-term objectives include
\begin{itemize}
\item developing domain specific ``proof tactics'' to express the idioms of universal algebra,
\item incorporating automated proof search for universal algebra, and
\item formalizing theorems emerging from our own mathematics research,
\item documenting the resulting software libraries so they are usable by other working mathematicians.
\end{itemize}

%% \section{Acknowledgments}\label{sec:acknowledgments}
%% Besides the main authors and developers of \agdaualib, a number of other people have contributed to the project in one way or another.

%% Special thanks go to Clifford Bergman, Venanzio Capretta, Andrej Bauer, Miklós Maróti, and Ralph Freese, for many helpful discussions, as well as the invaluable instruction, advice, and encouragement that they continue to lend to this project, often without even knowing it.

%% The first author would also like to thank his postdoctoral advisors and their institutions for supporting work on this project. These include Peter Mayr and University of Colorado in Boulder (Aug 2017--May 2019), Ralph Freese and the University of Hawaii in Honolulu (Aug 2016--May 2017), and Cliff Bergman and Iowa State University in Ames (Aug 2014--May 2016).

%% \subsubsection{Attributions and citations}\label{sec:attributions-and-citations}
%% Regarding the mathematical results that are implemented in the \agdaualib library, as well as the presentation and informal statements of these results in the documentation, The Authors makes no claims to originality.

%% Regarding the Agda source code in the \agdaualib library, this is mainly due to The Authors.

%% We have benefited enormously from \href{https://www.cs.bham.ac.uk/~mhe}{Martin Escardo's} outstanding \typetopology Agda library and the notes on \hottufinagda in which that library is so lucidly described.

%% Of course, the (current incarnation\footnote{previous versions were based on Coq and Lean}) \agdaualib library depends on the wonderful Agda programming language~\cite{Norell:2009}.

%% The first author is greatly indebted to Martin for teaching him about type theory in Agda at the \href{http://events.cs.bham.ac.uk/mgs2019/}{Midlands Graduate School in the Foundations of Computing Science} in Birmingham in 2019.

%% The development of the \agdaualib and its documentation is informed by and benefits from the references listed in the references section below.

%% \subsection{References}\label{sec:references}
%% The following Agda documentation and tutorials are excellent. They have been quite helpful to The Author of \agdaualib, and have informed the development of the latter and its documentation.

%% \begin{itemize}
%% \tightlist
%% \item Altenkirk, \href{}{Computer Aided Formal Reasoning}
%% \item Bove and Dybjer, \href{}{Dependent Types at Work}
%% \item Escardo, \href{}{Introduction to Univalent Foundations of Mathematics with Agda}
%% \item Gunther, Gadea, Pagano, \href{}{Formalization of Universal Algebra in Agda}
%% \item János, \href{}{Agda Tutorial}
%% \item Norell and Chapman, \href{}{Dependently Typed Programming in Agda}
%% \item Wadler, \href{}{Programming Language Foundations in Agda}
%% \end{itemize}

%% Finally, the official \href{}{Agda Wiki}, \href{}{Agda User's Manual}, \href{}{Agda Language Reference}, and the (open source) \href{}{Agda Standard Library} source code are also quite useful.



\bibliography{ualib_refs}

%% \bibliography{lipics-v2019-sample-article}

\appendix

\section{Imports from Type Topology}\label{sec:imports-from-type-topology}
Here is a complete list of all definitions \agdaualib imports from Martin Escardo's \typetopology Agda library.
\begin{code} \input{prelude/imports.tex} \end{code}

\section{Miscellaneous proofs}\label{sec:appendix-miscproofs}
\subsection{Homomorphism factorization theorem}\label{sec:appendix-homfactor}
\begin{code}\input{homomorphisms/homfactor.tex}\end{code}
\subsection{Closure under intersection}\label{sec:closure-under-intersection}
The intersection ⋂ᵢ \AB 𝐴\(_i\) of a collection \{\AB 𝐴\(_i\)\AS ∣\AS\AB 𝐴\(_i\)\AS\ASy ≤\AS\AB 𝑨\}
of subuniverses of an algebra \AB 𝑨 is again a subuniverse of \AB 𝑨. Here is how we formalize the proof of this easy fact in Agda.
\begin{code}\input{subuniverses/subintersection.tex}\end{code}

\section{Styles of lists, enumerations, and descriptions}\label{sec:itemStyles}
List of different predefined enumeration styles:

\begin{itemize}
\item \verb|\begin{itemize}...\end{itemize}|
\item \dots
\item \dots
%\item \dots
\end{itemize}

\begin{enumerate}
\item \verb|\begin{enumerate}...\end{enumerate}|
\item \dots
\item \dots
%\item \dots
\end{enumerate}

\begin{alphaenumerate}
\item \verb|\begin{alphaenumerate}...\end{alphaenumerate}|
\item \dots
\item \dots
%\item \dots
\end{alphaenumerate}

\begin{romanenumerate}
\item \verb|\begin{romanenumerate}...\end{romanenumerate}|
\item \dots
\item \dots
%\item \dots
\end{romanenumerate}

\begin{bracketenumerate}
\item \verb|\begin{bracketenumerate}...\end{bracketenumerate}|
\item \dots
\item \dots
%\item \dots
\end{bracketenumerate}

\begin{description}
\item[Description 1] \verb|\begin{description} \item[Description 1]  ...\end{description}|
\item[Description 2] Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\item[Description 3]  \dots
%\item \dots
\end{description}

\cref{sec:testenv-proposition} and \autoref{sec:testenv-proposition} ...

\section{Theorem-like environments}\label{sec:theorem-environments}

List of different predefined enumeration styles:

\begin{theorem}\label{sec:testenv-theorem}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{theorem}

\begin{lemma}\label{sec:testenv-lemma}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{lemma}

\begin{corollary}\label{sec:testenv-corollary}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{corollary}

\begin{proposition}\label{sec:testenv-proposition}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{proposition}

\begin{exercise}\label{sec:testenv-exercise}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{exercise}

\begin{definition}\label{sec:testenv-definition}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{definition}

\begin{example}\label{sec:testenv-example}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{example}

\begin{note}\label{sec:testenv-note}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{note}

\begin{note*}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{note*}

\begin{remark}\label{sec:testenv-remark}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{remark}

\begin{remark*}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{remark*}

\begin{claim}\label{sec:testenv-claim}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claim}

\begin{claim*}\label{sec:testenv-claim2}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claim*}

\begin{proof}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{proof}

\begin{claimproof}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claimproof}


\end{document}


