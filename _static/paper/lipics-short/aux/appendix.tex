\section{Agda Prerequisites}

For the benefit of readers who are not proficient in Agda and/or type theory, we describe some of the most important types and features of Agda used in the \ualib.


%% Prelude %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \section{Preliminaries}\label{sec:preliminaries}
We begin by highlighting some of the key parts of \ualibPreliminaries of the \agdaualib. This module imports everything we need from Martin Escardo's \typetopology library~\cite{MHE}, defines some other basic types and proves some of their properties.  We do not cover the entire Preliminaries module here, but call attention to aspects that differ from standard Agda syntax. For more details, see~\cite[\S2]{DeMeo:2021}.




\subsection{Options and imports}\label{ssec:options-and-imports}
Agda programs typically begin by setting some options and by importing from existing libraries.
Options are specified with the \AgdaKeyword{OPTIONS} \emph{pragma} and control the way Agda behaves by, for example, specifying which logical foundations should be assumed when the program is type-checked to verify its correctness.  
All Agda programs in the \ualib begin with the pragma
\ccpad
\begin{code}[number=code:options]
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\end{code}
\ccpad
This has the following effects:
\begin{enumerate}
\item
  \texttt{without-K} disables \axiomk; see~\cite{agdaref-axiomk};
\item
  \texttt{exact-split} makes Agda accept only definitions that are \emph{judgmental} or \emph{definitional} equalities. As \escardo explains, this ``makes sure that pattern matching corresponds to Martin-L√∂f eliminators;'' for more details see~\cite{agdatools-patternmatching};
\item
  \texttt{safe} ensures that nothing is postulated outright---every non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module); see~\cite{agdaref-safeagda} and~\cite{agdatools-patternmatching}.
\end{enumerate}
Throughout this paper we take assumptions 1--3 for granted without mentioning them explicitly.


The \agdaualib adopts the notation of the \typetopology library. In particular, universes are denoted by capitalized script letters from the second half of the alphabet, e.g., \ab ùì§, \ab ùì•, \ab ùì¶, etc. Also defined in \typetopology are the operators~\af Ãá~and~\af ‚Å∫. These map a universe \ab ùì§ to \ab ùì§ \af Ãá := \Set \ab ùì§ and \ab ùì§ \af ‚Å∫ \aod := \lsuc \ab ùì§, respectively.  Thus, \ab ùì§ \af Ãá is simply an alias for \Set \ab ùì§, and we have \ab ùì§ \af Ãá \as : (\ab ùì§ \af ‚Å∫) \af Ãá. Table~\ref{tab:dictionary} translates between standard \agda syntax and \typetopology/\ualib notation.









\subsection{Agda's universe hierarchy}\label{ssec:agdas-universe-hierarchy}
The hierarchy of universe levels in Agda is structured as \ab{ùì§‚ÇÄ} \as : \ab{ùì§‚ÇÅ}, \hskip3mm \ab{ùì§‚ÇÅ} \as : \ab{ùì§‚ÇÇ}, \hskip3mm \ab{ùì§‚ÇÇ} \as : \ab{ùì§‚ÇÉ}, \ldots{}. This means that \ab{ùì§‚ÇÄ} has type \ab{ùì§‚ÇÅ} \AgdaFunction{Ãá} and \ab{ùì§‚Çô} has type \ab{ùì§‚Çô‚Çä‚ÇÅ} \AgdaFunction{Ãá} for each \ab n.  It is important to note, however, this does \emph{not} imply that \ab{ùì§‚ÇÄ} \as : \ab{ùì§‚ÇÇ} and \ab{ùì§‚ÇÄ} \as : \ab{ùì§‚ÇÉ}, and so on. In other words, Agda's universe hierarchy is \emph{noncummulative}. This makes it possible to treat universe levels more generally and precisely, which is nice. On the other hand, it is this author's experience that a noncummulative hierarchy can sometimes make for a nonfun proof assistant.  (See~\cite[\S3.3]{DeMeo:2021} for a more detailed discussion.)


%% This section describes parts of the \ualibLifts module of the \agdaualib.
Because of the noncummulativity of Agda's universe level hierarchy, certain proof verification (i.e., type-checking) tasks may seem unnecessarily difficult. Luckily there are ways to circumvent noncummulativity without introducing logical inconsistencies into the type theory. We present here some domain specific tools that we developed for this purpose. (See~\cite[\S3.3]{DeMeo:2021} for more details).

A general \af{Lift} record type, similar to the one found in the \af{Level} module of the \agdastdlib, is
defined as follows.
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Lift}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}%
\>[50]\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaInductiveConstructor{lift}\<%
\\
%
\>[1]\AgdaKeyword{field}\AgdaSpace{}%
\AgdaField{lower}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Lift}\<%
\end{code}
\ccpad
It is useful to know that \AgdaInductiveConstructor{lift} and \AgdaField{lower} compose to the identity.
\ccpad
\begin{code}%
\>[0]\AgdaFunction{lower‚àºlift}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùìß}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùìß}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaField{lower}\AgdaSymbol{\{}\AgdaBound{ùìß}\AgdaSymbol{\}\{}\AgdaBound{ùì¶}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚àò}}\AgdaSpace{}%
\AgdaInductiveConstructor{lift}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaFunction{ùëñùëë}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
\>[0]\AgdaFunction{lower‚àºlift}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}
\ccpad
Similarly, \AgdaInductiveConstructor{lift}\AgdaSpace{}\AgdaOperator{\AgdaFunction{‚àò}}\AgdaSpace{}\AgdaField{lower}\AgdaSpace{}\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}\AgdaFunction{ùëñùëë}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Lift}\AgdaSymbol{\{}\AgdaBound{ùìß}\AgdaSymbol{\}\{}\AgdaBound{ùì¶}\AgdaSymbol{\}}.

\subsubsection{The lift of an algebra}\label{ssec:the-lift-of-an-algebra}
More domain-specifically, here is how we lift types of operations and algebras.
\ccpad
\begin{code}%
  \input{aux/Lifts.tex}
\end{code}














\subsection{Dependent pairs and projections}\label{ssec:dependent-pairs-and-projections}
Given universes \ab ùì§ and \ab ùì•, a type \ab X \as : \ab ùì§ \aof Ãá, and a type family \ab Y \as : X \as ‚Üí \ab ùì• \aof Ãá, the \defn{Sigma type} (or \defn{dependent pair type}) is denoted by \AgdaRecord{Œ£}(\ab x \as Íûâ \ab X)\as ,\ab Y(\ab x) and generalizes the Cartesian product \ab X \as √ó \ab Y by allowing the type \ab Y(\ab x) of the second argument of the ordered pair (\ab x\as , \ab y) to depend on the value \ab x of the first.  That is, \AgdaRecord{Œ£}(\ab x \as Íûâ \ab X)\as ,\ab Y(\ab x) is inhabited by pairs (\ab x\as , \ab y) such that \ab x \as : \ab X and \ab y \as : \ab Y(\ab x).

Agda's default syntax for a Sigma type is \AgdaRecord{Œ£}\sP{3}\AgdaSymbol{Œª}(\ab x\sP{3}Íûâ\sP{3}\ab X)\sP{3}\as ‚Üí\sP{3}\ab Y, but we prefer the notation \AgdaRecord{Œ£}~\ab x~Íûâ~\ab X~,~\ab Y, which is closer to the standard syntax described in the preceding paragraph. Fortunately, this preferred notation is available in the \typetopology library (see~\cite[Œ£ types]{MHE}).\footnote{The symbol \as Íûâ in the expression \AgdaRecord{Œ£}\sP{3}\ab x\sP{3}\as Íûâ\sP{3}\ab X\sP{3}\AgdaComma\sP{3}\ab Y is not the ordinary colon (:); rather, it is the symbol obtained by typing \texttt{\textbackslash{}:4} in \agdatwomode.} 

\newcommand\FstUnder{\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}}\xspace}
\newcommand\SndUnder{\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}}\xspace}
Convenient notations for the first and second projections out of a product are \FstUnder and \SndUnder, respectively. However, to improve readability or to avoid notation clashes with other modules, we sometimes use more standard alternatives, such as \AgdaFunction{pr‚ÇÅ} and \AgdaFunction{pr‚ÇÇ}, or \AgdaFunction{fst} and \AgdaFunction{snd}, or some combination of these. The definitions are standard so we omit them (see~\cite{DeMeo:2021} for details).






\subsection{Equality}\label{ssec:equality}
Perhaps the most important types in type theory are the equality types. The \emph{definitional equality} we use is a standard one and is often referred to as ``reflexivity'' or ``refl''.  In our case, it is defined in the Identity-Type module of the \TypeTopology library, but apart from syntax it is equivalent to the identity type used in most other Agda libraries. Here is the definition.
%% full listing of the \texttt{Identity-Type} module.
\ccpad
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}‚â°\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}














\subsection{Function extensionality and intensionality}\label{sssec:function-extensionality-and-intensionality}
Extensional equality of functions, or \emph{function extensionality}, is a principle that is often assumed in the \agdaualib. It asserts that two point-wise equal functions are equal and is defined in the \typetopology library in the following natural way:
\ccpad
\begin{code}
  \>[0]\AgdaFunction{funext}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{)}\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{funext}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚àº}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{g}\<%
\end{code}
\ccpad
where \ab f \af ‚àº \ab g denotes pointwise equality, that is,
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}.

Pointwise equality of functions is typically what one means in informal settings when one says that two functions are equal. However, as \escardo notes in~\cite{MHE}, function extensionality is known to be not provable or disprovable in Martin-L√∂f Type Theory. It is an independent axiom which may be assumed (or not) without making the logic inconsistent.

Dependent and polymorphic notions of function extensionality are also defined in the \ualib and \typetopology libraries (see~\cite[\S2.4]{DeMeo:2021} and~\cite[\S17-18]{MHE}).

\defn{Function intensionality} is the opposite of function extensionality and it comes in handy whenever we have a definitional equality and need a point-wise equality.
\ccpad
\begin{code}%
\>[0]\AgdaFunction{intensionality}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[200I]\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{‚Üí}%
\>[.][@{}l@{}]\<[200I]%
\>[14]
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{g}%
\>[25]\AgdaSymbol{‚Üí}%
\>[28]\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSpace{}\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSpace{}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[0]\AgdaFunction{intensionality}%
\>[16]\AgdaSymbol{(}\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[29]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}
\ccpad
Of course, the intensionality principle has dependent and polymorphic analogues defined in the \agdaualib, but we omit the definitions. See~\cite[\S2.4]{DeMeo:2021} for details.







\subsection{Truncation and sets}\label{ssec:truncation-and-sets}
In general, we may have many inhabitants of a given type, hence (via Curry-Howard correspondence) many proofs of a given proposition. For instance, suppose we have a type \ab X and an identity relation \AgdaOperator{\AgdaDatatype{‚â°‚Çì}} on \ab X so that, given two inhabitants of \ab X, say, \ab a\AgdaSpace{}\ab b \as : \ab X, we can form the type \ab a \AgdaOperator{\AgdaDatatype{‚â°‚Çì}} \ab b. Suppose \ab p and \ab q inhabit the type \ab a \AgdaOperator{\AgdaDatatype{‚â°‚Çì}} \ab b; that is, \ab p and \ab q are proofs of \ab a \AgdaOperator{\AgdaDatatype{‚â°‚Çì}} \ab b, in which case we write \ab p \ab q : \ab a \AgdaOperator{\AgdaDatatype{‚â°‚Çì}} \ab b. Then we might wonder whether and in what sense are the two proofs \ab p and \ab q the ``same.'' We are asking about an identity type on the identity type \AgdaOperator{\AgdaDatatype{‚â°‚Çì}}, and whether there is some inhabitant \ab r of this type; i.e., whether there is a proof \ab r : \ab p \AgdaOperator{\AgdaDatatype{‚â°‚Çì‚ÇÅ}} \ab q.  If such a proof exists for all \ab p \ab q : \ab a \AgdaOperator{\AgdaDatatype{‚â°‚Çì}} \ab b, then we say that the proof of \ab a \AgdaOperator{\AgdaDatatype{‚â°‚Çì}} \ab b is \emph{unique}. As a property of the types \ab X and \aod{‚â°‚Çì}, this is sometimes called \emph{uniqueness of identity proofs}.

Perhaps we have two proofs, say, \ab r \ab s : \ab p \AgdaOperator{\AgdaDatatype{‚â°‚Çì‚ÇÅ}} \ab q. Then it is natural to wonder whether \ab r \AgdaOperator{\AgdaDatatype{‚â°‚Çì‚ÇÇ}} \ab s has a proof!  However, we may decide that at some level the potential to distinguish two proofs of an identity in a meaningful way (so-called \emph{proof relevance}) is not useful or interesting. At that point, say, at level \ab k, we might assume that there is at most one proof of any identity of the form \ab p  \AgdaOperator{\AgdaDatatype{‚â°‚Çì‚Çñ}} \ab q. This is called \emph{truncation}.

In \emph{homotopy type theory}~\cite{HoTT:2013}, a type \ab X with an identity relation \AgdaDatatype{‚â°‚Çì} is called a \defn{set} (or \defn{0-groupoid} or \defn{h-set}) if for every pair \ab a \ab b \as : \ab X of elements of type \ab X there is at most one proof of \ab a \AgdaDatatype{‚â°‚Çì} \ab b. This notion is formalized in the \TypeTopology library as follows:
\ccpad
\begin{code}[number=code:is-set]
\>[0]\AgdaFunction{is-set}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{is-set}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{is-subsingleton}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\end{code}
\ccpad
where
\ccpad
\begin{code}[number=code:is-subsingleton]
\>[0]\AgdaFunction{is-subsingleton}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{is-subsingleton}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}
\ccpad
Truncation is used in various places in the \ualib, and it is required in the proof of Birkhoff's theorem. Consult~\cite[\S34-35]{MHE} or~\cite[\S7.1]{HoTT:2013} for more details.













\subsection{Inverses, Epics and Monics}\label{ssec:inverses}
This section describes some of the more important parts of the \ualibInverses module.
In \S~\ref{ssec:inverse-image-type}, we define an inductive datatype that represents our semantic notion of the \defn{inverse image} of a function. In \S~\ref{ssec:epic-and-monic-function-types} we define types for \defn{epic} and \defn{monic} functions. Finally, in Subsections~\ref{ssec:monics-are-set-embeddings}, we consider the type of \defn{embeddings} (defined in~\cite[\S26]{MHE}), and determine how this type relates to our type of monic functions.

\subsubsection{Inverse image type}\label{ssec:inverse-image-type}

\begin{code}%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{Image\AgdaUnderscore{}‚àã\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\<%
\\
%
\>[2]\AgdaInductiveConstructor{im}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚àã}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[2]\AgdaInductiveConstructor{eq}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚àã}}\AgdaSpace{}%
\AgdaBound{b}\<%
\end{code}
\ccpad
Note that an inhabitant of \af{Image} \ab f \ad ‚àã \ab b is a dependent pair (\ab a \ac \ab p), where \ab a \as : \ab A and \ab p \as : \ab b  \ad ‚â° \ab f \ab a is a proof that \ab f maps \ab a to \ab b. Thus, a proof that \ab b belongs to the image of \ab f (i.e., an inhabitant of \af{Image} \ab f \ad ‚àã \ab b), is always accompanied by a witness \ab a \as : \ab A, and a proof that \ab b \ad{‚â°} \ab f \ab a, so the inverse of a function \ab f can actually be \emph{computed} at every inhabitant of the image of \ab f.

We define an inverse function, which we call \af{Inv}, which, when given \ab b \as : \ab B and a proof (\ab a \ac \ab p) \as : \af{Image} \ab f \ad ‚àã \ab b that \ab b belongs to the image of \ab f, produces \ab a (a preimage of \ab b under \ab f).
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{Inv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)(}\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚àã}}\AgdaSpace{}%
\AgdaBound{b}%
\>[61]\AgdaSymbol{‚Üí}%
\>[64]\AgdaBound{A}\<%
\\
%
\>[1]\AgdaFunction{Inv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaSymbol{.(}}\AgdaDottedPattern{\AgdaBound{f}}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaBound{a}}\AgdaDottedPattern{\AgdaSymbol{)}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{im}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\<%
\\
%
\>[1]\AgdaFunction{Inv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaUnderscore\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{eq}\AgdaSpace{}%
\AgdaUnderscore\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaUnderscore\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\<%
\end{code}
\ccpad
Thus, the inverse is computed by pattern matching on the structure of the third explicit argument, which has (inductive) type \AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}\AgdaBound{f}\AgdaSpace{}\AgdaOperator{\AgdaDatatype{‚àã}}\AgdaSpace{}\AgdaBound{b}.  Since there are two constructors, \AgdaInductiveConstructor{im} and \AgdaInductiveConstructor{eq}, that argument must take one of two forms. Either it has the form \AgdaInductiveConstructor{im}\AgdaSpace{}\AgdaBound{a} (in which case the second explicit argument is \as{.(}\ab f \ab a \as )),\footnote{The dotted pattern is used when the form of the argument is forced... todo: fix this sentence} or it has the form \AgdaInductiveConstructor{eq} \ab b \ab a \ab p, where \ab p is a proof of \ab b \aof ‚â° \ab f \ab a.  (The underscore characters replace \ab b and \ab p in the definition since \af{Inv} doesn't care about them; it only needs to extract and return the preimage \ab a.)

We can formally prove that \af{Inv} \ab f is the right-inverse of \ab f, as follows.  Again, we use pattern matching and structural induction.
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{InvIsInv}%
\>[156I]\AgdaSymbol{:}%
\>[157I]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[157I]%
\>[12]\AgdaSymbol{(}\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{b‚ààImgf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚àã}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSymbol{)}\<%
\\
\>[156I][@{}l@{\AgdaIndent{0}}]%
\>[11]\AgdaComment{----------------------}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{‚Üí}%
\>[12]\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Inv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{b‚ààImgf}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{b}\<%
\\
%
\>[1]\AgdaFunction{InvIsInv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaSymbol{.(}}\AgdaDottedPattern{\AgdaBound{f}}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaBound{a}}\AgdaDottedPattern{\AgdaSymbol{)}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{im}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
%
\>[1]\AgdaFunction{InvIsInv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{eq}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b‚â°fa}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{b‚â°fa}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚Åª¬π}}\<%
\end{code}
\ccpad
Here we give names to all the arguments for readability, but most of them could be replaced with underscores.

\subsubsection{Epic and monic function types}\label{ssec:epic-and-monic-function-types}
Given universes \ab ùì§, \ab ùì¶, types \AgdaTyped{A}{ùì§ Ãá} and \AgdaTyped{B}{ùì¶ Ãá}, and \ab f \as : \ab A \as ‚Üí \ab B, we say that \ab f is an \emph{epic} (or \emph{surjective}) \emph{function from} \ab A \emph{to} \ab B provided we can produce an element (or proof or witness) of type \af{Epic} \ab f, where
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{Epic}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}%
\>[45]\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{Epic}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{Image}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚àã}}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}
\ccpad
We obtain the (right-) inverse of an epic function \ab f by applying the following function %% \af{EpicInv} defined below 
to \ab f and a proof %% , \ab{p} \as : \af{Epic} \ab f, 
that \ab f is epic.
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{EpicInv}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[233I]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[233I]%
\>[11]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSpace{}%
\AgdaBound{f}\<%
\\
%
\>[11]\AgdaComment{--------------------}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{‚Üí}%
\>[11]\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[1]\AgdaFunction{EpicInv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Inv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{b}\AgdaSymbol{)}\<%
\end{code}
\ccpad
The function defined by \af{EpicInv} \ab f \ab{p} is indeed the right-inverse of \ab f, as we now prove.
%% Here is how we formalize that assertion and its proof.
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{EpicInvIsRightInv}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[262I]\AgdaFunction{funext}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[262I]%
\>[21]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}%
\>[34]\AgdaSymbol{(}\AgdaBound{fE}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSpace{}%
\AgdaBound{f}\AgdaSymbol{)}\<%
\\
%
\>[21]\AgdaComment{--------------------}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{‚Üí}%
\>[21]\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚àò}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{EpicInv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{fE}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaFunction{ùëñùëë}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\>[1]\AgdaFunction{EpicInvIsRightInv}\AgdaSpace{}%
\AgdaBound{fe}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{fE}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{fe}\AgdaSpace{}%
\AgdaSymbol{(Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{InvIsInv}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{fE}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\<%
\end{code}
\ccpad

Similarly, we say that \ab f \as : \ab A \as ‚Üí \ab B is a \defn{monic} (or \defn{injective}) function from \ab A to \ab B if we have a proof of \af{Monic} \ab f, where
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{Monic}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{Monic}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{a‚ÇÅ}\AgdaSpace{}%
\AgdaBound{a‚ÇÇ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{a‚ÇÅ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{a‚ÇÇ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{a‚ÇÅ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{a‚ÇÇ}\<%
\end{code}
As one would hope and expect, the \emph{left-}inverse of a monic function is derived from a proof \ab p~\as :~\af{Monic}~\ab f in a similar way. (See \af{MonicInv} and \af{MonicInvIsLeftInv} in \cite[\S2.3]{DeMeo:2021} for details.)







\subsection{Monic functions are set embeddings}\label{ssec:monics-are-set-embeddings}
An \defn{embedding}, as defined in~\cite[\S26]{MHE}, is a function with \emph{subsingleton fibers}. The meaning of this will be clear from the definition, which involves the three functions \af{is-embedding}, \af{is-subsingleton}, and \af{fiber}. The second of these is defined in (\ref{code:is-subsingleton}); the other two are defined as follows.
\ccpad
\begin{code}
\input{aux/is-embedding.tex}
\end{code}
\ccpad
This is not simply a \emph{monic} function (\S\ref{ssec:epic-and-monic-function-types}), and it is important to understand why not. Suppose \ab f~\as :~\ab X~\as ‚Üí~\ab Y is a monic function from \ab X to \ab Y, so we have a proof \ab p \as : \af{Monic} \ab f.  To prove \ab f is an embedding we must show that for every \ab y~\as :~\ab Y we have
\AgdaFunction{is-subsingleton}\AgdaSpace{}\AgdaSymbol{(}\AgdaFunction{fiber}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}.  That is, for all \ab y \as : \ab Y, we must prove the following implication:
%% show that if (\ab x \ac \ab p) and (\ab{x'} \ac \ab q) satisfy\\
\begin{equation*}
  \infer{(\ab x \Mac \ab p) \Maof ‚â° (\ab{x'} \Mac \ab q)}
    {(\ab x \ \ab{x'} \Mas : \ab X) & (\ab p \Mas : \ab f \ \ab x \Maof ‚â° \ab y) & (\ab q \Mas : \ab f\  \ab{x'} \Maof ‚â° \ab y) & (\ab m \Mas : \af{Monic}\ \ab f)}
\end{equation*}
By \ab m, \ab p, and \ab q, we have \ab r \as : \ab x \aof ‚â° \ab{x'}.
Thus, in order to prove \ab f~is an embedding, we must somehow show that the proofs \ab p and \ab q (each of which entails \ab f \ab x \aof ‚â° \ab y) are the same.  However, there is no axiom or deduction rule in \mltt to indicate that \ab p \aof ‚â° \ab q must hold; indeed, the two proofs may differ.

One way we could resolve this is to assume that the codomain type, \ab B, is a \emph{set}, i.e., has \emph{unique identity proofs}.
Recall the definition~(\ref{code:is-set}) of \af{is-set} from the \typetopology library.
If the codomain of \ab f \as : \ab A ‚Üí \ab B is a set, and if \ab p and \ab q are two proofs of an equality in \ab B, then \ab p \aof ‚â° \ab q, and we can use this to prove that a injective function into \ab B is an embedding.
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaFunction{monic-into-set-is-embedding}
\>[371I]\AgdaSymbol{:}%
\>[372I]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{is-set}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{‚Üí}%
\>[.][@{}l@{}]\<[372I]%
\>[21]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}%
\>[44]\AgdaSymbol{‚Üí}%
\>[47]\AgdaFunction{Monic}\AgdaSpace{}%
\AgdaBound{f}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[21]\AgdaComment{--------------------}\<%
\\
%
\>[2]\AgdaSymbol{‚Üí}%
\>[21]\AgdaFunction{is-embedding}\AgdaSpace{}%
\end{code}
\ccpad
We omit the formal proof for lack of space, but see~\cite[\S2.3]{DeMeo:2021}.













%% Relations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \section{Relations}\label{sec:relations}

\subsection{Unary Relations (predicates)}\label{sec:predicates}
\newcommand{\ovu}{\ab ùìû \af ‚äî \ab ùì• \af ‚äî \ab ùì§ \af ‚Å∫ \af Ãá}
We need a mechanism for implementing the notion of subsets in Agda. A typical one is called \af{Pred} (for predicate). More generally, \af{Pred} \ab A \ab ùì§ can be viewed as the type of a property that elements of type \ab{A} might satisfy. We write \ab P \as : \af{Pred} \ab A \ab ùì§ to represent the semantic concept of a collection of elements of type \ab{A} that satisfy the property \ab{P}.
Here is the definition, which is similar to the one found in the \texttt{Relation/Unary.agda} file of the \agdastdlib.
\ccpad
\begin{code}%
\>[1]\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\end{code}
\ccpad
Below we will often consider predicates over the class of all algebras of a particular type. %% We will define the type of algebras \af{Algebra} \ab ùì§ \ab ùëÜ (for some universe level \ab ùì§). Like all types, \af{Algebra} \ab ùì§ \ab ùëÜ itself has a type which happens to be \ovu (see Section~\ref{ssec:algebra-type}). Therefore, the type of \af{Pred} (\af{Algebra} \ab ùì§ \ab ùëÜ)\ab ùì§ is \ovu as well.  
By definition, the inhabitants of the type \af{Pred} (\af{Algebra} \ab ùì§ \ab ùëÜ) \ab ùì§ are maps of the form \ab ùë® \as ‚Üí \ab ùì§ \af Ãá.

In type theory everything is a type. As we have just seen, this includes subsets. Since the notion of equality for types is usually a nontrivial matter, it may be nontrivial to represent equality of subsets. Fortunately, it is straightforward to write down a type that represents what it means for two subsets to be equal in informal (pencil-paper) mathematics. In the \ualib we denote this \defn{subset equality} by =Ãá and define it as follows.\footnote{Our notation and definition representing the semantic concept ``\ab x belongs to \ab P,'' or ``\ab x has property \ab P,'' is standard. We write either \ab x \af ‚àà \ab P or \ab P \ab x. Similarly, the ``subset'' relation is denoted, as usual, with the \af{‚äÜ} symbol (cf.  in the \agdastdlib).  The relations \af ‚àà and \af{‚äÜ} are defined in the \agdaualib in a was similar to that found in the \texttt{Relation/Unary.agda} module of the \agdastdlib. (See~\cite[\S4.1.2]{DeMeo:2021}.)}
\ccpad
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}=Ãá\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaBound{ùì£}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùì£}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì£}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{=Ãá}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚äÜ}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{√ó}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚äÜ}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\<%
\end{code}

%% -- END: \input{Relations/Unary.tex} -------------------------------------------









\subsection{Binary Relations}\label{ssec:binary-relations}
%% This section highlights a few relevant parts of the \ualibBinary module of the \agdaualib.
%%-- BEGIN: \input{Relations/Binary.tex}----------
In set theory, a binary relation on a set \ab{A} is simply a subset of the product \ab A \af √ó \ab A. As such, we could model these as predicates over the type \ab A \af √ó \ab A, or as relations of type \ab A \as ‚Üí \ab A \as ‚Üí \ab ùì° \af Ãá (for some universe \ab ùì°). A generalization of this notion is a binary relation is a \emph{relation from} \ab{A} \emph{to} \ab{B}, which we define first and treat binary relations on a single \ab{A} as a special case.
\ccpad
\begin{code}%
\>[1]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\end{code}


%% \subsubsection{Properties of binary relations}\label{sssec:properties-of-binary-relations}
The notions of reflexivity, symmetry, and transitivity are defined as one would hope and expect, so we present them here without further explanation.
\begin{code}%
\>[1]\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{‚âà}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{‚âà}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{‚âà}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{‚âà}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{‚âà}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{‚âà}}\AgdaSpace{}%
\AgdaBound{z}\<%
\end{code}

%%-- END: \input{Relations/Binary.tex}----------








\subsection{Kernels of functions}\label{ssec:kernels}
The kernel of a function can be defined in many ways. For example,
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{KER}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{KER}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì°}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}
\ccpad
or as a unary relation (predicate) over the Cartesian product,
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{KER-pred}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{√ó}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ùì°}\<%
\\
%
\>[1]\AgdaFunction{KER-pred}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}
\ccpad
or as a relation from \ab{A} to \ab{B},
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùìù}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{KER-rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùì°}\<%
\\
%
\>[1]\AgdaFunction{KER-rel}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}












\subsection{Equivalence Relations}\label{sssec:equiv-relat}
Types for equivalence relations are defined in the \ualibEquivalences module of the \agdaualib using a \AgdaKeyword{record} type, as follows:
%% BEGIN: \input{Relations/Equivalences.tex}
\ccpad
\begin{code}%
\>[1]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaField{rfl}%
\>[9]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\<%
\\
%
\>[3]\AgdaField{sym}%
\>[9]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\<%
\\
%
\>[3]\AgdaField{trans}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\<%
\end{code}
\ccpad
For example, here is how we construct an equivalence relation out of the kernel of a function.
\ccpad
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[1]\AgdaFunction{map-kernel-IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[122I]\AgdaSymbol{\{}\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[122I]%
\>[28]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaRecord{IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{KER-rel}\AgdaSpace{}%
\AgdaBound{f}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaFunction{map-kernel-IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùì¶}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{record}%
\>[142I]\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{rfl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaInductiveConstructor{ùìá‚ÑØùíªùìÅ}\<%
\\
\>[.][@{}l@{}]\<[142I]%
\>[9]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{sym}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{x‚ÇÅ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{‚â°-sym}\AgdaSymbol{\{}\AgdaBound{ùì¶}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{x‚ÇÅ}\<%
\\
%
\>[9]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{trans}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaBound{x‚ÇÅ}\AgdaSpace{}%
\AgdaBound{x‚ÇÇ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{‚â°-trans}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{x‚ÇÅ}\AgdaSpace{}%
\AgdaBound{x‚ÇÇ}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
%% END: \input{Relations/Equivalences.tex}








\subsection{Relation truncation}\label{ssec:relation-truncation}
Here we discuss a special technical issue that will arise when working with quotients, specifically when we must determine whether two equivalence classes are equal.
Given a binary relation\footnote{Binary relations, as represented in Agda in general and the \ualib in particular, are described in \S\ref{ssec:binary-relations}.} \af P, it may be necessary or desirable to assume that there is at most one way to prove that a given pair of elements is \af P-related. This is an example of \defn{proof-irrelevance}; indeed, under this assumption, proofs of \af P \ab x \ab y are indistinguishable, or rather distinctions are irrelevant in given context.

In the \ualib, the \af{is-subsingleton} type of \typetopology is used to express the assertion that a given type is a set, or \defn{0-truncated}.  Above we defined truncation for a type with an identity relation, but the general principle can be applied to arbitrary binary relations.  Indeed, we say that \af P is a \defn{0-truncated binary relation} on \ab X if for all \ab x \ab y \as : \ab X we have \af{is-subsingleton} (\af P \ab x \ab y).
\ccpad
\begin{code}%
\>[1]\AgdaFunction{Rel‚ÇÄ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaFunction{Rel‚ÇÄ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{is-subsingleton}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\end{code}
\ccpad
Thus, a \defn{set}, as defined in \S\ref{ssec:sets}, is a type \ab X along with an equality relation \af ‚â° of type \af{Rel‚ÇÄ} \ab X \ab ùìù, for some \ab ùìù.









\subsection{Nonstandard notation and syntax}
The notation we adopt is that of the \typetopology library of \MartinEscardo. Here we give a few more details and a table (Table~\ref{tab:dictionary}) which translates between standard \agda syntax and \typetopology/\ualib notation.

Many occasions call for a the universe that is the least upper bound of two universes, say, \ab ùì§  and \ab ùì•. This is denoted by \ab ùì§ \AgdaSymbol{‚äî} \ab ùì• in standard Agda syntax, and in our notation the correponding type is (\ab ùì§ \AgdaSymbol{‚äî} \ab ùì•) Ãá, or, more simply, \ab ùì§ \AgdaSymbol{‚äî} \ab ùì• Ãá (since \AgdaUnderscore{}\AgdaSymbol{‚äî}\AgdaUnderscore{} has higher precedence than \AgdaUnderscore{}Ãá).

To justify the introduction of this somewhat nonstandard notation for universe levels, \escardo points out that the Agda library uses \AgdaKeyword{Level} for universes (so what we write as \ab ùì§ Ãá is written \Set\sP{3}\ab ùì§ in standard Agda), but in univalent mathematics the types in \ab ùì§ Ãá need not be sets, so the standard Agda notation can be misleading.

In addition to the notation described in \S\ref{ssec:options-and-imports} above, the level \lzero is renamed \AgdaBound{ùì§‚ÇÄ}, so \AgdaBound{ùì§‚ÇÄ}\af Ãá is an alias for \Set \lzero. (For those familiar the \href{https://leanprover.github.io/}{Lean} proof assistant, \AgdaBound{ùì§‚ÇÄ}\af Ãá (i.e., \Set \lzero) is analogous to Lean's \texttt{Sort 0}.)

\begin{table}
\begin{tabular}{r|l}
Standard \agda                        &          \typetopology/\ualib \\
\hline
\AgdaKeyword{Level}          &   \AgdaFunction{Universe}\\
\ab ùì§ : \AgdaKeyword{Level}  & \ab ùì§ : \AgdaFunction{Universe}\\
\Set \ab ùì§                  &       \ab ùì§ Ãá \\
\lsuc \ab ùì§                   &    \ab ùì§ ‚Å∫\\
\Set (\lsuc \ab ùì§) &    \ab ùì§ ‚Å∫ Ãá\\
\lzero                       &         \AgdaBound{ùì§‚ÇÄ}\\
\AgdaFunction{Setœâ}  &         \AgdaFunction{ùì§œâ}
\end{tabular}
\caption{Special notation for universe levels}
\label{tab:dictionary}
\end{table}

