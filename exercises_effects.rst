
.. include:: _static/math_macros.rst

=========
Exercises
=========

**ATTRIBUTION**. The exercises in this section were supplied by `Andrej Bauer`_ to students of his course on `Algebraic Effects and Handlers`_ at `OPLSS 2018`_. We are merely "borrowing" these exercises for the time being as they may be helpful when we implement theories in Lean.  However, this section will ultimately be replaced and/or removed, unless Andrej agrees to be listed as a coauthor of the documentation when it is publicly released.


.. proof:exercise:: The theory of an associative unital operation

   Consider the theory :math:`T` of an associative operation with a unit. It has a constant :math:`ε` and a binary operation :math:`·` satisfying equations

   .. math:: 
      :label: 1

      (x · y) · z &= x · (y · z)\\
            ε · x &= x\\
            x · ε &= x

   Give a useful description of the free model of :math:`T` generated by a set :math:`X`.

   You can either guess an explicit construction of free models and show that it has the required universal property, or you can analyze the free model construction (equivalence classes of well-founded trees) and provide a simple description of it.


   .. container:: toggle
 
      .. container:: header
 
         *Solution*
      
      Let :math:`\Term(X)` be the clone of term operations defined inductively using the signature of :math:`T`.

      Define an equivalence relation :math:`Θ` on :math:`\Term(X)` inductively as follows:

      :math:`(t, s) ∈ Θ` iff one of the following holds:
        
      #. :math:`t = s`,
      #. :math:`t = (x ⋅ y) ⋅ z` and :math:`s = x ⋅ (y ⋅ z)`,
      #. :math:`t = ε ⋅ x` and :math:`s = x`,
      #. :math:`t = x ⋅ ε` and :math:`s = x`,
      #. :math:`t = opᵢ (s₁,\dots ,sₙ)` and :math:`s = opᵢ (s₁',\dots ,sₙ')`) where :math:`∀ i, sᵢ, sᵢ' ∈ \Term(X)` and :math:`(sᵢ, sᵢ') ∈ Θ`.

      Let :math:`Θ` be the smallest equivalence relation on :math:`\Term(X)` containing all pairs :math:`(t,s)` that satisfy one of these five conditions.

      Define :math:`F(X) = \Term(X)/Θ`.  We will prove that :math:`F(X)` is free for :math:`T` over :math:`X`.

      Let :math:`𝔸 = ⟨ A, \{ε^𝔸, ⋅^𝔸\}⟩` be a structure in the signature :math:`σ = (\{ε, ⋅\}, ρ)`, where :math:`ρ\, ε = 0` (unary) and :math:`ρ \, ⋅ = 2` (binary).
      
      Assume the identities in :eq:`1` are satisfied for all :math:`x, y, z ∈ A` (with :math:`ε^𝔸` in place of :math:`ε` and :math:`⋅^𝔸` in place of :math:`⋅`).

      We must show that for every mapping :math:`φ: X → A` there exists a unique hom :math:`ψ: F(X) → A` such that :math:`ψ\, x = φ \, x` for all :math:`x ∈ X`.

      It's a basic fact that every mapping from :math:`X` to :math:`A` extends uniquely to a homomorphism from :math:`\Term(X)` to :math:`𝔸`.
      
      Fix a mapping :math:`φ: X → A` and let :math:`h` be the unique hom extending :math:`φ` to :math:`\Term(X)`.

      Consider the kernel of :math:`h`; that is, the equivalence relation,

      .. math:: \ker h = \{(t, s) ∣ h\, t  = h \, s\}.

      We prove :math:`\ker h = Θ`.

      The inclusion :math:`\ker h ⊇ Θ` can be seen as follows:
      
      If :math:`(t, s) ∈ Θ` then, by the definition of :math:`Θ`, one of the following holds:
      
      #. :math:`t = s` (which implies :math:`φ'\, t = φ'\, s`, obviously); or
      #. :math:`t = (x ⋅ y) ⋅ z` and :math:`s = x ⋅ (y ⋅ z)`, which implies
      
         .. math:: h\, t = ((h \, x) ⋅^𝔸 (h\, y)) ⋅^𝔸  (h\, z)  = (h \, x) ⋅^𝔸 ((h\, y))⋅^𝔸 (h\, z))
         
         since :math:`𝔸` models :eq:`1`; or,
      #. :math:`t = ε ⋅ x` and :math:`s = x`, which implies 

         .. math:: h\, t = (h \, ε) ⋅^𝔸 (h\, x) = ε^𝔸 ⋅^𝔸 (h\, x) = h\, x = h\, s

         since :math:`𝔸` models :eq:`1`; or,
         
      #. :math:`t = x ⋅ ε` and :math:`s = x`, which implies :math:`h\, t = h\, s` for the same reason as the last item; or
      
      #. :math:`t = opᵢ (s₁,\dots ,sₙ)` and :math:`s = opᵢ (s₁',\dots ,sₙ')` where :math:`∀ i, (sᵢ, sᵢ') ∈ Θ`, and this case is handled by induction.
      
      For the last case, we assume that :math:`(u, v) ∈ Θ` implies :math:`h\, u = h\, v` for all terms :math:`u` and :math:`v` of maximum height :math:`n`.  Let :math:`t` and :math:`s` be terms of height :math:`n+1`.  Then :math:`t = f (s₁,\dots ,sₙ)` and :math:`s = f (s₁',\dots ,sₙ')` for some operation symbol :math:`f`, and so we have
      
      .. math:: h\, t = f(h\, s_1, \dots, h\, s_n)\; \text{ and }\; h \, s = f(h\, s_1', \dots, h\, s_n').
         :label: 2

      But recall our assumption that :math:`∀ i, (s_i, s_i') ∈ Θ` implies :math:`h\, s_i = h\, s_i'`.  It clearly follows from this and :eq:`2` that :math:`h\, t = h\, s`.  

      Let us now prove the reverse inclusion :math:`\ker h ⊆ Θ`.
      
      Assume :math:`h\, t = h\, s`.  We must prove :math:`(t, s) ∈ Θ`. 

      **Todo** complete proof of :math:`\ker h ⊆ Θ`.

      Finally, observe that by the first isomorphism theorem there is a unique homomorphism :math:`ψ: \Term(X)/\ker h → A`, and that this map satisfies :math:`ψ x = φ x` holds for all :math:`x ∈ X`.) 
      

.. proof:exercise:: The theory of the apocalypse

   We formulate an algebraic theory :math:`\Time` in which it is possible to explicitly record passage of time. The theory has a single unary operation :math:`\tick` and no equations. Each application of :math:`\tick` records the passage of one time step.

     #. Give a useful description of the free model of the theory, generated by a set :math:`X`.

     #. Fix a natural number :math:`n`. Describe a theory ``Apocalypse`` which extends the theory :math:`\Time` so that a computation crashes (aborts, necessarily terminates) if it performs more than :math:`n` of ticks. Give a useful description of its free models.

   *Advice*. Do *not* concern yourself with any sort of operational semantics which somehow "aborts" after :math:`n` ticks. Instead, use equations and postulate that certain computations are equal to an aborted one.

   .. container:: toggle
 
      .. container:: header
 
         *Solution*

      #. The signature of the language is :math:`Σ_{\Time} = \{(\tick, 1)\}` (since there is only one operation (:math:`\tick`) and it is unary (i.e., :math:`1`-ary).

         Since there are no equations, the free model for :math:`\Time` over :math:`X` is simply the clone of term operations, denoted by :math:`\Tree := \Tree_{\Time}(X)`, which is defined inductively as follows:

         .. math:: \frac{x∈ X}{x ∈ \Tree} \qquad  \frac{t ∈ \Tree}{\tick t ∈ \Tree}

      #. Fix :math:`n ∈ ℕ`.  For the theory ``Apocalypse``, expand the signature to

         .. math:: Σ_A := Σ_{\Time} ∪ \{(n,0), (1,0)\},

         and define :math:`ℰ_A` to be the following set of equations:

         .. math:: \{\tick^n(x) = ⊥, \tick(⊥) = ⊥\}.

         Next, define :math:`Θ` to be the least equivalence relation on :math:`\Tree` containing the following pairs:

         .. math:: (\tick^n, 1) \;\text{ and }\; (\tick(⊥), ⊥).

         Then :math:`F_A(X) = \Tree_A(X)/Θ` is free for :math:`A` over :math:`X`.

         **To do**. Supply proof that the :math:`F_A(X)` so defined is free for :math:`A`.


.. proof:exercise:: The theory of partial maps

   The models of the empty theory are precisely sets and functions. Is there a theory whose models form (a category equivalent to) the category of sets and *partial* functions?

   Recall that a partial function `f: A ⇀ B` is an ordinary function `f: S → B` defined on a subset `S ⊆ A`. (How do we define composition of partial functions?)


   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*




.. proof:exercise:: Models in the Category of Models

   In Example 1.27 of the `reading material`_ it is calculated that a model of the theory `Group` in the category `Mod(Group)` is an abelian group.
   
   We may generalize this idea and ask about models of a theory :math:`T_1` in the category of models :math:`\Mod(T₂)` of a theory :math:`T_2`.

   The **tensor product** of algebraic theories :math:`T_1` and :math:`T_2` is a theory :math:`T₁ ⊗ T₂` such that the category of models of :math:`T₁` in the category :math:`Mod(T₂)` is equivalent to the category of models of :math:`T₁ ⊗ T₂`.

   *Hint*. Start by outlining what data are needed to have a :math:`T₁`-model in :math:`\Mod(T₂)`, and pay attention to the fact that the operations of :math:`T₁` must be interpreted as :math:`T₂`-homomorphisms. That will tell you what the ingredients of :math:`T₁ ⊗ T₂` should be.

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*

      What are the models of :math:`T₁` that belong to :math:`\Mod (T₂)`?

      A model of :math:`T₁`Let :math:`𝔾 = ⟨G, u, \inv, f ⟩` be a model of :math:`T₁` and  let :math:`G₂` be a model of :math:`T₂`. Let :math:`f` be an operation symbol in the signature :math:`Σ`.  Let :math:`fᵢ: (ρ f → Gᵢ) → Gᵢ` be the interpretation of :math:`f` in the model :math:`Gᵢ`.  We learned that :math:`f₁` must be a homomorphism relative to the operations of :math:`G₂`. In particular, for all :math:`aᵢ: ρ f → G₁`  

      .. math:: f₁ \, (f₂ a₀) \cdots (f₂ a_{ρ f}) =




.. proof:exercise:: Morita Equivalence

   It may happen that two theories :math:`T₁` and :math:`T₂` have equivalent categories of models, i.e.,

   .. math:: \Mod(T₁) ≃ \Mod(T₂).

   In such a case we say that :math:`T₁` and :math:`T₂` are **Morita equivalent**.

   Let :math:`T` be an algebraic theory and :math:`t` a term in context :math:`x_1,\dots , x_n`.

   Define a **definitional extension `T+[op:=t]`** to be the theory `T` extended with an additional operation `op` and equation

   .. math:: x_1, \dots, x_n | op(x_1, \dots,  x_n) = t

   We say that `op` is a **defined operation**.

   #. Confirm the intuitive feeling that `T+[op:=t]` by proving that `T` and `T+[op:=t]` are Morita equivalent.

   #. Formulate the idea of a definitional extension so that we allow an arbitrary set of defined operations, and show that we still have Morita equivalence.

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*




.. proof:exercise:: The theory of a given set

   Given a set :math:`A`, define the **theory** :math:`T(A)` **of the set** :math:`A` as follows:

   * for every :math:`n` and every map :math:`f: Aⁿ → A`, the map :math:`op(f)` is an :math:`n`-ary operation,
   * for all :math:`f: A^n → A`, :math:`g: A^n → A` and :math:`h_₁,\dots, h_n: A^n → A`, if

   .. math::          f ∘ (h_1, \dots, h_n) = g

   then we have an equation

   .. math::  x_1, \dots x_n | op(f)(op(h_1)(x_1,\dots, x_n), \dots, hn(x₁,\dots, xⱼ)) = g(x₁, …, xⱼ)

   Is `T({0,1})` Morita equivalent to another, well-known algebraic theory?

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*



.. proof:exercise:: A comodel for non-determinism

   In Example 4.6 of the `reading material`_ it is shown that there is no comodel of non-determinism in the category of sets. Can you suggest a category in which we get a reasonable comodel of non-determinism?

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*



.. proof:exercise:: Formalization of algebraic theories

   If you prefer avoiding doing "real" math, you can formalize algebraic theories and their comodels in your favorite proof assistant.

   A possible starting point is `this gist`_, and a good goal is the construction of the free model of a theory generated by a set (or a type).

   Because the free model requires quotienting, you should think ahead on how you are going to do that. Some possibilities are:

   * use homotopy type theory and make sure that the types involved are h-Sets
   * use setoids
   * suggest your own solution

   It may be wiser to first show as a warm-up exercise that theories without equations have initial models, as that only requires the construction of well-founded trees (which are inductive types).

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*



.. include:: hyperlink_references.rst
