
.. include:: _static/math_macros.rst

=========
Exercises
=========

**ATTRIBUTION**. The exercises in this section were supplied by `Andrej Bauer`_ to students of his course on `Algebraic Effects and Handlers`_ at `OPLSS 2018`_. We are merely "borrowing" these exercises for the time being as they may be helpful when we implement theories in Lean.  However, this section will ultimately be replaced and/or removed, unless Andrej agrees to be listed as a coauthor of the documentation when it is publicly released.


.. proof:exercise:: The theory of an associative unital operation

   Consider the theory :math:`T` of an associative operation with a unit. It has a constant :math:`ε` and a binary operation :math:`·` satisfying equations

   .. math:: 
      :label: 1

      (x · y) · z &= x · (y · z)\\
            ε · x &= x\\
            x · ε &= x

   Give a useful description of the free model of :math:`T` generated by a set :math:`X`.

   You can either guess an explicit construction of free models and show that it has the required universal property, or you can analyze the free model construction (equivalence classes of well-founded trees) and provide a simple description of it.


   .. container:: toggle
 
      .. container:: header
 
         *Solution*
      
      Let :math:`\Term(X)` be the clone of term operations defined inductively using the signature of :math:`T`.

      Define an equivalence relation :math:`Θ` on :math:`\Term(X)` inductively as follows:

        Let :math:`R` be the relation defined by :math:`(t, s) ∈ R` iff one of the following holds:
        
        #. :math:`t = s`,
        #. :math:`t = (x ⋅ y) ⋅ z` and :math:`s = x ⋅ (y ⋅ z)`,
        #. :math:`t = ε ⋅ x` and :math:`s = x`,
        #. :math:`t = x ⋅ ε` and :math:`s = x`,
        #. :math:`t = opᵢ (s₁,\dots ,sₙ)` and :math:`s = opᵢ (s₁',\dots ,sₙ')` where :math:`∀ i, sᵢ, sᵢ' ∈ \Term(X)` and :math:`(sᵢ, sᵢ') ∈ R`.

      Let :math:`Θ` be the smallest equivalence relation on :math:`\Term(X)` containing :math:`R`.

      Define :math:`F(X) = \Term(X)/Θ`.  We will prove that :math:`F(X)` is free for :math:`T` over :math:`X`.

      Let :math:`𝔸 = ⟨ A, \{ε^𝔸, ⋅^𝔸\}⟩` be an algebra in the signature :math:`σ = (\{ε, ⋅\}, ρ)`, where :math:`ρ\, ε = 0` (unary) and :math:`ρ \, ⋅ = 2` (binary).
      
      Assume the identities in :eq:`1` are satisfied for all :math:`x, y, z ∈ A` (with :math:`ε^𝔸` in place of :math:`ε` and :math:`⋅^𝔸` in place of :math:`⋅`).

      We must show that for every mapping :math:`φ: X → A` there exists a unique hom :math:`ψ: F(X) → 𝔸` such that :math:`ψ\, x = φ \, x` for all :math:`x ∈ X`.

      Fix a mapping :math:`φ: X → A`.
      
      It's a basic fact that every mapping from :math:`X` to :math:`A` extends uniquely to a homomorphism from :math:`\Term(X)` to :math:`𝔸`. Let :math:`h: \Term(X) → 𝔸` be the unique homomorphic extension of :math:`φ`.

      Consider the kernel of :math:`h`; that is, the equivalence relation,

      .. math:: \ker h = \{(t, s) ∣ h\, t  = h \, s\}.

      **Claim**. :math:`Θ ⊆ \ker h`.

        *Proof*. If :math:`(t, s) ∈ Θ` then by the definition of :math:`Θ` one of the following holds:
      
        #. :math:`t = s`;
        #. :math:`t = (x ⋅ y) ⋅ z` and :math:`s = x ⋅ (y ⋅ z)`;
        #. :math:`t = ε ⋅ x` and :math:`s = x`;
         
        #. :math:`t = x ⋅ ε` and :math:`s = x`;
      
        #. :math:`t = opᵢ (s₁,\dots ,sₙ)` and :math:`s = opᵢ (s₁',\dots ,sₙ')` where :math:`∀ i, (sᵢ, sᵢ') ∈ Θ`.
      
        In the first case we have :math:`h\, t = h\, s`, obviously. In the second case, 

        .. math:: h\, t = ((h \, x) ⋅^𝔸 (h\, y)) ⋅^𝔸  (h\, z)  = (h \, x) ⋅^𝔸 ((h\, y))⋅^𝔸 (h\, z)) = h\, s
         
        since :math:`𝔸` models :eq:`1`. For the same reason, the third case implies

        .. math:: h\, t = (h \, ε) ⋅^𝔸 (h\, x) = ε^𝔸 ⋅^𝔸 (h\, x) = h\, x = h\, s.

        The fourth case is similar. The fifth and final case is dispensed with by induction, as follows:
        
        Assume that :math:`(u, v) ∈ Θ` implies :math:`h\, u = h\, v` for all terms :math:`u` and :math:`v` of height at most :math:`n`.  Let :math:`t` and :math:`s` be terms of height :math:`n+1`.  Then :math:`t = f (s₁,\dots ,sₙ)` and :math:`s = f (s₁',\dots ,sₙ')` for some operation symbol :math:`f`, and so we have
      
        .. math:: h\, t = f(h\, s_1, \dots, h\, s_n)\; \text{ and }\; h \, s = f(h\, s_1', \dots, h\, s_n').
           :label: 2

        But recall our assumption that :math:`∀ i, (s_i, s_i') ∈ Θ` implies :math:`h\, s_i = h\, s_i'`.  It follows from this and :eq:`2` that :math:`h\, t = h\, s`.  This completes the proof of the claim.

      Let :math:`π: \Term(X) → \Term(X)/Θ` be the natural projection homomorphism that takes each :math:`t∈ \Term(X)` to its :math:`\Theta`-class, :math:`t/Θ ∈ \Term(X)/Θ`.

      Similarly, let :math:`k: \Term(X) → \Term(X)/\ker h` be the natural projection homomorphism :math:`t ↦ t/\ker h`.
      
      Since :math:`Θ ⊆ \ker h`, there is a unique mapping :math:`p: \Term(X)/Θ →  \Term(X)/\ker h` such that :math:`p ∘ π = k`, and by the first isomorphism theorem, there is a unique :math:`ψ': \Term(X)/\ker h → 𝔸` such that :math:`ψ' ∘ k = h`.

      It follows that the mapping :math:`ψ := ψ' ∘ p` is a homomorphism from :math:`F(X) = \Term(X)/Θ` and, by the uniqueness of :math:`h`, :math:`p`, and :math:`ψ'`, it's clear that :math:`ψ` is also the unique homomorphism satisfying :math:`ψ\, x = h \, x = φ\, x`. ☐   

.. proof:exercise:: The theory of the apocalypse

   We formulate an algebraic theory :math:`\Time` in which it is possible to explicitly record passage of time. The theory has a single unary operation :math:`\tick` and no equations. Each application of :math:`\tick` records the passage of one time step.

     #. Give a useful description of the free model of the theory, generated by a set :math:`X`.

     #. Fix a natural number :math:`n`. Describe a theory ``Apocalypse`` which extends the theory :math:`\Time` so that a computation crashes (aborts, necessarily terminates) if it performs more than :math:`n` of ticks. Give a useful description of its free models.

   *Advice*. Do *not* concern yourself with any sort of operational semantics which somehow "aborts" after :math:`n` ticks. Instead, use equations and postulate that certain computations are equal to an aborted one.

   .. container:: toggle
 
      .. container:: header
 
   *Solution*

   #. The signature of the language is :math:`τ = (\{\tick\}, ρ)`, where :math:`ρ\, \tick = 1`. (There is only one operation, :math:`\tick`, which is unary.)

      Since there are no equations, the free model for :math:`\Time` over :math:`X` is simply the clone of term operations, denoted by :math:`\Tree := \Tree_τ(X)`, which is defined inductively as follows:

      .. math:: \frac{x∈ X}{x ∈ \Tree} \qquad  \frac{t ∈ \Tree}{\tick\, t ∈ \Tree}

   #. Fix :math:`n ∈ ℕ`.  For the theory ``Apocalypse``, expand the signature :math:`τ` to

      .. math:: σ := (F, ρ), \; \text{ where } \; F:= \{\tick, ⊥, n\}\; \text{ and }\; ρ⊥ = ρ \,n = 0.

      Denote by :math:`\tick^n` the composition of :math:`\tick` with itself :math:`n` times and let :math:`T` be the theory generated by the following set of identities:

      .. math:: \{\tick ⊥ = ⊥\} ∪ \{\tick^n\, t= ⊥ ∣ t ∈ \Tree_σ(X)\}

      Next, define :math:`Θ` to be the least equivalence relation on :math:`\Tree_σ(X)` containing

      .. math:: \{(\tick ⊥, ⊥)\} ∪ \{(\tick^n t, ⊥) ∣ t∈ \Tree_σ(X)\}.

      **Claim**. :math:`F(X) =\Tree_σ(X)/Θ` is free for :math:`T` over :math:`X`.

      *Proof*. Let :math:`𝔸 = ⟨ A, F^𝔸 ⟩` be a model of :math:`T` and let :math:`φ : X → A` be an arbitrary mapping.
      
      We must show that there is a unique homomorphism :math:`ψ : F(X) → 𝔸` such that :math:`ψ \, x = \varphi \, x` holds for all :math:`x ∈ X`.
      
      **Todo**. Finish proof!

.. proof:exercise:: The theory of partial maps

   The models of the empty theory are precisely sets and functions. Is there a theory whose models form (a category equivalent to) the category of sets and *partial* functions?

   Recall that a partial function `f: A ⇀ B` is an ordinary function `f: S → B` defined on a subset `S ⊆ A`. (How do we define composition of partial functions?)


   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*




.. proof:exercise:: Models in the Category of Models

   In Example 1.27 of the `reading material`_ it is calculated that a model of the theory `Group` in the category `Mod(Group)` is an abelian group.
   
   We may generalize this idea and ask about models of a theory :math:`T_1` in the category of models :math:`\Mod(T₂)` of a theory :math:`T_2`.

   The **tensor product** of algebraic theories :math:`T_1` and :math:`T_2` is a theory :math:`T₁ ⊗ T₂` such that the category of models of :math:`T₁` in the category :math:`Mod(T₂)` is equivalent to the category of models of :math:`T₁ ⊗ T₂`.

   *Hint*. Start by outlining what data are needed to have a :math:`T₁`-model in :math:`\Mod(T₂)`, and pay attention to the fact that the operations of :math:`T₁` must be interpreted as :math:`T₂`-homomorphisms. That will tell you what the ingredients of :math:`T₁ ⊗ T₂` should be.

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*

      What are the models of :math:`T₁` that belong to :math:`\Mod (T₂)`?

      A model of :math:`T₁`Let :math:`𝔾 = ⟨G, u, \inv, f ⟩` be a model of :math:`T₁` and  let :math:`G₂` be a model of :math:`T₂`. Let :math:`f` be an operation symbol in the signature :math:`Σ`.  Let :math:`fᵢ: (ρ f → Gᵢ) → Gᵢ` be the interpretation of :math:`f` in the model :math:`Gᵢ`.  We learned that :math:`f₁` must be a homomorphism relative to the operations of :math:`G₂`. In particular, for all :math:`aᵢ: ρ f → G₁`  

      .. math:: f₁ \, (f₂ a₀) \cdots (f₂ a_{ρ f}) =




.. proof:exercise:: Morita Equivalence

   It may happen that two theories :math:`T₁` and :math:`T₂` have equivalent categories of models, i.e.,

   .. math:: \Mod(T₁) ≃ \Mod(T₂).

   In such a case we say that :math:`T₁` and :math:`T₂` are **Morita equivalent**.

   Let :math:`T` be an algebraic theory and :math:`t` a term in context :math:`x_1,\dots , x_n`.

   Define a **definitional extension `T+[op:=t]`** to be the theory `T` extended with an additional operation `op` and equation

   .. math:: x_1, \dots, x_n | op(x_1, \dots,  x_n) = t

   We say that `op` is a **defined operation**.

   #. Confirm the intuitive feeling that `T+[op:=t]` by proving that `T` and `T+[op:=t]` are Morita equivalent.

   #. Formulate the idea of a definitional extension so that we allow an arbitrary set of defined operations, and show that we still have Morita equivalence.

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*




.. proof:exercise:: The theory of a given set

   Given a set :math:`A`, define the **theory** :math:`T(A)` **of the set** :math:`A` as follows:

   * for every :math:`n` and every map :math:`f: Aⁿ → A`, the map :math:`op(f)` is an :math:`n`-ary operation,
   * for all :math:`f: A^n → A`, :math:`g: A^n → A` and :math:`h_₁,\dots, h_n: A^n → A`, if

   .. math::          f ∘ (h_1, \dots, h_n) = g

   then we have an equation

   .. math::  x_1, \dots x_n | op(f)(op(h_1)(x_1,\dots, x_n), \dots, hn(x₁,\dots, xⱼ)) = g(x₁, …, xⱼ)

   Is `T({0,1})` Morita equivalent to another, well-known algebraic theory?

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*



.. proof:exercise:: A comodel for non-determinism

   In Example 4.6 of the `reading material`_ it is shown that there is no comodel of non-determinism in the category of sets. Can you suggest a category in which we get a reasonable comodel of non-determinism?

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*



.. proof:exercise:: Formalization of algebraic theories

   If you prefer avoiding doing "real" math, you can formalize algebraic theories and their comodels in your favorite proof assistant.

   A possible starting point is `this gist`_, and a good goal is the construction of the free model of a theory generated by a set (or a type).

   Because the free model requires quotienting, you should think ahead on how you are going to do that. Some possibilities are:

   * use homotopy type theory and make sure that the types involved are h-Sets
   * use setoids
   * suggest your own solution

   It may be wiser to first show as a warm-up exercise that theories without equations have initial models, as that only requires the construction of well-founded trees (which are inductive types).

   .. container:: toggle
 
      .. container:: header
 
         *Solution coming soon*



.. include:: hyperlink_references.rst
