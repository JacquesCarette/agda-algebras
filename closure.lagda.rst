.. FILE      : closure.lagda.rst
.. AUTHOR    : William DeMeo and Siva Somayyajula
.. DATE      : 2 Jul 2020
.. UPDATE    : 29 Jul 2020
.. COPYRIGHT : (c) 2020 William DeMeo


.. _equational logic in agda:

Equational Logic in Agda
===========================

This chapter describes the `closure module`_ of the `agda-ualib`_.

-------------------------------------------

Preliminaries
---------------

As usual, the development begins by satisfying dependencies, although this time we postpone some imports until the start of the `closure module`_ so that these later imports can share the same signature with the module.

::

  {-# OPTIONS --without-K --exact-split --safe #-}

  open import basic
  open import prelude using (global-dfunext; dfunext; im)

----------------------------------------------------

Closure operators
-----------------

Fix a signature 𝑆.

Let 𝒦 be a class of 𝑆-algebras. Define

  * H(𝒦) = homomorphic images of members of 𝒦;
  * S(𝒦) = algebras isomorphic to a subalgebra of a member of 𝒦;
  * P(𝒦) = algebras isomorphic to a direct product of members of 𝒦.

As a straight-forward verification confirms, H, S, and P are closure operators. A class 𝒦 of 𝑆-algebras is said to be *closed under the formation of homomorphic images* if H(𝒦) ⊆ 𝒦. Similarly, 𝒦 is *closed under the formation of subalgebras* (resp., *products*) provided S(𝒦) ⊆ 𝒦 (resp., P(𝒦) ⊆ 𝒦).

An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class H(𝒦) (resp., S(𝒦); resp., P(𝒦)) is closed under isomorphism.

The operators H, S, and P can be composed with one another repeatedly, forming yet more closure operators. If C₁ and C₂ are closure operators on classes of structures, let us say that C₁ ≤ C₂ if for every class 𝒦 we have C₁(𝒦) ⊆ C₂(𝒦).

.. _lem 3.41:

.. proof:lemma:: Lem. 3.41 of :cite:`Bergman:2012`

   SH ≤ HS, PS ≤ SP.

   .. container:: toggle

      .. container:: header

         *Proof*.

      Let C ∈ SH(𝒦). Then C ≤ B for some B ∈ H(A), where A ∈ 𝒦.  Let θ be such that B ≅ A/θ.  Then C is isomorphic to a subalgebra, say, T, of A/θ.  By the correspondence theorem, there is a subalgebra S ≤ A such that S/θ = T.  Thus, C ∈ HS(A) ⊆ HS(𝒦), as desired.

      Let C ∈ PS(𝒦). Then C = Π Bᵢ for some Bᵢ ≤ Aᵢ ∈ 𝒦. Clearly, C = Π Bᵢ ≤ Π Aᵢ, so C ∈ SP(𝒦), as desired. ∎

---------------------------------------------

Equational classes
---------------------

A class 𝒦 of 𝑆-algebras is called a **variety** if it is closed under each of the closure operators H, S, and P introduced above; the corresponding closure operator is often denoted 𝕍. Thus, if 𝒦 is a class of similar algebras, then the **variety generated by** 𝒦 is denoted by 𝕍(𝒦) and defined to be the smallest class that contains 𝒦 and is closed under H, S, and P.

.. The class of all varieties of 𝑆-algebras is ordered by inclusion, and closed under arbitrary intersection; thus, the class of varieties is a complete lattice.

We would like to know how to construct 𝕍(𝒦) directly from 𝒦, but it's not immediately obvious how many times we would have to apply the operators H, S, P before the result stabilizes to form a variety---the **variety generated by** 𝒦.  Fortunately, Garrett Birkhoff proved that if we apply the operators in the correct order, then it suffices to apply each one only once.

.. proof:theorem:: Thm 3.43 of :cite:`Bergman:2012`

   𝕍 = HSP.

   .. container:: toggle

      .. container:: header

         *Proof*.

      Let 𝒦 be a class of algebras. To see that HSP(𝒦) is a variety, we use :numref:`Lemma %s <lem 3.41>` to compute H(HSP) = HSP, S(HSP) ≤ HS²P = HSP, P(HSP) ≤ HSP² = HSP. Thus HSP ≥ 𝕍.

      On the other hand, HSP(𝒦) ⊆ HSP(𝕍(𝒦)) = 𝕍(𝒦) so HSP ≤ 𝕍.

-------------------------------

Types for identities
----------------------

In his treatment of Birhoff's HSP theorem, Cliff Bergman (at the start of Section 4.4 of his universal algebra textbook :cite:`Bergman:2012`) proclaims, "Now, finally, we can formalize the idea we have been using since the first page of this text."  He then proceeds to define **identities of terms** as follows (paraphrasing for notational consistency):

Let 𝑆 be a signature.  An **identity** or **equation** in 𝑆 is an ordered pair of terms, written 𝑝 ≈ 𝑞, from the term algebra 𝑻(X). If A is an 𝑆-algebra we say that A **satisfies** 𝑝 ≈ 𝑞 if 𝑝 ̇ A ≡ 𝑞 ̇ A.  In this  situation,  we  write A ⊧ 𝑝 ≈ 𝑞.

If 𝒦 is a class of 𝑆-algebras, we write 𝒦 ⊧ 𝑝 ≋ 𝑞 if, for every A ∈ 𝒦, A ⊧ 𝑝 ≈ 𝑞. Finally, if 𝓔 is a set of equations, we write 𝒦 ⊧ 𝓔 if every member of 𝒦 satisfies every member of 𝓔.

We formalize these notions in Agda in the `closure module`_, which begins as follows. (Note the imports that were postponed until after the start of the closure module so that the imports share the same signature 𝑆 with the `closure module`_.

::

  module closure
   {𝑆 : Signature 𝓞 𝓥}
   {X : 𝓤 ̇ }
   {gfe : global-dfunext}
   {dfe : dfunext 𝓤 𝓤}
   {𝕏 : (𝑨 : Algebra 𝓤 𝑆) → X ↠ 𝑨} where

  open import homomorphisms {𝑆 = 𝑆} public
  open import terms {𝑆 = 𝑆} renaming (generator to ℊ) public
  open import subuniverses {𝑆 = 𝑆} public
  open import congruences public

::

Our first definition in the `closure module`_ is notation that represents the satisfaction of equations.

The standard notation is ``𝑨 ⊧ p ≈ q``, which means that the identity ``p ≈ q`` is satisfied in 𝑨. In otherwords, for all assignments ``a : X → ∣ 𝑨 ∣`` of values to variables, we have ``(p ̇ 𝑨) a ≡ (q ̇ 𝑨) a``.

If 𝒦 is a class of structures, it is standard to write ``𝒦 ⊧ p ≈ q`` just in case all structures in the class 𝒦 model the identity p ≈ q.  However, because a class of structures has a different type than a single structure, we will need different notation, so we have settled on writing ``𝒦 ⊧ p ≋ q`` to denote this concept.

::

  _⊧_≈_ : Algebra 𝓤 𝑆
   →      Term{X = X} → Term → 𝓤 ̇

  𝑨 ⊧ p ≈ q = (p ̇ 𝑨) ≡ (q ̇ 𝑨)

  _⊧_≋_ : Pred (Algebra 𝓤 𝑆) 𝓦
   →      Term{X = X} → Term → 𝓞 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓤 ⁺ ̇

  _⊧_≋_ 𝒦 p q = {𝑨 : Algebra _ 𝑆} → 𝒦 𝑨 → 𝑨 ⊧ p ≈ q

---------------------------------------------

Compatibility of identities
------------------------------

Identities are compatible with the formation of subalgebras, homomorphic images and products. More precisely, for every class 𝒦 of structures, each of the classes S(𝒦), H(𝒦), P(𝒦), 𝕍(𝒦) satisfies the same set of identities as does 𝒦.

Here we formalize the notion of closure under the taking of products, subalgebras, and homomorphic images, and we prove that each of these closures preserves identities.

.. _obs 13 in agda:

Closure under Products
~~~~~~~~~~~~~~~~~~~~~~~

First a data type that represents a class of algebraic structures that is closed under the taking of products of algebras in the class can be defined in Agda_ as follows.

::

  data PClo (𝒦 : Pred (Algebra 𝓤 𝑆)(𝓤 ⁺)) : Pred (Algebra 𝓤 𝑆) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ ) where
   pbase : {𝑨 : Algebra 𝓤 𝑆} → 𝑨 ∈ 𝒦 → 𝑨 ∈ PClo 𝒦
   prod : {I : 𝓤 ̇ }{𝒜 : I → Algebra _ 𝑆}
    →     (∀ i → 𝒜 i ∈ PClo 𝒦)
    →     ⨅ 𝒜 ∈ PClo 𝒦

We prove that identities satisfied by all factors of a product are also satisfied by the product.

::

  products-preserve-identities :
        (p q : Term{X = X})
        (I : 𝓤 ̇ ) (𝒜 : I → Algebra 𝓤 𝑆)
   →    ((i : I) → (𝒜 i) ⊧ p ≈ q)
       -----------------------------------
   →     ⨅ 𝒜 ⊧ p ≈ q

  products-preserve-identities p q I 𝒜 𝒜⊧p≈q = γ
   where
     γ : (p ̇ ⨅ 𝒜) ≡ (q ̇ ⨅ 𝒜)
     γ = gfe λ a →
      (p ̇ ⨅ 𝒜) a
        ≡⟨ interp-prod gfe p 𝒜 a ⟩
      (λ i → ((p ̇ (𝒜 i)) (λ x → (a x) i)))
        ≡⟨ gfe (λ i → cong-app (𝒜⊧p≈q i) (λ x → (a x) i)) ⟩
      (λ i → ((q ̇ (𝒜 i)) (λ x → (a x) i)))
        ≡⟨ (interp-prod gfe q 𝒜 a)⁻¹ ⟩
      (q ̇ ⨅ 𝒜) a
        ∎

  products-in-class-preserve-identities :
       (𝒦 : Pred (Algebra 𝓤 𝑆) ( 𝓤 ⁺ ))
       (p q : Term{X = X})
       (I : 𝓤 ̇ ) (𝒜 : I → Algebra 𝓤 𝑆)
   →   𝒦 ⊧ p ≋ q  →  ((i : I) → 𝒜 i ∈ 𝒦)
       ------------------------------------
   →    ⨅ 𝒜 ⊧ p ≈ q

  products-in-class-preserve-identities 𝒦 p q I 𝒜 𝒦⊧p≋q all𝒜i∈𝒦 = γ
   where
     𝒜⊧p≈q : ∀ i → (𝒜 i) ⊧ p ≈ q
     𝒜⊧p≈q i = 𝒦⊧p≋q (all𝒜i∈𝒦 i)

     γ : (p ̇ ⨅ 𝒜) ≡ (q ̇ ⨅ 𝒜)
     γ = products-preserve-identities p q I 𝒜 𝒜⊧p≈q

Closure under subalgebras
~~~~~~~~~~~~~~~~~~~~~~~~~~

Next, we define a datatype that represents a class of algebraic structures that is closed under the taking of subalgebras.

Let S(𝒦) denote the class of algebras isomorphic to a subalgebra of a member of 𝒦.  With our new formal definition of Subalgebra, we will show that every term equation, ``p ≈ q``, that is satisfied by all ``𝑨 ∈ 𝒦`` is also satisfied by all ``B ∈ S(𝒦)``. In other words, the collection of identities modeled by a given class of algebras is also modeled by all of the subalgebras of that class.


::

  -- Subalgebra Closure
  data SClo (𝒦 : Pred (Algebra 𝓤 𝑆) (𝓤 ⁺)) : Pred (Algebra 𝓤 𝑆) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ ) where
   sbase : {𝑨 :  Algebra _ 𝑆} → 𝑨 ∈ 𝒦 → 𝑨 ∈ SClo 𝒦
   sub : {𝑨 : Algebra _ 𝑆} → 𝑨 ∈ SClo 𝒦 → (sa : SubalgebrasOf 𝑨) → ∣ sa ∣ ∈ SClo 𝒦

  subalgebras-preserve-identities : (𝒦 : Pred (Algebra 𝓤 𝑆) ( 𝓤 ⁺ ))(p q : Term{X = X})
   →  (𝒦 ⊧ p ≋ q) → (SAK : SubalgebrasOfClass 𝒦)
   →  (pr₁ ∥ (pr₂ SAK) ∥) ⊧ p ≈ q
  subalgebras-preserve-identities 𝒦 p q 𝒦⊧p≋q SAK = γ
   where

    𝑨 : Algebra 𝓤 𝑆
    𝑨 = ∣ SAK ∣

    A∈𝒦 : 𝑨 ∈ 𝒦
    A∈𝒦 = ∣ pr₂ SAK ∣

    A⊧p≈q : 𝑨 ⊧ p ≈ q
    A⊧p≈q = 𝒦⊧p≋q A∈𝒦

    subalg : SubalgebrasOf 𝑨
    subalg = ∥ pr₂ SAK ∥

    𝑩 : Algebra 𝓤 𝑆
    𝑩 = pr₁ subalg

    h : ∣ 𝑩 ∣ → ∣ 𝑨 ∣
    h = ∣ pr₂ subalg ∣

    hem : is-embedding h
    hem = pr₁ ∥ pr₂ subalg ∥

    hhm : is-homomorphism 𝑩 𝑨 h
    hhm = pr₂ ∥ pr₂ subalg ∥

    ξ : (b : X → ∣ 𝑩 ∣ ) → h ((p ̇ 𝑩) b) ≡ h ((q ̇ 𝑩) b)
    ξ b =
     h ((p ̇ 𝑩) b)  ≡⟨ comm-hom-term gfe 𝑩 𝑨 (h , hhm) p b ⟩
     (p ̇ 𝑨)(h ∘ b) ≡⟨ intensionality A⊧p≈q (h ∘ b) ⟩
     (q ̇ 𝑨)(h ∘ b) ≡⟨ (comm-hom-term gfe 𝑩 𝑨 (h , hhm) q b)⁻¹ ⟩
     h ((q ̇ 𝑩) b)  ∎

    hlc : {b b' : domain h} → h b ≡ h b' → b ≡ b'
    hlc hb≡hb' = (embeddings-are-lc h hem) hb≡hb'

    γ : 𝑩 ⊧ p ≈ q
    γ = gfe λ b → hlc (ξ b)


.. _obs 14 in agda:

Closure under hom images
~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall (:numref:`Obs %s <obs 14>`) that an identity is satisfied by all algebras in a class if and only if that identity is compatible with all homomorphisms from the term algebra 𝑻(X) into algebras of the class.  More precisely, if𝓚 is a class of 𝑆-algebras and 𝑝, 𝑞 terms in the language of 𝑆, then,

.. math:: 𝒦 ⊧ p ≈ q \; ⇔ \; ∀ 𝑨 ∈ 𝒦, ∀ h ∈ \mathrm{Hom}(𝑻(X), 𝑨), h ∘ p^{𝑻(X)} = h ∘ q^{𝑻(X)}.

We now formalize this result in Agda. Similarly, we define a datatype that represents classes of algebras that include all homomorphic images of algebras in the class, and we prove that identities satisfied by all algberas in a class are also satsified by all homomorphic images of algebras in the class.

::

  --Closure under hom images
  data HClo (𝒦 : Pred (Algebra 𝓤 𝑆)(𝓤 ⁺)) : Pred (Algebra 𝓤 𝑆) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ ) where
   hbase : {𝑨 : Algebra 𝓤 𝑆} → 𝑨 ∈ 𝒦 → 𝑨 ∈ HClo 𝒦
   hhom : {𝑨 : Algebra 𝓤 𝑆} → 𝑨 ∈ HClo 𝒦 → ((𝑩 , _ ) : HomImagesOf 𝑨) → 𝑩 ∈ HClo 𝒦

  module _ {𝒦 : Pred (Algebra 𝓤 𝑆) (𝓤 ⁺)} where

   -- ⇒ (the "only if" direction)
   identities-compatible-with-homs : (p q : Term{X = X})
    →                𝒦 ⊧ p ≋ q
         ----------------------------------------------------
    →     ∀ 𝑨 KA h → ∣ h ∣ ∘ (p ̇ (𝑻(X))) ≡ ∣ h ∣ ∘ (q ̇ (𝑻(X)))
   -- Here, the inferred types are
   -- 𝑨 : Algebra 𝓤 𝑆, KA : 𝒦 𝑨, h : hom ((𝑻(X))) 𝑨

   identities-compatible-with-homs p q 𝒦⊧p≋q 𝑨 KA h = γ
    where
     pA≡qA : p ̇ 𝑨 ≡ q ̇ 𝑨
     pA≡qA = 𝒦⊧p≋q KA

     pAh≡qAh : ∀(𝒂 : X → ∣ 𝑻(X) ∣ )
      →        (p ̇ 𝑨)(∣ h ∣ ∘ 𝒂) ≡ (q ̇ 𝑨)(∣ h ∣ ∘ 𝒂)
     pAh≡qAh 𝒂 = intensionality pA≡qA (∣ h ∣ ∘ 𝒂)

     hpa≡hqa : ∀(𝒂 : X → ∣ 𝑻(X) ∣ )
      →        ∣ h ∣ ((p ̇ 𝑻(X)) 𝒂) ≡ ∣ h ∣ ((q ̇ 𝑻(X)) 𝒂)
     hpa≡hqa 𝒂 =
      ∣ h ∣ ((p ̇ 𝑻(X)) 𝒂)  ≡⟨ comm-hom-term gfe (𝑻 X) 𝑨 h p 𝒂 ⟩
      (p ̇ 𝑨)(∣ h ∣ ∘ 𝒂) ≡⟨ pAh≡qAh 𝒂 ⟩
      (q ̇ 𝑨)(∣ h ∣ ∘ 𝒂) ≡⟨ (comm-hom-term gfe (𝑻 X) 𝑨 h q 𝒂)⁻¹ ⟩
      ∣ h ∣ ((q ̇ 𝑻(X)) 𝒂)  ∎

     γ : ∣ h ∣ ∘ (p ̇ 𝑻(X)) ≡ ∣ h ∣ ∘ (q ̇ 𝑻(X))
     γ = gfe hpa≡hqa

   -- ⇐ (the "if" direction)
   homs-compatible-with-identities : (p q : Term)
    →    (∀ 𝑨 KA h  →  ∣ h ∣ ∘ (p ̇ 𝑻(X)) ≡ ∣ h ∣ ∘ (q ̇ 𝑻(X)))
         --------------------------------------------------
    →                𝒦 ⊧ p ≋ q
   --inferred types: 𝑨 : Algebra 𝓤 𝑆, KA : 𝑨 ∈ 𝒦, h : hom (𝑻(X)) 𝑨

   homs-compatible-with-identities p q all-hp≡hq {𝑨} KA = γ
    where
     h : (𝒂 : X → ∣ 𝑨 ∣) → hom (𝑻 X) 𝑨
     h 𝒂 = lift-hom{𝑨 = 𝑨} 𝒂

     γ : 𝑨 ⊧ p ≈ q
     γ = gfe λ 𝒂 →
      (p ̇ 𝑨) 𝒂
        ≡⟨ 𝓇ℯ𝒻𝓁 ⟩
      (p ̇ 𝑨)(∣ h 𝒂 ∣ ∘ ℊ)
        ≡⟨(comm-hom-term gfe (𝑻 X) 𝑨 (h 𝒂) p ℊ)⁻¹ ⟩
      (∣ h 𝒂 ∣ ∘ (p ̇ 𝑻(X))) ℊ
        ≡⟨ ap (λ - → - ℊ) (all-hp≡hq 𝑨 KA (h 𝒂)) ⟩
      (∣ h 𝒂 ∣ ∘ (q ̇ 𝑻(X))) ℊ
        ≡⟨ (comm-hom-term gfe (𝑻 X) 𝑨 (h 𝒂) q ℊ) ⟩
      (q ̇ 𝑨)(∣ h 𝒂 ∣ ∘ ℊ)
        ≡⟨ 𝓇ℯ𝒻𝓁 ⟩
      (q ̇ 𝑨) 𝒂
        ∎

   compatibility-of-identities-and-homs : (p q : Term)
    →  (𝒦 ⊧ p ≋ q)
        ⇔ (∀ 𝑨 ka hh → ∣ hh ∣ ∘ (p ̇ 𝑻(X)) ≡ ∣ hh ∣ ∘ (q ̇ 𝑻(X)))
   --inferred types: 𝑨 : algebra 𝓤 s, ka : 𝑨 ∈ 𝒦, hh : hom (𝑻(X)) 𝑨.

   compatibility-of-identities-and-homs p q =
     identities-compatible-with-homs p q ,
     homs-compatible-with-identities p q

   ---------------------------------------------------------------

   --Compatibility of identities with interpretation of terms
   hom-id-compatibility : (p q : ∣ 𝑻(X) ∣ )
                          (𝑨 : Algebra _ 𝑆)
                          (ϕ : hom (𝑻 X) 𝑨)
    →                     (𝑨 ⊧ p ≈ q)
                         -------------------
    →                     ∣ ϕ ∣ p ≡ ∣ ϕ ∣ q

   hom-id-compatibility p q 𝑨 ϕ pA≡qA =
      ∣ ϕ ∣ p              ≡⟨ ap ∣ ϕ ∣ (term-agreement{gfe = gfe} p) ⟩
      ∣ ϕ ∣ ((p ̇ 𝑻 X) ℊ)  ≡⟨ (comm-hom-term gfe (𝑻 X) 𝑨 ϕ p ℊ) ⟩
      (p ̇ 𝑨) (∣ ϕ ∣ ∘ ℊ)  ≡⟨ intensionality pA≡qA (∣ ϕ ∣ ∘ ℊ)  ⟩
      (q ̇ 𝑨) (∣ ϕ ∣ ∘ ℊ)  ≡⟨ (comm-hom-term gfe (𝑻 X) 𝑨 ϕ q ℊ)⁻¹ ⟩
      ∣ ϕ ∣ ((q ̇ 𝑻 X) ℊ)  ≡⟨ (ap ∣ ϕ ∣ (term-agreement{gfe = gfe} q))⁻¹ ⟩
      ∣ ϕ ∣ q  ∎


Equational theories and classes
---------------------------------

Here we define the notation ``Th`` for the identities satisfied by all structures in a given class, and ``Mod`` for all structures that satisfy a given collection of identities.

::

  Th : Pred (Algebra 𝓤 𝑆)(𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ ) → Pred (Term{X = X} × Term) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺)
  Th 𝒦 = λ (p , q) → 𝒦 ⊧ p ≋ q

  Mod : Pred (Term{X = X} × Term) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺) → Pred (Algebra 𝓤 𝑆)(𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ )
  Mod ℰ = λ A → ∀ p q → (p , q) ∈ ℰ → A ⊧ p ≈ q

------------------------------------------

.. _the free algebra in agda:

The free algebra in Agda
---------------------------

Recall, we proved above that term algebra 𝑻(𝑋) is the absolutely free algebra in the class 𝓚(𝑆) of all 𝑆-structures. In this section, we formalize, for a given class 𝒦 of 𝑆-algebras, the (relatively) free algebra in SP(𝒦) over 𝑋.  Recall, this was defined above in :numref:`free algebras` as follows:

  𝔽(𝒦, 𝑋) := 𝑻(𝑋)/Ψ(𝒦, 𝑻(𝑋)).

Thus, we must first formalize the congruence ψ(𝒦, 𝑻(𝑋)) which is defined by

  Ψ(𝒦, 𝑻(𝑋)) := ⋀ ψ(𝒦, 𝑻(𝑋)),

where ψ(𝒦, 𝑻(𝑋)) := \{θ ∈ Con 𝑻(𝑋) : 𝑨/θ ∈ S(𝒦)\}.

Strictly speaking, 𝑋 is not a subset of 𝔽(𝒦, 𝑋) so it doesn't make sense to say that "𝑋 generates 𝔽(𝒦, 𝑋)."  But as long as 𝒦 contains a nontrivial algebra, we will have Ψ(𝒦, 𝑻(𝑋)) ∩ 𝑋² ≠ ∅, and we can identify 𝑋 with 𝑋/Ψ(𝒦, 𝑻(𝑋)) in 𝔽(𝒦, 𝑋). (See :numref:`Obs %s <obs 9.6>`.)

::

  module _ {𝒦 : Pred (Algebra 𝓤 𝑆) (𝓤 ⁺)} where

   𝑻HI = HomImagesOf (𝑻 X)

   𝑻img : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ ̇
   𝑻img  =  Σ 𝑨 ꞉ (Algebra 𝓤 𝑆) ,
              Σ ϕ ꞉ hom (𝑻 X) 𝑨 , (𝑨 ∈ SClo 𝒦) × Epic ∣ ϕ ∣

   𝑻𝑨 : (ti : 𝑻img) → Algebra 𝓤 𝑆
   𝑻𝑨 ti = ∣ ti ∣

   𝑻𝑨∈SClo𝒦 : (ti : 𝑻img) → (𝑻𝑨 ti) ∈ SClo 𝒦
   𝑻𝑨∈SClo𝒦 ti = ∣ pr₂ ∥ ti ∥ ∣

   𝑻ϕ : (ti : 𝑻img) → hom (𝑻 X) (𝑻𝑨 ti)
   𝑻ϕ ti = pr₁ ∥ ti ∥

   𝑻ϕE : (ti : 𝑻img) → Epic ∣ (𝑻ϕ ti) ∣
   𝑻ϕE ti = ∥ pr₂ ∥ ti ∥ ∥

   𝑻KER : 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ ̇
   𝑻KER = Σ (p , q) ꞉ (∣ (𝑻 X) ∣ × ∣ (𝑻 X) ∣) ,
      ∀ ti → (p , q) ∈ KER-pred{B = ∣ (𝑻𝑨 ti) ∣} ∣ 𝑻ϕ ti ∣

   Ψ : Pred (∣ (𝑻 X) ∣ × ∣ (𝑻 X) ∣) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺)
   Ψ (p , q) =
    ∀ ti → ∣ (𝑻ϕ ti) ∣ ∘ (p ̇ 𝑻(X)) ≡ ∣ (𝑻ϕ ti) ∣ ∘ (q ̇ 𝑻(X))

   Ψ' : Pred (∣ (𝑻 X) ∣ × ∣ (𝑻 X) ∣) (𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺)
   Ψ' (p , q) = ∀ ti → ∣ (𝑻ϕ ti) ∣ p ≡ ∣ (𝑻ϕ ti) ∣ q

N.B. Ψ is the kernel of 𝑻(X) → 𝔽(𝒦, 𝑻(X)).  Therefore, to prove 𝑨 is a homomorphic image of 𝔽(𝒦, 𝑻(X)), it suffices to show that the kernel of the lift h : 𝑻(X) → 𝑨 contains Ψ.

.. code-block::

   𝑻---- g --->>𝔽  (ker g = Ψ)
    \         .
     \       .
      h     ∃ϕ     (want: Ψ ⊆ ker h)
       \   .
        \ .
         V
         𝑨


----------------------------------------------------------

More tools for Birkhoff's theorem
----------------------------------

Here are some of the key facts and identities we need to complete the proof of Birkhoff's HSP theorem.

::

   𝑻hom-gen : (𝑪 : Algebra 𝓤 𝑆) → Σ h ꞉ (hom (𝑻 X) 𝑪), Epic ∣ h ∣
   𝑻hom-gen 𝑪 = h , lift-of-epic-is-epic h₀ hE
    where
      ℋ : X ↠ 𝑪
      ℋ = 𝕏 𝑪

      h₀ : X → ∣ 𝑪 ∣
      h₀ = fst ℋ

      hE : Epic h₀
      hE = snd ℋ

      h : hom (𝑻 X) 𝑪
      h = lift-hom{𝑨 = 𝑪}{X = X} h₀

   SClo𝒦→𝑻img : (𝑪 : Algebra 𝓤 𝑆) → (𝑪 ∈ SClo 𝒦) → 𝑻img
   SClo𝒦→𝑻img 𝑪 𝑪∈SClo𝒦 =
     𝑪 , (fst (𝑻hom-gen 𝑪)) , (𝑪∈SClo𝒦 , (snd (𝑻hom-gen 𝑪)))

   𝑻img→𝑻⊧ : ∀ p q
    →        (p , q) ∈ Ψ'
    →        (ti : 𝑻img)
         -----------------------------------
    →     ∣ (𝑻ϕ ti) ∣ ((p ̇ 𝑻(X)) ℊ)
         ≡ ∣ (𝑻ϕ ti) ∣ ((q ̇ 𝑻(X)) ℊ)
   𝑻img→𝑻⊧ p q pΨq ti = goal1
     where
      𝑪 : Algebra 𝓤 𝑆
      𝑪 = ∣ ti ∣

      ϕ : hom (𝑻 X) 𝑪
      ϕ = 𝑻ϕ ti

      pCq : ∣ ϕ ∣ p ≡ ∣ ϕ ∣ q
      pCq = pΨq ti

      𝓅 𝓆 : ∣ 𝑻 X ∣  -- Notation: 𝓅 = \Mcp
      𝓅 = ∣ tg{X = X}{gfe = gfe} p ∣
      𝓆 = ∣ tg{X = X}{gfe = gfe} q ∣

      p≡𝓅 : p ≡ (𝓅 ̇ 𝑻 X) ℊ
      p≡𝓅 = ∥ tg p ∥

      q≡𝓆 : q ≡ (𝓆 ̇ 𝑻 X) ℊ
      q≡𝓆 = ∥ tg q ∥

      ξ : ∣ ϕ ∣ ((𝓅 ̇ 𝑻(X)) ℊ) ≡ ∣ ϕ ∣ ((𝓆 ̇ 𝑻(X)) ℊ)
      ξ = (ap ∣ ϕ ∣ p≡𝓅)⁻¹ ∙ pCq ∙ (ap ∣ ϕ ∣ q≡𝓆)

      goal1 : ∣ ϕ ∣ ((p ̇ 𝑻(X)) ℊ) ≡ ∣ ϕ ∣ ((q ̇ 𝑻(X)) ℊ)
      goal1 = (ap ∣ ϕ ∣ (term-gen-agreement p))
               ∙ ξ ∙ (ap ∣ ϕ ∣ (term-gen-agreement q))⁻¹

   Ψ⊆ThSClo𝒦 : Ψ ⊆ Th (SClo 𝒦)
   Ψ⊆ThSClo𝒦 {p , q} pΨq {𝑪} 𝑪∈SClo𝒦 = 𝑪⊧p≈q
     where
      ti : 𝑻img
      ti = SClo𝒦→𝑻img 𝑪 𝑪∈SClo𝒦

      ϕ : hom (𝑻 X) 𝑪
      ϕ = 𝑻ϕ ti

      ϕE : Epic ∣ ϕ ∣
      ϕE = 𝑻ϕE ti

      ϕsur : (𝒄 : X → ∣ 𝑪 ∣ )(x : X) → Image ∣ ϕ ∣ ∋ (𝒄 x)
      ϕsur 𝒄 x = ϕE (𝒄 x)

      preim : (𝒄 : X → ∣ 𝑪 ∣)(x : X) → ∣ (𝑻 X) ∣
      preim 𝒄 x = (Inv ∣ ϕ ∣ (𝒄 x) (ϕsur 𝒄 x))

      ζ : (𝒄 : X → ∣ 𝑪 ∣) → ∣ ϕ ∣ ∘ (preim 𝒄) ≡ 𝒄
      ζ 𝒄 = gfe λ x → InvIsInv ∣ ϕ ∣ (𝒄 x) (ϕsur 𝒄 x)

      γ : ∣ ϕ ∣ ∘ (p ̇ 𝑻(X)) ≡ ∣ ϕ ∣ ∘ (q ̇ 𝑻(X))
      γ = pΨq ti

      𝑪⊧p≈q : (p ̇ 𝑪) ≡ (q ̇ 𝑪)
      𝑪⊧p≈q = gfe λ 𝒄 →
       (p ̇ 𝑪) 𝒄               ≡⟨ (ap (p ̇ 𝑪) (ζ 𝒄))⁻¹ ⟩
       (p ̇ 𝑪) (∣ ϕ ∣ ∘ (preim 𝒄)) ≡⟨ (comm-hom-term gfe (𝑻 X) 𝑪 ϕ p (preim 𝒄))⁻¹ ⟩
       ∣ ϕ ∣ ((p ̇ 𝑻(X))(preim 𝒄))     ≡⟨ (intensionality γ (preim 𝒄)) ⟩
       ∣ ϕ ∣ ((q ̇ 𝑻(X))(preim 𝒄))     ≡⟨ comm-hom-term gfe (𝑻 X) 𝑪 ϕ q (preim 𝒄) ⟩
       (q ̇ 𝑪)(∣ ϕ ∣ ∘ (preim 𝒄))  ≡⟨ ap (q ̇ 𝑪) (ζ 𝒄) ⟩
       (q ̇ 𝑪) 𝒄 ∎


   Ψ⊆Th𝒦 : ∀ p q → (p , q) ∈ Ψ → 𝒦 ⊧ p ≋ q
   Ψ⊆Th𝒦 p q pΨq {𝑨} KA = Ψ⊆ThSClo𝒦{p , q} pΨq (sbase KA)

-------------------------------------------------------

Closure under HSP
--------------------

Finally, we have a datatype that represents classes of algebras that are close under the taking of homomorphic images, subalgebras, and products of algebras in the class.

::

  -- Variety Closure
  data VClo (𝒦 : Pred (Algebra 𝓤 𝑆) (𝓤 ⁺)) : Pred (Algebra 𝓤 𝑆)(𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ⁺ ) where
   vbase : {𝑨 : Algebra 𝓤 𝑆} → 𝑨 ∈ 𝒦 → 𝑨 ∈ VClo 𝒦
   vprod : {I : 𝓤 ̇ }{𝒜 : I → Algebra _ 𝑆} → (∀ i → 𝒜 i ∈ VClo 𝒦) → ⨅ 𝒜 ∈ VClo 𝒦
   vsub : {𝑨 : Algebra 𝓤 𝑆} → 𝑨 ∈ VClo 𝒦 → (sa : SubalgebrasOf 𝑨) → ∣ sa ∣ ∈ VClo 𝒦
   vhom : {𝑨 : Algebra 𝓤 𝑆} → 𝑨 ∈ VClo 𝒦 → ((𝑩 , _ , _) : HomImagesOf 𝑨) → 𝑩 ∈ VClo 𝒦

-- ThVClo⊆ThSClo : Th (VClo 𝒦) ⊆ Th (SClo 𝒦)
-- ThVClo⊆ThSClo = ?

Identities for product closure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

  module _ {𝒦 : Pred (Algebra 𝓤 𝑆) ( 𝓤 ⁺ )} where

   pclo-id1 : ∀ {p q} → (𝒦 ⊧ p ≋ q) → (PClo 𝒦 ⊧ p ≋ q)
   pclo-id1 {p} {q} α (pbase x) = α x
   pclo-id1 {p} {q} α (prod{I}{𝒜} 𝒜-P𝒦 ) = γ
    where
     IH : (i : I)  → (p ̇ 𝒜 i) ≡ (q ̇ 𝒜 i)
     IH = λ i → pclo-id1{p}{q} α  ( 𝒜-P𝒦  i )
     γ : p ̇ (⨅ 𝒜)  ≡ q ̇ (⨅ 𝒜)
     γ = products-preserve-identities p q I 𝒜 IH

   pclo-id2 : ∀{p q} → ((PClo 𝒦) ⊧ p ≋ q ) → (𝒦 ⊧ p ≋ q)
   pclo-id2 p A∈𝒦 = p (pbase A∈𝒦)


Identities for subalgebra closure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::


   sclo-id1 : ∀{p q} → (𝒦 ⊧ p ≋ q) → (SClo 𝒦 ⊧ p ≋ q)
   sclo-id1 {p} {q} 𝒦⊧p≋q (sbase A∈𝒦) = 𝒦⊧p≋q A∈𝒦
   sclo-id1 {p} {q} 𝒦⊧p≋q (sub {𝑨 = 𝑨} A∈SClo𝒦 sa) = γ
    where
     A⊧p≈q : 𝑨 ⊧ p ≈ q
     A⊧p≈q = sclo-id1{p}{q} 𝒦⊧p≋q A∈SClo𝒦

     B : Algebra 𝓤 𝑆
     B = ∣ sa ∣

     h : ∣ B ∣ → ∣ 𝑨 ∣
     h = pr₁ ∥ sa ∥

     hem : is-embedding h
     hem = ∣ pr₂ ∥ sa ∥ ∣

     hhm : is-homomorphism B 𝑨 h
     hhm = ∥ pr₂ ∥ sa ∥ ∥

     ξ : (b : X → ∣ B ∣ ) → h ((p ̇ B) b) ≡ h ((q ̇ B) b)
     ξ b =
      h ((p ̇ B) b)  ≡⟨ comm-hom-term gfe B 𝑨 (h , hhm) p b ⟩
      (p ̇ 𝑨)(h ∘ b) ≡⟨ intensionality A⊧p≈q (h ∘ b) ⟩
      (q ̇ 𝑨)(h ∘ b) ≡⟨ (comm-hom-term gfe B 𝑨 (h , hhm) q b)⁻¹ ⟩
      h ((q ̇ B) b)  ∎

     hlc : {b b' : domain h} → h b ≡ h b' → b ≡ b'
     hlc hb≡hb' = (embeddings-are-lc h hem) hb≡hb'

     γ : p ̇ B ≡ q ̇ B
     γ = gfe λ b → hlc (ξ b)

   sclo-id2 : ∀ {p q} → (SClo 𝒦 ⊧ p ≋ q) → (𝒦 ⊧ p ≋ q)
   sclo-id2 p A∈𝒦 = p (sbase A∈𝒦)


Identities for hom image closure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::


   hclo-id1 : ∀{p q} → (𝒦 ⊧ p ≋ q) → (HClo 𝒦 ⊧ p ≋ q)
   hclo-id1 {p}{q} 𝒦⊧p≋q (hbase A∈𝒦) = 𝒦⊧p≋q A∈𝒦
   hclo-id1 {p}{q} 𝒦⊧p≋q (hhom{𝑨} A∈HClo𝒦 𝑩ϕhE) = γ
    where
     A⊧p≈q : 𝑨 ⊧ p ≈ q
     A⊧p≈q = (hclo-id1{p}{q} 𝒦⊧p≋q ) A∈HClo𝒦

     𝑩 : Algebra 𝓤 𝑆
     𝑩 = ∣ 𝑩ϕhE ∣

     ϕ : ∣ 𝑨 ∣ → ∣ 𝑩 ∣
     ϕ = ∣ ∥ 𝑩ϕhE ∥ ∣

     ϕhom : is-homomorphism 𝑨 𝑩 ϕ
     ϕhom = ∣ pr₂ ∥ 𝑩ϕhE ∥ ∣

     ϕsur : (𝒃 : X → ∣ 𝑩 ∣ )(x : X) → Image ϕ ∋ (𝒃 x)
     ϕsur 𝒃 x = ∥ pr₂ ∥ 𝑩ϕhE ∥ ∥ (𝒃 x)

     preim : (𝒃 : X → ∣ 𝑩 ∣)(x : X) → ∣ 𝑨 ∣
     preim 𝒃 x = (Inv ϕ (𝒃 x) (ϕsur 𝒃 x))

     ζ : (𝒃 : X → ∣ 𝑩 ∣) → ϕ ∘ (preim 𝒃) ≡ 𝒃
     ζ 𝒃 = gfe λ x → InvIsInv ϕ (𝒃 x) (ϕsur 𝒃 x)

     γ : (p ̇ 𝑩) ≡ (q ̇ 𝑩)
     γ = gfe λ 𝒃 →
      (p ̇ 𝑩) 𝒃               ≡⟨ (ap (p ̇ 𝑩) (ζ 𝒃))⁻¹ ⟩
      (p ̇ 𝑩) (ϕ ∘ (preim 𝒃)) ≡⟨ (comm-hom-term gfe 𝑨 𝑩 (ϕ , ϕhom) p (preim 𝒃))⁻¹ ⟩
      ϕ((p ̇ 𝑨)(preim 𝒃))     ≡⟨ ap ϕ (intensionality A⊧p≈q (preim 𝒃)) ⟩
      ϕ((q ̇ 𝑨)(preim 𝒃))     ≡⟨ comm-hom-term gfe 𝑨 𝑩 (ϕ , ϕhom) q (preim 𝒃) ⟩
      (q ̇ 𝑩)(ϕ ∘ (preim 𝒃))  ≡⟨ ap (q ̇ 𝑩) (ζ 𝒃) ⟩
      (q ̇ 𝑩) 𝒃 ∎

   hclo-id2 : ∀ {p q} → (HClo 𝒦 ⊧ p ≋ q) → (𝒦 ⊧ p ≋ q)
   hclo-id2 p A∈𝒦 = p (hbase A∈𝒦)

Identities for HSP closure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

   vclo-id1 : ∀ {p q} → (𝒦 ⊧ p ≋ q) → (VClo 𝒦 ⊧ p ≋ q)
   vclo-id1 {p} {q} α (vbase A∈𝒦) = α A∈𝒦
   vclo-id1 {p} {q} α (vprod{I = I}{𝒜 = 𝒜} 𝒜∈VClo𝒦) = γ
    where
     IH : (i : I) → 𝒜 i ⊧ p ≈ q
     IH i = vclo-id1{p}{q} α (𝒜∈VClo𝒦 i)

     γ : p ̇ (⨅ 𝒜)  ≡ q ̇ (⨅ 𝒜)
     γ = products-preserve-identities p q I 𝒜 IH

   vclo-id1 {p} {q} α ( vsub {𝑨 = 𝑨} A∈VClo𝒦 sa ) = γ
    where
     A⊧p≈q : 𝑨 ⊧ p ≈ q
     A⊧p≈q = vclo-id1{p}{q} α A∈VClo𝒦

     𝑩 : Algebra 𝓤 𝑆
     𝑩 = ∣ sa ∣

     h : ∣ 𝑩 ∣ → ∣ 𝑨 ∣
     h = pr₁ ∥ sa ∥

     hem : is-embedding h
     hem = ∣ pr₂ ∥ sa ∥ ∣

     hhm : is-homomorphism 𝑩 𝑨 h
     hhm = ∥ pr₂ ∥ sa ∥ ∥

     ξ : (b : X → ∣ 𝑩 ∣ ) → h ((p ̇ 𝑩) b) ≡ h ((q ̇ 𝑩) b)
     ξ b =
      h ((p ̇ 𝑩) b)  ≡⟨ comm-hom-term gfe 𝑩 𝑨 (h , hhm) p b ⟩
      (p ̇ 𝑨)(h ∘ b) ≡⟨ intensionality A⊧p≈q (h ∘ b) ⟩
      (q ̇ 𝑨)(h ∘ b) ≡⟨ (comm-hom-term gfe 𝑩 𝑨 (h , hhm) q b)⁻¹ ⟩
      h ((q ̇ 𝑩) b)  ∎

     hlc : {b b' : domain h} → h b ≡ h b' → b ≡ b'
     hlc hb≡hb' = (embeddings-are-lc h hem) hb≡hb'

     γ : p ̇ 𝑩 ≡ q ̇ 𝑩
     γ = gfe λ b → hlc (ξ b)

   vclo-id1 {p}{q} α (vhom{𝑨 = 𝑨} A∈VClo𝒦 𝑩ϕhE) = γ
    where
     A⊧p≈q : 𝑨 ⊧ p ≈ q
     A⊧p≈q = vclo-id1{p}{q} α A∈VClo𝒦

     𝑩 : Algebra 𝓤 𝑆
     𝑩 = ∣ 𝑩ϕhE ∣

     ϕ : ∣ 𝑨 ∣ → ∣ 𝑩 ∣
     ϕ = ∣ ∥ 𝑩ϕhE ∥ ∣

     ϕh : is-homomorphism 𝑨 𝑩 ϕ
     ϕh = ∣ pr₂ ∥ 𝑩ϕhE ∥ ∣

     ϕE : (𝒃 : X → ∣ 𝑩 ∣ )(x : X) → Image ϕ ∋ (𝒃 x)
     ϕE 𝒃 x = ∥ pr₂ ∥ 𝑩ϕhE ∥ ∥ (𝒃 x)

     preim : (𝒃 : X → ∣ 𝑩 ∣)(x : X) → ∣ 𝑨 ∣
     preim 𝒃 x = (Inv ϕ (𝒃 x) (ϕE 𝒃 x))

     ζ : (𝒃 : X → ∣ 𝑩 ∣) → ϕ ∘ (preim 𝒃) ≡ 𝒃
     ζ 𝒃 = gfe λ x → InvIsInv ϕ (𝒃 x) (ϕE 𝒃 x)

     γ : (p ̇ 𝑩) ≡ (q ̇ 𝑩)
     γ = gfe λ 𝒃 →
      (p ̇ 𝑩) 𝒃               ≡⟨ (ap (p ̇ 𝑩) (ζ 𝒃))⁻¹ ⟩
      (p ̇ 𝑩) (ϕ ∘ (preim 𝒃)) ≡⟨ (comm-hom-term gfe 𝑨 𝑩 (ϕ , ϕh) p (preim 𝒃))⁻¹ ⟩
      ϕ((p ̇ 𝑨)(preim 𝒃))     ≡⟨ ap ϕ (intensionality A⊧p≈q (preim 𝒃)) ⟩
      ϕ((q ̇ 𝑨)(preim 𝒃))     ≡⟨ comm-hom-term gfe 𝑨 𝑩 (ϕ , ϕh) q (preim 𝒃) ⟩
      (q ̇ 𝑩)(ϕ ∘ (preim 𝒃))  ≡⟨ ap (q ̇ 𝑩) (ζ 𝒃) ⟩
      (q ̇ 𝑩) 𝒃 ∎

   vclo-id2 : ∀ {p q} → (VClo 𝒦 ⊧ p ≋ q) → (𝒦 ⊧ p ≋ q)
   vclo-id2 p A∈𝒦 = p (vbase A∈𝒦)


--------------------------------------------------

Axiomatization of a class
-------------------------

We conclude the `closure module`_ by proving that a class 𝒦 of structures is axiomatized by ``Th (VClo 𝒦)``, which is the set of equations satisfied by all members of the varietal closure of 𝒦.

::

   -- Th (VClo 𝒦) is precisely the set of identities modeled by 𝒦
   ThHSP-axiomatizes : (p q : ∣ (𝑻 X) ∣)
             -----------------------------------------
    →         𝒦 ⊧ p ≋ q  ⇔  ((p , q) ∈ Th (VClo 𝒦))

   ThHSP-axiomatizes p q =
    (λ 𝒦⊧p≋q 𝑨∈VClo𝒦 → vclo-id1{p = p}{q = q} 𝒦⊧p≋q 𝑨∈VClo𝒦) ,
    λ pq∈Th 𝑨∈𝒦 → pq∈Th (vbase 𝑨∈𝒦)



-----------------------------------------------

Unicode Hints
---------------

Table of some special characters used in the `closure module`_.

  +--------+------------------------+
  | To get | Type                   |
  +--------+------------------------+
  | 𝒂, 𝒃   | ``\MIa``, ``\MIb``     |
  +--------+------------------------+
  | 𝑓 ̂ 𝑨  |  ``\Mif \^ \MIA``      |
  +--------+------------------------+
  | ≅      | ``≅`` or ``\cong``     |
  +--------+------------------------+
  | ∘      | ``\comp`` or ``\circ`` |
  +--------+------------------------+
  | 𝒾𝒹     | ``\Mci\Mcd``           |
  +--------+------------------------+
  | ℒ𝒦     | ``\McL\McK``           |
  +--------+------------------------+
  | ϕ      | ``\phi``               |
  +--------+------------------------+

See :numref:`unicode hints` for a longer list of symbols used in the agda-ualib_, or better yet, use these

  **Emacs commands providing information about special characters/input methods**:

    * ``M-x describe-char`` (or ``M-m h d c``) with the cursor on the character of interest

    * ``M-x describe-input-method`` (or ``C-h I``)

-------------------------

.. include:: hyperlink_references.rst

