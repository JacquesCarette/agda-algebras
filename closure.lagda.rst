.. FILE: closure.lagda.rst
.. AUTHOR: William DeMeo and Siva Somayyajula
.. DATE: 2 Jul 2020

=====================
Closure operators
======================

The operators 𝑯, 𝑺, 𝑷
----------------------

Fix a signature 𝑆.

Let 𝓚 be a class of 𝑆-algebras. Define

  * 𝑯(𝓚) = homomorphic images of members of 𝓚;
  * 𝑺(𝓚) = algebras isomorphic to a subalgebra of a member of 𝓚;
  * 𝑷(𝓚) = algebras isomorphic to a direct product of members of 𝓚.

As a straight-forward verification confirms, 𝑯, 𝑺, and 𝑷 are closure operators. A class 𝓚 of 𝑆-algebras is said to be *closed under the formation of homomorphic images* if 𝑯(𝓚) ⊆ 𝓚. Similarly, 𝓚 is *closed under the formation of subalgebras* (resp., *products*) provided 𝑺(𝓚) ⊆ 𝓚 (resp., 𝑷(𝓚) ⊆ 𝓚).

An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class 𝑯(𝓚) (resp., S(𝓚); resp., P(𝓚)) is closed under isomorphism.

The operators 𝑯, 𝑺, and 𝑷 can be composed with one another repeatedly, forming yet more closure operators. If C₁ and C₂ are closure operators on classes of structures, let us say that C₁ ≤ C₂ if for every class 𝓚 we have C₁(𝓚) ⊆ C₂(𝓚).

.. _lem 3.41:

.. proof:lemma:: Lem. 3.41 of :cite:`Bergman:2012`

   𝑺𝑯 ≤ 𝑯𝑺, 𝑷𝑺 ≤ 𝑺𝑷.

   .. container:: toggle

      .. container:: header

         *Proof*.

      Let 𝑪 ∈ 𝑺𝑯(𝓚). Then 𝑪 ≤ 𝑩 for some 𝑩 ∈ 𝑯(𝑨), where 𝑨 ∈ 𝓚.  Let θ be such that 𝑩 ≅ 𝑨/θ.  Then 𝑪 is isomorphic to a subalgebra, say, 𝑻, of 𝑨/θ.  By the correspondence theorem, there is a subalgebra 𝑺 ≤ 𝑨 such that 𝑺/θ = 𝑻.  Thus, 𝑪 ∈ 𝑯𝑺(𝑨) ⊆ 𝑯𝑺(𝓚), as desired.

      Let 𝑪 ∈ 𝑷𝑺(𝓚). Then 𝑪 = Π 𝑩ᵢ for some 𝑩ᵢ ≤ 𝑨ᵢ ∈ 𝓚. Clearly, 𝑪 = Π 𝑩ᵢ ≤ Π 𝑨ᵢ, so 𝑪 ∈ 𝑺𝑷(𝓚), as desired. ∎

---------------------------------------------

Varieties
-------------

A class 𝓚 of 𝑆-algebras is called a **variety** if it is closed under each of the closure operators 𝑯, 𝑺, and 𝑷 introduced above; the corresponding closure operator is often denoted 𝕍. Thus, if 𝓚 is a class of similar algebras, then the **variety generated by** 𝓚 is denoted by 𝕍(𝓚) and defined to be the smallest class that contains 𝓚 and is closed under 𝑯, 𝑺, and 𝑷.

.. The class of all varieties of 𝑆-algebras is ordered by inclusion, and closed under arbitrary intersection; thus, the class of varieties is a complete lattice.

We would like to know how to construct 𝕍(𝓚) directly from 𝓚, but it's not immediately obvious how many times we would have to apply the operators 𝑯, 𝑺, 𝑷 before the result stabilizes to form a variety---the **variety generated by** 𝓚.  Fortunately, Garrett Birkhoff proved that if we apply the operators in the correct order, then it suffices to apply each one only once.

.. proof:theorem:: Thm 3.43 of :cite:`Bergman:2012`

   𝕍 = 𝑯𝑺𝑷.

   .. container:: toggle

      .. container:: header

         *Proof*.

      Let 𝓚 be a class of algebras. To see that 𝑯𝑺𝑷(𝓚) is a variety, we use :numref:`Lemma %s <lem 3.41>` to compute 𝑯(𝑯𝑺𝑷) = 𝑯𝑺𝑷, 𝑺(𝑯𝑺𝑷) ≤ 𝑯𝑺²𝑷 = 𝑯𝑺𝑷, P(𝑯𝑺𝑷) ≤ 𝑯𝑺𝑷² = 𝑯𝑺𝑷. Thus 𝑯𝑺𝑷 ≥ 𝕍.

      On the other hand, 𝑯𝑺𝑷(𝓚) ⊆ 𝑯𝑺𝑷(𝕍(𝓚)) = 𝕍(𝓚) so 𝑯𝑺𝑷 ≤ 𝕍.

---------------------------------------------------

The closure module
---------------------

Preliminaries
~~~~~~~~~~~~~~~~~~~

::

  {-# OPTIONS --without-K --exact-split --safe #-}

  open import prelude
  open import basic using (Signature; Algebra; Π'; Op)
  open import subuniverses using (Subuniverses; SubunivAlg; hom-image-alg; _is-subalgebra-of_; Subalgebra)
  open import homomorphisms using (hom; is-homomorphism)
  -- open import UF-Extensionality using (funext; global-funext; global-dfunext; happly; extensionality-lemma; dfunext)
  open import terms using (Term; generator; node; _̇_; _̂_; interp-prod2; interp-prod; comm-hom-term')

  module closure {S : Signature 𝓞 𝓥} where


Equational classes
~~~~~~~~~~~~~~~~~~~~~~

In his treatment of Birhoff's HSP theorem, Cliff Bergman (at the start of Section 4.4 of his universal algebra textbook :cite:`Bergman:2012`) proclaims, "Now, finally, we can formalize the idea we have been using since the first page of this text."  He then proceeds to define **identities of terms** as follows (paraphrasing for notational consistency):

Let 𝑆 be a signature.  An **identity** or **equation** in 𝑆 is an ordered pair of terms, written 𝑝 ≈ 𝑞, from the term algebra 𝔉. If 𝑨 is an 𝑆-algebra we say that 𝑨 **satisfies** 𝑝 ≈ 𝑞 if 𝑝 ̇ 𝑨 ≡ 𝑞 ̇ 𝑨.  In this  situation,  we  write 𝑨 ⊧ 𝑝 ≈ 𝑞.

If 𝓚 is a class of 𝑆-algebras, we write 𝓚 ⊧ 𝑝 ≋ 𝑞 if, for every 𝑨 ∈ 𝓚, 𝑨 ⊧ 𝑝 ≈ 𝑞. Finally, if 𝓔 is a set of equations, we write 𝓚 ⊨ 𝓔 if every member of 𝓚 satisfies every member of 𝓔.

We formalize these notions in Agda as follows.

::

  _⊧_≈_ : {X : 𝓧 ̇ } → Algebra 𝓤 S
   →      Term{X = X} → Term → 𝓧 ⊔ 𝓤 ̇

  𝑨 ⊧ p ≈ q = (p ̇ 𝑨) ≡ (q ̇ 𝑨)

  _⊧_≋_ : {X : 𝓧 ̇ } → Pred (Algebra 𝓤 S) 𝓦
   →      Term{X = X} → Term → 𝓞 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓧 ⊔ 𝓤 ⁺ ̇

  _⊧_≋_ 𝓚 p q = {A : Algebra _ S} → 𝓚 A → A ⊧ p ≈ q

Identities are compatible with the formation of subalgebras, homomorphic images and products. More precisely,
for every class 𝒦 of structures, each of the classes 𝑺(𝒦), 𝑯(𝒦), 𝑷(𝒦), 𝕍(𝒦) satisfies the same set of identities as does 𝒦.

We formalize the notion of closure under the taking of homomorphic images in the `morphisms` module.  Here we will formalize closure under the taking of products and subuniverses, and prove that these closures preserve identities.

.. _obs 13 in agda:

Identities in products
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let ℙ (𝓚) denote the class of algebras isomorphic to a direct product of members of 𝓚.

::

  𝑷-closed : (𝓛𝓚 : (𝓤 : Universe) → Pred (Algebra 𝓤 S) (𝓤 ⁺ ))
   →      (𝓘 : Universe) (I : 𝓘 ̇ ) (𝓐 : I → Algebra 𝓘 S)
   →      (( i : I ) → 𝓐 i ∈ 𝓛𝓚 𝓘 ) → 𝓘 ⁺ ̇
  𝑷-closed 𝓛𝓚 = λ 𝓘 I 𝓐 𝓐i∈𝓛𝓚 →  Π' 𝓐  ∈ (𝓛𝓚 𝓘)

  module _
    (gfe : global-dfunext)
    (𝓚 : Pred (Algebra 𝓤 S)(𝓞 ⊔ 𝓥 ⊔ ((𝓤 ⁺) ⁺))) { X : 𝓧 ̇ } where

    products-preserve-identities : (p q : Term{X = X})
          (I : 𝓤 ̇ ) (𝓐 : I → Algebra 𝓤 S)
     →    𝓚 ⊧ p ≋ q  →  ((i : I) → 𝓐 i ∈ 𝓚)
     →    Π' 𝓐 ⊧ p ≈ q
    products-preserve-identities p q I 𝓐 𝓚⊧p≋q all𝓐i∈𝓚 = γ
     where
      all𝓐⊧p≈q : ∀ i → (𝓐 i) ⊧ p ≈ q
      all𝓐⊧p≈q i = 𝓚⊧p≋q (all𝓐i∈𝓚 i)

      γ : (p ̇ Π' 𝓐) ≡ (q ̇ Π' 𝓐)
      γ = gfe λ 𝒂 →
       (p ̇ Π' 𝓐) 𝒂
         ≡⟨ interp-prod gfe p 𝓐 𝒂 ⟩
       (λ i → ((p ̇ (𝓐 i)) (λ x → (𝒂 x) i)))
         ≡⟨ gfe (λ i → cong-app (all𝓐⊧p≈q i) (λ x → (𝒂 x) i)) ⟩
       (λ i → ((q ̇ (𝓐 i)) (λ x → (𝒂 x) i)))
         ≡⟨ (interp-prod gfe q 𝓐 𝒂)⁻¹ ⟩
       (q ̇ Π' 𝓐) 𝒂
         ∎



Identities in subalgebras
~~~~~~~~~~~~~~~~~~~~~~~~~~

Let 𝑺(𝓚) denote the class of algebras isomorphic to a subalgebra of a member of 𝓚. We show that every term equation, 𝑝 ≈ 𝑞, that is satisfied by all 𝑨 ∈ 𝓚 is also satisfied by all 𝑩 ∈ 𝑺(𝓚).

::

  _is-subalgebra-of-class_ : {𝓤 : Universe}(𝑩 : Algebra 𝓤 S)
   →                         Pred (Algebra 𝓤 S)(𝓤 ⁺) → 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇
  𝑩 is-subalgebra-of-class 𝓚 =
   Σ 𝑨 ꞉ (Algebra _ S) , (𝑨 ∈ 𝓚) × (𝑩 is-subalgebra-of 𝑨)

  module _
   (𝓚 : Pred (Algebra 𝓤 S) ( 𝓤 ⁺ ))
   (𝓚' : Pred (Algebra 𝓤 S)(𝓞 ⊔ 𝓥 ⊔ ((𝓤 ⁺) ⁺))){X : 𝓧 ̇ }
   (𝓤★ : Univalence) where

   gfe : global-dfunext
   gfe = univalence-gives-global-dfunext 𝓤★

   SubalgebrasOfClass : Pred (Algebra 𝓤 S)(𝓤 ⁺) → 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇
   SubalgebrasOfClass 𝓚 =
    Σ 𝑨 ꞉ (Algebra _ S) , (𝑨 ∈ 𝓚) × Subalgebra{𝑨 = 𝑨} 𝓤★

   𝕊-closed : (𝓛𝓚 : (𝓤 : Universe) → Pred (Algebra 𝓤 S) (𝓤 ⁺))
    →      (𝓤 : Universe) → (𝑩 : Algebra 𝓤 S) → 𝓞 ⊔ 𝓥 ⊔ 𝓤 ⁺ ̇
   𝕊-closed 𝓛𝓚 =
    λ 𝓤 𝑩 → (𝑩 is-subalgebra-of-class (𝓛𝓚 𝓤)) → (𝑩 ∈ 𝓛𝓚 𝓤)

   subalgebras-preserve-identities : (p q : Term{X = X})
    →  (𝓚 ⊧ p ≋ q) → (SAK : SubalgebrasOfClass 𝓚)
    →  (pr₁ ∥ (pr₂ SAK) ∥) ⊧ p ≈ q
   subalgebras-preserve-identities p q 𝓚⊧p≋q SAK = γ
    where

     𝑨 : Algebra 𝓤 S
     𝑨 = ∣ SAK ∣

     𝑨∈𝓚 : 𝑨 ∈ 𝓚
     𝑨∈𝓚 = ∣ pr₂ SAK ∣

     𝑨⊧p≈q : 𝑨 ⊧ p ≈ q
     𝑨⊧p≈q = 𝓚⊧p≋q 𝑨∈𝓚

     subalg : Subalgebra{𝑨 = 𝑨} 𝓤★
     subalg = ∥ pr₂ SAK ∥

     𝑩 : Algebra 𝓤 S
     𝑩 = pr₁ subalg

     h : ∣ 𝑩 ∣ → ∣ 𝑨 ∣
     h = ∣ pr₂ subalg ∣

     h-emb : is-embedding h
     h-emb = pr₁ ∥ pr₂ subalg ∥

     h-hom : is-homomorphism 𝑩 𝑨 h
     h-hom = pr₂ ∥ pr₂ subalg ∥

     ξ : (𝒃 : X → ∣ 𝑩 ∣ ) → h ((p ̇ 𝑩) 𝒃) ≡ h ((q ̇ 𝑩) 𝒃)
     ξ 𝒃 =
      h ((p ̇ 𝑩) 𝒃)  ≡⟨ comm-hom-term' gfe 𝑩 𝑨 (h , h-hom) p 𝒃 ⟩
      (p ̇ 𝑨)(h ∘ 𝒃) ≡⟨ intensionality 𝑨⊧p≈q (h ∘ 𝒃) ⟩
      (q ̇ 𝑨)(h ∘ 𝒃) ≡⟨ (comm-hom-term' gfe 𝑩 𝑨 (h , h-hom) q 𝒃)⁻¹ ⟩
      h ((q ̇ 𝑩) 𝒃)  ∎

     hlc : {b b' : domain h} → h b ≡ h b' → b ≡ b'
     hlc hb≡hb' = (embeddings-are-lc h h-emb) hb≡hb'

     γ : 𝑩 ⊧ p ≈ q
     γ = gfe λ 𝒃 → hlc (ξ 𝒃)


  -- Product Closure
  data PClo (𝓚 : Pred (Algebra 𝓤 S) 𝓣) : Pred (Algebra 𝓤 S)(𝓞 ⊔ 𝓥 ⊔ 𝓣 ⊔ 𝓤 ⁺ ) where
   pbase : {𝑨 : Algebra 𝓤 S} → 𝑨 ∈ 𝓚 → 𝑨 ∈ PClo 𝓚
   prod : {I : 𝓤 ̇ }{𝓐 : I → Algebra _ S}
    →     (∀ i → 𝓐 i ∈ PClo 𝓚)
    →     Π' 𝓐 ∈ PClo 𝓚

  -- Subalgebra Closure
  data SClo (𝓚 : Pred (Algebra 𝓤 S) 𝓣) : Pred (Algebra 𝓤 S)(𝓞 ⊔ 𝓥 ⊔ 𝓣 ⊔ 𝓤 ⁺ ) where
   sbase : {𝑨 : Algebra _ S} → 𝑨 ∈ 𝓚 → 𝑨 ∈ SClo 𝓚
   --sub : {𝑨 𝑩 : Algebra _ S} → 𝑨 ∈ SClo 𝓚 → 𝑩 is-subalgebra-of 𝑨 → 𝑩 ∈ SClo 𝓚
   --sub : {𝑨 : Algebra _ S} → 𝑨 ∈ SClo 𝓚 → 𝑩 is-subalgebra-of 𝑨 → 𝑩 ∈ SClo 𝓚
   sub : {𝑨 : Algebra _ S} {B : Pred ∣ 𝑨 ∣ 𝓤 }
         {𝐹 : (𝓸 : ∣ S ∣) → Op (∥ S ∥ 𝓸) (Σ B)}
         (B∈SubA : B ∈ Subuniverses 𝑨)
    →    𝑨 ∈ SClo 𝓚
    →    SubunivAlg{𝑨 = 𝑨}{B = B}{𝐹 = 𝐹} B∈SubA ∈ SClo 𝓚

  -- Homomorphic Image Closure
  data HClo (𝓚 : Pred (Algebra 𝓤 S) 𝓣) : Pred (Algebra 𝓤 S)(𝓞 ⊔ 𝓥 ⊔ 𝓣 ⊔ 𝓤 ⁺ ) where
   hbase : {𝑨 : Algebra 𝓤 S} → 𝑨 ∈ 𝓚 → 𝑨 ∈ HClo 𝓚
   hhom : {𝑨 𝑩 : Algebra 𝓤 S}{f : hom 𝑨 𝑩}
    →     𝑨 ∈ HClo 𝓚
    →     hom-image-alg {𝑨 = 𝑨}{𝑩 = 𝑩} f ∈ HClo 𝓚

  -- Variety Closure
  data VClo (𝓚 : Pred (Algebra 𝓤 S) 𝓣) : Pred (Algebra 𝓤 S)(𝓞 ⊔ 𝓥 ⊔ 𝓣 ⊔ 𝓤 ⁺ ) where
   vbase : {𝑨 : Algebra 𝓤 S} → 𝑨 ∈ 𝓚 → 𝑨 ∈ VClo 𝓚
   vprod : {I : 𝓤 ̇ }{𝓐 : I → Algebra _ S} → (∀ i → 𝓐 i ∈ VClo 𝓚) → Π' 𝓐 ∈ VClo 𝓚
   vsub : ∀{𝑨 : Algebra _ S}{𝑩 : Algebra _ S} → 𝑨 ∈ VClo 𝓚 → 𝑩 is-subalgebra-of 𝑨 → 𝑩 ∈ VClo 𝓚
   vhom : {𝑨 𝑩 : Algebra 𝓤 S}{f : hom 𝑨 𝑩}
    →     𝑨 ∈ VClo 𝓚 → hom-image-alg {𝑨 = 𝑨}{𝑩 = 𝑩} f ∈ VClo 𝓚

::

  module _
   (𝓚 : Pred (Algebra 𝓤 S) 𝓣)
   (gfe : global-dfunext)
   (dfe : dfunext 𝓤 𝓤)
   {X : 𝓤 ̇ } where

   _⊧'_≋_ : Pred (Algebra 𝓤 S) 𝓦 → Term {X = X} → Term → 𝓞 ⊔ 𝓥 ⊔ 𝓦 ⊔ 𝓤 ⁺ ̇
   _⊧'_≋_ = _⊧_≋_ {X = X}

   pclo-id1 : ∀ {p q} → (𝓚 ⊧ p ≋ q) → (PClo 𝓚 ⊧ p ≋ q)
   pclo-id1 {p} {q} α (pbase x) = α x
   pclo-id1 {p} {q} α (prod{I}{𝓐} 𝓐-P𝓚 ) = γ
    where
     IH : (i : I)  → (p ̇ 𝓐 i) ≡ (q ̇ 𝓐 i)
     IH = λ i → pclo-id1{p}{q} α  ( 𝓐-P𝓚  i )
     γ : p ̇ (Π' 𝓐)  ≡ q ̇ (Π' 𝓐)
     γ =
      (p ̇ (Π' 𝓐) )
        ≡⟨ interp-prod2 gfe p 𝓐 ⟩
      (λ (args : X → ∣ Π' 𝓐 ∣) → (λ i → (p ̇ 𝓐 i)(λ x → (args x) i)))
        ≡⟨ dfe (λ args → (ap (λ - → (λ i → (- i)(λ x → args x i))) (dfe IH))) ⟩
      (λ (args : X → ∣ Π' 𝓐 ∣) → (λ i → (q ̇ 𝓐 i)(λ x → (args x) i)))
        ≡⟨ (interp-prod2 gfe q 𝓐)⁻¹ ⟩
      (q ̇ (Π' 𝓐))
        ∎

   pclo-id2 : ∀{p q} → ((PClo 𝓚) ⊧' p ≋ q ) → (𝓚 ⊧ p ≋ q)
   pclo-id2 p 𝑨∈𝓚 = p (pbase 𝑨∈𝓚)

   sclo-id1 : ∀{p q} → (𝓚 ⊧' p ≋ q) → (SClo 𝓚 ⊧ p ≋ q)
   sclo-id1 {p} {q} 𝓚⊧p≋q (sbase A∈𝓚) = 𝓚⊧p≋q A∈𝓚
   sclo-id1 {p} {q} 𝓚⊧p≋q (sub {𝑨 = 𝑨}{B = B}{𝐹 = 𝐹} B∈SubA A∈SClo𝓚) = γ
    where
     IH : p ̇ 𝑨 ≡ q ̇ 𝑨
     IH = sclo-id1{p}{q} 𝓚⊧p≋q A∈SClo𝓚

     𝑩 : Algebra 𝓤 S
     𝑩 = SubunivAlg{𝑨 = 𝑨}{B = B}{𝐹 = 𝐹} B∈SubA
     -- We need to do this so that both A and Σ B , 𝐹 can be classified by the same predicate SClo.
     -- tB≡tA : ∀ 𝒕 → ( 𝒃 : X → Σ B ) → ( 𝒕 ̇ (Σ B , 𝐹) )( λ x →  𝒃 x ) ≡ (𝒕 ̇ 𝑨) (λ x →  ∣ 𝒃 x ∣ )
     -- tB≡tA 𝒕 = ?
      -- mem :   {B : Pred ∣ 𝑨 ∣ 𝓤}  { 𝐹 : ( 𝓸 : ∣ S ∣ ) → Op ( ∥ S ∥ 𝓸 ) (Σ B) }
      --   →    ( ( 𝓸 : ∣ S ∣ ) ( 𝒂 : ∥ S ∥ 𝓸 → Σ B )  →  ∣ 𝐹 𝓸 𝒂 ∣ ≡ ∥ 𝑨 ∥ 𝓸 (λ i → ∣ 𝒂 i ∣ ) )
      --   →    𝑨 is-supalgebra-of (Σ B , 𝐹)
     uni2alg : 𝑩 is-subalgebra-of 𝑨
     uni2alg = ?

     γ : p ̇ 𝑩 ≡ q ̇ 𝑩
     γ = let sts = uni2alg in
      gfe λ 𝒃 →
       (p ̇ 𝑩) 𝒃 ≡⟨ ? ⟩  -- we need an elimination rule here (see is-subalg-elim in UF-Subuniverse.agda)
         -- (p ̇ uni2alg) 𝒃 ≡⟨ IH ⟩
         -- (q ̇ uni2alg) 𝒃 ≡⟨ ? ⟩
       (q ̇ 𝑩) 𝒃  ∎

   sclo-id2 : ∀ {p q} → (SClo 𝓚 ⊧' p ≋ q) → (𝓚 ⊧ p ≋ q)
   sclo-id2 p 𝑨∈𝓚 = p (sbase 𝑨∈𝓚)

   hclo-id1 : ∀{p q} → (𝓚 ⊧ p ≋ q) → (HClo 𝓚 ⊧ p ≋ q)
   hclo-id1 {p}{q} 𝓚⊧p≋q (hbase A∈𝓚) = 𝓚⊧p≋q A∈𝓚
   hclo-id1 {p}{q} 𝓚⊧p≋q (hhom{A}{B}{f} A∈HClo𝓚) = γ
    where
     A⊧p≈q : A ⊧ p ≈ q
     A⊧p≈q = (hclo-id1{p}{q} 𝓚⊧p≋q ) A∈HClo𝓚

     IH : (p ̇ A) ≡ (q ̇ A)
     IH = A⊧p≈q

     HIA = hom-image-alg{𝑨 = A}{𝑩 = B} f

     𝒂 : (𝒃 : X → Σ (Image_∋_ ∣ f ∣))(x : X) → ∣ A ∣
     𝒂 = λ 𝒃 x → (Inv ∣ f ∣ (∣ 𝒃 x ∣)(∥ 𝒃 x ∥))

     hom-image-term-interpretation hiti : (𝒃 : X → ∣ HIA ∣)(p : Term)
      → (p ̇ HIA ) 𝒃 ≡ ∣ f ∣ ((p ̇ A)( λ i → 𝒂 𝒃 i )) , im ((p ̇ A)(λ i → 𝒂 𝒃 i))

     hom-image-term-interpretation 𝒃 (generator x) =
      let iiif = ( InvIsInv ∣ f ∣ ∣ 𝒃 x ∣ ∥ 𝒃 x ∥ )⁻¹ in
       𝒃 x ≡⟨ ? ⟩ ∣ f ∣ (𝒂 𝒃 x) , im (𝒂 𝒃 x) ∎

     hom-image-term-interpretation 𝒃 (node 𝓸 𝒕) =  ap (λ - → (𝓸 ̂ HIA) -) (gfe λ x → φIH x)
      where
       φIH : (x : ∥ S ∥ 𝓸)
        → ( 𝒕 x ̇ HIA ) 𝒃  ≡ ∣ f ∣ ( ( 𝒕 x ̇ A ) (𝒂 𝒃) ) , im ((𝒕 x ̇ A) (𝒂 𝒃 ) )
       φIH x = hom-image-term-interpretation 𝒃 (𝒕 x)

     hiti = hom-image-term-interpretation  -- alias

     γ : (p ̇ HIA) ≡ (q ̇ HIA)
     γ = (p ̇ HIA)
               ≡⟨ refl _ ⟩
           ( λ ( 𝒃 : X → ∣ HIA ∣ ) → (p ̇ HIA) ( λ x → (𝒃 x) ) )
               ≡⟨ gfe (λ x → hiti x p) ⟩
           ( λ 𝒃 → ∣ f ∣ ( (p ̇ A) ( λ x → 𝒂 𝒃 x ) ) , im ( (p ̇ A) ( λ x → 𝒂 𝒃 x ) ) )
               ≡⟨ ap (λ - → λ 𝒃 → ∣ f ∣ (- (λ x → 𝒂 𝒃 x) )  , im (-  (λ x → 𝒂 𝒃 x) )) IH ⟩
           ( λ 𝒃 → ∣ f ∣ ( (q ̇ A) ( λ x → 𝒂 𝒃 x ) ) , im ( (q ̇ A) ( λ x → 𝒂 𝒃 x ) ) )
               ≡⟨ ( gfe (λ x → hiti x q) )⁻¹ ⟩
           ( λ 𝒃 → (q ̇ HIA) ( λ x → (𝒃 x) ) )
               ≡⟨ refl _ ⟩
           (q ̇ HIA)    ∎

   --   postulate
   --     homclo-id2 : ∀ {p q} → {𝑨 : Algebra k S} → (h : Hom 𝔉 𝑨) → ∣ h ∣ p ≡ ∣ h ∣ q → 𝓚 ⊧ p ≋ q
   hclo-id2 : ∀ {p q} → (HClo 𝓚 ⊧' p ≋ q) → (𝓚 ⊧ p ≋ q)
   hclo-id2 p 𝑨∈𝓚 = p (hbase 𝑨∈𝓚)

   vclo-id1 : ∀ {p q} → (𝓚 ⊧' p ≋ q) → (VClo 𝓚 ⊧ p ≋ q)
   vclo-id1 {p} {q} α (vbase A∈𝓚) = α A∈𝓚
   vclo-id1 {p} {q} α (vprod{I = I}{𝓐 = 𝓐} allAi∈VClo𝓚) = γ
     where
      IH : (i : I) → 𝓐 i ⊧ p ≈ q
      IH i = vclo-id1{p}{q} α (allAi∈VClo𝓚 i)

      γ : p ̇ (Π' 𝓐)  ≡ q ̇ (Π' 𝓐)
      γ =
       (p ̇ (Π' 𝓐))
         ≡⟨ interp-prod2 gfe p 𝓐 ⟩
       (λ (args : X → ∣ Π' 𝓐 ∣) → (λ i → (p ̇ 𝓐 i)(λ x → (args x) i)))
         ≡⟨ dfe (λ args → (ap (λ - → (λ i → (- i)(λ x → args x i))) (dfe IH))) ⟩
       (λ (args : X → ∣ Π' 𝓐 ∣) → (λ i → (q ̇ 𝓐 i)(λ x → (args x) i)))
         ≡⟨ (interp-prod2 gfe q 𝓐)⁻¹ ⟩
       (q ̇ (Π' 𝓐))
         ∎

   --vsub : ∀ {𝑨 : Algebra _ S} {𝑩 : Algebra _ S} → 𝑨 ∈ VClo 𝓚 → 𝑩 is-subalgebra-of 𝑨 → 𝑩 ∈ VClo 𝓚
   vclo-id1 {p} {q} α ( vsub {𝑨 = A}{𝑩 = B} A∈VClo𝓚 B≤A ) = γ
     where
      γ : B ⊧ p ≈ q
      γ = ?

   --vhom : {𝑨 𝑩 : Algebra 𝓤 S} {f : Hom 𝑨 𝑩} → 𝑨 ∈ VClo 𝓚 →  hom-image-alg {𝑨 = 𝑨}{𝑩 = 𝑩} f ∈ VClo 𝓚
   vclo-id1 {p} {q} α ( vhom{𝑨 = A}{𝑩 = B}{f = f} 𝑨∈VClo𝓚 ) = γ
     where
      γ : hom-image-alg{𝑨 = A}{𝑩 = B} f ⊧ p ≈ q
      γ = {!!}

   vclo-id2 : ∀ {p q} → (VClo 𝓚 ⊧' p ≋ q) → (𝓚 ⊧ p ≋ q)
   vclo-id2 p 𝑨∈𝓚 = p (vbase 𝑨∈𝓚)

   -- sclo-id1 {generator x} {generator x₁} α (sub {𝑨} {.(Σ _ , _)} (sbase x₂) (mem B≤𝑨 )) = γ
   --   where
   --     γ : ((generator x) ̇ (Σ _ , _)) ≡ ((generator x₁) ̇ (Σ _ , _) )
   --     γ =  (λ 𝒂 → 𝒂 x) ≡⟨ {!!}  ⟩
   --            (λ 𝒂 → 𝒂 x₁) ∎

   -- sclo-id1 {generator x} {generator x₁} α (sub {𝑨} {.(Σ _ , _)} (sub x₂ x₃) (mem B≤𝑨)) = γ
   --   where
   --     γ : ((generator x) ̇ (Σ _ , _)) ≡ ((generator x₁) ̇ (Σ _ , _) )
   --     γ =  (λ 𝒂 → 𝒂 x) ≡⟨ {!!}  ⟩
   --            (λ 𝒂 → 𝒂 x₁) ∎

   -- sclo-id1 {generator x} {node 𝓸 𝒕} α (sub {𝑨} {.(Σ _ , _)} 𝑨∈SClo𝓚 (mem B≤𝑨)) = γ
   --   where
   --     γ : ((generator x) ̇ (Σ _ , _)) ≡ ((node 𝓸 𝒕) ̇ (Σ _ , _) )
   --     γ =  ( λ 𝒂 → 𝒂 x ) ≡⟨ {!!} ⟩
   --           ( λ 𝒂 → (𝓸 ̂ (Σ _ , _) ) (λ x₁ → (𝒕 x₁ ̇ (Σ _ , _) ) 𝒂) )   ∎

   -- sclo-id1 {node 𝓸 𝒕} {generator x} α (sub {𝑨} {.(Σ _ , _)} 𝑨∈SClo𝓚 (mem B≤𝑨)) = γ
   --   where
   --     γ : ((node 𝓸 𝒕) ̇ (Σ _ , _)) ≡ ((generator x) ̇ (Σ _ , _) )
   --     γ = ( ( λ 𝒂 → 𝒂 x ) ≡⟨ {!!} ⟩
   --            ( λ 𝒂 → (𝓸 ̂ (Σ _ , _) ) (λ x₁ → (𝒕 x₁ ̇ (Σ _ , _) ) 𝒂) )   ∎ ) ⁻¹

   -- sclo-id1 {node 𝓸 𝒕} {node 𝓸₁ 𝒕₁} α (sub {𝑨} {.(Σ _ , _)} 𝑨∈SClo𝓚 (mem B≤𝑨)) = γ
   --   where
   --     γ : ((node 𝓸 𝒕) ̇ (Σ _ , _)) ≡ ((node 𝓸₁ 𝒕₁) ̇ (Σ _ , _) )
   --     γ = {!!}
