.. file: basic.lagda.rst
.. Author: William DeMeo  <williamdemeo@gmail.com>
.. Date: 24 Dec 2019
.. Updated: 29 Jan 2020
.. Note: This was used for the second part of my talk at JMM Special Session.
.. Copyright (c) 2019 William DeMeo

.. _datatypes for algebras:

Datatypes for Algebras
========================

.. _preliminaries:

Preliminaries
-------------------------

All but the most trivial Agda programs typically begin by importing from existing libraries (e.g., the `Agda Standard Library`_) and setting some options that effect how Agda behaves. In particular, logical axioms and deduction rules can be specified according to what one wishes to assume. 

For example, here's the start of the first Agda source file in our library, which we call ``Preliminaries.agda``.

.. code-block:: agda

   {-# OPTIONS --without-K --exact-split #-}

   --`without-K` disables Streicher's K axiom; see "Note on axiom K" 
     --            of the ualib documentation (ualib.org).
     --
     --`exact-split` makes Agda to only accept definitions with the
     --              equality sign "=" that behave like so-called
     --              judgmental or definitional equalities.

   module Preliminaries where

   -- Export common imports
   open import Level public renaming (suc to lsuc ; zero to lzero)
   open import Data.Empty using (‚ä•) public
   open import Data.Bool using (Bool) public
   --open import Data.Product using (‚àÉ; _,_; _√ó_; proj‚ÇÅ; proj‚ÇÇ) public
   open import Data.Product using (‚àÉ; _,_; _√ó_) public
     renaming (proj‚ÇÅ to ‚à£_‚à£; proj‚ÇÇ to ‚ü¶_‚üß)

   open import Relation.Unary using (Pred; _‚àà_; _‚äÜ_; ‚ãÇ) public
   open import Relation.Binary public
   import Relation.Binary.PropositionalEquality as Eq
   open Eq using (_‚â°_; refl; trans; cong; cong-app; sym; subst) public
   open Eq.‚â°-Reasoning public
   open import Function using (_‚àò_) public
   open import Agda.Builtin.Nat public
     renaming ( Nat to ‚Ñï; _-_ to _‚à∏_; zero to nzero; suc to succ )

We don't have the space (or patience!) to describe each of the imports appearing in ``Preliminaries.agda``. Some of them will come up for discussion in due course. Until then, we refer the reader to the above mentioned documentation, as well as the brief :ref:`axiomk` in the appendix; the latter explains the ``--without-K`` option.

The full ``Preliminaries.agda`` file, which defines other notation and objects we will use throughout the library, appears in the appendix :ref:`preliminaries.agda`. We will describe each of the objects defined therein as they come up in later sections.

-----------------------------------

.. _signatures operations and algebras:

Signatures, Operations, and Algebras
------------------------------------

We may wish to encode arity as an arbitrary type (which Agda denotes ``Set``).

The contents of the  agda-ualib_ file ``Basic.agda`` are as follows:

.. code-block:: agda

   {-# OPTIONS --without-K --exact-split #-}

   open import Preliminaries
     using (Level; lzero; lsuc;_‚äî_; ‚àÉ; _,_; ‚ä•; Bool;
	    _√ó_; ‚à£_‚à£; ‚ü¶_‚üß; _‚â°_; _‚àò_; Pred; _‚àà_; Lift)

   module Basic where

   -- Operations and projections
   module _ {i j} where
     Op : Set i ‚Üí Set j ‚Üí Set (i ‚äî j)
     Op I A = (I ‚Üí A) ‚Üí A

     œÄ : {I : Set i} {A : Set j} ‚Üí I ‚Üí Op I A
     œÄ i x = x i

   -- i is the universe in which the operation symbols lives
   -- j is the universe in which the arities live
   Signature : (i j : Level) ‚Üí Set _
   Signature i j = ‚àÉ Œª (F : Set i) ‚Üí F ‚Üí Set j

   private
     variable
       i j : Level

   -- k is the universe in which the operational type lives
   Algebra : (k : Level)  ->  Signature i j
	     -------------------------------
     ->      Set _
   Algebra k (ùêπ , œÅ) =
     ‚àÉ Œª (A : Set k) -> (ùì∏ : ùêπ) -> Op (œÅ ùì∏) A

   private
     variable
       k l m : Level
       S : Signature i j

   -- Indexed product of algebras is an algebra
   -- The trick is to view the Pi-type as a dependent product i.e.
   -- A i1 √ó A i2 √ó A i3 √ó ... = (i : I) ‚Üí A i
   Œ† : {I : Set m} ‚Üí (I ‚Üí Algebra k S) ‚Üí Algebra (k ‚äî m) S
   Œ† {I = I} A = ((i : I) ‚Üí ‚à£ A i ‚à£) , Œª ùì∏ x i ‚Üí ‚ü¶ A i ‚üß ùì∏ Œª j ‚Üí x j i

   -- Keep I at the same universe as A so that both A and Œ† A can
   -- be classified by PClo
   data PClo {i j k l} {S : Signature i j} (K : Pred (Algebra k S) l) :
     Pred (Algebra k S) (lsuc (i ‚äî j ‚äî k ‚äî l)) where
       pbase : {A : Algebra _ S} -> A ‚àà K -> A ‚àà PClo K
       prod : {I : Set k} {A : I -> Algebra _ S}
	 ->   (‚àÄ i -> A i ‚àà PClo K) -> Œ† A ‚àà PClo K

   -- Subalgebras
   module _ {i j k : Level} {S : Signature i j} where
     -- To keep A at same universe level as ‚àÉ P , B, force P to live
     -- in the same universe. We need to do this so that both A and
     -- ‚àÉ P , B can be classified by the same predicate SClo.
     data _is-supalgebra-of_ (A : Algebra k S) :
       Pred (Algebra k S) (lsuc (i ‚äî j ‚äî k))
       where
       mem : {P : Pred ‚à£ A ‚à£ k} {B : (o : ‚à£ S ‚à£) -> Op (‚ü¶ S ‚üß o) (‚àÉ P)}
	 ->  ((o : ‚à£ S ‚à£) -> (x : ‚ü¶ S ‚üß o -> ‚àÉ P)
	   -> ‚à£ B o x ‚à£ ‚â° ‚ü¶ A ‚üß o (Œª i ‚Üí ‚à£ x i ‚à£))
	 ->  A is-supalgebra-of (‚àÉ P , B)

     _is-subalgebra-of_ : Algebra _ S ‚Üí Algebra _ S ‚Üí Set _
     B is-subalgebra-of A = A is-supalgebra-of B

     data SClo (K : Pred (Algebra k S) l) :
       Pred (Algebra k S) (lsuc (i ‚äî j ‚äî k ‚äî l))
       where
       sbase : {A : Algebra _ S} -> A ‚àà K -> A ‚àà SClo K
       sub : ‚àÄ {A : Algebra _ S} {B : Algebra _ S}
	 ->  A ‚àà SClo K
	 ->  B is-subalgebra-of A
	 ->  B ‚àà SClo K

   --Example: monoid
   --  A monoid signature has two operation symbols, say, `e`
   --  and `¬∑`, of arities 0 and 2, of types `(Empty -> A) -> A`
   --  and `(Bool -> A) -> A`, resp. The types indicate that `e`
   --  is nullary (i.e., takes no args, equivalently, takes args
   --  of type `Empty -> A`), while `¬∑` is binary, as indicated
   --  by argument type `Bool -> A`.

   data monoid-op : Set where
     e : monoid-op
     ¬∑ : monoid-op

   monoid-sig : Signature _ _
   monoid-sig = monoid-op , Œª { e ‚Üí ‚ä•; ¬∑ ‚Üí Bool }

.. _signatures in agda:

Signatures in Agda
~~~~~~~~~~~~~~~~~~~~~

Notice that, when importing ``Data.Product``, we renamed ``proj‚ÇÅ`` to ``‚à£_‚à£`` and ``proj‚ÇÇ`` to ``‚ü¶_‚üß``.  Consequently, if e.g. ``S : Signature i j``, then

  ``‚à£ S ‚à£`` = the set of operation symbols (which we sometimes call ``ùë≠``), and

  ``‚ü¶ S ‚üß`` = the arity function (which we sometimes call ``œÅ``).

If  ``ùì∏ : ‚à£ S ‚à£``  is an operation symbol of the signature ``S``, then ``‚ü¶ S ‚üß ùì∏`` denotes the arity of ``ùì∏``.


.. _operations in agda:

Operations in Agda
~~~~~~~~~~~~~~~~~~~~~

As seen above, we represent the notions **operation** and **projection** in Agda as follows:

.. code-block:: agda

   -- Operations and projections
   module _ {i j} where
     Op : Set i ‚Üí Set j ‚Üí Set (i ‚äî j)
     Op I A = (I ‚Üí A) ‚Üí A

     œÄ : {I : Set i} {A : Set j} ‚Üí I ‚Üí Op I A
     œÄ i x = x i

The last two lines above codify the ``i``-th ``I``-ary projection operation on ``A``.

.. _algebras in agda:

Algebras in Agda
~~~~~~~~~~~~~~~~~~

An algebraic structure is represented in our library using the following type:

.. code-block:: agda

   -- k is the universe in which the operational type lives
   Algebra : {i j : Level}
	     (k : Level)  ->  Signature i j
	     -------------------------------
     ->      Set (i ‚äî j ‚äî lsuc k)
   Algebra k (ùêπ , œÅ) =
     ‚àÉ Œª (A : Set k) -> (ùì∏ : ùêπ) -> Op (œÅ ùì∏) A

We will have much to say about this type later.  For now, we continue setting down our Agda syntax for the basic objects of universal algebra.

-----------------------------------

.. _homomorphisms in agda:

Homomorphisms in Agda
----------------------

The file called ``Hom.agda`` in agda-ualib_ implements the notions **homomorphism** and **equalizer**. Here are the contents of ``Hom.agda``.

.. code-block:: agda

   {-# OPTIONS --without-K --exact-split #-}

   open import Preliminaries
   open import Basic

   module Hom where

   private
     variable
       i j k l m : Level
       S : Signature i j
       ùë® : Algebra k S
       ùë© : Algebra l S
       ùë™ : Algebra m S

   --The category of algebras Alg with morphisms as Homs
   Hom : Algebra k S -> Algebra l S -> Set _
   Hom {S = F , œÅ} (A , ùêπ·¥¨) (B , ùêπ·¥Æ) =
       ‚àÉ Œª (f : A -> B) -> (ùì∏ : F) (ùíÇ : œÅ ùì∏ -> A)
	-----------------------------------------
	 ->    f (ùêπ·¥¨ ùì∏ ùíÇ) ‚â° ùêπ·¥Æ ùì∏ (f ‚àò ùíÇ)

   id : (ùë® : Algebra k S) -> Hom ùë® ùë®
   id (A , ùë®) = (Œª x -> x) , Œª _ _ -> refl

   _>>>_ : {S : Signature i j} {ùë® : Algebra k S}
	   {ùë© : Algebra l S} {ùë™ : Algebra m S}
     ->    Hom ùë® ùë©  ->  Hom ùë© ùë™
	   ---------------------
     ->         Hom ùë® ùë™
   _>>>_ {S = F , œÅ} {ùë® = A , ùêπ·¥¨} {ùë™ = C , ùêπ·∂ú}
	 (f , Œ±) (g , Œ≤) = g ‚àò f , Œ≥
	   where
	   Œ≥ :    (ùì∏ : F) (ùíÇ : œÅ ùì∏ -> A)
		---------------------------------------
	     ->   (g ‚àò f) (ùêπ·¥¨ ùì∏ ùíÇ) ‚â° ùêπ·∂ú ùì∏ (g ‚àò f ‚àò ùíÇ)
	   Œ≥ ùì∏ ùíÇ rewrite Œ± ùì∏ ùíÇ = Œ≤ ùì∏ (f ‚àò ùíÇ)

   -- Equalizers in Alg
   _~_ : Hom ùë® ùë© ‚Üí Hom ùë® ùë© ‚Üí Pred ‚à£ ùë® ‚à£ _
   _~_ (f , _) (g , _) x = f x ‚â° g x

-----------------------------------------------

.. _isomorphisms in agda:

Isomorphisms in Agda
-------------------------

We define a type for **isomorphism** for each of the three flavors of algebra datatype, as follows.

#. **Isomorphisms for algebras with carriers of type** ``Set``.

   .. code-block:: agda

      open hom

      _‚âÖ·µ§_ :  {S : signature}
	     (A : algebra S) -> (B : algebra S) -> Set _

      A ‚âÖ·µ§ B = (‚àÉ f : hom A B)
	->    (‚àÉ g : hom B A)
	->    ( (‚ü¶ g ‚üß‚Çï ‚àò ‚ü¶ f ‚üß‚Çï) ‚â° identity _ ) -- ‚ü¶ A ‚üß·µ§
	    ‚àß ( (‚ü¶ f ‚üß‚Çï ‚àò ‚ü¶ g ‚üß‚Çï) ‚â° identity _ ) -- ‚ü¶ B ‚üß·µ§ 


#. **Isomorphisms for algebras with carriers of type** ``Pred (S Œ©) zero``.

   .. code-block:: agda

      open homP

      _‚âÖ‚Çö_ :  {S : signature}
	     (A : algebraP S) -> (B : algebraP S) -> Set _

      A ‚âÖ‚Çö B = (‚àÉ f : homP A B)
	->    (‚àÉ g : homP B A)
	->    ( (hmap g) ‚àò (hmap f) ‚â° identity _ )
	    ‚àß ( (hmap f) ‚àò (hmap g) ‚â° identity _ )

#. **Isomorphisms for algebras with carriers of type** ``Setoid``.

   .. code-block:: agda

      open Hom

      _‚âÖ‚Çõ_ : {S : signature}
	    (A : Algebra S) -> (B : Algebra S) -> Set _

      A ‚âÖ‚Çõ B = (‚àÉ f : Hom A B)
	->    (‚àÉ g : Hom B A)
	->    ( (‚ü¶ g ‚üß‚Çï ‚àò ‚ü¶ f ‚üß‚Çï) ‚â° identity _ ) -- (Carrier ‚ü¶ A ‚üß·µ£) )
	    ‚àß ( (‚ü¶ f ‚üß‚Çï ‚àò ‚ü¶ g ‚üß‚Çï) ‚â° identity _ ) -- (Carrier ‚ü¶ B ‚üß·µ£)  )


.. _congruence relations in agda:

Congruence relations in Agda
---------------------------------

Next we define a type for congruence relations. For this we define functions that test whether a given operation or term is **compatible** with a given relation. The notions are defined in the file ``Con.agda``, the contents of which are shown below.

.. code-block:: agda

   {-# OPTIONS --without-K --exact-split #-}

   open import Preliminaries
   open import Basic 
   open import Hom

   module Con {i j k : Level} {S : Signature i j}  where

   -- lift a binary relation from pairs to pairs of tuples.
   lift-rel : ‚àÄ{‚Ñì‚ÇÅ : Level} {Idx : Set ‚Ñì‚ÇÅ} {‚Ñì‚ÇÇ : Level} {Z : Set ‚Ñì‚ÇÇ}
    ->         Rel Z ‚Ñì‚ÇÇ
	    -----------------
    ->       Rel (Idx -> Z) (‚Ñì‚ÇÅ ‚äî ‚Ñì‚ÇÇ)
   lift-rel R = Œª args‚ÇÅ args‚ÇÇ -> ‚àÄ i -> R (args‚ÇÅ i) (args‚ÇÇ i)

   -- compatibility of a give function-relation pair
   compatible-fun : ‚àÄ {‚Ñì‚ÇÅ ‚Ñì‚ÇÇ : Level} {Œ≥ : Set ‚Ñì‚ÇÅ} {Z : Set ‚Ñì‚ÇÇ}
    ->             ((Œ≥ -> Z) -> Z)
    ->             (Rel Z ‚Ñì‚ÇÇ)
		  -----------------------------------------
    ->             Set (‚Ñì‚ÇÅ ‚äî ‚Ñì‚ÇÇ)
   compatible-fun f ùìª = (lift-rel ùìª) =[ f ]‚áí ùìª

   -- relation compatible with an operation
   compatible : (ùë® : Algebra k S)
    ->         ‚à£ S ‚à£
    ->         Rel ‚à£ ùë® ‚à£ k
	     -------------------------------
    ->         Set (j ‚äî k)
   compatible ùë® ùì∏ ùìª =
    (lift-rel {j} {‚ü¶ S ‚üß ùì∏} {k} {‚à£ ùë® ‚à£}  ùìª) =[ (‚ü¶ ùë® ‚üß ùì∏) ]‚áí ùìª

   -- relation compatible with all operations of an algebra
   compatible-alg : (ùë® : Algebra k S)
    ->            Rel ‚à£ ùë® ‚à£ k
		------------------------------
    ->             Set (i ‚äî j ‚äî k)
   compatible-alg ùë® ùìª = ‚àÄ ùì∏ -> compatible ùë® ùì∏ ùìª

   -- Congruence relations
   Con : (ùë® : Algebra k S)
	 -----------------------
    ->    Set (i ‚äî j ‚äî lsuc k)
   --  ->    Set (lsuc i ‚äî lsuc j ‚äî lsuc k)
   Con ùë® = ‚àÉ Œª (Œ∏ : Rel ‚à£ ùë® ‚à£ k)
	    -> IsEquivalence Œ∏ √ó compatible-alg ùë® Œ∏

   con : (ùë® : Algebra k S)
	 -----------------------
    ->   Pred (Rel ‚à£ ùë® ‚à£ k) _
   con ùë® = Œª Œ∏ ‚Üí IsEquivalence Œ∏ √ó compatible-alg ùë® Œ∏
	  --  -> 
   record Congruence (ùë® : Algebra k S) : Set (i ‚äî j ‚äî lsuc k) where
    constructor mkcon
    field
      ‚à•_‚à• : Rel ‚à£ ùë® ‚à£ k
      Compatible : compatible-alg ùë® ‚à•_‚à•
      IsEquiv : IsEquivalence ‚à•_‚à•
   open Congruence 

   --a single Œ∏-class of A
   [_]_ : {A : Set k} -> (a : A) -> Rel A k -> Pred A _
   [ a ] Œ∏ = Œª x ‚Üí Œ∏ a x

   --the collection of Œ∏-classes of A
   _//_ : (A : Set k) -> Rel A k -> Set _
   A // Œ∏ = ‚àÉ Œª (C : Pred A _) -> (‚àÉ Œª a -> C ‚â° [ a ] Œ∏)


   _/_ : (ùë® : Algebra k S)
    ->  Congruence ùë®
       -----------------------
    ->  Algebra (lsuc k) S
   ùë® / Œ∏ = ( ( ‚à£ ùë® ‚à£ // ‚à• Œ∏ ‚à• ) , -- carrier
	     ( Œª ùì∏ args        -- operations
		 -> ( [ ‚ü¶ ùë® ‚üß ùì∏ (Œª i‚ÇÅ -> ‚à£ ‚ü¶ args i‚ÇÅ ‚üß ‚à£) ] ‚à• Œ∏ ‚à• ) ,
		    ( ‚ü¶ ùë® ‚üß ùì∏ (Œª i‚ÇÅ -> ‚à£ ‚ü¶ args i‚ÇÅ ‚üß ‚à£) , refl )
	     )
	   )

   _IsHomImageOf_ : (ùë© : Algebra (lsuc k) S)
    ->             (ùë® : Algebra k S)
    ->             Set _
   ùë© IsHomImageOf ùë® =
    ‚àÉ Œª (Œ∏ : Rel ‚à£ ùë® ‚à£ k) -> con ùë® Œ∏
      ->   (‚à£ ùë® ‚à£ // Œ∏) ‚âÉ ‚à£ ùë© ‚à£

   HomImagesOf : Algebra k S -> Pred (Algebra (lsuc k) S) (i ‚äî j ‚äî lsuc k)
   HomImagesOf ùë® = Œª ùë© -> ùë© IsHomImageOf ùë® 

   _IsHomImageOfClass_ : Algebra (lsuc k) S -> Pred (Algebra k S) k -> Set _
   ùë© IsHomImageOfClass ùìö = ‚àÉ Œª ùë® -> ùë® ‚àà ùìö -> ùë© IsHomImageOf ùë®

   HomImagesOfClass : Pred (Algebra k S) k
     ->               Pred (Algebra (lsuc k) S) (i ‚äî j ‚äî lsuc k)
   HomImagesOfClass ùìö = Œª ùë© -> ‚àÉ Œª ùë® -> ùë® ‚àà ùìö -> ùë© IsHomImageOf ùë®

----------------------------

In the next chapter we turn to the important topic of **terms** (the datatypes for which we have defined in the file ``free.agda``).

-----------------------------------------------


.. include:: hyperlink_references.rst



    
