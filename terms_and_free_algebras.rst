===============================
Terms and Free Algebras in Lean
===============================

Most of the Lean code described in this section can be found in the file at https://github.com/UniversalAlgebra/lean-ualib/blob/master/src/free.lean .
Most of the Lean code described in this section can be found in the files ``free.lean`` which reside in the ``src`` directory of the lean-ualib_ repository.

.. _inductively-defined-type:

Inductively defined types
-------------------------

A primary motivation for this project was our observation that, on the one hand, many important constructs in universal algebra can be defined inductively, and on the other hand, type theory in general, and Lean in particular, offers excellent support for defining inductive types and powerful tactics for proving their properties.

These two facts suggest that there should be much to gain from implementing universal algebra in an expressive type system that offers powerful tools for proving theorems about inductively defined types.

.. index:: subuniverse generated by a set

As such, we are pleased to present the following inductive type that implements the **subuniverse generated by a set**; cf. the definition :eq:`subalgebra-inductive` given in the informal language.

.. code-block:: lean

    inductive Y (X : set α) : set α
    | var (x : α) : x ∈ X → Y x
    | app (f : F) (a : ρ f → α) : (∀ i, Y (a i)) → Y (A f a)
  
Next we prove that the type ``Y X`` defines a subuniverse, and that it is, in fact, equal to :math:`\mathrm{Sg}^𝐀(X)`.

.. code-block:: lean

    -- Y X is a subuniverse
    lemma Y_is_Sub (X : set α) : Sub (Y X) := 
    assume f a (h: ∀ i, Y X (a i)), show Y X (A f a), from 
    Y.app f a h 
   
    -- Y X is the subuniverse generated by X
    theorem sg_inductive (X : set α) : Sg X = Y X :=
    have h₀ : X ⊆ Y X, from 
      assume x (h : x ∈ X), 
      show x ∈ Y X, from Y.var x h,
    have h₁ : Sub (Y X), from 
      assume f a (h : ∀ x, Y X (a x)), 
      show Y X (A f a), from Y.app f a h,
    have inc_l : Sg X ⊆ Y X, from 
       assume u (h : u ∈ Sg X), 
       show u ∈ Y X, from (sInter_mem u) h h₁ h₀,
    have inc_r : Y X ⊆ Sg X, from
       assume a (h: a ∈ Y X), show a ∈ Sg X, from
         have h' : a ∈ Y X → a ∈ Sg X, from 
           Y.rec
           --base: a = x ∈ X
           ( assume x (h1 : x ∈ X), 
             show x ∈ Sg X, from subset_X_of_SgX X h1 )
           --inductive: a = A f b for some b with ∀ i, b i ∈ Sg X
           ( assume f b (h2 : ∀ i, b i ∈ Y X) (h3 : ∀ i, b i ∈ Sg X),
             show A f b ∈ Sg X, from SgX_is_Sub X f b h3 ),
         h' h,
    subset.antisymm inc_l inc_r

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A ⊆ B → B ⊆ A → A = B`.

.. index:: recursor

We proved ``Y X ⊆ Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined.

The Lean keyword ``assume`` is syntactic sugar for ``λ``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

----------------------------------------------

.. index:: variables, word, term, free algebra

.. _terms-and-free-algebras:

Terms and free algebras
-----------------------

Fix a signature :math:`σ = (F, ρ)`, let :math:`X` be a set of **variables** and assume :math:`X ∩ F = ∅`.

For every :math:`n < ω`, let  :math:`F_n = ρ^{-1} \{n\}` be the set of :math:`𝗇`-ary operation symbols.

By a **word** on :math:`X ∪ F` we mean a nonempty, finite sequence of members of :math:`X ∪ T`.

We denote the concatenation of sequences by simple juxtaposition. We define, by recursion on :math:`n`, the sets :math:`T_n` of words on :math:`X ∪ F` by

.. math::      T_0 &= X ∪ F_0;\\
           T_{n+1} &= T_n ∪ \{ f s ∣ f ∈  F, \ s : ρf → T_n \}. 

Define the set of **terms in the signature** σ **over** :math:`X` by :math:`T_ρ(X) = ⋃_{n < ω}T_n`.

The definition of :math:`T_ρ (X)` is recursive, indicating that *the set of terms in a signature can be implemented in Lean using an inductive type*.

We will confirm this in the next subsection, but before doing so, we impose an algebraic structure on :math:`T_ρ(X)`, and then state and prove some basic but important facts about this algebra. These will be formalized in the next section, giving us another chance to compare informal language proofs to their formal Lean counterparts and to show off inductively defined types in Lean.

If :math:`w` is a term, let :math:`|w|` be the least :math:`n` such that :math:`w ∈ T_n`, called the *height* of :math:`w`. [1]_ The height is a useful index for recursion and induction.

Notice that the set :math:`T_ρ (X)` is nonempty iff either :math:`X` or :math:`F_0` is nonempty. As long as :math:`T_ρ (X)` is nonempty, we can impose upon this set an algebraic structure, as follows:

For every basic operation symbol :math:`f ∈ F` let :math:`f^{𝐓_ρ (X)}` be the operation on :math:`𝐓_ρ (X)` that maps each tuple :math:`𝐚 : ρf → T_ρ (X)` to the formal term :math:`f 𝐚`.

We define :math:`𝐓_ρ (X)` to be the algebra with universe :math:`T_ρ (X)` and with basic operations :math:`\{f^{𝐓_ρ (X)} | f ∈ F\}`. [2]_

Indeed, Part (2) of :ref:`Theorem 4.21 <thm-4-21>` below asserts that :math:`𝐓_ρ (X)` is *universal for* \sigma-algebras.

To prove this, we need the following basic lemma, which states that a homomorphism is uniquely determined by its restriction to a generating set. (See also :cite:`Bergman:2012`, Ex. 1.16.6.)

.. _ex_1-16-6-brief:

.. proof:lemma::

   Let :math:`f` and :math:`g` be homomorphisms from 𝐀 to 𝐁. If :math:`X ⊆ A` and :math:`X` generates 𝐀 and :math:`f|_X = g|_X`, then :math:`f = g`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Suppose the subset :math:`X ⊆ A` generates 𝐀 and suppose :math:`f|_X = g|_X`. Fix an arbitrary element :math:`a ∈ A`.

      We show :math:`f(a) = g(a)`. Since :math:`X` generates 𝐀, there exists a (say, :math:`n`-ary) term :math:`t` and a tuple :math:`(x_1, \dots, x_n) ∈ X^n` such that :math:`a = t^{𝐀}(x_1, \dots, x_n)`. Therefore,

      .. math:: f(a) = f(t^{𝐀}(x_1, \dots, x_n)) &= t^{𝐁}(f(x_1), \dots, f(x_n)) \\
                                    &= t^{𝐁}(g(x_1), \dots, g(x_n)) = g(t^{𝐀}(x_1, \dots, x_n)) = g(a).

Here is another useful theorem. (See also :cite:`Bergman:2012`, Thm. 4.21.) 

.. _thm-4-21:

.. proof:theorem::

   Let :math:`σ = (F, ρ)` be a signature.

   #. :math:`𝐓_ρ (X)` is generated by X.
   #. For every σ-algebra 𝐀 and every function :math:`h : X → A` there is a unique homomorphism :math:`g : 𝐓_ρ (X) → 𝐀` such that :math:`g|_X = h`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      The definition of :math:`𝐓_ρ (X)` exactly parallels the construction in :ref:`Theorem 1.14 <thm-1-14>`. That accounts for (1).

      For (2), define :math:`g(t)` by induction on :math:`ρt`. Suppose :math:`ρt = 0`. Then :math:`t ∈ X ∪ F`.
      
      If :math:`t ∈ X` then define :math:`g(t) = h(t)`. For :math:`t ∉ X`, :math:`g(t) = t^{𝐀}`.
      
      Note that since 𝐀 is an \sigma-algebra and 𝗍 is a nullary operation symbol, :math:`t^{𝐀}` is defined.
    
      For the inductive step, let :math:`|t| = n + 1`. Then :math:`t = f(s_1, \dots, s_k)` for some :math:`f ∈ F_k` and :math:`s_1, \dots, s_k` each of height at most :math:`n`.
      
      We define :math:`g(t) = f^{𝐀}(g(s_1), \dots, g(s_k))`.
      
      By its very definition, 𝗀 is a homomorphism.
      
      Finally, the uniqueness of 𝗀 follows from :ref:`Lemma 1.16 <ex_1-16-6-brief>`. 

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`𝐓(X)` of all terms of a given signature.

.. code-block:: lean

    import basic
    section
      parameters {σ : signature} (X :Type*) 
      local notation `F` := σ.F
      local notation `ρ` := σ.ρ 
    
      inductive term
      | var : X → term
      | app (f : F) : (ρ f → term) → term
  
      def Term : algebra S := ⟨term, term.app⟩
    end

The set of terms along with the operations :math:`F^{𝐓} := \{\mathsf{app} f | f : F\}` forms an algebra :math:`𝐓(X) = ⟨T(X), F^{𝐓}⟩` in the signature :math:`σ = (F, ρ)`.

Suppose :math:`𝐀 = ⟨A, F^{𝐀}⟩` is an algebra in the same signature and :math:`h : X → A` is an arbitrary function.  We will show that :math:`h : X → A` has a unique *extension* (or *lift*) to a homomorphism from :math:`𝐓(X)` to 𝐀.

Since 𝐀 and :math:`h : X → A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`𝐓(X)` is *universal* for σ-algebras. Some authors say, ":math:`𝐓(X)` is *absolutely free* for σ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. code-block:: lean

    section
      open term
      parameters {σ : signature} (X :Type*) {A : algebra σ}
      definition F := σ.F         -- operation symbols
      definition ρ := σ.ρ         -- arity function
      definition 𝕋 := @Term σ     -- term algebra over X
      definition 𝕏 := @var σ X    -- generators of the term algebra

If :math:`h : X → A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`𝕋(X)` is defined inductively as follows:

.. code-block:: lean

    definition lift_of (h : X → A) : 𝕋(X) → 
    | (var x) := h x
    | (app f a) := (A f) (λ x, lift_of (a x))

To prove that the term algebra is universal for σ-algebras, we show that the lift of an arbitrary function :math:`h : X → A` is a homomorphism and that this lift is unique.

.. code-block:: lean

      -- The lift is a homomorphism.
      lemma lift_is_hom (h : X → A) : homomorphic (lift_of h) :=
      λ f a, show lift_of h (app f a) = A f (lift_of h ∘ a), from rfl
    
      -- The lift is unique.
      lemma lift_is_unique : ∀ {h h' : 𝕋(X) → A},
      homomorphic h → homomorphic h' → h ∘ 𝕏 = h' ∘ 𝕏 → h = h' :=
      assume (h h' : 𝕋(X) → A) (h₁ : homomorphic h)
        (h₂ : homomorphic h')(h₃ : h ∘ 𝕏 = h' ∘ 𝕏),
        show h = h', from 
          have h₀ : ∀ t : 𝕋(X), h t = h' t, from 
            assume t : 𝕋(X), 
            begin
              induction t with t f a ih₁ ,
              show h (𝕏 t) = h' (𝕏 t),
              { apply congr_fun h₃ t },
    
              show h (app f a) = h' (app f a),
              { have ih₂  : h ∘ a = h' ∘ a, from funext ih₁,
                calc h (app f a) = A f (h ∘ a) : h₁ f a
                             ... = A f (h' ∘ a) : congr_arg (A f) ih₂ 
                             ... = h' (app f a) : (h₂ f a).symm }
            end,
          funext h₀ 
    end

Let :math:`𝐀 = ⟨A, F^{𝐀}⟩` be a \sigma-algebra.

.. with congruence lattice $\Con\<A, \dots \>$.

.. index:: clone

Recall that a **clone** on a nonempty set :math:`A` is a set of operations on :math:`A` that contains the projection operations and is closed under general composition. 

Let :math:`A` denote the set of all clones on :math:`A`.

The **clone of term operations** of an σ-algebra 𝐀, denoted by :math:`\mathrm{Clo} 𝐀`, is the smallest clone on :math:`A` containing the basic operations of 𝐀, that is,

.. math:: \mathrm{Clo} 𝐀 = ⋂ \{ U ∈ 𝖢 A ∣ F^{𝐀} ⊆ U\}.

The set of :math:`n`-ary members of :math:`\mathrm{Clo} 𝐀` is sometimes denoted by :math:`\mathrm{Clo}_n 𝐀` (despite the fact that the latter is obviously not a clone).

We now state a theorem that shows how the clone of term operations of a signature can be defined inductively.

.. _thm-4-3:

.. proof:theorem::

   Let :math:`X` be a set and :math:`σ = (F, ρ)` a signature. Define

   .. math:: F_0 &= X;\\
         F_{n+1} &= F_n ∪ \{ f g ∣ f ∈ F, g : ρf → (F_n ∩ (ρ g → X)) \}, \quad n < ω.

   Then :math:`\mathrm{Clo}^X(F) = ⋃_n F_n`.

Thus *the clone of terms operations can be implemented (e.g., in Lean) as an inductive type*. The following theorem makes this precise. (See also :cite:`Bergman:2012`, Thm. 4.32.)

.. _thm-4-32:

.. proof:theorem::

   Let 𝐀 and 𝐁 be algebras of type :math:`ρ`.

   #. For every :math:`n`-ary term :math:`t ∈ T_ρ (X_ω)` and homomorphism :math:`g : 𝐀 → 𝐁`,
      
      .. math:: g(t^{𝐀}(a_1,\dots, a_n)) = t^{𝐁}(g(a_1),\dots, g(a_n)).

   #. For all :math:`t ∈ T_ρ (X_ω)`, :math:`θ ∈ \mathrm{Con} 𝐀`, :math:`𝐚 : ρ t → A` and :math:`𝐛 : ρ t → A`,
   
      .. math:: 𝐚 \mathrel{θ} 𝐛 ⟹ t^{𝐀}(𝐚) \mathrel{θ} t^{𝐀}(𝐛).

   #. For every subset :math:`Y ⊆ A`,

      .. math:: \mathrm{Sg}^{𝐀}(Y) = \{ t^{𝐀}(a_1, \dots, a_n) : t ∈ T(X_n), a_i ∈ Y, i ≤ n < ω\}.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      The first statement is an easy induction on :math:`|t|`.

      The second statement follows from the first by taking :math:`𝐁 = 𝐀/θ` and 𝗀 the canonical homomorphism.
  
      For the third statement, again by induction on the height of 𝗍, every subalgebra must be closed under the action of :math:`t^{𝐀}`. 
  
      Thus the right-hand side is contained in the left. On the other hand, the right-hand side is clearly a subalgebra containing the elements of :math:`Y` (take :math:`t = x_1`) from which the reverse inclusion follows.

------------------------

.. rubric:: Footnotes

.. [1]
   The **height** of a type is simply type's *level* (see Section ???) and the syntax :math:`Type*` indicates that we do not wish to commit in advance to a specific height.

.. [2]
   The construction of :math:`𝐓_ρ (X)` may seem to be making something out of nothing, but it plays a crucial role in the theory.

.. _Lean: https://leanprover.github.io/

.. _`github.com/UniversalAlgebra/lean-ualib`: https://github.com/UniversalAlgebra/lean-ualib/

.. _lean-ualib: https://github.com/UniversalAlgebra/lean-ualib/