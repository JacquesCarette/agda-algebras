.. include:: _static/math_macros.rst

.. role:: cat
.. role:: code

.. _algebras:

========
Algebras
========

Our vision for the `lean-ualib`_ (Lean Universal Algebra Library) originated with our observation that, on the one hand, a number of the most basic and important constructs in universal algebra can be defined recursively, while on the other hand, :term:`type theory` in general, and :term:`dependent <dependent type>` and :term:`inductive types <inductive type>` in particular, facilitates elegant representations of recursively defined objects. Such objects can therefore be implemented in a :term:`proof assistant` such as `Lean`_, a language that not only supports :term:`dependent <dependent type>` and :term:`inductive types <inductive type>`, but also provides powerful :term:`tactics <proof tactic>` for proving properties of objects that inhabit these types.

These observations suggest that there is much to gain from implementing universal algebra in a proof assistant that offers powerful tools for working with :term:`dependent <dependent type>` and :term:`inductive types <inductive type>`. Lean is one such proof assistant.

The goal of the `Lean Universal Algebra Library`_, and this documentation explaining it, is to demonstrate that our vision manifests in a careful (and, whenever possible, :term:`constructive`) presentation of the elementary theory of universal algebra in the language of type theory, along with a formal implementation of this theory in the Lean proof assistant.  Specific examples of this manifestation appear below in :numref:`subalgebras-in-lean`, :numref:`terms-in-lean`, and :numref:`clones-in-lean`.

.. In particular, our Lean_ implementation of the notion of :term:`subuniverse` illustrates one of these underlying themes motivating our work.

Specifically, we present fundamental definitions and theorems about :term:`subalgebras <subalgebra>`, terms, and clones---first in this chapter using the informal language of universal algebra, and then in the next chapter using the formal language of Lean.

The idea is to demonstrate the power and utility of implementing the theory in a formal language that supports :term:`dependent <dependent type>` and :term:`inductive types <inductive type>`, which are essential for expressing and working with infinite objects in a :term:`constructive` and :term:`computable` way, and for proving (by induction) properties of these objects.

-----------------------------------------


.. index:: ! graph (of a function)
.. index:: ! idempotent, ! projection
.. index:: operation, arity, image
.. index:: pair: ‚Ñï; œâ 

.. _operations:

Operations
-----------

The symbols ‚Ñï, œâ, and ``nat`` are used interchangeably; they all denote the set of natural numbers.

If :math:`m` is a natural number, we write :math:`m: ‚Ñï` and say ":math:`m` has type ‚Ñï." [1]_

We denote and define natural numbers by :math:`m := \{0, 1, \dots, m-1\}`.

It is sometimes convenient to formally identify a function with its graph.  For example, the function :math:`a: m ‚Üí A` may be identified with the tuple :math:`(a\,0, a\,1, \dots, a\,(m-1)): A^m`.

.. It seems an egregious abuse of notation to simply write :math:`a = (a\,0, a\,1, \dots, a\,(m-1))`, so we opt for the more standard notation :math:`a[m]` to denote the **image** of the set :math:`m` under the function :math:`a`; that is, :math:`a[m]:=(a\, 0, a\, 1, \dots, a\, (m-1))`.

If :math:`h: A ‚Üí A` and :math:`a: m ‚Üí A` are functions, then :math:`h ‚àò a: m ‚Üí A` denotes the composition of :math:`h` with :math:`a`; this is the function that maps each :math:`i: m` to the element

.. math:: (h ‚àò a)(i) = h(a\, i)

of :math:`A`.

We may formally identify the function :math:`h ‚àò a: m ‚Üí A` with its graph, which is the :math:`m`-tuple,

.. math:: (h(a\, 0), h(a\, 1), \dots, h(a\, (m-1))).

Suppose :math:`A` is a nonempty set and :math:`n ‚àà ‚Ñï` is a natural number.

An :math:`n`-**ary operation** on :math:`A` is a function :math:`f: A^n ‚Üí A` which, if :math:`n>0`, maps each :math:`n`-tuple :math:`(a_0, a_1, \dots, a_{n-1})` in :math:`A^n` to a particular element :math:`f(a_0, a_1, \dots, a_{n-1})` in :math:`A`. If :math:`n=0`, then :math:`f: () ‚Üí A` is a function that takes no arguments and returns an element of :math:`A`, so :math:`f` in this case is merely notation for a particular element of :math:`A`.

An operation gives rise to a special kind of :math:`(n+1)`-ary relation, namely

.. math:: Gf := \{(a_0, a_1, \dots, a_{n-1}, b) \in A^{n+1} ‚à£ b = f(a_0, a_1, \dots, a_{n-1})\},

which is sometimes called the **graph** of :math:`f`.

For two sets :math:`A` and :math:`B`, the collection of all functions :math:`f: B ‚Üí A` is denoted by :math:`A^B`. When :math:`B = A^n`, this is set :math:`A^{A^n}` of all :math:`n`-ary operations on :math:`A`.

If we let :math:`ùñÆ_A` denote the collection of all finitary operations on :math:`A`, then

.. math:: ùñÆ_A = ‚ãÉ_{n ‚àà ‚Ñï} A^{A^n}.

If :math:`F ‚äÜ ùñÆ_A` is a set of operations on :math:`A`, let us denote by :math:`F_n` the :math:`n`-ary operations in :math:`F`.

Clearly, :math:`F_n = F ‚à© A^{A^n}`. For example, the set of *all* :math:`n`-ary operations on :math:`A` is

.. math:: (ùñÆ_A)_n = ùñÆ_A ‚à© A^{A^n} = A^{A^n}`.

Given an :math:`n`-tuple :math:`a = (a_0, a_1, \dots, a_{n-1}) ‚àà A^n`, we will need a convenient way to refer to the set :math:`\{a_i : 0 ‚â§ i < n\}` of elements that occur in the tuple without explicitly naming each element in this set.  In fact, we already have notation for this, since an :math:`n`-tuple is actually a function, defined on the (ordered) set :math:`\{0, 1, \dots, n-1\}`, whose image is the set of elements in the tuple.

That is, if :math:`a = (a_0, a_1, \dots, a_{n-1})`, then :math:`\im a = \{a_0, a_1, \dots, a_{n-1}\}`. In particular, :math:`|\im a|` is a convenient way to write the number of distinct
elements that occur in the tuple :math:`a`.

For example, if :math:`a = (1,1,3)`, then :math:`\im a = \{1, 3\}`, and :math:`|\im a| = 2`.

An operation :math:`f ‚àà A^{A^n}` is called **idempotent** provided :math:`f(a, a, \dots, a) = a` for all :math:`a ‚àà A`.

Important examples of idempotent operations are the projections. If :math:`k` and :math:`n` are natural numbers with :math:`1 ‚â§ k ‚â§ n` then the :math:`k`-**th** :math:`n`-**ary projection** of :math:`A` is denoted by :math:`œÄ^n_k` and defined to be the function that maps :math:`A^n` onto :math:`A` according to the rule :math:`(a_1, \dots, a_n) ‚Ü¶ a_k`.

Thus, the arity of an operation is the number of operands upon which it acts, and we say that :math:`f` is an :math:`n`-**ary operation on** :math:`A` if :math:`\dom f = A^n` and :math:`\cod f = A`.

An operation is called **nullary** (or constant) if its arity is zero. **Unary**, **binary**, and **ternary** operations have arities 1, 2, and 3, respectively.


---------------------------

.. index:: signature, arity

.. _signatures:

Signatures
----------

Classically, a **signature** is a pair :math:`(F, œÅ)` consisting of a set :math:`F` of operation symbols and an "arity" function :math:`œÅ: F ‚Üí ‚Ñï`.

For each operation symbol :math:`f ‚àà F`, the value :math:`œÅ f` is the **arity** of :math:`f`. (Intuitively, the arity can be thought of as the "number of arguments" that :math:`f` takes as "input".)

If the arity of :math:`f` is :math:`n`, then we call :math:`f` an :math:`n`-**ary** function. In case :math:`n` is 0, 1, 2, or 3, we call the function "nullary", "unary", "binary", or "ternary," respectively.

If :math:`A` is a set and :math:`f` is a :math:`œÅ f`-ary function on :math:`A`, then we often write :math:`f: A^{œÅf} ‚Üí A` to indicate this.

On the other hand, the arguments of such a function form a :math:`œÅ f`-tuple, :math:`(a_0, a_1, \dots, a_{œÅf -1})`, which may be viewed as the graph of the function :math:`a: œÅf ‚Üí A`, where :math:`a\, i = a_i`.

Thus, by identifying the :math:`œÅ f`-th power :math:`A^{œÅf}` with the type :math:`œÅ f ‚Üí A` of functions from :math:`\{0, 1, \dots, œÅ f-1\}` to :math:`A`, we identify the function type :math:`A^{œÅ f} ‚Üí A` with the function (or "functional") type :math:`(œÅf ‚Üí A) ‚Üí A`. [2]_

.. proof:example::

   Suppose 

     :math:`g : (m ‚Üí A) ‚Üí A` is an :math:`m`-ary operation on :math:`A`, and 
   
     :math:`a : m ‚Üí A` is an :math:`m`-tuple on :math:`A`.

   Then :math:`g\, a = g(a\, 0, a\, 1, \dots, a\, (m-1))` has type :math:`A`.

   Suppose

     :math:`f : (œÅf ‚Üí B) ‚Üí B` is a :math:`œÅf`-ary operation on :math:`B`,

     :math:`a : œÅf ‚Üí A` is a :math:`œÅf`-tuple on :math:`A`, and

     :math:`h : A ‚Üí B`.
      
   Then :math:`h ‚àò a : œÅf ‚Üí B` and :math:`f (h ‚àò a) : B`.

It is important to be familiar with the classical notions of signature and arity, since these are used at the present time by virtually all algebraists.

**Formalization**. Our formal implementation (in `Lean`_) of the concept of signature is described in :numref:`Section %s <signatures-in-lean>` and is included in the `basic.lean`_ file of the `lean-ualib`_ library.

In :numref:`Chapter %s <postmodern-algebra>` we give alternative, category theoretic definitions of these concepts and show how this alternative presentation can often simplify implementation of the mathematics in :term:`type theory`.

--------------------------

.. index:: pair: ! algebra; ! algebraic structure
.. index:: ! œÉ-algebra, ! arity, ! trivial algebra, ! reduct

.. _algebraic-structures:

Algebraic Structures
---------------------

Some of the renewed interest in universal algebra has focused on representations of algebras in categories other than :cat:`Set`, such as multisorted algebras, and higher-type universal algebra :cite:`Adamek:2011`, :cite:`Behrisch:2012`, :cite:`Finster:2018`, :cite:`Gepner:2018`, :cite:`Meinke:1992`). These are natural generalizations that we will incorporate in our development later. (See :numref:`Chapter %s <postmodern-algebra>`.) But our first goal is to develop a working library for classical (single-sorted, set-based) universal algebra. We now define such structures.

A (universal) **algebraic structure** (or, **algebra**) is a pair :math:`‚ü®A, F‚ü©` where :math:`A` is a *nonempty* set and :math:`F = \{f_i: i ‚àà I\}` is a collection of finitary operations on :math:`A`.

That is, :math:`f_i: A^n ‚Üí A` for some :math:`n ‚àà ‚Ñï`.

.. A common shorthand for :eq:`algebra` is :math:`‚ü®A, f_i‚ü©_{i ‚àà I}`.

The number :math:`n` is called the **arity** of the operation :math:`f_i`.

If :math:`A=‚Ñù` and :math:`f: ‚Ñù √ó ‚Ñù ‚Üí ‚Ñù` is the map that takes each pair :math:`(a, b) ‚àà ‚Ñù √ó ‚Ñù` to the number :math:`f(a,b) = a+b ‚àà ‚Ñù`, then :math:`‚ü®A, \{f\}‚ü©` is an example of an algebra with a single binary operation. In such cases, we often simplify the notation and write :math:`‚ü®A, f‚ü©` in stead of :math:`‚ü®A, \{f\}‚ü©`.

.. An algebra is called **unary** if all of its operations are unary. 

An algebra is **finite** if :math:`|A|` is finite, and is called **trivial** if :math:`|A| = 1`.

Given two algebras :math:`ùî∏` and :math:`ùîπ`, we say that :math:`ùîπ` is a **reduct** of :math:`ùî∏` if both algebras have the same universe and :math:`ùîπ` can be obtained from :math:`ùî∏` by removing  operations.

.. index:: ! operation symbol, ! arity, ! interpretation, ! signature, ! similarity type

A better approach
~~~~~~~~~~~~~~~~~

An **operation symbol** :math:`f` is an object that has an associated **arity**; we denote the arity of :math:`f` by :math:`œÅ \,f`.

A pair :math:`(F, œÅ)` consisting of a set :math:`F` of operation symbols and an arity function :math:`œÅ: F ‚Üí N` is called a **signature** (or, **similarity type**).

A (universal) **algebra** (or, **algebraic structure**) in the signature :math:`œÉ = (F, œÅ)` is denoted by :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` and consists of 

  #. :math:`A` := a set, called the **carrier** (or **universe**) of the algebra,
  #. :math:`F^ùî∏ = \{ f^ùî∏ ‚à£ f ‚àà F, \ f^ùî∏ : (œÅ f ‚Üí A) ‚Üí A \}` is a collection of operations on :math:`A`,
  #. a collection of identities satisfied by elements of :math:`A` and operations in :math:`F^ùî∏`.

Note that to each operation symbol :math:`f‚àà F` corresponds an operation :math:`f^ùî∏` on :math:`A` of arity :math:`œÅ f`; we call this :math:`f^ùî∏` the **interpretation** of :math:`f` in :math:`ùî∏`.

We call an algebra in the signature :math:`œÉ` a :math:`œÉ`-**algebra** (although this is not standard). [3]_ 

.. proof:example::

   Consider the set of integers :math:`‚Ñ§` with operation symbols :math:`F = \{0, 1, -(\,), +, ‚ãÖ\}`, which have respective arities :math:`\{0, 0, 1, 2, 2\}`.

   The operation :math:`+^‚Ñ§` is the usual binary addition, while :math:`-^‚Ñ§(\,)` is negation, which takes the integer :math:`z` to :math:`-^‚Ñ§(z) = -z`.

   The constants :math:`0^‚Ñ§` and :math:`1^‚Ñ§` are nullary operations. Of course we usually just write :math:`+` for :math:`+^‚Ñ§`, etc.

More examples of algebraic structures that have historically played a central role in mathematics over the last century (e.g., groups, rings, modules) are described in the next section.

**Formalization**. Our formal implementation (in `Lean`_) of the concept of algebraic structure is described in :numref:`algebras-in-lean`, and is included in the `basic.lean`_ file of the `lean-ualib`_ library.


.. index:: ! magma, ! groupoid, ! binar, ! vector space, ! bilinear algebra, ! associative algebra, ! semigroup, ! monoid, ! group, multiplicative inverse, ! abelian group, additive identity, additive inverse,! ring, ! unital ring, ! multiplicative identity, ! unit, ! division ring, ! field, ! module 

.. _examples-of-algebras:

Examples of algebras
~~~~~~~~~~~~~~~~~~~~~~

Recall from above that an algebra :math:`ùî∏` is an ordered pair :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` where :math:`A` is a nonempty set and :math:`F` is a family of finitary operations on :math:`A`.

The set :math:`A` is called the **universe** of :math:`ùî∏`, and the elements :math:`f^ùî∏ ‚àà F` are called the **basic operations** of :math:`ùî∏`.

(In practice we often write :math:`f` instead of :math:`f^ùî∏` when no ambiguity could result from this shorthand.

Here is a list of a few of the most frequently encountered and historically important algebraic structures. [4]_

* **Magma**. An algebra :math:`‚ü®A, ‚ãÖ‚ü©` with a single binary operation is called a **magma** (or **groupoid** or **binar**). The operation is usually denoted by :math:`+` or :math:`‚ãÖ`, and we write :math:`a+b` or :math:`a ‚ãÖ b` (or just :math:`ab`) for the image of :math:`(a, b)` under this operation, which we call the *sum* or *product* of :math:`a` and :math:`b`, respectively.

* **Semigroup**. A magma :math:`‚ü®A, ‚ãÖ‚ü©` whose binary operation is associative is called a **semigroup**.  That is, a semigroup is a magma whose binary operation satisfies :math:`‚àÄ a, b, c ‚àà A`, :math:`(a ‚ãÖ b) ‚ãÖ c = a ‚ãÖ (b ‚ãÖ c)`.

* **Monoid**. If :math:`‚ü®A, ‚ãÖ‚ü©` is a semigroup and if :math:`e ‚àà A` is a *multiplicative identity* (i.e., :math:`‚àÄ a ‚àà A`, :math:`e ‚ãÖ a = a ‚ãÖ e = a`), then :math:`‚ü®A, \{e, ‚ãÖ\}‚ü©` is called a **monoid**.

* **Group**. A **group** is a monoid along with a unary operation :math:`^{-1}` called *multiplicative inverse*. That is, the reduct :math:`‚ü® A, \{e, ‚ãÖ\}‚ü©` is a monoid and :math:`^{-1}`
  satisfies :math:`a ‚ãÖ a^{-1} =  a^{-1} ‚ãÖ a = e`, for all :math:`a ‚àà A`.
  
* **Abelian group**. A group is called **abelian** just in case its binary operation is commutative, in which case we usually denote the operation by :math:`+` instead of :math:`‚ãÖ`. Also in this case we let :math:`0` (instead of :math:`e`) denote the *additive identity*, and we let :math:`-\,` (instead of :math:`^{-1}`) denote the *additive inverse*. Thus, an **abelian group** is a group :math:`ùî∏ = ‚ü® A, 0, -,+‚ü©` such that :math:`a+b = b+a` for all :math:`a, b ‚àà A`.

* **Ring**. An algebra :math:`‚ü®R, \{0, -, +, ‚ãÖ\}‚ü©` is called a **ring** just in case the following conditions hold:

  #. the reduct :math:`‚ü®R, \{0, -,+\}‚ü©` is an abelian group,

  #. the reduct :math:`‚ü®R, ‚ãÖ ‚ü©` is a semigroup, and

  #. "multiplication" :math:`‚ãÖ` distributes over "addition" :math:`+`; that is, :math:`‚àÄ a, b, c ‚àà R`, :math:`a ‚ãÖ (b+c) = a ‚ãÖ b + a ‚ãÖ c` and :math:`(a+b)‚ãÖ c = a ‚ãÖ c + b ‚ãÖ c`.

  A **ring with unity** (or **unital ring**) is an algebra :math:`‚ü®R, \{0, 1, -, +, ‚ãÖ\}‚ü©` with a ring reduct :math:`‚ü®R, \{0, -, +, ‚ãÖ\}‚ü©` and a *multiplicative identity* :math:`1 ‚àà R`; that is :math:`‚àÄ r ‚àà R`, :math:`r ‚ãÖ 1 = r = 1 ‚ãÖ r`.

  If :math:`‚ü®R, \{0, 1, -, +, ‚ãÖ\}‚ü©` is a unital ring, an element :math:`r ‚àà R` is called a **unit** if it has a multiplicative inverse, that is, there exists :math:`s ‚àà R` with :math:`r ‚ãÖ s = 1 = s ‚ãÖ r`.  (We usually denote such an :math:`s` by :math:`r^{-1}`.)

* **Division ring**.  A ring in which every non-zero element is a unit is called a **division ring**.

* **Field**. A commutative division ring is called a **field**.

* **Module**. Let :math:`R` be a ring with unit. A **left unitary** :math:`R`-**module** (or simply :math:`R`-**module**) is an algebra :math:`‚ü®M, \{0, -, +\} ‚à™ \{f_r : r‚àà R\}‚ü©` with an abelian group reduct :math:`‚ü®M, \{0, -, +\}‚ü©` and unary operations :math:`\{f_r : r ‚àà R\}` that satisfy the following: :math:`‚àÄ r, s ‚àà R`, :math:`‚àÄ x, y ‚àà M`,

  #. :math:`f_r(x + y)  = f_r(x) + f_r(y)`

  #. :math:`f_{r+s}(x) = f_r(x) + f_s(x)`

  #. :math:`f_r(f_s(x)) = f_{rs}(x)`

  #. :math:`f_1(x) = x`.

  Note that Condition 1 says that each :math:`f_r` is an :term:`endomorphism` of the abelian group :math:`‚ü® M, \{0, -, +\}‚ü©`, while the other conditions amount to the following: (1) the set :math:`E := \{f_r ‚à£ r‚àà R\}` of endomorphisms is a ring with unit where multiplication is function composition, and (2) the map :math:`r ‚Ü¶ f_r` is a ring :term:`epimorphism` from :math:`R` onto :math:`E`.

  One reason modules are important is that every ring is, up to isomorphism, a ring of endomorphisms of some abelian group. This fact is analogous to the more familiar theorem of Cayley stating that every group is isomorphic to a group of permutations of some set.

* **Vector space**. In :math:`R` happens to be a field, then an :math:`R`-module is typically called a **vector space** over :math:`R`.

* **Bilinear algebra**. If :math:`ùîΩ = ‚ü®F, \{0, 1, -, ‚ãÖ\}‚ü©` is a field, then the algebra :math:`ùî∏ = ‚ü®A, \{0, -, +, ‚ãÖ\} ‚à™ \{f_r ‚à£ r ‚àà F\}‚ü©` is called a **bilinear algebra** over :math:`ùîΩ` provided

  #. :math:`‚ü®A, \{0, -, +\} ‚à™ \{f_r ‚à£ r ‚àà F\}‚ü©` is a vector space over :math:`ùîΩ` and 
  #. :math:`‚àÄ a, b, c ‚àà A`, :math:`‚àÄ r ‚àà F`,

     .. math:: \begin{gather}
               (a + b) ‚ãÖ c = (a ‚ãÖ c) + (b ‚ãÖ c),\\
               c ‚ãÖ (a + b) = (c ‚ãÖ a) + (c ‚ãÖ b),\\
               a ‚ãÖ f_r(b) = f_r(a ‚ãÖ b) = f_r(a) ‚ãÖ b.
               \end{gather}

  If in addition :math:`(a ‚ãÖ b) ‚ãÖ c = a ‚ãÖ (b ‚ãÖ c)` for all :math:`a, b, c ‚àà A`, then :math:`ùî∏` is called an **associative algebra** over :math:`ùîΩ`. Thus an associative algebra over a field has both a vector space reduct and a ring reduct. An example of an associative algebra is the space of *linear transformations* (endomorphisms) of any vector space into itself.


---------------------------

.. index:: ! subuniverse, ! subalgebra
.. index:: ùñ≤(ùî∏)
.. index:: ùñ≤ùóÄ

.. _subalgebras:

Subalgebras
-------------

This section introduces two important concepts in universal algebra, **subuniverse** and **subalgebra**.

.. A **subuniverse** of an algebra :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` is a subset :math:`B ‚äÜ A` that is closed under the operations in :math:`F^ùî∏`.

Suppose :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` is an algebra. Recall, the (nonempty) set :math:`A` is called the **universe** of ùî∏.

We call a subset :math:`B ‚äÜ A` **closed under** (the operations in) :math:`F^ùî∏` if for each :math:`f ‚àà F` and all :math:`b_0, \dots, b_{œÅf-1} ‚àà B` we have :math:`f^ùî∏(b_0, \dots, b_{œÅ f-1}) ‚àà B`.  Equivalently,

.. math:: ‚àÄ f ‚àà F,\ ‚àÄ b: œÅ f ‚Üí B, \ (f^ùî∏ \, b) ‚àà B`.

If a subset :math:`B ‚äÜ A` is closed under :math:`F^ùî∏`, then we call :math:`B` a **subuniverse** of :math:`ùî∏`.

If :math:`B ‚â† ‚àÖ` is a subuniverse of ùî∏, and if we let :math:`F^ùîπ = \{ f^ùî∏ ‚Üæ B : f ‚àà F \}`, then :math:`ùîπ = ‚ü® B, F^ùîπ ‚ü©` is an algebra, called a **subalgebra** of ùî∏.

.. Equivalently, if :math:`B ‚â† ‚àÖ` is a subuniverse of ùî∏ and :math:`F^{ùîπ|_A} = \{f^ùî∏|_B ‚à£ f ‚àà F\}` is the set of basic operations of ùî∏ restricted to the set :math:`B`, then :math:`ùîπ = ‚ü®B, F^{ùîπ|_A}‚ü©` is a **subalgebra** of ùî∏.

Conversely, all subalgebras are of this form.

If ùîπ is a subalgebra of ùî∏, we denote this fact by :math:`ùîπ ‚â§ ùî∏`. Similarly, we write :math:`B ‚â§ ùî∏` if :math:`B` is a subuniverse of :math:`ùî∏`. 

  *The empty set is a subuniverse of every algebra, but the universe of an algebra is never empty*.

In other terms, if :math:`ùñ≤(ùî∏)` denotes the collection of all subalgebras of :math:`ùî∏`, then 

.. math:: ùñ≤ (ùî∏) = \{‚ü®B, F^ùîπ‚ü© : B ‚â§ ùî∏ \text{ and } B ‚â† ‚àÖ\}.

It is obvious that the intersection of subuniverses is again a subuniverse. Let us nevertheless record this observation.

.. proof:lemma::

   Suppose :math:`A_i ‚â§ ùî∏` for all :math:`i` in some set :math:`I`. Then :math:`‚ãÇ_{i‚àà I} A_i` is a subuniverse of :math:`ùî∏`.

.. index:: subuniverse generation

.. _subuniverse-generation:

Subuniverse generation
~~~~~~~~~~~~~~~~~~~~~~

As above :math:`ùñ≤(ùî∏)` denotes the collection of all subalgebras of ùî∏.  If ùî∏ is an algebra and :math:`A_0 ‚äÜ A` a subset of the universe of ùî∏, then the **subuniverse of** ùî∏ **generated by** :math:`A_0`, denoted by :math:`\Sg^ùî∏ (A_0)` or :math:`‚ü®A_0‚ü©`, is the smallest subuniverse of ùî∏ containing the set :math:`A_0`.  Equivalently, 

.. math:: \Sg^{ùî∏}(A_0)  =  ‚ãÇ \{ U ‚àà ùñ≤ (ùî∏) ‚à£ A_0 ‚äÜ U \}.
  :label: SgDef

We can also use recursion to define the **subuniverse of** ùî∏ **generated by a set** and prove that this new definition is equivalent to the one given by :eq:`SgDef`

.. (cf. :cite:`Bergman:2012` Thm. 1.14).

.. in :numref:`subuniverse-and-subalgebra` 

.. _thm-1-14:

.. proof:theorem:: Subuniverse generation

   Let :math:`ùî∏ = ‚ü®A, F^{ùî∏}‚ü©`  be  an  algebra in the signature :math:`œÉ = (F, œÅ)` and let :math:`A_0` be a subset of :math:`A`.

   Define, by recursion on :math:`n`, the sets :math:`A_n` as follows:

     If :math:`A_0 = ‚àÖ`, then :math:`A_n = ‚àÖ` for all :math:`n<œâ`.

     If :math:`A_0 ‚â† ‚àÖ`, then

     .. math:: A_{n+1} =  A_n ‚à™ \{ f\, a ‚à£ f ‚àà F, \ a ‚àà œÅ f ‚Üí A_n\}.
        :label: subalgebra-inductive

   Then the subuniverse of ùî∏ generated by :math:`A_0` is :math:`\Sg^ùî∏(A_0) = ‚ãÉ_{n<œâ} A_n`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Let :math:`Y := ‚ãÉ_{n < œâ} A_n`. Clearly :math:`A_n ‚äÜ Y ‚äÜ A`, for every :math:`n < œâ`. In particular :math:`A = A_0 ‚äÜ Y`. We first show that :math:`Y` is a subuniverse of ùî∏.

      Let :math:`f` be a basic :math:`k`-ary operation and let :math:`a: k ‚Üí Y` be a :math:`k`-tuple of elements of :math:`Y`.
    
      From the construction of :math:`Y`, there is an :math:`n < œâ` such that :math:`‚àÄ i,\ a,\ i ‚àà A_n`.
    
      From its definition, :math:`f \,a ‚àà A_{n+1} ‚äÜ Y`. Since :math:`f` was arbitrary, it follows that :math:`Y` is a subuniverse of ùî∏ containing :math:`A_0`.
    
      Thus, by :eq:`SgDef`, :math:`\Sg^ùî∏(A_0) ‚äÜ Y`.
    
      For the opposite inclusion, it is enough to check, by induction on :math:`n`, that :math:`A_n ‚äÜ \Sg^ùî∏(A_0)`.
    
      Clearly, :math:`A_0 ‚äÜ \Sg^ùî∏(A_0)`.
      
      Assume :math:`A_n ‚äÜ \Sg^ùî∏(A_0)`.  We show :math:`A_{n+1} ‚äÜ \Sg^ùî∏(A_0)`.
      
      If :math:`b ‚àà A_{n+1} - A_n`, then :math:`b = f\, a` for a basic :math:`k`-ary operation :math:`f` and some :math:`a: k ‚Üí A_n`.
      
      But :math:`‚àÄ i, \ a i ‚àà \Sg^ùî∏(A_0)` and since this latter object is a subuniverse, :math:`b ‚àà \Sg^ùî∏(X)` as well.
    
      Therefore, :math:`A_{n+1} ‚äÜ \Sg^ùî∏(A_0)`, as desired. ‚òê 

.. The argument in the proof of :numref:`Theorem %s <thm-1-14>` is of a type that one encounters frequently throughout algebra. It has two parts.

..   #. Some set :math:`Y` is shown to be a subuniverse of ùî∏ that contains :math:`A_0`.

..   #. Every subuniverse containing :math:`A_0` is shown to contain :math:`Y` as well.

..   #. One concludes that :math:`Y = \Sg^ùî∏ (A_0)`.


**Formalization**. Our formal implementation (in `Lean`_) of the concept of subalgebra is described in :numref:`Sections %s <subalgebras-in-lean>` and :numref:`%s <subalgebras-in-lean_reprise>`, and is included in the `subuniverse.lean`_ file of the `lean-ualib`_ library.

---------------------------

.. index:: ! subdirect product

.. _subdirect-products:

Subdirect products
-------------------

If :math:`k, n ‚àà ‚Ñï`, if :math:`A = (A_0, A_1, \dots, A_{n-1})` is a list of sets, and if :math:`œÉ : k ‚Üí n` is a :math:`k`-tuple, then a relation :math:`R` over :math:`A` with scope :math:`œÉ` is a subset of the Cartesian product :math:`A_{œÉ(0)} √ó A_{œÉ(1)} √ó \cdots √ó A_{œÉ(k-1)}`.

Let :math:`F` be a set of operation symbols and for each :math:`i<n` let :math:`ùî∏_i = ‚ü® A_i, F ‚ü©` be an algebra of type :math:`F`. If :math:`ùî∏ = ‚àè_{i<n}ùî∏_i` is the product of these algebras, then a relation :math:`R` over :math:`ùî∏` with scope :math:`œÉ` is called **compatible with** ùî∏ if it is closed under the basic operations in
:math:`F`. In other words, :math:`R` is compatible if the induced algebra :math:`‚Ñù = ‚ü® R, F ‚ü©` is a subalgebra of :math:`\prod_{j<k} ùî∏_{œÉ(j)}`.

If :math:`R` is compatible with the product algebra and if the projection of :math:`R` onto each factor is surjective, then :math:`‚Ñù` is called a **subdirect product** of the algebras in the list :math:`(ùî∏_{œÉ(0)}, ùî∏_{œÉ(1)}, \dots, ùî∏_{œÉ(k-1)})`; we denote this situation by writing :math:`‚Ñù ‚â§_{\mathrm{sd}} \prod_{j< k} ùî∏_{œÉ(j)}`.

**Formalization**. (not yet implemented)

.. todo:: implement subdirect product in Lean

-----------------------------------------------

.. index:: ! homomorphism
.. index:: ! epimorphism, ! monomorphism, ! automorphism

.. _homomorphisms:

Homomorphisms
-------------

Let :math:`ùîπ = ‚ü® B, F^ùîπ ‚ü©` and :math:`‚ÑÇ = ‚ü® C, F^‚ÑÇ ‚ü©` be algebras of the same signature, and let :math:`h: B ‚Üí C` be a function (e.g., on sets).

Take an operation symbol :math:`f ‚àà F`, and suppose that for all :math:`œÅ f`-tuples :math:`b: œÅ f ‚Üí B` of :math:`B` the following equation holds:

.. math:: h (f^ùîπ \, b) = f^‚ÑÇ (h ‚àò b).

Then :math:`h` is said to **respect the interpretation of** :math:`f`.

If :math:`h` respects the interpretation of every :math:`f ‚àà F`, then we call :math:`h` a **homomorphism** from ùîπ to ‚ÑÇ, and we write :math:`h ‚àà \hom(ùîπ, ‚ÑÇ)`, or simply, :math:`h: ùîπ ‚Üí ‚ÑÇ`.

A homomorphism :math:`h: ùîπ ‚Üí ‚ÑÇ` is called an **epimorphism** if for every algebra :math:`ùîª` and pair :math:`g_1, g_2: ‚ÑÇ ‚Üí ùîª` of homomorphisms, the equation :math:`g_1 ‚àò h = g_2 ‚àò h` implies :math:`g_1 = g_2`. We often write :math:`h: ùîπ ‚Ü† ‚ÑÇ`, and we say ":math:`h` is **epi**" and ":math:`h` maps ùîπ **onto** ‚ÑÇ," in this case.

A homomorphism :math:`h: ùîπ ‚Üí ‚ÑÇ` is called a **monomorphism** if for every algebra :math:`ùî∏` and every pair :math:`g_1, g_2: ùî∏ ‚Üí ùîπ` of homomorphisms, the equation :math:`h ‚àò g_1 = h ‚àò g_2` implies :math:`g_1 = g_2`.  We sometimes write :math:`h: ùî∏ ‚Ü£ ùîπ`, and we say ":math:`h` is **mono**" and ":math:`h` maps ùîπ **into** ‚ÑÇ," in this case.

.. proof:notation:: homo-, epi-, mono-, automorphism

   We adopt the following notation. If :math:`ùîπ` and :math:`‚ÑÇ` are algebras in the same signature, then

   + :math:`\hom(ùîπ, ‚ÑÇ) =` the set of homomorphisms from ùîπ to ‚ÑÇ.
   + :math:`\epi(ùîπ, ‚ÑÇ) =` the set of epimorphisms from ùîπ onto ‚ÑÇ.
   + :math:`\mono(ùîπ, ‚ÑÇ) =` the set of monomorphisms from ùîπ into ‚ÑÇ.
   + :math:`\aut(ùîπ, ‚ÑÇ) =` the set of automorphisms from ùîπ into and onto ‚ÑÇ.

**Formalization**. Our formal implementation (in `Lean`_) of these concepts is described in  :numref:`subalgebras-in-lean`, :numref:`basic-facts-in-lean`, :numref:`factoring-homomorphisms`, and is included in the `birkhoff.lean`_ and `subuniverse.lean`_ files of the `lean-ualib`_ library.

----------------------

.. index:: ! projection operator, ! idempotent operation

.. _idempotent-operations-projections:

Idempotent operations, projections
----------------------------------

An operation :math:`f: A^n ‚Üí A` is called **idempotent** provided :math:`f(a, a, \dots, a) = a` for all :math:`a ‚àà A`.

Examples of idempotent operations are the *projections* and these play an important role in the theory, so we introduce a sufficiently general and flexible notation for them.

Denote and define the set ‚Ñï of natural numbers inductively as follows:

.. math:: 0 = ‚àÖ, \quad 1 = \{0\}, \quad  2 := \{0, 1\}, \dots, n = \{0, 1, \dots, n-1\}.

Let :math:`\{A_i: i ‚àà I\}` be a collection of sets (for some :math:`I ‚äÜ ‚Ñï`) and let :math:`A = ‚àè_{i ‚àà I} A_i`. View the elements of :math:`A` as functions:

.. math:: a ‚àà ‚àè_{i‚ààI} A_i \quad ‚ü∑ \quad \begin{cases} a : I ‚Üí ‚ãÉ_{i‚ààI} A_i, & \\ a\,i ‚àà A_i, & ‚àÄ i ‚àà I. \end{cases}
   :label: 7
   
This correspondence simply records the fact that the product type (on the left of the ‚ü∑ symbol) is a special kind of function type (depicted on the right of ‚ü∑ using the usual arrow notation for function types).

In other words,¬†:eq:`7` says that an element of the product type :math:`‚àè_{i‚ààI} A_i` is a function from :math:`I` into :math:`‚ãÉ_{i‚ààI} A_i`.  As explained in :numref:`pi-types`, such a function (or product) type is known as a :term:`dependent type`.

Given a subset :math:`J ‚äÜ I`, a function :math:`œÉ: J ‚Üí I`, and an element :math:`a ‚àà ‚àè_{i‚ààI} A_i`, consider the composition :math:`a ‚àò œÉ`. This is a function from :math:`J` to :math:`‚ãÉ_{j‚ààJ} A_{œÉ\, j}`, where :math:`(a ‚àò œÉ)\, j ‚àà A_{œÉ\, j}`.

We could express this function type using the arrow notation, as in, ":math:`a ‚àò œÉ: J ‚Üí ‚ãÉ_{j‚ààJ} A_{œÉ\, j}` where :math:`(a ‚àò œÉ)\, j ‚àà A_{œÉ\, j}`," but this specification has a nicer, more compact description using a :term:`dependent function type`, namely, 

.. math:: a ‚àò œÉ ‚àà ‚àè_{j‚ààJ} A_{œÉ \, j}.

If :math:`œÉ` happens to be one-to-one, then we will define the **projection operator induced by** :math:`œÉ`. We denote this operator by

.. math:: \Proj\, œÉ : ‚àè_{i‚ààI} A_i ‚Üí ‚àè_{j‚ààJ} A_{œÉ \, i},
   :label: projection

and define it for each :math:`a ‚àà ‚àè_{i‚ààI} A_i` by :math:`\Proj\, œÉ \, a = a ‚àò œÉ`.

The following is closer to what we want, but still imperfect:

.. math:: \Proj: (J ‚Üí I) ‚Üí ‚àè_{i‚ààI} A_{i} ‚Üí ‚àè_{j‚ààJ} A_{g(j)}.
   :label: 9

This says that :math:`\Proj` takes a function :math:`œÉ: J ‚Üí I` and a function :math:`a ‚àà ‚àè_{i‚ààI} A_i` and returns the function :math:`a ‚àò œÉ ‚àà ‚àè_{j‚ààJ} A_{œÉ \, j}`.

Here again we see that the arrow notation is not expressive enough because :math:`‚àè_{j‚ààJ} A_{œÉ \, j}` depends on :math:`œÉ`, but there is no :math:`œÉ` symbol available from earlier in :eq:`9`.

The solution is again to denote the function type as a product. Product types are very expresive and enable us to concisely specify such dependent function types. Before demonstrating this, we make one more notational adjustment. Instead of denoting set membership by :math:`a ‚àà A`, we adopt the type-theoretic notation :math:`a:A`, which expresses the fact that :math:`a` *has type* :math:`A`. Thus, the full :term:`dependent type` specification of the projection operator is

.. math:: \Proj: ‚àè_{œÉ:J‚ÜíI} \left( ‚àè_{(i:I)} A_{i} ‚Üí  ‚àè_{(j:J)} A_{œÉ\, j} \right).

This is a special case of the more general types that we define in later chapters, after reviewing some concepts of category theory in :numref:`Chapter %s <postmodern-algebra>` that are essential for this purpose.

.. proof:example:: Projection terminology

   Let us explain why the term "projection" is reserved for the case when :math:`œÉ` is one-to-one.
   
   Suppose :math:`k=4`, :math:`n=3`, and consider the 4-tuple :math:`œÉ = (1, 0, 1, 1)`.
   
   Then :math:`œÉ` is the function :math:`œÉ : \{0,1,2,3\} ‚Üí \{0,1,2\}` given by
   
   .. math:: œÉ\, 0 = 1, \; œÉ\, 1 = 0`, \; œÉ\, 2 = 1, \; œÉ\, 3 = 1,
   
   and so :math:`a ‚Ü¶ a ‚àò œÉ` is the function that takes :math:`(a\, 0, a\, 1, a\, 2) ‚àà A_0 √ó A_1 √ó A_2` to :math:`(a\, 1, a\, 0, a\, 1, a\, 1) ‚àà A_1 √ó A_0 √ó A_1 √ó A_1`.

Let :math:`A = ‚àè_{0‚â§ i<n} A_i`, let :math:`œÉ: k ‚Üí n` be one-to-one, and define the projection :math:`\Proj\, œÉ` as in¬†:eq:`projection` above. Then the :term:`kernel` of :math:`\Proj\, œÉ`, which we denote by :math:`\mathbf{0} œÉ`, is denoted and defined by

.. math:: \mathbf{0} œÉ &= \ker \Proj\, œÉ = \{(a,a') ‚àà A^2 | \Proj\, œÉ a = \Proj\, œÉ a'\}\\
                       &= \{ (a,a') ‚àà A^2 | a ‚àò œÉ = a' ‚àò g \} = \{ (a,a') ‚àà A^2 | ‚àÄ j ‚àà \im œÉ, \ a\, j = a'\, j \}.
   :label: kernel

It is obvious that :math:`\mathbf{0} œÉ` is an equivalence relation on the set :math:`A`.

More generally, if :math:`Œ∏` is an equivalence relation on the set :math:`‚àè_{0‚â§ j<k} A_{œÉ\,j}`---that is, :math:`Œ∏ ‚äÜ (‚àè_{0‚â§ j<k} A_{œÉ\, j})^2` and :math:`Œ∏` is reflexive, symmetric, and transitive---then we define the equivalence relation :math:`Œ∏ œÉ` on the set :math:`A = ‚àè_{0‚â§ i<n} A_i` as follows:

.. math:: Œ∏ œÉ = \{(a, a') ‚àà A^2 ‚à£ (a ‚àò œÉ) \mathrel{\theta} (a' ‚àò œÉ)\}.
   :label: 17

In other words, :math:`Œ∏ œÉ` consists of all pairs in :math:`A^2` that land in :math:`Œ∏` when projected onto the coordinates in :math:`\im œÉ`.

#. Recall that :math:`\Proj\, œÉ : A ‚Üí ‚àè_{j<k} A_{œÉ\, j}` is the function that maps :math:`a` to :math:`a ‚àò œÉ`.

   Now, suppose we have a tuple :math:`(a\, 0, a\, 1, \dots, a\, (p-1))‚àà A^p`, and suppose we intend to apply :math:`\Proj\, œÉ` to each component, :math:`a \, j`.

   To do so, we need to lift :math:`\Proj\, œÉ` from type :math:`A ‚Üí ‚àè_{j<k} A_{œÉ\, j}` to type :math:`A^p ‚Üí (‚àè_{j<k} A_{œÉ\, j})^p`, which is accomplished using a functor that often goes by the name :math:`map`.

   For instance, if :math:`(a, a') ‚àà A^2`, then :math:`map \,(\Proj\, œÉ)\, (a, a') = (\Proj\, œÉ \, a, \Proj\, œÉ \, a')`.

   Therefore,

   .. math:: Œ∏ œÉ =\{(a, a') ‚àà A^2 ‚à£ map \, (\Proj\, œÉ)\, (a, a') ‚àà Œ∏ \},

   whence, :math:`Œ∏_g = map \, (\Proj\, œÉ)^{-1} \, Œ∏`.

#. If :math:`f: X ‚Üí A` and :math:`g: X ‚Üí B` are functions defined  on the same domain :math:`X`, then :math:`(f,g): X ‚Üí A √ó B` is the unique function that composes with the first projection to give :math:`f` and composes with the second projection to give :math:`g`. For example, in the last remark there appears the expression :math:`(\Proj\, œÉ\, a, \Proj\, œÉ \, a') = (a ‚àò œÉ, a' ‚àò œÉ)`, which has type :math:`( ‚àè_{j<k} A_{œÉ\, j} )^2`. [5]_

#. If the domain of :math:`œÉ` is a singleton, :math:`k = \{0\}`, then of course :math:`œÉ` is just a one-element list, say, :math:`œÉ = (j)`. In such cases, we write :math:`\Proj\, j` instead of :math:`\Proj\, {(j)}`.  Similarly, we write and :math:`\mathbf{0}\, j` and :math:`Œ∏\, j` instead of :math:`\mathbf{0}\, {(j)}` and :math:`Œ∏\, {(j)}`. Thus, :math:`\Proj\, j \, a = a\, j`, and :math:`\mathbf{0} \, j = \{(a, a') ‚àà A^2 ‚à£ a \, j = a' \, j\}`, and, if :math:`Œ∏ ‚àà \Con ùî∏_j`, then :math:`Œ∏ \, j = \{(a, a') ‚àà A^2 ‚à£ a \, j \mathrel{\theta} a'\, j\}`.

Here are some obvious consequences of the foregoing notation and definitions that are worth noting.

.. math::

   ‚ãÅ_{0‚â§j<n}\mathbf{0}j = A^2, \quad \mathbf{0} œÉ = ‚ãÄ_{j ‚àà œÉ} \mathbf{0} j, \quad \mathbf{0}n = ‚ãÄ_{0‚â§j<n}\mathbf{0} j = 0_A, \quad
   Œ∏œÉ = ‚ãÄ_{0‚â§j<k} Œ∏ \, œÉ\, j,

where :math:`0_{A}` denotes the least equivalence relation on :math:`A`, that is, :math:`0_{A}:= \{(a, a') ‚àà A^2 ‚à£ a = a'\}`.

.. As we alluded to above, :math:`Œ∑_œÉ` is shorthand for :math:`(0_A)_œÉ`.

.. index:: projection kernel

.. _kernels-of-projections:

Kernels of projections
~~~~~~~~~~~~~~~~~~~~~~~

Let :math:`ùî∏ = ‚àè_{(i:I)} ùî∏_i` be a product of algebras with the same :term:`signature`, and suppose :math:`g: J ‚Üí I` is a one-to-one function, where :math:`‚àÖ ‚â† J ‚äÜ I ‚äÜ ‚Ñï`.

Define the **kernel of the projection of** :math:`ùî∏` **onto** :math:`‚àè_{(j:J)} A_{g(j)}` as follows:

.. math:: Œîg = \{(a,a'): ùî∏^2 | a ‚àò g = a' ‚àò g \} = \ker (\Proj\, g)

This is a congruence of :math:`ùî∏`. More generally, if :math:`Œ∏` is a congruence of :math:`‚àè_{(j:J)} A_{g(j)}`, define :math:`Œ∏g: \Con ùî∏` as follows:

.. math:: Œ∏g = (\Proj\, g)^{-1}(Œ∏) =  \{ (a, a') : ùî∏^2 | (a ‚àò g) \mathrel{\theta} (a' ‚àò g) \}.

This indicates the origin of the notation :math:`Œîg`, where :math:`Œî` denotes the trivial (identity) relation on :math:`‚àè_{(j:J)} A_{g(j)}`. If :math:`J = \{0\}` and :math:`g:I` is just a constant, say, :math:`g(0) = k`, then we write :math:`Œ∏ k` instead of :math:`Œ∏ \{k\}`, so

.. math:: Œ∏ k = \{(a, a') \in ùî∏^2 : a\,k \mathrel{\theta} a'\,k\}.

(Here, :math:`\theta` must be in :math:`\Con ùî∏_k`.)

The symbols ‚Ñï, œâ, and ``nat`` are used interchangeably; they all denote the set of natural numbers.

Fix :math:`m ‚àà ‚Ñï`. If :math:`a = (a_0, a_1, \dots, a_{m-1})` is an :math:`m`-tuple of elements from :math:`A`, then (keeping in mind that :math:`m` is the set :math:`\{0, 1, \dots, m-1\}`) it is useful to understand that this tuple is a function :math:`a: m ‚Üí A`, where :math:`a\,i = a_i`, for each :math:`i<m`. If :math:`h: A ‚Üí A`, then :math:`h ‚àò a: m ‚Üí A` is the tuple :math:`(h\, a_0, h\, a_1, \dots, h\, a_{m-1}) ‚àà A^m`, whose :math:`i`-th coordinate is :math:`(h ‚àò a)\, i = h(a\, i) = h(a_i) ‚àà A`.

On the other hand, if :math:`g: A^m ‚Üí A`---equivalently, :math:`g: (m ‚Üí A) ‚Üí A`---then :math:`g a` is the element :math:`g(a_0, a_1, \dots, a_{m-1}) ‚àà A`.

If :math:`f: (œÅ f ‚Üí B) ‚Üí B` is a :math:`œÅ f`-ary operation on :math:`B`, if :math:`a: œÅ f ‚Üí A` is a :math:`œÅ f`-tuple on :math:`A`, and if :math:`h: A ‚Üí B`, then
:math:`h ‚àò a: œÅ f ‚Üí B`, so :math:`f (h ‚àò a): B`.


--------------------------

.. _basic-facts:

Basic facts
------------

.. Some of them involve homomorphisms, or terms, or clones.  

Throughout this section,

+ :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©, \ ùîπ = ‚ü®B, F^ùîπ‚ü©, \ ‚ÑÇ = ‚ü®C, F^‚ÑÇ‚ü©\ ` are algebras in the same signature :math:`œÉ = (F, œÅ)`, and

+ :math:`g, h : \hom(ùî∏, ùîπ)` are homomorphisms from ùî∏ to ùîπ;

.. index:: ! equalizer

The **equalizer** of :math:`g` and :math:`h` is the set

.. math:: ùñ§(g,h) = \{a: A ‚à£ g\, a = h\, a\}.

Here is a small collection of basic observations that we will need later. When we refer back to these, we will call them :numref:`Obs %s <obs-one>`, etc.

.. _obs-one:

.. proof:observation::

   :math:`ùñ§(g,h)` is a subuniverse of ùî∏.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.

      Fix arbitrary :math:`f ‚àà F` and :math:`a : œÅf ‚Üí ùñ§(g,h)`.

      We show that :math:`g (f^ùî∏ \, a) = h (f^ùî∏ \, a)`, as this will show that :math:`ùñ§(g, h)` is closed under the operation :math:`f^ùî∏` of :math:`ùî∏`.

      For all :math:`i<œÅ f` we have :math:`a \, i ‚àà ùñ§(g,h)`, so :math:`g\, a \, i= h\, a\, i`.  Therefore (by function extensionality) :math:`g ‚àò a = h ‚àò a` and so, by definition of homomorphism,

      .. math:: g  (f^ùî∏\,a) = f^ùîπ (g ‚àò a) = f^ùîπ (h ‚àò a) = h (f^ùî∏\, a).

      ‚òê

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-one>` is described in :numref:`equalizer-as-subuniverse`,  and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.

.. _obs-two:

.. proof:observation::

   If the set :math:`X ‚äÜ A` generates ùî∏ and :math:`g|_X = h|_X`, then :math:`g = h`.

   .. container:: toggle
    
      .. container:: header
  
         *Proof*.

      Suppose the subset :math:`X ‚äÜ A` generates :math:`‚ü®A, F^ùî∏‚ü©` and suppose :math:`g|_X = h|_X`.
 
      Fix an arbitrary :math:`a: A`. We show :math:`g\, a = h\, a`.
 
      Since :math:`X` generates ùî∏, there exists a term :math:`t` and a tuple :math:`x: œÅt ‚Üí X` of generators such that :math:`a = t^ùî∏\, x`.
 
      Therefore, since :math:`g|_X = h|_X`, we have
    
      .. math:: g ‚àò x = (g\, x_0, \dots, g\, x_{œÅ t}) = (h\, x_0, \dots, h\, x_{œÅ t}) = h ‚àò x,

      so

      .. math:: g\, a = g(t^ùî∏ \, x) = t^ùîπ (g ‚àò x) = t^ùîπ (h ‚àò x) = h(t^ùî∏ \,x) = h\, a.

      ‚òê

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-two>` is described in :numref:`homomorphisms-that-agree-on-a-generating-set`,  and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.

.. _obs-three:

.. proof:observation::

   If :math:`A, B` are finite and :math:`X` generates ùî∏, then :math:`|\hom(ùî∏, ùîπ)| ‚â§ |B|^{|X|}`.

   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      By :ref:`Obs 2 <obs-two>`, a homomorphism is uniquely determined by its restriction to a generating set.

      If :math:`X` generates ùî∏, then since there are exactly :math:`|B|^{|X|}` functions from :math:`X` to :math:`B` we have :math:`|\hom(ùî∏, ùîπ)| ‚â§ |B|^{|X|}`. ‚òê
    
.. _obs-four:

.. proof:observation::

   If :math:`g ‚àà \epi (ùî∏, ùîπ)`, :math:`h ‚àà \hom (ùî∏, ‚ÑÇ)`, and :math:`\ker g ‚äÜ \ker h`, then

   .. math:: ‚àÉ k ‚àà \hom(ùîπ, ‚ÑÇ), \ h = k ‚àò g.
    
   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      We define :math:`k ‚àà \hom(ùîπ, ‚ÑÇ)` as follows:

      Fix :math:`b ‚àà B`.

      Since :math:`g` is surjective, the set :math:`g^{-1}\{b\} ‚äÜ A` is nonempty, and since :math:`\ker g ‚äÜ \ker h`, it is clear that every element of :math:`g^{-1}\{b\}` is mapped by :math:`h` to a single element of :math:`C`.

      Label this element :math:`c_b`. That is, :math:`h(a) = c_b`, for all :math:`a ‚àà g^{-1}\{b\}`.
   
      For each such :math:`b`, and its associated :math:`c_b`, define :math:`k(b) = c_b`.
   
      The observant reader may have noticed a slight-of-hand in the foregoing "construction" of the function :math:`k`. While it's true that for each :math:`b ‚àà B` there exists a :math:`c_b` such that :math:`h(a) = c_b` for all :math:`a ‚àà g^{-1}\{b\}`, it's also true that we have no means of producing such :math:`c_b` constructively.
      
      One could argue that each :math:`c_b` is easily computed as :math:`c_b = h(a)` for some (every) :math:`a ‚àà g^{-1}\{b\}`. But this requires producing a particular :math:`a ‚àà g^{-1}\{b\}` to use as "input" to the function :math:`h`. How do we select such an element from the (nonempty) set :math:`g^{-1}\{b\}`?
      
      We must appeal to the Axiom of :term:`Choice` at this juncture and concede that the function :math:`k` will not be constructively defined. (We have more to say about this in :numref:`Sec %s <basic-facts-in-lean>` when we implement :numref:`Obs %s <obs-four>` in Lean.)  Nonetheless, we forge ahead (nonconstructively) and define :math:`k` as described above, using the Axiom of :term:`Choice` to compute a :math:`c_b` for each :math:`b ‚àà B`.
   
      It is then easy to see that :math:`k ‚àò g = h`.  Indeed, for each :math:`a ‚àà A`, we have :math:`a ‚àà g^{-1}\{g(a)\}`, so :math:`k(g(a)) = h(a)` by definition.

      Finally, to prove that :math:`k` is a homomorphism, fix an operation symbol :math:`f ‚àà F` and a tuple :math:`b: œÅ f ‚Üí B`; we will show that
      
      .. math:: f^‚ÑÇ (k ‚àò b) = k (f^ùîπ(b)).
         :label: hom1

      Let :math:`a: œÅ f ‚Üí A` be such that :math:`g ‚àò a = b`.  Then the left hand side of :eq:`hom1` is :math:`f^‚ÑÇ (k ‚àò g ‚àò a) = f^‚ÑÇ (h ‚àò a)`, which is equal to :math:`h (f^ùî∏ (a))` since :math:`h` is a homomorphism.
   
      Therefore,
   
      .. math:: 
      
         f^‚ÑÇ (k ‚àò b) &= f^‚ÑÇ (k ‚àò g ‚àò a) = f^‚ÑÇ (h ‚àò a)\\ 
                 & = h (f^ùî∏ (a)) = (k ‚àò g)(f^ùî∏ (a))\\
                 & = k (f^ùîπ (g ‚àò a)) = k (f^ùîπ (b)),

      as desired, where the penultimate equality holds by virtue of the fact that :math:`g` is a homomorphism. ‚òê

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-four>` is described in :numref:`factoring-homomorphisms`, and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.


.. Formalization
.. -------------

.. Our formal implementation (in `Lean`_) of these objects is described in :numref:`Sections %s <basic-facts-in-lean>`, :numref:`%s <terms-in-lean>`, and :numref:`%s <clones-in-lean>`.

------------------------

.. rubric:: Footnotes

.. [1]
   For a brief and gentle introduction to type theory see the `section on axiomatic foundations <https://leanprover.github.io/logic_and_proof/axiomatic_foundations.html?highlight=type#type-theory>`_ in `Logic and Proof <https://leanprover.github.io/logic_and_proof/>`_.  Alternatively, viewing :math:`m  : \mathbb N` as roughly equivalent to :math:`n\in \mathbb N` is not totally unreasonable at this point.

.. [2]
   By "functional" we mean a function whose domain is a collection of functions.

.. [3]
   The term :math:`œÉ`-**algebra** has a special meaning, different from ours, in other areas of mathematics such as real analysis, probability, and measure theory.

.. [4]
   A list of many others may be found at http://www.math.chapman.edu/~jipsen/structures/doku.php/index.html.

.. [5]
   In retrospect, a more appropriate name for :math:`\mathbf{0} œÉ` might be :math:`Œî_œÉ`, or even :math:`=_œÉ`, but this may lead to conflicts with more standard notational conventions.


.. include:: hyperlink_references.rst
