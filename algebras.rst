.. File: algebras.rst
.. Author: William DeMeo <williamdemeo@gmail.com>
.. Date: 17 May 2019
.. Updated: 5 Nov 2019
.. Copyright (c) 2019 William DeMeo (see the LICENSE file)

.. include:: _static/math_macros.rst

.. role:: cat
.. role:: code

.. _algebras:

========
Algebras
========

In this chapter we use the informal language of universal algebra to present foundational definitions and theorems about :term:`subalgebras <subalgebra>`, :term:`terms <term>`, and :term:`clones <clone>`.  In :numref:`Chapters %s <algebras-in-lean>` and :numref:`%s <clones-and-terms-in-lean>` we will show how the definitions and results presented in this section can be formalized (or "implemented") in type theory using Lean.

The idea is to demonstrate the power and utility of implementing our mathematical are of expertise in a formal language that supports dependent and inductive types, which are essential for expressing and working with infinite objects in a :term:`constructive` and :term:`computable` way, and for proving properties of these objects.

------------------------------

.. _tuple-functors:

Tuple functors
--------------

This (and the next) section assumes the reader knows what a functor is (see, e.g., categorytheory.gitlab.io_, for the definition). However, nothing beyond the basic definitions of category theory is required, so readers with no prior exposure to that subject should be able to comprehend all of the concepts we introduce here.

For :math:`m: ‚Ñï`, the :math:`\mathrm{mtuple}` functor on :cat:`Set` is denoted and defined as follows by its action on

+ **objects**: if :math:`A` is a set, then :math:`\mathrm{mtuple}(A) := \{(a_0, \dots, a_{m-1}) ‚à£ a_i : A\}`;

+ **arrows**: if :math:`f: A ‚Üí B` is a function from the set :math:`A` to the set :math:`B`, then :math:`\mathrm{mtuple} f: \mathrm{mtuple}(A) ‚Üí \mathrm{mtuple}(B)` is defined for each :math:`(a_0, \dots, a_{m-1})` of type :math:`\mathrm{mtuple}(A)` as follows:

.. math:: \mathrm{mtuple} f (a_0, \dots, a_{m-1}) = (f a_0, \dots, f a_{m-1}),

which inhabits the type :math:`\mathrm{mtuple}(A)`.

We use the standard set-theoretic convention that identifies the natural number :math:`0‚â§ m < œâ` with the set :math:`\{0,1,\dots, m-1\}`.

Then :math:`a:=(a_0, \dots, a_{m-1})` has type :math:`\mathrm{mtuple}(A)` iff it can be identified with a function of type :math:`m ‚Üí A`; that is, iff the mtuple :math:`(a_0, \dots, a_{m-1})` is equivalent to the function :math:`a: m ‚Üí A` defined for each :math:`0 ‚â§ i < n` by :math:`a(i) = a_i`.

Thus, we have the following equivalence of types: :math:`\mathrm{mtuple}(A) ‚âÖ m \to A`.

Let :math:`m = (m_0, \dots, m_{n-1}): \mathrm{ntuple}(‚Ñï)`.

The :math:`\mathbf{mtuple}` functor is defined as follows by its action on

+ **objects**: if :math:`A` is a set, then

  .. math:: \mathbf{mtuple}(A) = \{((a_{00}, \dots, a_{0(m_1-1)}), \dots, (a_{(n-1)0}, \dots, a_{(n-1)(m_n-1)})) ‚à£ a_{ij} : A\}.

  (We may write :math:`ùêö_i` in place of :math:`(a_{i0}, \dots, a_{i(k-1)})`, if :math:`k` is clear from context.)

+ **arrows**: if :math:`f` is a function from :math:`A` to :math:`B`, then :math:`\mathbf{mtuple} f :  \mathbf{mtuple}(A) ‚Üí  \mathbf{mtuple}(B)` is defined for each :math:`(ùêö_0, \dots, ùêö_{n-1})` in :math:`\mathbf{mtuple}(A)` as follows:

  .. math:: \mathbf{mtuple} f (ùêö_1, \dots, ùêö_n) &= (\mathrm{m_1tuple}f ùêö_1, \dots, \mathrm{m_ntuple} f ùêö_n) \\
                                            &= ((f a_{11}, \dots, f a_{1m_1}), \dots, (f a_{n1}, \dots, f a_{nm_n})).

Notice that :math:`ùêö_i` has type :math:`\mathrm{m_ituple}(A)` iff it can be represented as a function of type :math:`m_i ‚Üí A`; that is, iff the tuple :math:`(a_{i0}, \dots, a_{i(m_i-1)})` is (the graph of) the function defined by :math:`ùêö_i(j) = a_{ij}` for each :math:`0 ‚â§ j < m_i`.

Thus, if :math:`m = (m_0, \dots, m_{n-1}): \mathrm{ntuple}(‚Ñï)`, then :math:`\mathbf{mtuple}(A)` is the :term:`dependent function type`,

.. math:: ‚àè_{(i:n)} (m_i ‚Üí A).

-------------------------------------

.. index:: fork, dependent fork, eval

.. _general-composition:

General composition
-------------------

In this section we give a somewhat unconventional presentation of general composition of functions and operations. We feel our presentation is more elegant and concise than those typically found in books on universal algebra.

Of course, to each, his own, particularly when it comes to notational sensibilities.  But aesthetics aside, our main reason for what may seem like a belabored discussion of such an elementary topic is that our definition---via composition of the standard "fork" and "eval" operators familiar to most (functional) programmers---leads to a more natural and efficient implementation of general composition in any functional programming language that supports dependent types.

.. index:: ! fork, ! eval

.. _fork:

fork
~~~~

Recall the definition of :term:`product`.  Given types :math:`A`, :math:`B`, :math:`C`, and functions :math:`f: A ‚Üí B` and :math:`g: A ‚Üí C`, there exists a unique function :math:`(f, g): A ‚Üí B √ó C` such that :math:`œÄ_1 (f, g) = f` and :math:`œÄ_2 (f, g) = g`.

Evidently, this (the so called :term:`universal mapping <universal mapping property>`) is defined for each :math:`a: A` by :math:`(f, g)\, a = (f\,a, g\,a)`.

Denote and define the (nondependent) **fork operator** (on :math:`A`, :math:`B`, and :math:`C`) by

.. math:: \fork: (A ‚Üí B) ‚Üí (A ‚Üí C) ‚Üí A ‚Üí (B √ó C),

and, for each :math:`f: A ‚Üí B` and :math:`g: A ‚Üí C`, 

.. math:: \fork \, f\, g: A ‚Üí (B √ó C)

is the function that takes each :math:`a:A` to the pair,
  
.. math:: (\fork \, f\, g)\, a = (f\,a, g\,a): B √ó C.

(Of course, we could have taken the domain of :math:`\fork` to be :math:`(A ‚Üí B) √ó (A ‚Üí C)`, but we prefer the "curried" version defined above for a number of reasons; e.g., it's easier to implement partial application of a curried function.)

The definition of the universal mapping for the product naturally generalizes to arbitrary collections of functions with common domain.  Therefore, it's no surprise that the definition of :math:`\fork` is just a special case of a more general definition that operates on :term:`dependent function types <dependent function type>`, as we now describe.

If :math:`n<œâ` and if :math:`f_i: A ‚Üí B_i` for each :math:`0‚â§ i < n`, then there exists a unique function of type :math:`A ‚Üí (B_0 √ó \cdots √ó B_{n-1})` whose :math:`k`-th projection is :math:`f_k`.  Precisely, this function is denoted by :math:`(f_0, \dots, f_{n-1})` and defined for each :math:`a:A` by

.. math:: (f_0, \dots, f_{n-1})\, a = (f_0\, a, \dots, f_{n-1}\, a).

More generally still, if :math:`I` is a type and :math:`f: ‚àè_{(i:I)} (A ‚Üí B_i)` denotes an :math:`I`-tuple of functions, then we define :math:`\fork f : A ‚Üí ‚àè_{(i:I)}B_i` to be the function that takes :math:`a:A` to the :math:`I`-tuple :math:`\fork f \, a`, where :math:`\fork f \, a \, i = f_i\, a`.

.. .. raw:: latex
..    \begin{prooftree}
..    \AXM{\exists x A(x)}
..    \AXM{}
..    \RLM{1}
..    \UIM{A(y)}
..    \noLine
..    \UIM{\vdots}
..    \noLine
..    \UIM{B}
..    \RLM{1}
..    \BIM{B}
..    \end{prooftree}

.. .. include:: latex_images/first_order_logic.8.tex

To generalize in another direction, suppose that :math:`A` is a type and :math:`B: A ‚Üí \Type` and :math:`C: A ‚Üí \Type` are such that, for each :math:`a:A`, we have types :math:`B a` and :math:`C a`.

Denote and define the (dependent) **fork operator** by

.. math:: \fork: ‚àè_{(x:A)} B x ‚Üí ‚àè_{(y:A)} C y ‚Üí ‚àè_{(a:A)} (B a √ó C a),

and, for each :math:`f: ‚àè_{(x:A)} B x` and :math:`g: ‚àè_{(y:A)} C y`,

.. math:: \fork \, f\, g: ‚àè_{(a:A)} B a √ó C a

is the function that maps each :math:`a:A` to the pair

.. math:: (\fork \, f\, g)\, a = (f\,a, g\,a): B a √ó C a.

(Incidentally, since we opted for a "curried" version of :math:`\fork`, we can partially apply it, obtaining the typing judgment,

.. math:: \fork \, f: ‚àè_{(a:A)} C a ‚Üí ‚àè_{(a:A)} (B a √ó C a).)

The last two generalizations above may be viewed as special cases of our final definition of :math:`\fork`.

Suppose :math:`I` and :math:`A` are types, and let :math:`B: I ‚Üí A ‚Üí \Type` be a **type constructor**; that is, for each :math:`i:I` and :math:`a:A` we obtain a new type by applying :math:`B`, namely, :math:`Bia: \Type`.

Next suppose that for each :math:`i:I` we have a dependent function :math:`f_i: ‚àè_{(a:A)} B i a` (so the codomain types of :math:`f_i` depend on both :math:`i` and :math:`a`. Let :math:`f: ‚àè_{(i:I)} ‚àè_{(a:A)}B i a` be the tuple of these functions; that is, for each :math:`i:I` we have :math:`f\, i = f_i`.

Then, :math:`\fork f` is the function that maps each :math:`a:A` to the function :math:`\fork f \, a` of type :math:`‚àè_{(i:I)} Bia`.  Thus, for each :math:`a:A` and :math:`i:I`, we have :math:`(\fork f \, a)\, i = f_i\, a`.

To summarize, 

.. math:: \fork: ‚àè_{(i:I)} ‚àè_{(a:A)}B i a ‚Üí‚àè_{(a:A)} ‚àè_{(i:I)} B i a;

so if we have an :math:`I`-tuple :math:`f: ‚àè_{(i:I)} ‚àè_{(a:A)}B i a` of dependent functions, then

.. math:: \fork f : ‚àè_{(a:A)} ‚àè_{(i:I)} B i a. 

.. _eval:

eval
~~~~

Next, we define a :term:`function application <eval>` operation on types :math:`A` and :math:`B`.

Denote and define the **eval operator** by

.. math:: \eval: ((A ‚Üí B) √ó A) ‚Üí B

and for each :math:`f: A ‚Üí B`, :math:`\eval \, f` is the function that maps each :math:`a: A` to :math:`f\, a:B`. 

Notice that :math:`\eval` is polymorphic as it depends on the types :math:`A` and :math:`B`. Indeed,

.. math:: \eval: ‚àè_{(A: \mathsf{Type})} ‚àè_{(B: \mathsf{Type})} ((A ‚Üí B) √ó A) ‚Üí B,

so it would seem that when we introduced the :math:`\eval` operation above, we should have said,

  "...the eval operator *on* :math:`A` *and* :math:`B` is denoted by :math:`\eval \, A \, B: ((A ‚Üí B) √ó A) ‚Üí B`..."
  
However, our implementation of :math:`\eval` will use :term:`implicit arguments <implicit arguments>`, so that :math:`A` and :math:`B` need not be mentioned explicitly.

.. proof:example::

   As an example of function application with dependent types, let :math:`f: ‚àè_{a:A}(Ca ‚Üí D)` and :math:`g: ‚àè_{(a:A)} Ca`. Then for each :math:`a:A` we have :math:`f\,a : Ca ‚Üí D` and :math:`g\,a: Ca`. Thus, :math:`\eval\, (f\,a, g\,a) = (f\,a)(g\,a): D`.

   We can also specify the types explicitly if desired, as in,

   .. math:: (@ \eval\ Ca \ D) (f\,a, g\,a) = (f\,a)(g\, a).

   As shown here, the :math:`@` symbol indicates that we will explicitly specify all arguments. (Lean_ also uses the :math:`@` symbol for this purpose.)

.. proof:example::

   Let us briefly mention a typical use case on which our definition of general composition in :numref:`general-composition-of-operations` will depend. (For more details, see the next section.) In the foregoing descriptions of :math:`\fork` and :math:`\eval`, make the following substitutions:

     * :math:`n = \{0,1,\dots, n-1\}` for :math:`A`, 
  
     * :math:`A` for :math:`D`, and
  
     * :math:`k_i ‚Üí A` for :math:`Ca`, for each :math:`i:n`.

   Then :math:`g: ‚àè_{(i:n)} ((k_i ‚Üí A) ‚Üí A)` is an :math:`n`-tuple of operations on :math:`A` and :math:`a: ‚àè_{(i:n)}(k_i ‚Üí A)` is an :math:`n`-tuple of tuples of elements of type :math:`A`.  Thus,

   .. math:: (\fork \, g \, a)\, i = (g\,i, a\,i): ((k_i ‚Üí A) ‚Üí A) √ó (k_i ‚Üí A),

   and :math:`\eval \, (\fork \, g\, a) \, i = \eval(g\,i, a\,i) = (g\,i)(a\,i): A`.

.. _general-composition-of-operations:

General composition of operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In universal algebra we mainly deal with *finitary* operations in :cat:`Set` (the category of sets).

By an :math:`n`-**ary operation** on the set :math:`A` we mean a function :math:`f: A^n ‚Üí A`, that takes an :math:`n`-tuple :math:`(a_0, \dots, a_{n-1})` of elements of type :math:`A` and returns an element :math:`f(a_0,\dots, a_{n-1})` of type :math:`A`.

If we identify the natural number :math:`n: ‚Ñï` with the set :math:`\{0,1,\dots, n-1\}`, and the :math:`\mathrm{ntuple}` type with function type :math:`n ‚Üí  A`, then the type of :math:`n`-ary operations on :math:`A` is :math:`(n ‚Üí A) ‚Üí A`. Evaluating such an operation :math:`f:(n ‚Üí A) ‚Üí A` at the tuple :math:`a: n ‚Üí A` is simply function application, expressed by the usual rule (sometimes called "implication elimination" or "modus ponens").

.. .. raw:: latex

..   \begin{prooftree}
..   \AxiomC{$f : (n ‚Üí A) ‚Üí A$}
..   \AxiomC{$a : n ‚Üí A$}
..   \RightLabel{$_{(‚Üí \mathrm{E})}$}
..   \BinaryInfC{$f a : A$}
..   \end{prooftree}

Letting :math:`a_i` denote the value of :math:`a` at :math:`i`, and identifying :math:`a` with it's graph (the tuple :math:`(a_0, \dots, a_{n-1})`), we have :math:`f\,a = f(a_0, \dots, a_{n-1})`.

Denote and define the collection of all finitary operations on :math:`A` by

.. math:: \mathrm{Op}(A) = A^{A^n} \cong ‚ãÉ_{n<œâ} (A^n ‚Üí A) \cong ‚ãÉ_{n<œâ} ((n ‚Üí A) ‚Üí A).

We now develop a general formulation of composition of operations on sets that is more elegant and computationally practical than the standard formulation, but we first briefly review the standard description of operation composition.

Let :math:`f : (n ‚Üí A) ‚Üí A` be an :math:`n`-ary operation and for each :math:`0‚â§ i < n` let :math:`g_i : (k_i ‚Üí A) ‚Üí A` a :math:`k_i`-ary operation on :math:`A`. The **composition of** :math:`f` **with** :math:`(g_0, \dots, g_{n-1})`, denoted :math:`f ‚àò (g_0, \dots, g_{n-1})`, is usually expressed as follows: for each

.. math:: ((a_{00}, \dots, a_{0(k_0-1)}), \dots, (a_{(n-1)0}, \dots, a_{(n-1)(k_{n-1}-1)})): A^{k_0} √ó \cdots √ó A^{k_{n-1}},
   :label: args

.. math:: f & ‚àò (g_0, \dots, g_{n-1})((a_{00}, \dots, a_{0(k_0-1)}), \dots, (a_{(n-1)0}, \dots, a_{(n-1)(k_{n-1}-1)}))\\
                &= f(g_0(a_{00}, \dots, a_{0(k_0-1)}), \dots, g_{n-1}(a_{(n-1)0}, \dots, a_{(n-1)(k_{n-1}-1)})).

This notation is ugly and tedious and lends itself poorly to computation. Let us try to clean it up.

Consider the :math:`n`-tuple :math:`(g_0, \dots, g_{n-1})` of operations from :math:`\mathrm{Op}(A)`.

Let :math:`g: ‚àè_{(i:n)} ((k_i ‚Üí A) ‚Üí A)` be the function with domain the set :math:`n = \{0,1,\dots, n-1\}`, codomain :math:`\mathrm{Op}(A)`, and defined for each :math:`0 ‚â§ i < n` by :math:`g\,i = g_i`.

Let :math:`a: ‚àè_{(i:n)} (k_i ‚Üí A)` be such that for each :math:`0‚â§ i < n` we have a function :math:`a\,i: k_i ‚Üí A` which is defined for each :math:`0‚â§ j < k_i` by :math:`a\,i\,j = a_{ij}`.
  
Then the :math:`n`-tuple of arguments in expression :eq:`args` above can be identified with the :math:`n`-tuple :math:`a = (a\,0, \dots, a\,(n-1))` of functions.

Recalling the definitions of :math:`\fork` (:numref:`fork`) and :math:`\eval` (:numref:`eval`), it is not hard to see how to perform general composition using these definitions and dependent types.

If :math:`g: ‚àè_{(i:n)} ((k_i ‚Üí A) ‚Üí A)` and :math:`a: ‚àè_{(i:n)}(k_i ‚Üí A)`, then 

.. math:: \fork \, g\, a: ‚àè_{(i:n)}\bigl((k_i ‚Üí A) ‚Üí A\bigr) \times (k_i ‚Üí A)

is the function that maps each :math:`0‚â§ i < n` to the pair

.. math:: (\fork \, g\, a)\, i = (g\,i, a\,i): \bigl((k_i ‚Üí A) ‚Üí A\bigr) √ó (k_i ‚Üí A).

Applying :math:`g\,i` to :math:`a\,i` with the :math:`\eval` function, we have

.. math:: \eval \, (\fork \, g\, a)\, i = \eval \, (g\,i, a\,i) = (g\,i)(a\,i).

Observe that the codomain :math:`A` of the function :math:`\eval\, (\fork \, g\, a)` does not depend on :math:`i`, so the type :math:`‚àè_{(i:n)} A` simplifies to :math:`n ‚Üí A` in this case, resulting in the typing judgment, :math:`\eval \, (\fork \, g\, a): n ‚Üí A`.

.. On the other hand,

.. .. math:: \eval\,\fork \, g: ‚àè_{(i:n)}  (k_i ‚Üí A) ‚Üí (n ‚Üí A).

Thus, if

  :math:`f: (n ‚Üí A) ‚Üí A` (an :math:`n`-ary operation) and 
  
  :math:`g: ‚àè_{(i:n)} ((k_i ‚Üí A) ‚Üí A)` (an :math:`n`-tuple of operations), then we 
  
  denote and define the **composition of** :math:`f` **with** :math:`g` as follows:

.. math:: f \comp g := f \, \eval \, \fork \, g: ‚àè_{(i:n)}((k_i ‚Üí A) ‚Üí A).

Indeed, if :math:`a: ‚àè_{(i:n)}(k_i ‚Üí A)`, then :math:`\eval \, \fork \, g \, a` has type :math:`n ‚Üí A`, which is the domain type of :math:`f`; therefore, :math:`f\, \eval \, \fork \, g \, a` has type :math:`A`, as desired.

.. _greater-generality:

Greater generality
~~~~~~~~~~~~~~~~~~

In the last section we looked at an operation :math:`f` on a set :math:`A`. We took the domain of :math:`f` to be :math:`n ‚Üí A` (the type of :math:`n`-tuples over :math:`A`) for some :math:`n`.  In particular, we assumed that :math:`A` was a set, and that the arity of :math:`f` was some natural number, say, :math:`n`. Although this is the standard setup in universal algebra.  However, it is not necessary to be so specific about the arities, domains, and codomains of operations.

In this section we start with two types :math:`Œ±` and :math:`Œ≥` and consider :math:`Œ≥`-**ary operations on** :math:`Œ±`---e.g., :math:`f: (Œ≥ ‚Üí Œ±) ‚Üí Œ±`---and show how to express composition of operations in this general context.

Suppose that for each :math:`i: Œ≥` we have a type :math:`Œ≥_i` and an operation :math:`g_i` of type :math:`(Œ≥_i ‚Üí Œ±) ‚Üí Œ±` on :math:`Œ±`.

Denote by :math:`G` the ":math:`Œ≥`-tuple" of these operations; that is, for each :math:`i: Œ≥` the ":math:`i`-th component" of :math:`G` is 
:math:`G\, i = g_i`. Evidently, this results in the typing judgment,

.. math:: G: ‚àè_{(i:Œ≥)} ((Œ≥_i ‚Üí Œ±) ‚Üí Œ±).

Even in this more general context, we can still use the fork and eval maps introduced above to express composition of operations.
Indeed, we *define* the **composition of** :math:`f` **with** :math:`G` to be

.. math:: f \, \eval \, \fork \, G.

Let us adopt the following convenient notation:

  *Denote by* :math:`\comp` *the general composition operation* :math:`\eval \, \fork`.

Then, given :math:`f: (Œ≥ ‚Üí Œ±) ‚Üí Œ±` and :math:`G: ‚àè_{(i:Œ≥)} ((Œ≥_i ‚Üí Œ±) ‚Üí Œ±)`, the **general composition of** :math:`f` **with** :math:`G` is :math:`f \comp G := f \, \eval \, \fork \, G`.  Evidently, this yields the typing judgment,

.. math:: f \comp G : \bigl(‚àè_{(i:Œ≥)}(Œ≥_i ‚Üí Œ±)\bigr) ‚Üí Œ±.

Indeed, if :math:`a: ‚àè_{(i:Œ≥)}(Œ≥_i ‚Üí Œ±)`, then for each :math:`i:Œ≥` we have,

.. math:: a\, i : Œ≥_i ‚Üí Œ± \quad \text{ and } \quad  G\, i : (Œ≥_i ‚Üí Œ±) ‚Üí Œ±,

so evaluation of :math:`\comp\, G \, a` at a particular :math:`i: Œ≥` is simply function application. That is,

.. math:: \comp \,G \, a \, i:= \eval \, \fork \, G \, a \, i = (G\, i)(a\, i): Œ±.

Thus, :math:`\comp\, G \, a` has type :math:`Œ≥ ‚Üí Œ±`, which is precisely the domain type of :math:`f`.

To summarize, we have the following typing judgments:

.. math:: \comp\, G \, a : Œ≥ ‚Üí Œ± \quad \text{ and } \quad f: (Œ≥ ‚Üí Œ±) ‚Üí Œ±,

whence :math:`f \comp G \, a: Œ±` is well-typed.




-----------------------------------------


.. index:: ! graph (of a function)
.. index:: ! idempotent, ! projection
.. index:: operation, arity, image
.. index:: pair: ‚Ñï; œâ 

.. _operations:

Operations
-----------

The symbols ‚Ñï, œâ, and ``nat`` are used interchangeably; they all denote the set of natural numbers.

If :math:`m` is a natural number, we write :math:`m: ‚Ñï` and say ":math:`m` has type ‚Ñï." [1]_

We denote and define natural numbers by :math:`m := \{0, 1, \dots, m-1\}`.

It is sometimes convenient to formally identify a function with its graph.  For example, the function :math:`a: m ‚Üí A` may be identified with the tuple :math:`(a\,0, a\,1, \dots, a\,(m-1)): A^m`.

.. It seems an egregious abuse of notation to simply write :math:`a = (a\,0, a\,1, \dots, a\,(m-1))`, so we opt for the more standard notation :math:`a[m]` to denote the **image** of the set :math:`m` under the function :math:`a`; that is, :math:`a[m]:=(a\, 0, a\, 1, \dots, a\, (m-1))`.

If :math:`h: A ‚Üí A` and :math:`a: m ‚Üí A` are functions, then :math:`h ‚àò a: m ‚Üí A` denotes the composition of :math:`h` with :math:`a`; this is the function that maps each :math:`i: m` to the element

.. math:: (h ‚àò a)(i) = h(a\, i)

of :math:`A`.

We may formally identify the function :math:`h ‚àò a: m ‚Üí A` with its graph, which is the :math:`m`-tuple,

.. math:: (h(a\, 0), h(a\, 1), \dots, h(a\, (m-1))).

Suppose :math:`A` is a nonempty set and :math:`n ‚àà ‚Ñï` is a natural number.

An :math:`n`-**ary operation** on :math:`A` is a function :math:`f: A^n ‚Üí A` which, if :math:`n>0`, maps each :math:`n`-tuple :math:`(a_0, a_1, \dots, a_{n-1})` in :math:`A^n` to a particular element :math:`f(a_0, a_1, \dots, a_{n-1})` in :math:`A`. If :math:`n=0`, then :math:`f: () ‚Üí A` is a function that takes no arguments and returns an element of :math:`A`, so :math:`f` in this case is merely notation for a particular element of :math:`A`.

An operation gives rise to a special kind of :math:`(n+1)`-ary relation, namely

.. math:: Gf := \{(a_0, a_1, \dots, a_{n-1}, b) \in A^{n+1} ‚à£ b = f(a_0, a_1, \dots, a_{n-1})\},

which is sometimes called the **graph** of :math:`f`.

For two sets :math:`A` and :math:`B`, the collection of all functions :math:`f: B ‚Üí A` is denoted by :math:`A^B`. When :math:`B = A^n`, this is set :math:`A^{A^n}` of all :math:`n`-ary operations on :math:`A`.

If we let :math:`ùñÆ_A` denote the collection of all finitary operations on :math:`A`, then

.. math:: ùñÆ_A = ‚ãÉ_{n ‚àà ‚Ñï} A^{A^n}.

If :math:`F ‚äÜ ùñÆ_A` is a set of operations on :math:`A`, let us denote by :math:`F_n` the :math:`n`-ary operations in :math:`F`.

Clearly, :math:`F_n = F ‚à© A^{A^n}`. For example, the set of *all* :math:`n`-ary operations on :math:`A` is

.. math:: (ùñÆ_A)_n = ùñÆ_A ‚à© A^{A^n} = A^{A^n}`.

Given an :math:`n`-tuple :math:`a = (a_0, a_1, \dots, a_{n-1}) ‚àà A^n`, we will need a convenient way to refer to the set :math:`\{a_i : 0 ‚â§ i < n\}` of elements that occur in the tuple without explicitly naming each element in this set.  In fact, we already have notation for this, since an :math:`n`-tuple is actually a function, defined on the (ordered) set :math:`\{0, 1, \dots, n-1\}`, whose image is the set of elements in the tuple.

That is, if :math:`a = (a_0, a_1, \dots, a_{n-1})`, then :math:`\im a = \{a_0, a_1, \dots, a_{n-1}\}`. In particular, :math:`|\im a|` is a convenient way to write the number of distinct
elements that occur in the tuple :math:`a`.

For example, if :math:`a = (1,1,3)`, then :math:`\im a = \{1, 3\}`, and :math:`|\im a| = 2`.

An operation :math:`f ‚àà A^{A^n}` is called **idempotent** provided :math:`f(a, a, \dots, a) = a` for all :math:`a ‚àà A`.

Important examples of idempotent operations are the projections. If :math:`k` and :math:`n` are natural numbers with :math:`1 ‚â§ k ‚â§ n` then the :math:`k`-**th** :math:`n`-**ary projection** of :math:`A` is denoted by :math:`œÄ^n_k` and defined to be the function that maps :math:`A^n` onto :math:`A` according to the rule :math:`(a_1, \dots, a_n) ‚Ü¶ a_k`.

Thus, the arity of an operation is the number of operands upon which it acts, and we say that :math:`f` is an :math:`n`-**ary operation on** :math:`A` if :math:`\dom f = A^n` and :math:`\cod f = A`.

An operation is called **nullary** (or constant) if its arity is zero. **Unary**, **binary**, and **ternary** operations have arities 1, 2, and 3, respectively.


---------------------------

.. index:: signature, arity

.. _signatures:

Signatures
----------

(Our formal `Lean`_ implementation of the concept of signature is described in :numref:`signatures-in-lean`.)

Classically, a **signature** is a pair :math:`(F, œÅ)` consisting of a set :math:`F` of operation symbols and an "arity" function :math:`œÅ: F ‚Üí ‚Ñï`.

For each operation symbol :math:`f ‚àà F`, the value :math:`œÅ f` is the **arity** of :math:`f`. (Intuitively, the arity can be thought of as the "number of arguments" that :math:`f` takes as "input".)

If the arity of :math:`f` is :math:`n`, then we call :math:`f` an :math:`n`-**ary** function. In case :math:`n` is 0, 1, 2, or 3, we call the function "nullary", "unary", "binary", or "ternary," respectively.

If :math:`A` is a set and :math:`f` is a :math:`œÅ f`-ary function on :math:`A`, then we often write :math:`f: A^{œÅf} ‚Üí A` to indicate this.

On the other hand, the arguments of such a function form a :math:`œÅ f`-tuple, :math:`(a_0, a_1, \dots, a_{œÅf -1})`, which may be viewed as the graph of the function :math:`a: œÅf ‚Üí A`, where :math:`a\, i = a_i`.

Thus, by identifying the :math:`œÅ f`-th power :math:`A^{œÅf}` with the type :math:`œÅ f ‚Üí A` of functions from :math:`\{0, 1, \dots, œÅ f-1\}` to :math:`A`, we identify the function type :math:`A^{œÅ f} ‚Üí A` with the function (or "functional") type :math:`(œÅf ‚Üí A) ‚Üí A`. [2]_

.. proof:example::

   Suppose 

     :math:`g : (m ‚Üí A) ‚Üí A` is an :math:`m`-ary operation on :math:`A`, and 
   
     :math:`a : m ‚Üí A` is an :math:`m`-tuple on :math:`A`.

   Then :math:`g\, a = g(a\, 0, a\, 1, \dots, a\, (m-1))` has type :math:`A`.

   Suppose

     :math:`f : (œÅf ‚Üí B) ‚Üí B` is a :math:`œÅf`-ary operation on :math:`B`,

     :math:`a : œÅf ‚Üí A` is a :math:`œÅf`-tuple on :math:`A`, and

     :math:`h : A ‚Üí B`.
      
   Then :math:`h ‚àò a : œÅf ‚Üí B` and :math:`f (h ‚àò a) : B`.

It is important to be familiar with the classical notions of signature and arity, since these are used at the present time by virtually all algebraists.

In :numref:`Chapter %s <postmodern-algebra>` we give alternative, category theoretic definitions of these concepts and show how this alternative presentation can often simplify implementation of the mathematics in :term:`type theory`.

--------------------------

.. index:: ! pair: algebra; algebraic structure
.. index:: ! œÉ-algebra, ! arity, ! trivial algebra, ! reduct

.. _algebraic-structures:

Algebraic Structures
---------------------

(Our formal `Lean`_ implementation of the concept of algebraic structure is described in :numref:`Chapter %s <algebras-in-lean>`.)

Our first goal is to develop a working vocabulary and formal library for classical (single-sorted, set-based) universal algebra.  In this section we define the main objects of study. 

An **algebraic structure** (or **algebra**) is a pair :math:`‚ü®A, F‚ü©` where :math:`A` is a *nonempty* set and :math:`F = \{f_i: i ‚àà I\}` is a collection of finitary operations on :math:`A`. That is, for each :math:`i‚àà I` there exists an :math:`n ‚àà ‚Ñï` such that :math:`f_i: A^n ‚Üí A`. The number :math:`n` is called the **arity** of the operation :math:`f_i`.

.. proof:example::

   If :math:`A=‚Ñù` and :math:`f: ‚Ñù √ó ‚Ñù ‚Üí ‚Ñù` is the map that takes each pair :math:`(a, b) ‚àà ‚Ñù √ó ‚Ñù` to the number :math:`f(a,b) = a+b ‚àà ‚Ñù`, then :math:`‚ü®A, \{f\}‚ü©` is an example of an algebra with a single binary operation. In such cases, we often simplify the notation and write :math:`‚ü®A, f‚ü©` in stead of :math:`‚ü®A, \{f\}‚ü©`.

An algebra is **finite** if :math:`|A|` is finite, and is called **trivial** if :math:`|A| = 1`.

Given two algebras :math:`ùî∏` and :math:`ùîπ`, we say that :math:`ùîπ` is a **reduct** of :math:`ùî∏` if both algebras have the same universe and :math:`ùîπ` can be obtained from :math:`ùî∏` by removing  operations.

.. index:: ! operation symbol, ! arity, ! interpretation, ! signature, ! similarity type

A better approach
~~~~~~~~~~~~~~~~~

We start with a set :math:`F` and call the members of :math:`F` "operation symbols."  An **operation symbol** is simply an object that has an associated **arity**.

We denote the arity of :math:`f` by :math:`œÅ \,f`, where :math:`œÅ: F ‚Üí N` is an "arity function" that maps :math:`F` into some "arity type" :math:`N`.  Often we take the arity type to be :math:`‚Ñï`, so that the arity of each symbol is a natural number, :math:`N = ‚Ñï`, and :math:`œÅ \, f ‚àà ‚Ñï` for all :math:`f‚àà F`. 

A pair :math:`(F, œÅ)` consisting of a set :math:`F` of operation symbols and an **arity function** :math:`œÅ: F ‚Üí N` is called a **signature** (or **similarity type**).

An **algebraic structure** (or **algebra**) in the signature :math:`œÉ = (F, œÅ)` is denoted by :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` and consists of 

  #. :math:`A` := a set, called the **carrier** (or **universe**) of the algebra,
  #. :math:`F^ùî∏ = \{ f^ùî∏ ‚à£ f ‚àà F, \ f^ùî∏ : (œÅ f ‚Üí A) ‚Üí A \}` is a collection of operations on :math:`A`,
  #. a collection of identities satisfied by elements of :math:`A` and operations in :math:`F^ùî∏`.

Note that to each operation symbol :math:`f‚àà F` corresponds an operation :math:`f^ùî∏` on :math:`A` of arity :math:`œÅ f`; we call this :math:`f^ùî∏` the **interpretation** of :math:`f` in :math:`ùî∏`.

We call an algebra in the signature :math:`œÉ` a :math:`œÉ`-**algebra** (although this is not standard). [3]_ 

.. proof:example::

   Consider the set of integers :math:`‚Ñ§` with operation symbols :math:`F = \{0, 1, -(\,), +, ‚ãÖ\}`, which have respective arities :math:`\{0, 0, 1, 2, 2\}`.

   The operation :math:`+^‚Ñ§` is the usual binary addition, while :math:`-^‚Ñ§(\,)` is negation, which takes the integer :math:`z` to :math:`-^‚Ñ§(z) = -z`.

   The constants :math:`0^‚Ñ§` and :math:`1^‚Ñ§` are nullary operations. Of course we usually just write :math:`+` for :math:`+^‚Ñ§`, etc.

More :ref:`examples of algebraic structures <examples-of-algebras>` that have historically played a central role in mathematics over the last century (e.g., groups, rings, modules) appear in the appendix.

Some of the renewed interest in universal algebra focuses on representations of algebras in categories other than :cat:`Set`, such as multisorted algebras, and higher-type universal algebra :cite:`Adamek:2011`, :cite:`Behrisch:2012`, :cite:`Finster:2018`, :cite:`Gepner:2018`, :cite:`Meinke:1992`). These are natural generalizations that we will incorporate in our development later. (See :numref:`Chapter %s <postmodern-algebra>`.)

---------------------------

.. index:: ! subuniverse, ! subalgebra
.. index:: ùñ≤(ùî∏)
.. index:: ùñ≤ùóÄ

.. _subalgebras:

Subalgebras
-------------

This section introduces two important concepts in universal algebra, **subuniverse** and **subalgebra**.

.. A **subuniverse** of an algebra :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` is a subset :math:`B ‚äÜ A` that is closed under the operations in :math:`F^ùî∏`.

Suppose :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` is an algebra. Recall, the (nonempty) set :math:`A` is called the **universe** of ùî∏.

We call a subset :math:`B ‚äÜ A` **closed under** (the operations in) :math:`F^ùî∏` if for each :math:`f ‚àà F` and all :math:`b_0, \dots, b_{œÅf-1} ‚àà B` we have :math:`f^ùî∏(b_0, \dots, b_{œÅ f-1}) ‚àà B`.  Equivalently,

.. math:: ‚àÄ f ‚àà F,\ ‚àÄ b: œÅ f ‚Üí B, \ (f^ùî∏ \, b) ‚àà B`.

If a subset :math:`B ‚äÜ A` is closed under :math:`F^ùî∏`, then we call :math:`B` a **subuniverse** of :math:`ùî∏`.

If :math:`B ‚â† ‚àÖ` is a subuniverse of ùî∏, and if we let :math:`F^ùîπ = \{ f^ùî∏ ‚Üæ B : f ‚àà F \}`, then :math:`ùîπ = ‚ü® B, F^ùîπ ‚ü©` is an algebra, called a **subalgebra** of ùî∏.

.. Equivalently, if :math:`B ‚â† ‚àÖ` is a subuniverse of ùî∏ and :math:`F^{ùîπ|_A} = \{f^ùî∏|_B ‚à£ f ‚àà F\}` is the set of basic operations of ùî∏ restricted to the set :math:`B`, then :math:`ùîπ = ‚ü®B, F^{ùîπ|_A}‚ü©` is a **subalgebra** of ùî∏.

Conversely, all subalgebras are of this form.

If ùîπ is a subalgebra of ùî∏, we denote this fact by :math:`ùîπ ‚â§ ùî∏`. Similarly, we write :math:`B ‚â§ ùî∏` if :math:`B` is a subuniverse of :math:`ùî∏`. 

  *The empty set is a subuniverse of every algebra, but the universe of an algebra is never empty*.

In other terms, if :math:`ùñ≤(ùî∏)` denotes the collection of all subalgebras of :math:`ùî∏`, then 

.. math:: ùñ≤ (ùî∏) = \{‚ü®B, F^ùîπ‚ü© : B ‚â§ ùî∏ \text{ and } B ‚â† ‚àÖ\}.

It is obvious that the intersection of subuniverses is again a subuniverse. Let us nevertheless record this observation.

.. proof:lemma::

   Suppose :math:`A_i ‚â§ ùî∏` for all :math:`i` in some set :math:`I`. Then :math:`‚ãÇ_{i‚àà I} A_i` is a subuniverse of :math:`ùî∏`.

.. index:: subuniverse generation

.. _subuniverse-generation:

Subuniverse generation
~~~~~~~~~~~~~~~~~~~~~~

As above :math:`ùñ≤(ùî∏)` denotes the collection of all subalgebras of ùî∏.  If ùî∏ is an algebra and :math:`A_0 ‚äÜ A` a subset of the universe of ùî∏, then the **subuniverse of** ùî∏ **generated by** :math:`A_0`, denoted by :math:`\Sg^ùî∏ (A_0)` or :math:`‚ü®A_0‚ü©`, is the smallest subuniverse of ùî∏ containing the set :math:`A_0`.  Equivalently, 

.. math:: \Sg^{ùî∏}(A_0)  =  ‚ãÇ \{ U ‚àà ùñ≤ (ùî∏) ‚à£ A_0 ‚äÜ U \}.
  :label: SgDef

We can also use recursion to define the **subuniverse of** ùî∏ **generated by a set** and prove that this new definition is equivalent to the one given by :eq:`SgDef`

.. (cf. :cite:`Bergman:2012` Thm. 1.14).

.. in :numref:`subuniverse-and-subalgebra` 

.. _thm-1-14:

.. proof:theorem:: Subuniverse generation

   Let :math:`ùî∏ = ‚ü®A, F^{ùî∏}‚ü©`  be  an  algebra in the signature :math:`œÉ = (F, œÅ)` and let :math:`A_0` be a subset of :math:`A`.

   Define, by recursion on :math:`n`, the sets :math:`A_n` as follows:

     If :math:`A_0 = ‚àÖ`, then :math:`A_n = ‚àÖ` for all :math:`n<œâ`.

     If :math:`A_0 ‚â† ‚àÖ`, then

     .. math:: A_{n+1} =  A_n ‚à™ \{ f\, a ‚à£ f ‚àà F, \ a ‚àà œÅ f ‚Üí A_n\}.
        :label: subalgebra-inductive

   Then the subuniverse of ùî∏ generated by :math:`A_0` is :math:`\Sg^ùî∏(A_0) = ‚ãÉ_{n<œâ} A_n`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Let :math:`Y := ‚ãÉ_{n < œâ} A_n`. Clearly :math:`A_n ‚äÜ Y ‚äÜ A`, for every :math:`n < œâ`. In particular :math:`A = A_0 ‚äÜ Y`. We first show that :math:`Y` is a subuniverse of ùî∏.

      Let :math:`f` be a basic :math:`k`-ary operation and let :math:`a: k ‚Üí Y` be a :math:`k`-tuple of elements of :math:`Y`.
    
      From the construction of :math:`Y`, there is an :math:`n < œâ` such that :math:`‚àÄ i,\ a,\ i ‚àà A_n`.
    
      From its definition, :math:`f \,a ‚àà A_{n+1} ‚äÜ Y`. Since :math:`f` was arbitrary, it follows that :math:`Y` is a subuniverse of ùî∏ containing :math:`A_0`.
    
      Thus, by :eq:`SgDef`, :math:`\Sg^ùî∏(A_0) ‚äÜ Y`.
    
      For the opposite inclusion, it is enough to check, by induction on :math:`n`, that :math:`A_n ‚äÜ \Sg^ùî∏(A_0)`.
    
      Clearly, :math:`A_0 ‚äÜ \Sg^ùî∏(A_0)`.
      
      Assume :math:`A_n ‚äÜ \Sg^ùî∏(A_0)`.  We show :math:`A_{n+1} ‚äÜ \Sg^ùî∏(A_0)`.
      
      If :math:`b ‚àà A_{n+1} - A_n`, then :math:`b = f\, a` for a basic :math:`k`-ary operation :math:`f` and some :math:`a: k ‚Üí A_n`.
      
      But :math:`‚àÄ i, \ a i ‚àà \Sg^ùî∏(A_0)` and since this latter object is a subuniverse, :math:`b ‚àà \Sg^ùî∏(X)` as well.
    
      Therefore, :math:`A_{n+1} ‚äÜ \Sg^ùî∏(A_0)`, as desired. ‚òê 

.. The argument in the proof of :numref:`Theorem %s <thm-1-14>` is of a type that one encounters frequently throughout algebra. It has two parts.

..   #. Some set :math:`Y` is shown to be a subuniverse of ùî∏ that contains :math:`A_0`.

..   #. Every subuniverse containing :math:`A_0` is shown to contain :math:`Y` as well.

..   #. One concludes that :math:`Y = \Sg^ùî∏ (A_0)`.


**Formalization**. Our formal implementation (in `Lean`_) of the concept of subalgebra is described in :numref:`Sections %s <subalgebras-in-lean>` and :numref:`%s <subalgebras-in-lean_reprise>`, and is included in the `subuniverse.lean`_ file of the `lean-ualib`_ library.

---------------------------

.. index:: ! subdirect product

.. _subdirect-products:

Subdirect products
-------------------

If :math:`k, n ‚àà ‚Ñï`, if :math:`A = (A_0, A_1, \dots, A_{n-1})` is a list of sets, and if :math:`œÉ : k ‚Üí n` is a :math:`k`-tuple, then a relation :math:`R` over :math:`A` with scope :math:`œÉ` is a subset of the Cartesian product :math:`A_{œÉ(0)} √ó A_{œÉ(1)} √ó \cdots √ó A_{œÉ(k-1)}`.

Let :math:`F` be a set of operation symbols and for each :math:`i<n` let :math:`ùî∏_i = ‚ü® A_i, F ‚ü©` be an algebra of type :math:`F`. If :math:`ùî∏ = ‚àè_{i<n}ùî∏_i` is the product of these algebras, then a relation :math:`R` over :math:`ùî∏` with scope :math:`œÉ` is called **compatible with** ùî∏ if it is closed under the basic operations in
:math:`F`. In other words, :math:`R` is compatible if the induced algebra :math:`‚Ñù = ‚ü® R, F ‚ü©` is a subalgebra of :math:`\prod_{j<k} ùî∏_{œÉ(j)}`.

If :math:`R` is compatible with the product algebra and if the projection of :math:`R` onto each factor is surjective, then :math:`‚Ñù` is called a **subdirect product** of the algebras in the list :math:`(ùî∏_{œÉ(0)}, ùî∏_{œÉ(1)}, \dots, ùî∏_{œÉ(k-1)})`; we denote this situation by writing :math:`‚Ñù ‚â§_{\mathrm{sd}} \prod_{j< k} ùî∏_{œÉ(j)}`.

**Formalization**. (not yet implemented)

.. todo:: implement subdirect product in Lean

-----------------------------------------------

.. index:: ! homomorphism
.. index:: ! epimorphism, ! monomorphism, ! automorphism

.. _homomorphisms:

Homomorphisms
-------------

Let :math:`ùîπ = ‚ü® B, F^ùîπ ‚ü©` and :math:`‚ÑÇ = ‚ü® C, F^‚ÑÇ ‚ü©` be algebras of the same signature, and let :math:`h: B ‚Üí C` be a function (e.g., on sets).

Take an operation symbol :math:`f ‚àà F`, and suppose that for all :math:`œÅ f`-tuples :math:`b: œÅ f ‚Üí B` of :math:`B` the following equation holds:

.. math:: h (f^ùîπ \, b) = f^‚ÑÇ (h ‚àò b).

Then :math:`h` is said to **respect the interpretation of** :math:`f`.

If :math:`h` respects the interpretation of every :math:`f ‚àà F`, then we call :math:`h` a **homomorphism** from ùîπ to ‚ÑÇ, and we write :math:`h ‚àà \hom(ùîπ, ‚ÑÇ)`, or simply, :math:`h: ùîπ ‚Üí ‚ÑÇ`.

A homomorphism :math:`h: ùîπ ‚Üí ‚ÑÇ` is called an **epimorphism** if for every algebra :math:`ùîª` and pair :math:`g_1, g_2: ‚ÑÇ ‚Üí ùîª` of homomorphisms, the equation :math:`g_1 ‚àò h = g_2 ‚àò h` implies :math:`g_1 = g_2`. We often write :math:`h: ùîπ ‚Ü† ‚ÑÇ`, and we say ":math:`h` is **epi**" and ":math:`h` maps ùîπ **onto** ‚ÑÇ," in this case.

A homomorphism :math:`h: ùîπ ‚Üí ‚ÑÇ` is called a **monomorphism** if for every algebra :math:`ùî∏` and every pair :math:`g_1, g_2: ùî∏ ‚Üí ùîπ` of homomorphisms, the equation :math:`h ‚àò g_1 = h ‚àò g_2` implies :math:`g_1 = g_2`.  We sometimes write :math:`h: ùî∏ ‚Ü£ ùîπ`, and we say ":math:`h` is **mono**" and ":math:`h` maps ùîπ **into** ‚ÑÇ," in this case.

.. proof:notation:: homo-, epi-, mono-, automorphism

   We adopt the following notation. If :math:`ùîπ` and :math:`‚ÑÇ` are algebras in the same signature, then

   + :math:`\hom(ùîπ, ‚ÑÇ) =` the set of homomorphisms from ùîπ to ‚ÑÇ.
   + :math:`\epi(ùîπ, ‚ÑÇ) =` the set of epimorphisms from ùîπ onto ‚ÑÇ.
   + :math:`\mono(ùîπ, ‚ÑÇ) =` the set of monomorphisms from ùîπ into ‚ÑÇ.
   + :math:`\aut(ùîπ, ‚ÑÇ) =` the set of automorphisms from ùîπ into and onto ‚ÑÇ.

**Formalization**. Our formal implementation (in `Lean`_) of these concepts is described in  :numref:`subalgebras-in-lean`, :numref:`basic-facts-in-lean`, :numref:`factoring-homomorphisms`, and is included in the `birkhoff.lean`_ and `subuniverse.lean`_ files of the `lean-ualib`_ library.

----------------------

.. index:: ! projection operator, ! idempotent operation

.. _idempotence-and-projections:

Idempotence and projections
----------------------------

An operation :math:`f: A^n ‚Üí A` is called **idempotent** provided :math:`f(a, a, \dots, a) = a` for all :math:`a ‚àà A`.

Examples of idempotent operations are the *projections* and these play an important role in the theory, so we introduce a sufficiently general and flexible notation for them.

Denote and define the set ‚Ñï of natural numbers inductively as follows:

.. math:: 0 = ‚àÖ, \quad 1 = \{0\}, \quad  2 := \{0, 1\}, \dots, n = \{0, 1, \dots, n-1\}.

Let :math:`\{A_i: i ‚àà I\}` be a collection of sets (for some :math:`I ‚äÜ ‚Ñï`) and let :math:`A = ‚àè_{i ‚àà I} A_i`. View the elements of :math:`A` as functions:

.. math:: a ‚àà ‚àè_{i‚ààI} A_i \quad ‚ü∑ \quad \begin{cases} a : I ‚Üí ‚ãÉ_{i‚ààI} A_i, & \\ a\,i ‚àà A_i, & ‚àÄ i ‚àà I. \end{cases}
   :label: 7
   
This correspondence simply records the fact that the product type (on the left of the ‚ü∑ symbol) is a special kind of function type (depicted on the right of ‚ü∑ using the usual arrow notation for function types).

In other words,¬†:eq:`7` says that an element of the product type :math:`‚àè_{i‚ààI} A_i` is a function from :math:`I` into :math:`‚ãÉ_{i‚ààI} A_i`.  As explained in the section on :ref:`Pi types <pi-types>`, such a function (or product) type is known as a :term:`dependent type`.

Given a subset :math:`J ‚äÜ I`, a function :math:`œÉ: J ‚Üí I`, and an element :math:`a ‚àà ‚àè_{i‚ààI} A_i`, consider the composition :math:`a ‚àò œÉ`. This is a function from :math:`J` to :math:`‚ãÉ_{j‚ààJ} A_{œÉ\, j}`, where :math:`(a ‚àò œÉ)\, j ‚àà A_{œÉ\, j}`.

We could express this function type using the arrow notation, as in, ":math:`a ‚àò œÉ: J ‚Üí ‚ãÉ_{j‚ààJ} A_{œÉ\, j}` where :math:`(a ‚àò œÉ)\, j ‚àà A_{œÉ\, j}`," but this specification has a nicer, more compact description using a :term:`dependent function type`, namely, 

.. math:: a ‚àò œÉ ‚àà ‚àè_{j‚ààJ} A_{œÉ \, j}.

If :math:`œÉ` happens to be one-to-one, then we will define the **projection operator induced by** :math:`œÉ`. We denote this operator by

.. math:: \Proj\, œÉ : ‚àè_{i‚ààI} A_i ‚Üí ‚àè_{j‚ààJ} A_{œÉ \, i},
   :label: projection

and define it for each :math:`a ‚àà ‚àè_{i‚ààI} A_i` by :math:`\Proj\, œÉ \, a = a ‚àò œÉ`.

The following is closer to what we want, but still imperfect:

.. math:: \Proj: (J ‚Üí I) ‚Üí ‚àè_{i‚ààI} A_{i} ‚Üí ‚àè_{j‚ààJ} A_{g(j)}.
   :label: 9

This says that :math:`\Proj` takes a function :math:`œÉ: J ‚Üí I` and a function :math:`a ‚àà ‚àè_{i‚ààI} A_i` and returns the function :math:`a ‚àò œÉ ‚àà ‚àè_{j‚ààJ} A_{œÉ \, j}`.

Here again we see that the arrow notation is not expressive enough because :math:`‚àè_{j‚ààJ} A_{œÉ \, j}` depends on :math:`œÉ`, but there is no :math:`œÉ` symbol available from earlier in :eq:`9`.

The solution is again to denote the function type as a product. Product types are very expresive and enable us to concisely specify such dependent function types. Before demonstrating this, we make one more notational adjustment. Instead of denoting set membership by :math:`a ‚àà A`, we adopt the type-theoretic notation :math:`a:A`, which expresses the fact that :math:`a` *has type* :math:`A`. Thus, the full :term:`dependent type` specification of the projection operator is

.. math:: \Proj: ‚àè_{œÉ:J‚ÜíI} \left( ‚àè_{(i:I)} A_{i} ‚Üí  ‚àè_{(j:J)} A_{œÉ\, j} \right).

This is a special case of the more general types that we define in later chapters, after reviewing some concepts of category theory in :numref:`Chapter %s <postmodern-algebra>` that are essential for this purpose.

.. proof:example:: Projection terminology

   Let us explain why the term "projection" is reserved for the case when :math:`œÉ` is one-to-one.
   
   Suppose :math:`k=4`, :math:`n=3`, and consider the 4-tuple :math:`œÉ = (1, 0, 1, 1)`.
   
   Then :math:`œÉ` is the function :math:`œÉ : \{0,1,2,3\} ‚Üí \{0,1,2\}` given by
   
   .. math:: œÉ\, 0 = 1, \; œÉ\, 1 = 0`, \; œÉ\, 2 = 1, \; œÉ\, 3 = 1,
   
   and so :math:`a ‚Ü¶ a ‚àò œÉ` is the function that takes :math:`(a\, 0, a\, 1, a\, 2) ‚àà A_0 √ó A_1 √ó A_2` to :math:`(a\, 1, a\, 0, a\, 1, a\, 1) ‚àà A_1 √ó A_0 √ó A_1 √ó A_1`.

Let :math:`A = ‚àè_{0‚â§ i<n} A_i`, let :math:`œÉ: k ‚Üí n` be one-to-one, and define the projection :math:`\Proj\, œÉ` as in¬†:eq:`projection` above. Then the :term:`kernel` of :math:`\Proj\, œÉ`, which we denote by :math:`\mathbf{0} œÉ`, is denoted and defined by

.. math:: \mathbf{0} œÉ &= \ker \Proj\, œÉ = \{(a,a') ‚àà A^2 | \Proj\, œÉ a = \Proj\, œÉ a'\}\\
                       &= \{ (a,a') ‚àà A^2 | a ‚àò œÉ = a' ‚àò g \} = \{ (a,a') ‚àà A^2 | ‚àÄ j ‚àà \im œÉ, \ a\, j = a'\, j \}.
   :label: kernel

It is obvious that :math:`\mathbf{0} œÉ` is an equivalence relation on the set :math:`A`.

More generally, if :math:`Œ∏` is an equivalence relation on the set :math:`‚àè_{0‚â§ j<k} A_{œÉ\,j}`---that is, :math:`Œ∏ ‚äÜ (‚àè_{0‚â§ j<k} A_{œÉ\, j})^2` and :math:`Œ∏` is reflexive, symmetric, and transitive---then we define the equivalence relation :math:`Œ∏ œÉ` on the set :math:`A = ‚àè_{0‚â§ i<n} A_i` as follows:

.. math:: Œ∏ œÉ = \{(a, a') ‚àà A^2 ‚à£ (a ‚àò œÉ) \mathrel{\theta} (a' ‚àò œÉ)\}.
   :label: 17

In other words, :math:`Œ∏ œÉ` consists of all pairs in :math:`A^2` that land in :math:`Œ∏` when projected onto the coordinates in :math:`\im œÉ`.

#. Recall that :math:`\Proj\, œÉ : A ‚Üí ‚àè_{j<k} A_{œÉ\, j}` is the function that maps :math:`a` to :math:`a ‚àò œÉ`.

   Now, suppose we have a tuple :math:`(a\, 0, a\, 1, \dots, a\, (p-1))‚àà A^p`, and suppose we intend to apply :math:`\Proj\, œÉ` to each component, :math:`a \, j`.

   To do so, we need to lift :math:`\Proj\, œÉ` from type :math:`A ‚Üí ‚àè_{j<k} A_{œÉ\, j}` to type :math:`A^p ‚Üí (‚àè_{j<k} A_{œÉ\, j})^p`, which is accomplished using a functor that often goes by the name :math:`map`.

   For instance, if :math:`(a, a') ‚àà A^2`, then :math:`map \,(\Proj\, œÉ)\, (a, a') = (\Proj\, œÉ \, a, \Proj\, œÉ \, a')`.

   Therefore,

   .. math:: Œ∏ œÉ =\{(a, a') ‚àà A^2 ‚à£ map \, (\Proj\, œÉ)\, (a, a') ‚àà Œ∏ \},

   whence, :math:`Œ∏_g = map \, (\Proj\, œÉ)^{-1} \, Œ∏`.

#. If :math:`f: X ‚Üí A` and :math:`g: X ‚Üí B` are functions defined  on the same domain :math:`X`, then :math:`(f,g): X ‚Üí A √ó B` is the unique function that composes with the first projection to give :math:`f` and composes with the second projection to give :math:`g`. For example, in the last remark there appears the expression :math:`(\Proj\, œÉ\, a, \Proj\, œÉ \, a') = (a ‚àò œÉ, a' ‚àò œÉ)`, which has type :math:`( ‚àè_{j<k} A_{œÉ\, j} )^2`. [4]_

#. If the domain of :math:`œÉ` is a singleton, :math:`k = \{0\}`, then of course :math:`œÉ` is just a one-element list, say, :math:`œÉ = (j)`. In such cases, we write :math:`\Proj\, j` instead of :math:`\Proj\, {(j)}`.  Similarly, we write and :math:`\mathbf{0}\, j` and :math:`Œ∏\, j` instead of :math:`\mathbf{0}\, {(j)}` and :math:`Œ∏\, {(j)}`. Thus, :math:`\Proj\, j \, a = a\, j`, and :math:`\mathbf{0} \, j = \{(a, a') ‚àà A^2 ‚à£ a \, j = a' \, j\}`, and, if :math:`Œ∏ ‚àà \Con ùî∏_j`, then :math:`Œ∏ \, j = \{(a, a') ‚àà A^2 ‚à£ a \, j \mathrel{\theta} a'\, j\}`.

Here are some obvious consequences of the foregoing notation and definitions that are worth noting.

.. math::

   ‚ãÅ_{0‚â§j<n}\mathbf{0}j = A^2, \quad \mathbf{0} œÉ = ‚ãÄ_{j ‚àà œÉ} \mathbf{0} j, \quad \mathbf{0}n = ‚ãÄ_{0‚â§j<n}\mathbf{0} j = 0_A, \quad
   Œ∏œÉ = ‚ãÄ_{0‚â§j<k} Œ∏ \, œÉ\, j,

where :math:`0_{A}` denotes the least equivalence relation on :math:`A`, that is, :math:`0_{A}:= \{(a, a') ‚àà A^2 ‚à£ a = a'\}`.

.. As we alluded to above, :math:`Œ∑_œÉ` is shorthand for :math:`(0_A)_œÉ`.

.. index:: projection kernel

.. _kernels-of-projections:

Kernels of projections
~~~~~~~~~~~~~~~~~~~~~~~

Let :math:`ùî∏ = ‚àè_{(i:I)} ùî∏_i` be a product of algebras with the same :term:`signature`, and suppose :math:`g: J ‚Üí I` is a one-to-one function, where :math:`‚àÖ ‚â† J ‚äÜ I ‚äÜ ‚Ñï`.

Define the **kernel of the projection of** :math:`ùî∏` **onto** :math:`‚àè_{(j:J)} A_{g(j)}` as follows:

.. math:: Œîg = \{(a,a'): ùî∏^2 | a ‚àò g = a' ‚àò g \} = \ker (\Proj\, g)

This is a congruence of :math:`ùî∏`. More generally, if :math:`Œ∏` is a congruence of :math:`‚àè_{(j:J)} A_{g(j)}`, define :math:`Œ∏g: \Con ùî∏` as follows:

.. math:: Œ∏g = (\Proj\, g)^{-1}(Œ∏) =  \{ (a, a') : ùî∏^2 | (a ‚àò g) \mathrel{\theta} (a' ‚àò g) \}.

This indicates the origin of the notation :math:`Œîg`, where :math:`Œî` denotes the trivial (identity) relation on :math:`‚àè_{(j:J)} A_{g(j)}`. If :math:`J = \{0\}` and :math:`g:I` is just a constant, say, :math:`g(0) = k`, then we write :math:`Œ∏ k` instead of :math:`Œ∏ \{k\}`, so

.. math:: Œ∏ k = \{(a, a') \in ùî∏^2 : a\,k \mathrel{\theta} a'\,k\}.

(Here, :math:`\theta` must be in :math:`\Con ùî∏_k`.)

The symbols ‚Ñï, œâ, and ``nat`` are used interchangeably; they all denote the set of natural numbers.

Fix :math:`m ‚àà ‚Ñï`. If :math:`a = (a_0, a_1, \dots, a_{m-1})` is an :math:`m`-tuple of elements from :math:`A`, then (keeping in mind that :math:`m` is the set :math:`\{0, 1, \dots, m-1\}`) it is useful to understand that this tuple is a function :math:`a: m ‚Üí A`, where :math:`a\,i = a_i`, for each :math:`i<m`. If :math:`h: A ‚Üí A`, then :math:`h ‚àò a: m ‚Üí A` is the tuple :math:`(h\, a_0, h\, a_1, \dots, h\, a_{m-1}) ‚àà A^m`, whose :math:`i`-th coordinate is :math:`(h ‚àò a)\, i = h(a\, i) = h(a_i) ‚àà A`.

On the other hand, if :math:`g: A^m ‚Üí A`---equivalently, :math:`g: (m ‚Üí A) ‚Üí A`---then :math:`g a` is the element :math:`g(a_0, a_1, \dots, a_{m-1}) ‚àà A`.

If :math:`f: (œÅ f ‚Üí B) ‚Üí B` is a :math:`œÅ f`-ary operation on :math:`B`, if :math:`a: œÅ f ‚Üí A` is a :math:`œÅ f`-tuple on :math:`A`, and if :math:`h: A ‚Üí B`, then
:math:`h ‚àò a: œÅ f ‚Üí B`, so :math:`f (h ‚àò a): B`.

----------------------------------------------


.. index:: ! clone
.. index:: ! clone of projections
.. index:: ! clone of polynomial operations
.. index:: ! clone of term operations

.. _clones:

Clones
------

**Formalization**. For a description of our implementation (in `Lean`_) of the objects described in this section, see :numref:`Chapter %s <clones-and-terms-in-lean>`.

An **operational clone** (or just **clone**) on a nonempty set :math:`A` is a set of operations on :math:`A` that contains the projection operations and is closed under general composition.

Let :math:`ùñ¢ A` denote the collection of all clones on :math:`A`.

The smallest clone on :math:`A` is the **clone of projections**, which we denote and define as follows:

.. math:: \Proj  A = ‚ãÉ_{i < n < œâ}  \{œÄ^n_i : ‚àÄ a ‚àà A^n,\ œÄ^n_i\, a = a(i)\}.

Let us set down some conventions that will help simplify notation.  Recall, the natural number :math:`k< œâ` may be constructed as (or at least identified with) the set :math:`\{0,1,\dots, k-1\}`, and this will be helpful here.

For each :math:`k< œâ`, denote and define the tuple :math:`\pi^k: k ‚Üí ((k ‚Üí A) ‚Üí A)` of all :math:`k`-ary projections on :math:`A` as follows: for each :math:`0‚â§ i < k`,  :math:`œÄ^k(i)` is the :math:`i`-th :math:`k`-ary projection operation that takes each :math:`k`-tuple :math:`a: k ‚Üí A` to its entry at index :math:`i`:

.. math:: œÄ^k (i) a = a(i).

Observe that if :math:`f: (k ‚Üí A) ‚Üí A` is a :math:`k`-ary operation on :math:`A`, then 

The **clone of term operations** of a œÉ-algebra ùî∏ is the smallest clone on :math:`A` containing the basic operations of ùî∏; this is
denoted and defined by

.. math:: \Clo (F^ùî∏) = ‚ãÇ \{ U ‚àà ùñ¢ A ‚à£ F^ùî∏ ‚äÜ U\}.

The set of :math:`n`-ary members of :math:`\Clo (F^ùî∏)` is sometimes denoted by :math:`\Clo _n (F^ùî∏)` (despite the fact that the latter is clearly not a clone).

The **clone of polynomial operations** (or **polynomial clone**) of a œÉ-algebra ùî∏ is denoted by :math:`\Pol (F^ùî∏)` and is defined to be the clone generated by the collection consisting of the basic operations (i.e., :math:`F^ùî∏`) of ùî∏ along with the **constants** on :math:`A`. [6]_

The set of :math:`n`-ary members of :math:`\Pol (F^ùî∏)` is sometimes denoted by :math:`\Pol _n (F^ùî∏)`. 

.. .. [9] Lean's built-in sigma type is defined as follows: :math:`structure sigma {Œ± : Type u} (Œ≤ : Œ± ‚Üí Type v) := mk :: (fst : Œ±) (snd : Œ≤ fst)`

The clone :math:`\Clo (F^ùî∏)` is associated with the algebra :math:`ùî∏` only insofar as the former is constructed out of the basic operations of ùî∏ and the set :math:`A` on which those operations are defined.  However, all that is required when defining a clone is a set :math:`A` and some collection :math:`F` of operations defined on :math:`A`; from only these ingredients, we can construct the clone generated by :math:`F`, which we denote by :math:`\Clo (F)`.

Thus

  *the clone of terms operations can be implemented (e.g., in Lean) as an inductive type*.
  
The following theorem makes this more precise (cf. Theorem 4.32 of :cite:`Bergman:2012`). (See also :numref:`Chapter %s <inductively-defined-types>`, where we formalize this in Lean.)

.. We seek a "bottom-up," inductive description of the members of :math:`\Clo (F)`.  By thinking of the clone itself as a kind of algebra, a description analogous to :numref:`Obs %s <thm-1-14>` ought to be possible.  In fact, since function composition is associative, a slightly slicker formulation is available.

..  Theorem  4.3. of Bergman [1].

.. _obs-five:

.. proof:observation::

   Let :math:`A` be a set and let :math:`F ‚äÜ \Op (A):= ‚ãÉ_{n<œâ} A^{A^n}` be a collection of operations on :math:`A`.
   
   Define :math:`F_0 := \Proj (A)` (the set of projections on :math:`A`) and for all :math:`0 ‚â§ n < œâ` let
 
   .. math:: F_{n+1} := F_n ‚à™ \{ f g \mid f ‚àà F, g : œÅf ‚Üí (F_n ‚à© (œÅg ‚Üí A)) \}.
 
   Then :math:`\Clo (F) = ‚ãÉ_n F_n`.
 
   .. container:: toggle
    
      .. container:: header
  
         *Proof*.

      Let :math:`FÃÑ = ‚ãÉ_n F_n`. It is easy to argue by induction that every :math:`F_n` is a subset of :math:`\Clo (F)`. Thus, :math:`F ‚äÜ \Clo (F)`.
    
      For the converse, we must show that :math:`FÃÑ` is a clone that contains :math:`F`.
    
      Obviously :math:`FÃÑ` contains the projection operations, :math:`F_0 ‚äÜ FÃÑ`.

      For every :math:`f ‚àà F`, we have :math:`f œÄ^k ‚àà F_1 ‚äÜ FÃÑ`, where :math:`k:= œÅ f`.
 
      We are reduced to showing that :math:`FÃÑ` is closed under generalized composition. This follows from the following claim.
 
      **Claim**. If :math:`f ‚àà F_n` and :math:`g_0, \dots, g_{œÅ f-1} ‚àà F_m` are all :math:`k`-ary, then :math:`f g \in F_{n+m}`, where we have defined :math:`g: œÅ f ‚Üí (k ‚Üí A) ‚Üí A` to be the tuple given by :math:`g\,i = g_i` for each :math:`0 ‚â§ i < œÅ f`.

      Note that the types match up; indeed, for each :math:`a: (k ‚Üí A) ‚Üí A`, we have

      .. math:: f (g ‚àò a) = f(g_0(a_0, \dots, a_{k-1}), 
 
      We prove the claim by induction on :math:`n`.
      
      If :math:`n = 0` then :math:`f` is a projection, so :math:`f g = g_i ‚àà F_{0+m}` for some :math:`0‚â§ i < œÅ f`.

      Assume the claim holds for :math:`n` and that :math:`f ‚àà F_{n+1} - F_n`.
      
      From the definition, there is a :math:`t`-ary operation :math:`f_i ‚àà F` and a :math:`t`-tuple :math:`h = (h_0, \dots, h_{t-1}) ‚àà t ‚Üí F_n`, such that :math:`f = f_i h`. (Note that :math:`h: t ‚Üí (œÅ f ‚Üí A) ‚Üí A` is given by :math:`h(j) = h_j`, and that the arity of each :math:`h_i` must be equal to that of :math:`f`, namely :math:`œÅ f`.)
      
      By the induction hypothesis, for each :math:`i ‚â§ k`, :math:`h_i' = h_i g \in F_{n+m}` (where, as above, :math:`g = (g_0, \dots, g_{k-1})`).
      
      Applying the definition, :math:`f_1 h' ‚àà F_{n+m+1} = F_{(n+1)+m}`. Since 
      
      .. math:: f_1 h' = f_1 ‚àò (h_1 g, \dots, h_t g) = f g,

      the claim is proved. ‚ñ°

------------------------

.. index:: ! term, ! term algebra, ! œÉ-term 

.. _terms:

Terms
-----

**Formalization**. For a description of our implementation (in `Lean`_) of the objects described in this section, see :numref:`Chapter %s <clones-and-terms-in-lean>`.

Fix a :term:`signature` :math:`œÉ = (F, œÅ)`, let :math:`X` be a set of **variables**, and assume :math:`X ‚à© F = ‚àÖ`.

By a **word** on :math:`X ‚à™ F` we mean a nonempty, finite sequence of members of :math:`X ‚à™ F`, and we will denote the concatenation of such sequences by simple juxtaposition.

Let :math:`F_0` denote the set of nullary operation symbols. We define by induction on :math:`n` the sets :math:`T_n` of **terms on** :math:`X ‚à™ F` as follows:

.. math::      T_0 &= X ‚à™ F_0;\\
           T_{n+1} &= T_n ‚à™ \{ f\, s ‚à£ f ‚àà  F, \ s: œÅf ‚Üí T_n \},

and we define the collection of **terms of signature** :math:`œÉ` **over** :math:`X` by :math:`T_œÉ(X) = ‚ãÉ_{n < œâ}T_n`.

By a :math:`œÉ`-**term** we mean a term in the signature :math:`œÉ`. 

The definition of :math:`T_œÉ (X)` is recursive, indicating that

  *terms can be implemented as an inductive type*

(in Lean, for example). We confirm this in :numref:`Chapter %s <inductively-defined-types>` below.

Before doing so, let us impose an algebraic structure on :math:`T_œÉ (X)`, and then state and prove some basic facts about this important algebra. These will be formalized in :numref:`Chapter %s <inductively-defined-types>`, giving us a chance to show off inductively defined types in Lean.

If :math:`t` is a term, then the **height** of :math:`t` is denoted by :math:`|t|` and defined to be the least :math:`n` such that :math:`t ‚àà T_n`. The height of is a useful index for recursion and induction.

.. Let :math:`œÅ: T_œÉ(X) ‚Üí ‚Ñï` denote the **arity function for term**, defined as follows:
.. .. math:: œÅ t = \min \{n ‚à£t ‚àà T_n,\; 0‚â§ n < œâ\}.

Notice that :math:`T_œÉ (X)` is nonempty iff :math:`X ‚à™ F_0` is nonempty.

If :math:`T_œÉ (X)` is nonempty, then we can impose upon it an algebraic structure, which we denote by :math:`ùïã_œÉ (X)` (or :math:`ùïã` when :math:`œÉ` and :math:`X` are clear from context).

We call :math:`ùïã_œÉ (X)` the **term algebra in the signature** :math:`œÉ` **over** :math:`X` (or, the :math:`œÉ`-**term algebra over** :math:`X`); it is constructed as follows:

  For every basic operation symbol :math:`f ‚àà F` let :math:`f^ùïã` be the operation on :math:`T_œÉ (X)` that maps each tuple :math:`s: œÅ f ‚Üí T_œÉ (X)` to the formal term :math:`f\,s`; define :math:`ùïã_œÉ(X)` to be the algebra with universe :math:`T_œÉ (X)` and basic operations :math:`\{f^ùïã | f ‚àà F\}`. [5]_

Let us now prove a couple of easy but important consequences of these definitions.

.. about the :math:`œÉ`-term algebra over :math:`X`.

.. _obs-six:

.. proof:observation::

   #. :math:`ùïã := ùïã_œÉ(X)` is generated by :math:`X`.
 
   #. For every :math:`\sigma`-algebra :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` and function :math:`g: X ‚Üí A` there is a unique homomorphism :math:`h: ùïã ‚Üí ùî∏` such that :math:`h|_X = g`.
 
   .. container:: toggle
    
      .. container:: header
     
         *Proof*.
     
      The definition of :math:`ùïã` exactly parallels the construction in :numref:`Theorem %s <thm-1-14>`. That accounts for the first assertion.
     
      For the second assertion, define :math:`h\,t` by induction on the :term:`height` of :math:`|t|`.
     
      Suppose :math:`|t| = 0`.  Then :math:`t ‚àà X ‚à™ F_0`.
      
      If :math:`t ‚àà X`, then define :math:`h\,t = g\,t`. If :math:`t ‚àà F_0`, then let :math:`h\,t = t^ùî∏`.
     
      For the inductive step, assume :math:`|t| = n + 1`. Then :math:`t = f\,s` for some :math:`f ‚àà F` and :math:`s: œÅ f ‚Üí T_n`, where for each :math:`0 ‚â§ i< œÅ f` the term :math:`s\, i` has height at most :math:`n`. We define :math:`h\,t = f^ùî∏(h ‚àò s) = f^ùî∏(h\,s_1, \dots, h\,s_k)`.
     
      By its very definition, :math:`h` is a homomorphism that agrees with :math:`g` on :math:`X`. The uniqueness of :math:`h` follows from :numref:`Obs %s <obs-two>`. ‚òê

.. index:: interpretation (of a term), ! arity (of a term)

.. _interpretation-of-a-term:

Interpretation of a term
~~~~~~~~~~~~~~~~~~~~~~~~

..  and let :math:`T_n := T_œÉ(X_n)` be the subalgebra of :math:`T_œÉ(X_œâ)` generated by :math:`X_n`.  Then, :math:`T_0 ‚äÜ  T_1 ‚äÜ T_2 ‚äÜ \cdots` and :math:`T_œÉ(X_œâ) = ‚ãÉ_{n<œâ}  T_n`.

We denote and define the set :math:`X := \{x_0,x_1,\dots \}` of variable symbols, and for each natural number :math:`n` we let :math:`X_n:=\{x_0,x_1,\dots, x_{n-1}\}`.

Let :math:`œÉ = (F, œÅ)` be a signature, :math:`ùî∏` a :math:`œÉ`-algebra, and :math:`ùïã` the :math:`œÉ`-term algebra over :math:`X`; that is, 

.. math:: ùî∏ := ‚ü®A, F^ùî∏‚ü© \quad \text{ and } \quad ùïã := ‚ü®T_œÉ(X), F^ùïã‚ü©. 

Each operation symbol :math:`f ‚àà F` gives rise to

#.  a :math:`œÅ f`-ary operation on :math:`T_œÉ(X)`, denoted by :math:`f^ùïã`, which maps each :math:`œÅ f`-tuple :math:`s: œÅ f ‚Üí T_œÉ(X)` to the formal term :math:`f \,s` in :math:`T_œÉ(X)`, and

#.  a :math:`œÅ f`-ary operation on :math:`A`, denoted by :math:`f^ùî∏`, which maps each :math:`œÅ f`-tuple :math:`a: œÅ f ‚Üí A` to the element :math:`f^ùî∏ \,a` in :math:`A`. The operation :math:`f^ùî∏` is called the **interpretation of** :math:`f` **in the algebra** :math:`ùî∏`.  

In the present section we explain how to define the interpretation of a :math:`œÉ`-term in a :math:`œÉ`-algebra.

As usual, for each :math:`0<n<œâ` we identify the :math:`n`-tuple :math:`(x_0, x_1, \dots, x_{n-1})` with the function :math:`x: n ‚Üí X_n` defined by :math:`x\, i = x_i` :math:`(0‚â§i<n)`.

Recall, a term :math:`t` is either a variable, say, :math:`t = x`, or has the form :math:`t = f \,s` for some operation symbol :math:`f ‚àà F`, and some :math:`œÅ f`-tuple :math:`s: œÅ f ‚Üí T_œÉ (X)` of terms.

.. and suppose :math:`|t| = n`.
..  : (n ‚Üí X_n) ‚Üí T_n` be an :math:`n`-ary term. 

Let :math:`t ‚àà T_œÉ(X)` be a term. Define the **operation** :math:`t^ùî∏` **on** :math:`A` by recursion on the :term:`height` :math:`|t|` of :math:`t` as follows: for each tuple :math:`a: X ‚Üí A` of :math:`A`, 

#. (:math:`|t| = 0`) if :math:`t` is the variable :math:`x_i ‚àà X`, then :math:`t^ùî∏ \, a = œÄ^X_i\, a = a\, i`,
#. (:math:`|t| = n+1`) if :math:`t = f\, s` where :math:`f ‚àà F` is an operation symbol and :math:`s: œÅ f ‚Üí T_n` is a tuple of terms whose heights are at most :math:`n` (i.e., :math:`‚àÄ i < œÅf, |s\, i| ‚â§ n`), then :math:`t^ùî∏ = f^ùî∏ \, s^ùî∏`.
 
.. .. Let :math:`X_œâ := \{x_0, x_1, \dots\}` be a collection of variables and define :math:`X_n:=\{x_0, x_1, \dots, x_{n-1}\}`.

In the next observation, assume :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©` and :math:`ùîπ = ‚ü®B, F^ùîπ‚ü©` are algebras in the same signature :math:`œÉ = (F, œÅ)`, and let :math:`t ‚àà T_œÉ (X)` be an :math:`n`-ary term.

In particular, as we just explained, :math:`t` has an interpretation in :math:`ùî∏`, denoted by :math:`t^ùî∏ a = t^ùî∏ (a\, 0, a\, 1, \dots, a\, (n-1))`, where :math:`a: n ‚Üí A`, as well as an interpretation :math:`t^ùîπ: (n ‚Üí B) ‚Üí B` in :math:`ùîπ`.
    
.. _thm-4-32:

.. _obs-seven:

.. proof:observation:: homomorphisms commute with terms

   #. :math:`g: ùî∏ ‚Üí ùîπ` is a homomorphism, then :math:`g ‚àò a: n ‚Üí B` is the :math:`n`-tuple whose :math:`i`-th component is :math:`(g ‚àò a)\, i = g(a\, i)`, and
  
      .. math:: g(t^ùî∏ a) = t^ùîπ(g ‚àò a).

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      This is an easy induction on :math:`|t|`. ‚òê
    
.. _obs-eight:

.. proof:observation:: terms respect congruences

   If :math:`Œ∏` is a congruence of :math:`ùî∏` and :math:`a, a': n ‚Üí A` are :math:`n`-tuples over :math:`A`, then
    
   .. math:: (a, a') ‚àà Œ∏ \; ‚üπ  \; (t^ùî∏\,a, t^ùî∏\,a') ‚àà Œ∏.

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      This follows from :numref:`Obs %s <obs-seven>` by taking :math:`‚ü®B, F^ùîπ‚ü© = ‚ü®A, F^ùî∏‚ü©/Œ∏ = ‚ü®A/Œ∏, F^{ùî∏/Œ∏}‚ü©` and :math:`g=` the canonical homomorphism. ‚òê
    
.. _obs-nine:

.. proof:observation:: subuniverse generation as image of terms

   If :math:`Y` is a subset of :math:`A`, then

      .. math:: \Sg^{ùî∏}(Y) = \{ t^ùî∏ \, a ‚à£ t ‚àà T_œÉ(X_n), \, n ‚àà ‚Ñï, \; a: œÅ t ‚Üí Y\}.

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      A straightforward induction on the height of :math:`t` shows that every subuniverse is closed under the action of :math:`t^ùî∏`. Thus the right-hand side is contained in the left. On the other hand, the right-hand side is a subuniverse that contains the elements of :math:`Y` (take :math:`t = x_1`), so it contains :math:`\Sg^{ùî∏}(Y)` as the latter is the smallest subuniverse containing :math:`Y`. ‚òê

.. todo:: complete this section (include material on free algebras)

.. .. index:: ! Malcev condition, ! Taylor term
..
.. Special terms
.. ~~~~~~~~~~~~~~
.. .. _thm-4-3:
..
.. .. proof:theorem::
..
..    Let :math:`X` be a set and :math:`œÉ = (F, œÅ)` a signature. Define
..
..    .. math:: F_0 &= X;\\
..          F_{n+1} &= F_n ‚à™ \{ f g ‚à£ f ‚àà F, g : œÅf ‚Üí (F_n ‚à© (œÅ g ‚Üí X)) \}, \quad n < œâ.
..
..    Then :math:`\Clo ^X(F) = ‚ãÉ_n F_n`.
..
..
.. For a nonempty set :math:`A`, we let :math:`ùñÆ_A` denote the set of all finitary operations on :math:`A`. That is, :math:`ùñÆ_A = ‚ãÉ_{n‚àà ‚Ñï} A^{A^n}` on :math:`A` is a subset of :math:`ùñÆ_A` that contains all projection operations and is closed under the (partial) operation of :ref:`general composition <general-composition>`.
..
.. If :math:`ùî∏ = ‚ü® A, F^ùî∏ ‚ü©` denotes the algebra with universe :math:`A` and set of basic operations :math:`F`, then :math:`\Clo  (ùî∏)` denotes the clone generated by :math:`F`, which is also known as the **clone of term operations** of :math:`ùî∏`.
..
.. We will discuss varieties in more detail later, but for now define a :index:`variety` to be a collection of algebras of the same signature which is defined by a set of identities. [3]_ 
..   
.. In 1977, Walter Taylor showed (:cite:`Taylor1977`) that a variety ùïç satisfies some nontrivial :term:`idempotent` :term:`Malcev condition` if and only if it satisfies one of the following form: for some :math:`n`, ùïç has an idempotent :math:`n`-ary term  :math:`t` such that for each :math:`0 ‚â§ i < n` there is an identity of the form 
..
..    .. math:: t(‚àó, \cdots, ‚àó, x, ‚àó, \cdots, ‚àó) ‚âà t(‚àó, \cdots, ‚àó, y, ‚àó, \cdots, ‚àó)
..
.. that is true in ùïç and is such where distinct variables :math:`x` and :math:`y` appear in the :math:`i`-th position on each side of the identity. Such a term :math:`t` now goes by the name :index:`Taylor term`.

.. .. [3]
..   We will also have much to say about Malcev conditions, but for now we ask the reader to trust us when we say that such conditions play an important role in many deep results in universal algebra.

--------------------------

.. _basic-facts:

Basic facts
------------

.. Some of them involve homomorphisms, or terms, or clones.  

Throughout this section,

+ :math:`ùî∏ = ‚ü®A, F^ùî∏‚ü©, \ ùîπ = ‚ü®B, F^ùîπ‚ü©, \ ‚ÑÇ = ‚ü®C, F^‚ÑÇ‚ü©\ ` are algebras in the same signature :math:`œÉ = (F, œÅ)`, and

+ :math:`g, h : \hom(ùî∏, ùîπ)` are homomorphisms from ùî∏ to ùîπ;

.. index:: ! equalizer

The **equalizer** of :math:`g` and :math:`h` is the set

.. math:: ùñ§(g,h) = \{a: A ‚à£ g\, a = h\, a\}.

Here is a small collection of basic observations that we will need later. When we refer back to these, we will call them :numref:`Obs %s <obs-one>`, etc.

.. _obs-one:

.. proof:observation::

   :math:`ùñ§(g,h)` is a subuniverse of ùî∏.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.

      Fix arbitrary :math:`f ‚àà F` and :math:`a : œÅf ‚Üí ùñ§(g,h)`.

      We show that :math:`g (f^ùî∏ \, a) = h (f^ùî∏ \, a)`, as this will show that :math:`ùñ§(g, h)` is closed under the operation :math:`f^ùî∏` of :math:`ùî∏`.

      For all :math:`i<œÅ f` we have :math:`a \, i ‚àà ùñ§(g,h)`, so :math:`g\, a \, i= h\, a\, i`.  Therefore (by function extensionality) :math:`g ‚àò a = h ‚àò a` and so, by definition of homomorphism,

      .. math:: g  (f^ùî∏\,a) = f^ùîπ (g ‚àò a) = f^ùîπ (h ‚àò a) = h (f^ùî∏\, a).

      ‚òê

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-one>` is described in :numref:`equalizer-as-subuniverse`,  and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.

.. _obs-two:

.. proof:observation::

   If the set :math:`X ‚äÜ A` generates ùî∏ and :math:`g|_X = h|_X`, then :math:`g = h`.

   .. container:: toggle
    
      .. container:: header
  
         *Proof*.

      Suppose the subset :math:`X ‚äÜ A` generates :math:`‚ü®A, F^ùî∏‚ü©` and suppose :math:`g|_X = h|_X`.
 
      Fix an arbitrary :math:`a: A`. We show :math:`g\, a = h\, a`.
 
      Since :math:`X` generates ùî∏, there exists a term :math:`t` and a tuple :math:`x: œÅt ‚Üí X` of generators such that :math:`a = t^ùî∏\, x`.
 
      Therefore, since :math:`g|_X = h|_X`, we have
    
      .. math:: g ‚àò x = (g\, x_0, \dots, g\, x_{œÅ t}) = (h\, x_0, \dots, h\, x_{œÅ t}) = h ‚àò x,

      so

      .. math:: g\, a = g(t^ùî∏ \, x) = t^ùîπ (g ‚àò x) = t^ùîπ (h ‚àò x) = h(t^ùî∏ \,x) = h\, a.

      ‚òê

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-two>` is described in :numref:`homomorphisms-that-agree-on-a-generating-set`,  and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.

.. _obs-three:

.. proof:observation::

   If :math:`A, B` are finite and :math:`X` generates ùî∏, then :math:`|\hom(ùî∏, ùîπ)| ‚â§ |B|^{|X|}`.

   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      By :ref:`Obs 2 <obs-two>`, a homomorphism is uniquely determined by its restriction to a generating set.

      If :math:`X` generates ùî∏, then since there are exactly :math:`|B|^{|X|}` functions from :math:`X` to :math:`B` we have :math:`|\hom(ùî∏, ùîπ)| ‚â§ |B|^{|X|}`. ‚òê
    
.. _obs-four:

.. proof:observation::

   If :math:`g ‚àà \epi (ùî∏, ùîπ)`, :math:`h ‚àà \hom (ùî∏, ‚ÑÇ)`, and :math:`\ker g ‚äÜ \ker h`, then

   .. math:: ‚àÉ k ‚àà \hom(ùîπ, ‚ÑÇ), \ h = k ‚àò g.
    
   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      We define :math:`k ‚àà \hom(ùîπ, ‚ÑÇ)` as follows:

      Fix :math:`b ‚àà B`.

      Since :math:`g` is surjective, the set :math:`g^{-1}\{b\} ‚äÜ A` is nonempty, and since :math:`\ker g ‚äÜ \ker h`, it is clear that every element of :math:`g^{-1}\{b\}` is mapped by :math:`h` to a single element of :math:`C`.

      Label this element :math:`c_b`. That is, :math:`h(a) = c_b`, for all :math:`a ‚àà g^{-1}\{b\}`.
   
      For each such :math:`b`, and its associated :math:`c_b`, define :math:`k(b) = c_b`.
   
      The observant reader may have noticed a slight-of-hand in the foregoing "construction" of the function :math:`k`. While it's true that for each :math:`b ‚àà B` there exists a :math:`c_b` such that :math:`h(a) = c_b` for all :math:`a ‚àà g^{-1}\{b\}`, it's also true that we have no means of producing such :math:`c_b` constructively.
      
      One could argue that each :math:`c_b` is easily computed as :math:`c_b = h(a)` for some (every) :math:`a ‚àà g^{-1}\{b\}`. But this requires producing a particular :math:`a ‚àà g^{-1}\{b\}` to use as "input" to the function :math:`h`. How do we select such an element from the (nonempty) set :math:`g^{-1}\{b\}`?
      
      We must appeal to the Axiom of :term:`Choice` at this juncture and concede that the function :math:`k` will not be constructively defined. (We have more to say about this in :numref:`Sec %s <basic-facts-in-lean>` when we implement :numref:`Obs %s <obs-four>` in Lean.)  Nonetheless, we forge ahead (nonconstructively) and define :math:`k` as described above, using the Axiom of :term:`Choice` to compute a :math:`c_b` for each :math:`b ‚àà B`.
   
      It is then easy to see that :math:`k ‚àò g = h`.  Indeed, for each :math:`a ‚àà A`, we have :math:`a ‚àà g^{-1}\{g(a)\}`, so :math:`k(g(a)) = h(a)` by definition.

      Finally, to prove that :math:`k` is a homomorphism, fix an operation symbol :math:`f ‚àà F` and a tuple :math:`b: œÅ f ‚Üí B`; we will show that
      
      .. math:: f^‚ÑÇ (k ‚àò b) = k (f^ùîπ(b)).
         :label: hom1

      Let :math:`a: œÅ f ‚Üí A` be such that :math:`g ‚àò a = b`.  Then the left hand side of :eq:`hom1` is :math:`f^‚ÑÇ (k ‚àò g ‚àò a) = f^‚ÑÇ (h ‚àò a)`, which is equal to :math:`h (f^ùî∏ (a))` since :math:`h` is a homomorphism.
   
      Therefore,
   
      .. math:: 
      
         f^‚ÑÇ (k ‚àò b) &= f^‚ÑÇ (k ‚àò g ‚àò a) = f^‚ÑÇ (h ‚àò a)\\ 
                 & = h (f^ùî∏ (a)) = (k ‚àò g)(f^ùî∏ (a))\\
                 & = k (f^ùîπ (g ‚àò a)) = k (f^ùîπ (b)),

      as desired, where the penultimate equality holds by virtue of the fact that :math:`g` is a homomorphism. ‚òê

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-four>` is described in :numref:`factoring-homomorphisms`, and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.


---------------------------

.. rubric:: Footnotes

.. [1]
   For a brief and gentle introduction to type theory see the `section on axiomatic foundations <https://leanprover.github.io/logic_and_proof/axiomatic_foundations.html?highlight=type#type-theory>`_ in `Logic and Proof <https://leanprover.github.io/logic_and_proof/>`_.  Alternatively, viewing :math:`m  : \mathbb N` as roughly equivalent to :math:`n\in \mathbb N` is not totally unreasonable at this point.

.. [2]
   By "functional" we mean a function whose domain is a collection of functions.

.. [3]
   The term :math:`œÉ`-**algebra** has a special meaning, different from ours, in other areas of mathematics such as real analysis, probability, and measure theory.

.. [4]
   In retrospect, a more appropriate name for :math:`\mathbf{0} œÉ` might be :math:`Œî_œÉ`, or even :math:`=_œÉ`, but this may lead to conflicts with more standard notational conventions.

.. [5]
   By "the constants on :math:`A`" we mean the **constant operations**; i.e., functions :math:`f: A ‚Üí A` such that :math:`‚àÄ a ‚àà A, f(a) = c`, for some :math:`c ‚àà A`.

.. [6]
   The construction of :math:`ùïã_œÅ (X)` may seem to be making something out of nothing, but it plays an significant role in the theory.

.. include:: hyperlink_references.rst





.. include:: hyperlink_references.rst
