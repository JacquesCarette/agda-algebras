.. File: glossary_structures.rst
.. Author: William DeMeo <williamdemeo@gmail.com>
.. Date: 8 Dec 2019
.. Updated: 8 Dec 2019
.. Copyright (c) 2019 William DeMeo (see the LICENSE file)

.. include:: _static/math_macros.rst

.. role:: code

.. highlight:: lean

Glossary: structures, categories, varieties
-------------------------------------------

.. glossary:: 

    abelian group
      A :term:`group` is called **abelian** just in case its binary operation is commutative.
 
    absorbing
      Let 𝐀 be a finite algebra in a :term:`Taylor variety` 𝒱 and let t ∈ Clo(𝐀) be a :math:`k`-ary term operation of 𝐀.
      
      A subalgebra 𝐁 ≤ 𝐀 is said to be **absorbing** in 𝐀 with respect to the **absorbing term** :math:`t` if for all :math:`1 ≤ j ≤ k` and for all
      
      .. math:: (b_1, \dots, b_{j-1}, a, b_{j+1}, \dots, b_k) ∈ B^{j-1} × A × B^{k-j},
 
      we have
 
      .. math:: t^𝐀 (b_1, \dots, b_{j-1}, a, b_{j+1}, \dots, b_k) ∈ B.
 
      In other terms, :math:`t^𝐀[B^{j-1} × A × B^{k-j}] ⊆ B` for all :math:`1 ≤ j ≤ k`, where :math:`t^𝐀[D] := \{t^𝐀(x) : x ∈ D\}`.
 
      We denote the fact that 𝐁 is an absorbing subalgebra of 𝐀 with respect to some term by writing :math:`𝐁 \triangleleft 𝐀`. If we wish to be explicit about the term, we write :math:`𝐁 \triangleleft_t 𝐀`.
 
    absorption-free
      An algebra is said to be **absorption-free** if it has no proper :term:`absorbing` subalgebras.
 
    abstract category
      An **abstract category** is one whose objects are not sets or whose :term:`morphisms <morphism>` are not functions defined on sets.
 
    additive
      Let :math:`𝔐 = \{M_λ: λ∈ Λ\}` be a collection of sets and let :math:`R` be a :term:`ring`.  An :math:`R`-valued function :math:`s: 𝔐 → R` defined on the collection :math:`𝔐` is called **additive** if for every subset :math:`Γ ⊆ Λ` such that :math:`\{M_γ : γ ∈ Γ\}` is a subcollection of *pairwise disjoint* subsets in :math:`𝔐`, we have
 
      .. math:: s \bigl( ⋃_{γ∈Γ}  M_γ \bigr) = ∑_{γ∈ Γ} s (M_γ).
      
    adjoint
      Suppose that :math:`X` and :math:`Y` are :term:`normed linear spaces <normed linear space>` and :math:`T ∈ 𝔅(X, Y)` (a :term:`bounded linear transformation`). The **adjoint** (or **transpose**) of :math:`T` is denoted by :math:`T^†: Y^∗ → X^∗` and defined for each :math:`f∈ Y^∗` by :math:`T^† f = f T`.
      
      It is not hard to show that :math:`T^† ∈ 𝔅(Y^∗, X^∗)` and :math:`\|T^†\| = \|T\|`.
 
    algebra
      See :term:`structure`.
 
    algebra of functions
      Let :math:`F` be a :term:`field` and let :math:`F^X` denote the collection of all functions from :math:`X` to :math:`F`.  A subset :math:`𝔄 ⊆ F^X` of :math:`F`-valued functions on :math:`X` is called an **algebra** if it is closed under point-wise product.  That is, for all :math:`f, g ∈ 𝔄`, the function :math:`h = f ⋅ g` defined by :math:`h: x ↦ f(x) ⋅ g(x)` also belongs to :math:`𝔄`.
 
    algebra of sets
      Let :math:`X` be a nonempty set. An **algebra of sets** on :math:`X` is a nonempty collection :math:`𝔄` of subsets of :math:`X` that is :term:`closed <closed set>` under finite unions and complements. (Some authors call this a "field of sets.")
 
    algebraic lattice
      a :term:`lattice` generated by its :term:`compact elements <compact element>`. 
 
    algebraic signature
      By an **algebraic signature** (or **signature** for :term:`algebraic structures <algebraic structure>`) we mean a pair :math:`σ = (F, ρ)` that consists of a collection :math:`F` of *operation symbols* and an :term:`arity` function :math:`ρ : F → N` that maps each operation symbol to its arity; here, :math:`N` denotes the arity type (which is often, but not always, taken to be ℕ).
 
    algebraic structure
      An **algebraic structure** in the :term:`signature` :math:`σ = (F, ρ)` (or, :math:`σ`-**algebra**) is denoted by :math:`𝔸 = ⟨A, F^𝔸⟩` and consists of 
 
      #. :math:`A` := a set, called the *carrier* (or *universe*) of the algebra,
      #. :math:`F^𝔸 = \{ f^𝔸 ∣ f ∈ F, \ f^𝔸: (ρ f → A) → A \}` := a set of operations on :math:`A`, and
      #. a collection of identities satisfied by elements of :math:`A` and operations in :math:`F^𝔸`.
 
    antichain
      A subset :math:`A` of the :term:`preordered <preorder>` set :math:`X` is called an **antichain** if for all :math:`x, y ∈ A` we have :math:`x ≤ y` implies :math:`y ≤ x`.
 
    antisymmetric
      A binary relation :math:`R` on a set :math:`X` is called **antisymmetric** provided :math:`∀  x, y ∈ X \ (x \mathrel{R} y ∧ y\mathrel{R} x \ → \ x=y)`.
 
    arity
      Given a :term:`signature` :math:`σ = (F, ρ)`, each operation symbol :math:`f ∈ F` is assigned a value :math:`ρ f`, called the **arity** of :math:`f`. (Intuitively, the arity can be thought of as the "number of arguments" that :math:`f` takes as "input".)
 
    associative algebra
      If :math:`𝔸` is a :term:`bilinear algebra` with an associative product---:math:`(a ⋅ b) ⋅ c = a ⋅ (b ⋅ c)` for all :math:`a, b, c ∈ A`---then :math:`𝔸` is called an **associative algebra**.
      
      Thus an associative algebra over a field has both a :term:`vector space` :term:`reduct` and a :term:`ring` :term:`reduct`.
      
      An example of an associative algebra is the space of :term:`linear transformations <linear transformation>` (:term:`endomorphisms <endomorphism>`) of a vector space into itself.
 
    bilinear algebra
      Let :math:`𝔽= ⟨ F, 0, 1, -\, , +, ⋅⟩` be a field. An algebra :math:`𝔸 = ⟨ A, 0, -\, , +, ⋅, f_r⟩_{r∈ F}` is a **bilinear algebra** over :math:`𝔽` provided :math:`⟨A, 0, -, +, ⋅, f_r⟩_{r ∈ F}` is a :term:`vector space` over :math:`𝔽` and for all :math:`a, b, c ∈ A` and all :math:`r ∈ F`, we have
 
      .. math::   (a + b) ⋅ c &= (a ⋅ c) + (b ⋅ c)\\
                  c ⋅ (a + b) &= (c⋅ a) + (c⋅ b)\\
                   a⋅  f_r(b) &= f_r(a⋅ b) = f_r(a)⋅ b.
 
      If, in addition, :math:`(a ⋅ b) ⋅ c = a ⋅ (b ⋅ c)` for all :math:`a, b, c ∈ A`, then :math:`𝔸` is called an **associative algebra over** :math:`𝔽`. Thus an associative algebra over a field has both a vector space reduct and a ring reduct. An example of an associative algebra is the space of linear transformations (endomorphisms) of any vector space into itself.
 
    binary operation
      An operation :math:`f` on a set :math:`A` is called **binary** if the arity of :math:`f` is 2.  That is, :math:`f: A × A → A` (or, in curried form, :math:`f: A → A → A`).
 
    Boolean algebra
      A **Boolean algebra** is a :term:`lattice` L equipped with a unary operation ¬: L → L satisfying

      .. math:: a ∧ b ≤ c \quad ⟺ \quad a ≤ ¬b ∨ c

      See also: https://ncatlab.org/nlab/show/Boolean+algebra

    Boolean algebra homomorphism
      a :term:`lattice homomorphism` that also preserves complementation (but every lattice homomorphism between Boolean lattices automatically preserves complementation, so we may characterize the morphisms of this category more simply as the lattice homomorphisms).
 
    Cartesian product
      See :term:`product`.
 
    category of categories
      has categories as objects and :term:`functors <functor>` as :term:`morphisms <morphism>`.
 
    category of small categories
      See :term:`Cat`.
 
    chain
      Let :math:`⟨ X, ≤ ⟩` be a :term:`preordered <preorder>` set and :math:`C ⊆ X`. We call :math:`C` a **chain** of :math:`⟨ X, ≤ ⟩` if for all :math:`x, y ∈ C` either :math:`x ≤ y` or :math:`y ≤ x` holds.
 
    characteristic function
      The **characteristic function** :math:`χ_A` of a subset :math:`A ⊆ X` is the function :math:`χ_A: X → \{0,1\}` that is 1 if and only if :math:`x ∈ A`; that is, :math:`χ_A(x) = 0` if :math:`x ∉ A` and :math:`χ_A(x) = 1` if :math:`x ∈ A`.
 
    Choice
      is short for the `Axiom of Choice <https://en.wikipedia.org/wiki/Axiom_of_choice>`_.
 
    clone
      An **operational clone** (or just **clone**) on a nonempty set :math:`A` is a set of operations on :math:`A` that contains all :term:`projection operations <projection operation>` and is closed under :term:`general composition`.
 
    closed set
      If :math:`𝖢` is a :term:`closure operator` on :math:`X`, then a subset :math:`A ⊆ X` is called **closed** with respect to :math:`𝖢` (or :math:`𝖢`-**closed**) provided :math:`𝖢(A) ⊆ A` (equivalently, :math:`𝖢(A) = A`).
 
      Here's an important example. Let :math:`σ = (F, ρ)` be a :term:`signature` and :math:`X` a set. Define for each :math:`A ⊆ X` the set :math:`𝖢(A) = \{f\, b ∣ f ∈ F, \, b: ρ f → A\}`.  Then :math:`𝖢` is a closure operator on :math:`X` and a subset :math:`A ⊆ X` is said to be "closed under the operations in :math:`F`" provided :math:`A` is :math:`𝖢`-closed.
 
    closed term
      A :term:`term` is said to be **closed** (or **constant**) if it contains no :term:`free variables <free variable>`. In particular, every constant symbol in the set 𝐂 of a :term:`signature` is a closed term.
 
    closure
       If :math:`X` is a :term:`metric <metric space>` or :term:`topological space` then the **closure** of a subset :math:`E ⊆ X` is denoted by :math:`Ē` and defined to be the smallest :math:`closed` subset of :math:`X` containing :math:`E`.
       
       The closure :math:`Ē` exists since the collection :math:`Ω` of all closed subsets of :math:`X` which contain :math:`E` is not empty (since :math:`X ∈ Ω`), so define :math:`Ē` to be the intersection of all members of :math:`Ω`.
 
       Here is an alternative, equivalent definition. The **closure** of :math:`E` is the intersection of all :term:`closed <closed set>` sets containing :math:`E`.
 
    closure operator
      Let :math:`X` be a set and let :math:`𝒫(X)` denote the collection of all subsets of :math:`X`. A **closure operator** on :math:`X` is a set function :math:`𝖢: 𝒫 (X) → 𝒫 (X)` satisfying the following conditions, for all :math:`A, B ∈ 𝒫 (X)`, 
 
      #. :math:`A ⊆ 𝖢(A)`,
      #. :math:`𝖢 ∘ 𝖢 = 𝖢`,
      #. :math:`A ⊆ B ⟹ 𝖢(A) ⊆ 𝖢(B)`.
 
    cocomplete
      See :term:`cocomplete poset`.
 
    cocomplete poset
      A :term:`poset` in which all joins exist is called **cocomplete**.
 
    codomain
      If f: A → B is a function or relation from A to B, then B is called the **codomain** of f, denoted by cod f.
 
    commutative diagram
      A **commutative diagram** is a diagram with the following property: for all objects C and D, all paths from C to D yield the same :term:`morphism`.
 
    commutative group
      See :term:`abelian group`.
 
    compact element
      an element :math:`x` of a :term:`lattice` :math:`L` is called **compact** provided for all :math:`Y ⊆ L`, if :math:`x ≤ ⋁ Y`, then there exists a finite subset :math:`F ⊆ Y` such that :math:`x ≤ ⋁ F`.
 
    complete
      A :term:`poset` in which all meets exist is called **complete**.
 
    complete lattice
      a :term:`poset` whose universe is closed under arbitrary meets and joins.
 
    complete lattice homomorphism
      A **complete lattice homomorphism** is a function :math:`f: X → Y` that preserves complete meets and joins.
 
    complete poset
      A :term:`poset` in which all meets exist is called **complete**.
 
    component    
      If :math:`α : F ⇒ G` is a :term:`natural transformation`, then the **component** of α at :math:`A` is the :term:`morphism` :math:`α_A : FA → GA`.
 
    composition of operations
      If :math:`f: (n → A) → A` is an :math:`n`-ary operation on the set :math:`A`, and if :math:`g: ∏_{(i:n)} ((k_i → A) → A)` is an :math:`n`-tuple of operations, then we define the **composition of** :math:`f` **with** :math:`g`, using the :term:`eval` and :term:`fork` operations, as follows:
   
      .. math:: f [g] := f\, (\mathbf{eval} \, \mathbf{fork}\, g): ∏_{(i:n)}(k_i → A) → A.
   
      Indeed, 
      
      .. math:: \mathbf{eval} \, \mathbf{fork} \, g: ∏_{(i:n)}(k_i → A) → (n → A)
      
      is the function that maps each :math:`a: ∏_{(i:n)}(k_i → A)` to :math:`∏_{(i:n)}\mathbf{eval} \,(g \, i, a\, i) = g ∘ a`, where for each :math:`(i:n)` :math:`(g ∘ a)(i) = (g i)(a i): A`.
      
      Thus, if :math:`a: ∏_{(i:n)}(k_i → A)`, then :math:`(\mathbf{eval} \, \mathbf{fork} \, g) (a)` has type :math:`n → A`, which is the domain type of :math:`f`.  Therefore, :math:`f \, (\mathbf{eval} \, \mathbf{fork}\, g)\, (a)` has type :math:`A`.
 
    concrete category
      A **concrete category** is one whose objects are sets and whose :term:`morphisms <morphism>` are functions defined on these sets (possibly satisfying some other special properties).
 
    congruence-permutable
      An :term:`algebraic structure` is called **congruence-permutable** if every pair of its congruences :term:`permute <permuting relations>`.
      
      A :term:`variety` is **congruence-permutable** if all of its members are congruence-permutable.

    constant term
      See :term:`closed term`.
 
    consecutive functions
      If :math:`f : A → B` and :math:`g : B → C`, then :math:`\cod f = \dom g` and we say that :math:`f` and :math:`g` are **consecutive functions**.
 
    contravariant powerset functor
      The **contravariant powerset functor** is a functor :math:`P^{\mathrm{op}}: \mathbf{Set} → \mathbf{Set}` such that for each :term:`morphism` :math:`g: B → A` the morphism :math:`P^{\mathrm{op}}g: 𝒫(A) → 𝒫(B)` is given by :math:`P^{\mathrm{op}} g (S) = \{b ∈ B : g(b) ∈ S\}` for each :math:`S ⊆ A`.
 
    coproduct
      Given two objects :math:`A` and :math:`B` a **coproduct** (or **sum**) of :math:`A` and :math:`B` is denoted by :math:`A+B` and defined to be an object with morphisms :math:`ι_1 : A → A + B` and :math:`ι_2 : B → A + B` such that for every object :math:`X` and all morphisms :math:`u : A → Y` and :math:`v : B → Y` there exists a unique morphism :math:`[u,v] : A+B → Y` such that :math:`[u,v] ∘ ι_1 = u` and :math:`[u,v] ∘ ι_2 = v`.
 
    countably additive
      Let :math:`𝒮 = \{S_λ: λ∈ Λ\}` be a collection of sets and let :math:`R` be a :term:`ring`.  A function :math:`s: 𝒮 → R` is called **countably additive** if for every *countable* subset :math:`Γ ⊆ Λ` such that :math:`\{S_γ : γ ∈ Γ\}` is a collection of *pairwise disjoint* subsets in :math:`𝒮`, we have
 
     .. math:: s \bigl( ⋃_{γ∈Γ}  A_γ \bigr) = ∑_{γ∈ Γ} s (A_γ).
 
    countably subadditive
      Let :math:`𝒮 = \{S_λ: λ∈ Λ\}` be a collection of sets and let :math:`R` be a :term:`ring`.  A function :math:`s: 𝒮 → R` is called **countably subadditive** if for every *countable* subset :math:`Γ ⊆ Λ` such that :math:`\{S_γ : γ ∈ Γ\}` is a collection of subsets in :math:`𝒮`, we have
 
    covariant powerset functor
      The **(covariant) powerset functor** is a functor :math:`P : \mathbf{Set} → \mathbf{Set}` such that for each :math:`f : A → B` the morphism :math:`Pf : PA → PB` is given by :math:`Pf(S) = \{f(x) : x ∈ S\}` for each :math:`S \subseteq A`.
 
    directed cocomplete poset
      an :term:`antisymmetric` :term:`directed cocomplete preorder`.
 
    directed cocomplete preorder
      a :term:`preorder` for which the joins of all :term:`directed <directed set>` subsets exist. 
      
    directed graph
      A **directed graph** is a :term:`relational structure` consisting of a vertex set :math:`V` (whose elements are called vertices) and an edge set :math:`E ⊆ V^2` (whose elements are called edges).
 
    directed set
      A subset :math:`D` of a :term:`preorder` is called **directed** if every finite subset of :math:`D` has an upper bound in :math:`D`. That is, if :math:`F ⊆ D` and :math:`F` is finite, then there exists :math:`d ∈ D` such that :math:`f ≤ d` for all :math:`f ∈ F`.
 
    division ring
      A :term:`ring` in which every nonzero element is a unit is called a **division ring**.
 
    domain
      If f : A → B is a function or relation from A to B, then A is called the **domain** of f, denoted by dom f.
 
    dual
      If :math:`X` is a :term:`normed linear space` over the :term:`field` :math:`F`, then the collection :math:`𝔅(X,F)` of :term:`bounded linear functionals <bounded linear functional>` is called the **dual space** (or **dual**) of :math:`X`.
 
      If :math:`F` is :term:`complete`, then :math:`𝔅(X,F)` is complete, hence a :term:`Banach space`.
 
    edge term
      Let 𝒱 be a variety and k>1, an integer. A (k+1)-ary term t is called a **k-edge term** for 𝒱 if the following k identities hold in 𝒱:
 
      .. math:: t(y,y,x,x,x,\dots,x) &≈ x\\
                t(y,x,y,x,x,\dots,x) &≈ x\\
                t(x,x,x,y,x,\dots,x) &≈ x\\
                &⋮ \\
                t(x,x,x,x,x,\dots,y) &≈ x.
 
      Clearly every edge term is :term:`idempotent <idempotent term>` and a :term:`Taylor term`; also, every :term:`Maltsev term` and every :term:`near unanimity term` is an edge term.
      
    endofunctor
      A :term:`functor` that maps a category to itself is called an **endofunctor**.
 
    endomorphism
      A :term:`morphism` from a structure to itself---say, f: 𝔸 → 𝔸 (i.e., dom f = cod f)---is called an **endomorphism**.
 
    epimorphism
      A :term:`morphism` :math:`f: X → Y` is called an **epimorphism** if for every object :math:`Z` and pair :math:`g_1, g_2: Y → Z` of morphisms we have :math:`g_1 ∘ f = g_2 ∘ f` implies :math:`g_1 = g_2`. When :math:`f: X → Y` is an **epimorphism** we often say ":math:`f` is epi" and write :math:`f: X ↠ Y`.
 
    equivalence class
      If :math:`R` is an :term:`equivalence relation` on :math:`A`, then for each :math:`a ∈ A`, there is an **equivalence class** containing :math:`a`, which is denoted and defined by :math:`a/R = \{b ∈ A ∣ a \mathrel R b\}`.
 
    equivalence relation
      An **equivalence relation** is a :term:`symmetric` :term:`preorder`. The collection of all equivalence relations on :math:`X` is denoted by :math:`\mathrm{Eq}(X)`.
 
    equivalent categories
      Two categories :math:`\mathcal C` and :math:`\mathcal D` are called **equivalent categories** if there are functors :math:`F : \mathcal C →  \mathcal D` and :math:`G : \mathcal D → \mathcal C` together with natural isomorphisms :math:`ε : FG ≅ \mathrm{id}_{\mathcal D}`, and :math:`η : \mathrm{id}_{\mathcal C} ≅ GF`. We say that :math:`F` is an equivalence with an inverse equivalence :math:`G` and denote the equivalence by :math:`F : \mathcal C ≃ \mathcal D : G`.
 
    essentially surjective on objects
      A functor :math:`F : C → D` is called **essentially surjective on objects** if for every object :math:`D ∈ \mathcal D`, there is some :math:`A ∈ \mathcal C` such that :math:`F A` is isomorphic to :math:`D`.
 
    Euclidean norm
      For :math:`𝐱 = (x_1,\dots, x_n) ∈ ℝ^n` the **Euclidean norm** of :math:`𝐱` is denoted and defined by :math:`\|𝐱\|_2 = \left(∑_{i=1}^n x_i^2\right)^{1/2}`.
 
    Euclidean space
      For :math:`n∈ ℕ` the :term:`normed linear space` :math:`(ℝ^n, \|\,⋅\,\|_2)`, where :math:`\|\,⋅\,\|_2` is the :term:`Euclidean norm`, is called :math:`n`-dimensional **Euclidean space**.
 
    evaluation functor
      The **evaluation functor** is the functor :math:`Ev : \mathcal C × \mathbf{Set}^{\mathcal C} → \mathbf{Set}`, which takes each pair :math:`(A, F) ∈ \mathcal C_{\mathrm{obj}} × \mathbf{Set}^{{\mathcal C}_{\mathrm{obj}}}` of objects to the set :math:`Ev(A, F) = FA`, and takes each pair :math:`(g, μ) ∈ \mathcal C_{\mathrm{obj}} × \mathbf{Set}^{\mathcal C_{\mathrm{mor}}}` of morphisms to a function on sets, namely, :math:`Ev(g, μ) = μ_{A'} ∘ F g = F' g ∘ μ_A`, where :math:`g ∈ \mathcal C(A, A')` and :math:`μ : F ⇒ F'`.
 
    evaluation natural transformation
      The **evaluation natural transformation** is denoted by :math:`eval^A : F_A →  \mathrm{id}_{\mathbf{Set}}` and defined by... (**Todo** complete definition)
 
    existential image functor
      the functor :math:`∃ f : P(A) → P(B)` defined by :math:`∃ f(X) = \{f(x) : x ∈  X\},` for :math:`X ∈ P(A)`.
 
    faithful functor
      A functor :math:`F : \mathcal C → \mathcal D` is called **faithful** if for all objects :math:`A`, :math:`B` in :math:`\mathcal C_{\mathrm{obj}}`, the map :math:`\mathcal C(A, B) → \mathcal D(F A, F B)` is injective.
      
      (Note: A faithful functor need not be injective on morphisms.)
 
    field
      A **field** is a commutative :term:`division ring`.
      
    filter
      A subset F of a partially ordered set (P, ≤) is a **filter** if the following conditions hold:
 
        * F is non-empty.
        * ∀ x, y ∈ F, x ∧ y ∈ F.
        * ∀ x ∈ F, ∀ y ∈ P, x ≤ y → y ∈ F.
 
      A filter is a **proper filter** if it is not equal to the whole set P. (Some authors add this last condition to the definition of a filter.)
 
      The dual notion is called an :term:`order ideal`.
 
    finite ordinals
      The category :math:`\mathrm{Ord}_{\mathrm{fin}}` of **finite ordinals** (also called the **simplex category** :math:`\Delta`) has :math:`\underline n = \{0, 1, \dots, n-1\}` for objects (for each :math:`n ∈ ℕ`) and :math:`f : \underline n → \underline m` :term:`monotone functions <monotone function>` for morphisms.
 
    finite set
      A set is called **finite** if it contains only a finite number of elements.
 
    finitely generated variety
      A :term:`variety` is called **finitely generated** if it is of the form :math:`𝒱(K)` where :math:`K` is a finite set of finite algebras.
      
    first category
      A set :math:`G` is of the **first category** if it is a countable union of :term:`nowhere dense` sets.
 
    free algebra
      The **free algebra** in a :term:`variety` is the :term:`initial object` in a category whose objects are :term:`algebraic structures <algebraic structure>`.
      
      Precisely, if :math:`𝒱` is a :term:`variety` of :term:`algebras <algebraic structure>` and if :math:`X` is a set, then the **free algebra** generated by :math:`X` is denoted by :math:`𝔽(X)` and defined as follows: for every algebra :math:`𝔸 ∈ 𝒱` and every function :math:`f: X → A`, there exists a unique :term:`homomorphism` :math:`h: 𝔽(X) → 𝔸` such that :math:`∀ x ∈ X, h(x) = f(x)`.  We say that :math:`𝔽(X)` is "universal", or "has the :term:`universal mapping property`", for :math:`𝒱`
 
    free object
      See :term:`initial object`.
 
    free monoid
      The **free monoid** is the :term:`initial object` in a category of :term:`monoids <monoid>`.
 
    free variable
      A variable that is not :term:`bound <bound variable>` by a quantifier is called a **free variable**.
     
      A formula in first-order logic is an assertion about the free variables in the formula.
     
      For example, if the "domain of discourse" is the set of natural numbers, then the formula :math:`∀ y \; (x ≤ y)` asserts that :math:`x` is less or equal every natural number.
     
      This is logically equivalent (more precisely, "α-equivalent") to the formula :math:`∀ z \; (x ≤ z)`.  
     
      On the other hand, the formula :math:`\forall y (w \le y)` says that :math:`w` is less than or equal to every natural number. This is an entirely different statement: it says something about :math:`w`, rather than :math:`x`. So renaming a *free* variable changes the meaning of a formula.
 
    full embedding
      a :term:`fully faithful functor` that is injective on objects.
 
    full functor
      A functor :math:`F : \mathcal C → \mathcal D` is called **full** if for all objects :math:`A`, :math:`B` in :math:`\mathcal C`, the map :math:`\mathcal C(A, B) → \mathcal D(F A, F B)` is surjective.
      
      (N.B. A full functor need not be surjective on morphisms.)
 
    full subcategory
      If there exists a :term:`full embedding` :math:`F : \mathcal C → \mathcal D`, then :math:`\mathcal C` is called a **full subcategory** of :math:`\mathcal D`.
 
    fully faithful functor
      a functor that is both :term:`full <full functor>` and :term:`faithfull <faithful functor>`.
 
    function application
      See :term:`eval`.
 
    functor
      A **functor** F: 𝒞 → 𝒟 consists of a function :math:`\mathrm F_0` that maps objects of 𝒞 to objects of 𝒟 and a function :math:`\mathrm F_1` that maps morphisms of 𝒞 to morphisms of 𝒟 such that F preserves (co)domains of morphisms, identities, and compositions.
 
    functor category
      The **functor category** from 𝒞 to 𝒟 has functors F: 𝒞 → 𝒟 as objects and natural transformations α: F ⇒ G as morphisms.
 
    Galois connection
      See https://en.wikipedia.org/wiki/Galois_connection.
 
    Galois pair
      See https://en.wikipedia.org/wiki/Galois_connection.
 
    general composition
      See :term:`composition of operations`.
 
    generalized element
      A :term:`morphism` h: X → A is sometimes called a **generalized element** of A.
      
      A morphism f is a :term:`monomorphism` when it is injective on the generalized elements of its domain.
 
    global element
      See :term:`point`.
 
    graph morphism
      Let :math:`𝐆_1 =(V_1, E_1)` and :math:`𝐆_2 = (V_2, E_2)` be graphs. We say that a pair of functions :math:`f=(f_v,f_e)` is a **graph morphism** from :math:`𝐆_1` to :math:`𝐆_2` provided :math:`f_v : V_1 → V_2`, :math:`f_e : E_1 → E_2`, and for any edge :math:`e = (v_1,v_2) ∈ E_1` we have that we have :math:`f_e(e) = (f_v(v_1), f_v(v_2))`.
 
    group
      A **group** is a :term:`monoid` expanded with a unary operation :math:`^{-1}`, called *multiplicative inverse*, which satisfies :math:`∀ a ∈ A`, :math:`a ⋅ a^{-1} =  a^{-1} ⋅ a = e`.
 
    groupoid
      See :term:`magma`.
 
    height
      If :math:`w` is a term, then the **height** of :math:`w` is denoted by :math:`|w|` and defined to be the least :math:`n` such that :math:`w ∈ T_n`.
 
      If :math:`α` is a type, then we sometimes refer to the **height** of :math:`α`, by which we mean the *universe level* of :math:`α`
      
      (See the :ref:`appendix section on Lean's type hierarchy <leans-type-hierarchy>`.)
 
    Heyting algebra
      A **Heyting algebra** :math:`⟨L, ∧, ∨, ⊥, ⊤, →⟩` is a bounded :term:`lattice` with least and greatest elements ⊥ and ⊤, and a binary "implication" → that satisfies :math:`∀ a, b, c ∈ L, \ (c ∧ a ≤ b \ ⟺ \ c ≤ a → b)`.  Logically, this says a → b is the weakest proposition for which the modus ponens rule, :math:`\{a → b, a\} ⊢ b`, is sound. The class of Heyting algebras forms a variety that is finitely axiomatizable.
   
    Heyting algebra homomorphism
      a :term:`lattice homomorphism` that also preserves Heyting implications; that is, if :math:`x, x' ∈ X`, then :math:`f(x → x') = f(x) → f(x')`.
 
    hom set
      Some authors require that :math:`\mathcal C(A,B)` always be a set and call :math:`\mathcal C(A,B)` the **hom set** from :math:`A` to :math:`B`.
 
    homomorphism
      See :term:`morphism` and :term:`relational structure homomorphism`.
 
    ideal
      See :term:`order ideal`.
 
    idempotent algebra
      If :math:`𝐀 = ⟨A, F^𝐀⟩` is an algebraic structure and if every basic operation :math:`f ∈ F^𝐀` is :term:`idempotent <idempotent operation>`, then we call 𝐀 an **idempotent algebra**.
 
    idempotent operation
      An operation :math:`f: A^n → A` is called **idempotent** provided :math:`f(a, a, \dots, a) = a` for all :math:`a ∈ A`. That is, :math:`f` maps constant tuples to their constant image value.
      
      Equivalently, if the operation is presented in "curried," say, :math:`f: (ρ f → A) → A`, then we call :math:`f` idempotent iff for each constant tuple :math:`a: ρ f → A` (say, :math:`a\, i = c, ∀ i`) we have :math:`f\, a = c`.
 
    idempotent term
      A term :math:`t` in a variety 𝒱 is called **idempotent** provided :math:`t(s, s, \dots, s) = s` holds for all terms :math:`s` in 𝒱.
 
    idempotent variety
      If every term in a variety is :term:`idempotent <idempotent term>`, then we call the variety **idempotent**.  Equivalently, a variety 𝒱 is idempotent iff every algebra in 𝒱 is an :term:`idempotent algebra`.
 
    initial object
      An object :math:`0` in a category is called the **initial object**  (or **free object**) if for every object :math:`A` in the category there exists a unique morphism :math:`!_A: 0 → A`.
      
      The :term:`free algebra` in a :term:`variety` is a **free object** in a category whose objects are :term:`algebraic structures <algebraic structure>`.
     
    inner product 
      Let :math:`X` be a :term:`vector space` over the field :math:`F`.  An **inner product** on :math:`X` is a function :math:`⟨·,·⟩: X × X → F` satisfying the following conditions:
 
      #. :math:`⟨⋅,⋅⟩` is linear in the first variable; i.e., :math:`⟨α x + βy, z⟩ = α⟨x,z⟩ + β⟨y,z⟩` for all :math:`α, β ∈ F` and :math:`x, y, z ∈ X`;
      #. :math:`⟨⋅,⋅⟩` is symmetric; i.e., :math:`⟨x, y⟩ = ⟨y, x⟩` for all :math:`x, y ∈ X`; and
      #. :math:`⟨x, x⟩ ≥ 0` for each :math:`x∈ X` and :math:`⟨x, x⟩ = 0` if and only if :matH:`x = 0`.
 
    inner product space
      An **inner product space** is a vector space equipped with an :term:`inner product`.
 
    isomorphism
      A morphism :math:`f: A → B` is called an **isomorphism** if there exists a morphism :math:`g: A → B` such that :math:`g ∘ f= \mathrm{id}_A` and :math:`f ∘ g = \mathrm{id}_B`. We write :math:`f^{-1}` to denote :math:`g` when it exists.
 
    kernel
      By the **kernel** of a function :math:`f: A → B` we mean the binary relation on :math:`A` denoted and defined by :math:`\mathrm{ker} f := \{(a₁, a₂) : f a₁  = f a₂\}`.   
 
    Kleene closure
      See :term:`free monoid`.
 
    language
      The **language** :math:`L = L(σ)` of the signature σ is the set of all :term:`σ-formulas <formula>`.
 
      Every language :math:`L` comes equipped with a countable supply of variables.
      
      If σ =  so the cardinality of :math:`L` is :math:`|L| = \max \{ℵ_0, |𝐂 ∪ 𝐅 ∪ 𝐑|\}`.
 
    lattice
      a :term:`poset` whose universe is closed under all *finite* meets and joins is called a lattice.
     
    lattice homomorphism
      a function :math:`f: X → Y` preserving finite meets and joins.
 
    left module
       See :term:`module`.
 
    lift (n)
      See :term:`lifts (v)`
 
    lifts (v)
      For :math:`ρ ⊆ α × α`, and :math:`f: α → β`, we say that :math:`f` **lifts** to a function on the quotient :math:`α/ρ` provided the following implication holds for all :math:`x y: α`: if :math:`ρ x y` then :math:`f x = f y`.  The function to which :math:`f` lifts is called the **lift** of :math:`f`.
 
    linked product
      A product :math:`R ≤ A_0 × A_1` is called **linked** if it satisfies the following: for all :math:`a, a' ∈ \mathrm{Proj}_0 R` there exist elements :math:`c_0, c_2, \dots, c_{2n} ∈ A_0` and :math:`c_1, c_3, \dots, c_{2n+1} ∈ A_1` such that :math:`c_0 = a`, :math:`c_{2n} = a'`, and for all :math:`0≤ i<n`,
      
      .. math:: (c_{2i},c_{2i+1})∈ R \quad \text{ and } \quad (c_{2i+2},c_{2i+1}) ∈ R.
 
      Here is an easily proved fact that provides equivalent ways to define "linked."
 
      **Lemma**. Let :math:`R ≤ A_0 × A_1`, let :math:`η_{R_i} = \ker(R ↠ A_i)` denote the kernel of the projection of :math:`R` onto its i-th coordinate, and let :math:`R^{-1} = \{(y,x) ∈ A_1 × A_0 : (x,y) ∈ R\}`. Then the following are equivalent:
        
        #. :math:`R` is linked;
        #. :math:`η_{R_0} ∨ η_{R_1} = 1_R`;
        #. if :math:`a, a' ∈ \mathrm{Proj}_0 R`, then :math:`(a,a')` is in the transitive closure of :math:`R ∘ R^{-1}`.
 
    locally finite algebra
      An :term:`algebra` is called **locally finite** if every finitely generated subalgebra is finite.
      
    locally finite variety
      A :term:`variety` is **locally finite** if every member is :term:`locally finite <locally finite algebra>`.
 
    locally small category
      A category 𝒞 is **locally small** if for every pair A, B of objects in 𝒞 the collection of :term:`morphisms <morphism>` from A to B is a set.
 
    magma
      An algebra with a single binary operation is called a **magma** (or **groupoid** or **binar**). The operation is usually denoted by :math:`+` or :math:`⋅`, and we write :math:`a+b` or :math:`a ⋅ b` (or just :math:`ab`) for the image of :math:`(a, b)` under this operation, which we call the *sum* or *product* of :math:`a` and :math:`b`, respectively.
 
    Maltsev class
      We can formalize the notion of Maltsev condition through that of interpretation.
      
      Write 𝒱 ≤ 𝒲 if there is an :term:`interpretation` of the variety 𝒱 in the variety 𝒲. 
      
      Observe, this ≤ relation is reflexive and transitive, but it is not anti-symmetric. (For example there are interpretations of rings into Abelian groups and vice versa, but the two varieties are not even :term:`term-equivalent`.)

      For a fixed, :term:`finitely based` variety 𝒲, the **strong Maltsev class** defined by 𝒲 is the class of all varieties 𝒱 such that 𝒲 ≤ 𝒱.
      
      The class of congruence-permutable varieties is an example of a strong Maltsev class.

      A **Maltsev class** is defined by an infinite sequence 𝒲₀ ≥ 𝒲₁ ≥ 𝒲₂ ≥ ... of finitely based varieties, and 𝒱 belongs to the Maltsev class if, for some :math:`i<ω, 𝒱 ≥ 𝒲`. (Congruence-distributivity is an example.)
      
      Finally, a **weak Maltsev class** is the intersection of a countable family of Maltsev classes.

    Maltsev term
      See :term:`Maltsev term`

    Maltsev product
      Let 𝒱 and 𝒲 be idempotent varieties. The **Maltsev product** (or **Maltsev  product**) of 𝒱 and 𝒲 is the class
 
      .. math:: 𝒱 ∘ 𝒲 = \{𝐀 : ∃ θ ∈ \mathrm{Con} 𝐀, (𝐀/θ ∈ 𝒲 \text{ and } ∀ a ∈ A, a/θ ∈ 𝒱)\}.
 
      𝒱 ∘ 𝒲 is always an idempotent quasivariety, but is generally not closed under homomorphic images.
      
      Freese and McKenzie show in :cite:`Freese:2017` that a number of important properties are preserved under Maltsev product; in particular, they prove,
 
      **Theorem**. Let 𝒱 and 𝒲 be idempotent varieties. For each of the following properties, P, if both 𝒱 and 𝒲 have P, then so does 𝖧(𝒱 ∘ 𝒲). 
 
        * P = is idempotent;
        * P = has a :term:`Taylor term`;
        * P = is SD∧;
        * P = has an :term:`edge term`.
 
      It follows from the theorem that if both 𝒱 and 𝒲 are SD∧, or both have an edge term, then every finite member of 𝖧(𝒱 ∘ 𝒲) is tractable. 
      
      **Question**. Suppose 𝒱 has one of the properties in the list and 𝒲 has another.  Is every finite member of 𝖧(𝒱 ∘ 𝒲) is tractable?

    Maltsev term
      A **Maltsev term** is ternary term :math:`t` that satisfies the identities :math:`t(x, y, y) ≈ x ≈ t(y, y, x)`.
 
      One of the first theorems of universal algebra is the following famous result of Maltsev :cite:`Maltsev:1954`:
      
      **Theorem**.  If 𝒱 is a variety of algebras, then the following are equivalent:
     
        #. 𝒱 is :term:`congruence-permutable`;
        #. :math:`𝔽_𝒱^(3)` is congruence-permutable;
        #. 𝒱 has a :term:`Maltsev term`; i.e., there exists a term :math:`t`,
 
           .. math:: 𝒱 ⊧ t(x, y, y) ≈ x ≈ t(y, y, x).

      As Bergman puts it in :cite:`Bergman:2012`, the theorem above "initiated the study of congruence-permutable varieties. Besides providing one of the most important tools in universal algebra, it is also one of its most beautiful results, linking the algebraic and logical sides of the subject."

    metric space
      A **metric space** is a pair :math:`(X, d)` where :math:`X` is a set and :math:`d: X × X → ℝ` is a **metric** (or **distance function**), that is, a function satisfying the following conditions for all :math:`x, y, z ∈ X`:
 
      #. :math:`d(x, y) ≥ 0`
      #. :math:`d(x,y) = 0` if and only if :math:`x = y`
      #. (symmetry) :math:`d(x, y) = d(y, x)` 
      #. (triangle inequality) :math:`d(x, z) ≤ d(x, y)+d(y, z)`.
 
    middle linear map
      If :math:`B_r` and :math:`_rC` are modules over a ring :math:`R`, and :math:`A` is an abelian group, then a **middle linear** map from :math:`B × C` to :math:`A` is a function :math:`f: B × C → A` such that for all :math:`b, b_1, b_2 ∈ B` and :math:`c, c_1, c_2 ∈ C` and :math:`r ∈ R`:
 
      .. math:: f(b_1 + b_2, c) &= f(b_1,c) + f(b_2,c)\\
                f(b, c_1 + c_2) &= f(b,c_1) + f(b,c_2)\\
                       f(br, c) &= f(b,rc)
 
    minimal absorbing subalgebra
      We call 𝐁 a **minimal absorbing subalgebra** of 𝐀, and we write 𝐁 ◁◁ 𝐀, just in case 𝐁 is an absorbing subalgebra of 𝐀 and 𝐁 is minimal (with respect to set inclusion of universes) among the absorbing subalgebras of 𝐀.
 
    module
      Let :math:`R` be a :term:`ring` with unit. A **left unitary** :math:`R`-**module** (or simply :math:`R`-**module**) is an algebra :math:`⟨M, \{0, -, +\} ∪ \{f_r : r∈ R\}⟩` with an :term:`abelian group` :term:`reduct` :math:`⟨M, \{0, -, +\}⟩` and unary operations :math:`\{f_r : r ∈ R\}` that satisfy the following: :math:`∀ r, s ∈ R`, :math:`∀ x, y ∈ M`,
 
      #. :math:`f_r(x + y)  = f_r(x) + f_r(y)`
      #. :math:`f_{r+s}(x) = f_r(x) + f_s(x)`
      #. :math:`f_r(f_s(x)) = f_{rs}(x)`
      #. :math:`f_1(x) = x`.
 
    monoid
      If :math:`⟨M, ⋅⟩` is a :term:`semigroup` and if there exists :math:`e ∈ M` that is a multiplicative identity (i.e., :math:`∀ m ∈ M`, :math:`e ⋅ m = m = m ⋅ e`), then :math:`⟨M, \{e, ⋅\}⟩` is called a **monoid**.
 
    monoid homomorphism
      Given :term:`monoids <monoid>` :math:`𝐌_1 = (M_1, e_1, ⋆)` and :math:`𝐌_2 = (M_2, e_2, ∗)` we say that a function :math:`f : M_1 → M_2` is a **monoid homomorphism** from :math:`𝐌_1` to :math:`𝐌_2` provided :math:`f` preserves the :term:`nullary <nullary operation>` (identity) and :term:`binary operations <binary operation>`; that is, :math:`f(e_1) = e_2` and :math:`f (x ⋆ y) = f(x) ∗ f(y)` for all :math:`x, y ∈ M_1`.
 
    monomorphism
      A :term:`morphism` :math:`f: A → B` is called a **monomorphism** if for every object :math:`X` and every pair :math:`h, h' : X → A` of morphisms, :math:`f ∘ h = f ∘ h'` implies :math:`h = h'`. When :math:`f` is a monomorphism we often say :math:`f` is "mono" and write :math:`f: A ↣ B`.
 
    monotone function
      Given :term:`posets <poset>` :math:`⟨A, ≤ᴬ⟩` and :math:`(B, ≤ᴮ)` we say that a function :math:`f: A → B` is **monotone** from :math:`⟨A, ≤ᴬ⟩` to :math:`⟨B, ≤ᴮ ⟩` when for any :math:`x, y ∈ A` we have that :math:`x ≤ᴬ y` implies that :math:`f(x) ≤ᴮ f(y)`.
      
      (See also :term:`monotone increasing function`.)
 
    monotone increasing function
      A real- or extended real-valued function :math:`f` deifned on :math:`ℝ` is called **monotone increasing** (or **monotonically increasing**) on the interval :math:`[a,b] ⊆ ℝ` if :math:`a≤ x < y ≤ b` implies :math:`f(x) ≤ f(y)`.
      
      (See also :term:`monotone function`.)
 
    morphism
      If :math:`𝔸 = ⟨A, F^𝔸⟩` and :math:`𝔹 = ⟨B, F^𝔹⟩` are :term:`algebraic structures <algebraic structure>` in the :term:`signature` :math:`σ = (F, ρ)`, then a **morphism** (or **homomorphism**) :math:`h: 𝔸 → 𝔹` is a function from :math:`A` to :math:`B` that preserves (or commutes with) all operations; that is, for all :math:`f∈ F`, for all :math:`a_1, \dots, a_{ρ f} ∈ A`,
 
      .. math:: f^𝔹 (h\,a_1, \dots, h\,a_{ρ f}) = h f^𝔸(a_1, \dots, a_{ρ f}).
 
    multiplicative inverse
      Let :math:`𝔸 = ⟨ A, e, ∘, \dots ⟩` be an algebra in a signature with a nullary "identity" operation :math:`e: () → A` and a binary "multiplication" operation :math:`∘: A × A → A`. Then the element :math:`b ∈ A` is a **multiplicative inverse** of :math:`a ∈ A` provided :math:`a ∘ b = e = b ∘ a`.
 
    natural isomorphism
      An isomorphism in a functor category is referred to as a **natural isomorphism**.
      
    natural transformation
      Given :term:`functors <functor>` :math:`F, G : \mathcal C → \mathcal D`, a **natural transformation** :math:`α : F ⇒ G` is a family :math:`\{α_A : A ∈ \mathcal C_{\mathrm{obj}}\}` of morphisms in :math:`\mathcal D` indexed by the objects of :math:`\mathcal C` such that, for each :math:`A ∈ \mathcal C_{\mathrm{obj}}`, the map :math:`\alpha_A` is a morphism from :math:`FA` to :math:`GA` satisfying the *naturality condition*, :math:`Gf ∘ α_A = α_B ∘ Ff`, for each :math:`f : A → B` in :math:`\mathcal C_{\mathrm{mor}}`. We shall write :math:`α : F ⇒ G : \mathcal C → \mathcal D` to indicate that α is a natural transformation from :math:`F` to :math:`G`, where :math:`F, G : \mathcal C → \mathcal D`.
 
    naturally isomorphic
      If there is a natural isomorphism between the functors :math:`F` and :math:`G`, then we call :math:`F` and :math:`G` **naturally isomorphic**.
 
    near unanimity term
      An idempotent term w(x₁, ..., xₖ) satisfying w(y,x,...,x) ≈ w(x,y,x,...,x) ≈ ... ≈ w(x,...,x,y) ≈ x is called a **near unanimity** (or **NU**) term.

    normal form
      In :term:`dependent type theory`, every term has a computational behavior and may be *reduced* using certain reduction rules (e.g., the α, β, η rules).  The form beyond which a term :math:`t` cannot be reduced, if such a form exists, is called the **normal form** of :math:`t`. 
  
    normed linear space
      A **normed linear space** (or **normed vector space**) is a pair :math:`(X, \|\,⋅\,\|)` consisting of a :term:`vector space` :math:`X` and a :term:`norm` :math:`\|\,⋅\,\|` defined on :math:`X`.
 
    normed vector space
      See :term:`normed linear space`.
 
    nowhere dense
      A set :math:`G` is **nowhere dense** in :math:`X` if the :term:`closure` of :math:`G` contains no nonempty open subsets of :math:`X`. Equivalently, the :term:`interior` of the closure of :math:`G` is empty (in symbols, :math:`Ḡ^o = ∅`).
 
    nullary operation
      An operation :math:`f` on a set :math:`A` is called **nullary** if the arity of :math:`f` is 0; that is, :math:`f: () → A`; equialently, :math:`f` takes no arguments, so is simply a (constant) element of :math:`A`.
 
    ω-chain
      Let :math:`⟨ X, ≤ ⟩` be a preordered set. An ω-**chain** is an enumerable :term:`chain`; that is, a :term:`chain` the elements that can be indexed by the natural numbers.
 
    ω-chain cocomplete
      A :term:`preorder` in which joins of all ω-chains exist is called ω-**chain cocomplete**.
 
    ω-chain cocomplete poset
      an :term:`antisymmetric` :term:`ω-chain cocomplete` :term:`preorder`.
 
    opposite category
      Given a category 𝒞 the **opposite** (or **dual**) **category** :math:`𝒞^{\mathrm{op}}` has the same objects as 𝒞 and whenever f: A → B is a morphism in 𝒞 we define f: B → A to be a morphism in :math:`𝒞^{\mathrm{op}}`.
 
    order ideal
      A subset I of a partially ordered set (P, ≤) is a **order ideal** (or just **ideal**) if the following conditions hold:
 
        * I is non-empty.
        * ∀ x, y ∈ I, x ∨ y ∈ I.
        * ∀ x ∈ I, ∀ y ∈ P, x ≥ y → y ∈ I.
 
      An ideal is a **proper ideal** if it is not the whole of P. (Some authors add this last condition to the definition of an order ideal.)
 
      The dual notion is called a :term:`filter`.
 
    parallel morphisms
      Morphisms f, g: A → B are called **parallel morphisms** just in case dom f = dom g and cod f = cod g.
 
    partial function
      A **partial function** from A to B is a total function on some (potentially proper) subset, dom f, of A.
 
    partial order
      See :term:`partial order`.
 
    partial ordering
      A **partial ordering** (or "partial order") is an :term:`antisymmetric` :term:`preorder`.
      
    partially ordered set
      A **partially ordered set** (or "poset") ⟨X, R⟩ is a set X along with a :term:`partial ordering` R defined on X.
 
    permuting relations
      Binary relations α and β are said to **permute** if α ∘ β = β ∘ α.  If α and β are permuting congruences, then α ∘ β = α ∨ β in the congruence lattice.

    point
      Given a category with an initial object :math:`\mathbf{1}` and another object :math:`A`, the morphisms with domain :math:`\mathbf{1}` and codomain :math:`A` are called the **points** or **global elements** of :math:`A`.
 
    pointwise limit
      Let :math:`f_n: X → [-∞, ∞]` for each :math:`n∈ ℕ`. If the limit :math:`f(x) = \lim_{n→∞} f_n(x)` exist at every :math:`x ∈ X`, then we call :math:`f: X → ℝ` the **pointwise limit** of the sequence :math:`\{f_n\}`. 
 
    polymorphic function
      a function that operates in the "same way" independently of the object parameter.
 
    polymorphism
      Let :math:`𝔸 = ⟨ A, R₁^𝔸, \dots)` and :math:`𝔹 = ⟨ A, R₁^𝔹, \dots)` be relational structures of the same signature. A k-ary (total) function :math:`f: A^k → B` is called a **polymorphism** of (𝔸, 𝔹) if it is :term:`compatible` with every pair :math:`(R_i^𝔸, R_i^𝔹)`, that is, for all tuples :math:`𝐫 ∈ R_i^𝔸`, the tuple :math:`f 𝐫`  is in :math:`R_i^𝔹`.
 
      We denote the set of all polymorphisms of (𝔸, 𝔹) by Poly(𝔸, 𝔹).
 
    poset
      A **poset** :math:`⟨X, ⊑⟩` consists of a set :math:`X` and an :term:`antisymmetric` :term:`preorder` :math:`⊑` on :math:`X`.
 
    power set operator
      The **powerset operator** :math:`𝒫` maps a class :math:`X` to the class :math:`𝒫 (X)` of all subsets of :math:`X`.
 
    powerset functor
      The **(covariant) powerset functor** is a :term:`functor` :math:`P: \mathbf{Set} → \mathbf{Set}` such that for each :term:`morphism` :math:`f: A → B` the morphism :math:`P f : 𝒫(A) → 𝒫(B)` is given by :math:`P f(S) = \{f(x): x ∈ S\}` for each :math:`S ⊆ A`.
 
    preorder
      A **preorder** on a set :math:`X` is a :term:`reflexive` and :term:`transitive` subset of :math:`X × X`.
 
    preserves
      See :term:`respects`.
 
    product
      Given two objects :math:`A` and :math:`B` a **product** of :math:`A` and :math:`B` is defined to be an object, :math:`A × B`, along with :term:`morphisms <morphism>` :math:`π_1: A × B → A` and :math:`π_2: A × B → B` such that for every object :math:`X` and all morphisms :math:`f: X → A` and :math:`g: X → B` there exists a unique morphism :math:`⟨f,g⟩: X → A × B` such that :math:`p_1 ∘ ⟨f,g⟩ = f` and :math:`p_2 ∘ ⟨f,g⟩ = g`.
 
    projection operation
      The :math:`i`**-th** :math:`k`**-ary projection operation on** :math:`A` is denoted by :math:`π^k_i: (k → A) → A` and defined for each :math:`k`-tuple :math:`a: k → A` by :math:`π^k_i \, a  = a\, i`. 

    projection operator
      If :math:`σ: k → n` is a :math:`k`-tuple of numbers in the set :math:`n = \{0, 1, \dots, n-1\}`, then we can compose an :math:`n`-tuple :math:`a ∈ ∏_{0≤i<n} A_i` with :math:`σ` yielding :math:`a ∘ σ ∈ ∏_{0≤i<k} A_{σ\, i}`.
 
      The result is a :math:`k`-tuple whose :math:`i`-th component is :math:`(a ∘ σ)(i) = a(σ(i))`.
 
      If :math:`σ` happens to be one-to-one, then we call the following a **projection operator**:
 
      .. math:: \mathrm{Proj}\, σ: ∏_{0≤i< n} A_i → ∏_{0≤i<k} A_{σ\, i};  \ \ a ↦ a ∘ σ.
 
      That is, for :math:`a ∈ ∏_{0≤i<n} A_i` we define :math:`\mathrm{Proj}\,σ\, a = a ∘ σ`.
 
    pseudoelementary class
      A **pseudoelementary class** is a class of structures derived from an :term:`axiomatizable` class by omitting some of its sorts and relations.
      
      This is the mathematical logic analog of the notion in category theory of (the codomain of) a forgetful functor. Axiomatizable classes are (vacuously) pseudoelementary but the converse is not always true; nevertheless pseudoelementary classes share some of the properties of axiomatizable classes such as being closed under :term:`ultraproduct`.
 
    quasiidentity
      A **quasiidentity** in the language L is an implication of the form s₁ ≈ t₁ ∧ ... ∧ sₙ ≈ tₙ ⟶  s ≈ t, where s, s₁, ..., sₙ, t, t₁, ..., tₙ are terms built up from variables using the operation symbols of L.
 
    quasivariety
      A **quasivariety** is a class K of algebras of the same signature satisfying any of the following equivalent conditions:
 
        #. K is a :term:`pseudoelementary class` closed under subalgebra and :term:`product`.
 
        #. K is the class of all :term:`models <model>` of a set of :term:`quasiidentities <quasiidentity>`.
 
        #. K contains a trivial algebra and is closed under isomorphism, subalgebra, and :term:`reduced product`.
 
        #. K contains a trivial algebra and is closed under isomorphism, subalgebra, product, and :term:`ultraproduct`.
 
    quotient
      If :math:`R` is an :term:`equivalence relation` on :math:`A`, then the **quotient** of :math:`A` modulo :math:`R` is denoted by :math:`A/R` and is defined to be the collection :math:`\{ a/R ∣ a ∈ A \}` of :term:`equivalence classes <equivalence class>` of :math:`R`.
 
    reduced product
      Let :math:`I` be an index set, and let :math:`𝕄_i` be a structure for each :math:`i ∈ I` (all of the same signature). Let :math:`F` be a :term:`filter` on :math:`I`.
      
      Define the equivalence relation ~ on the :term:`product` structure :math:`𝐌 := ∏_{i∈ I}𝕄_i` as follows: ∀ 𝐚, 𝐛 ∈ 𝐌, 
 
      .. math:: 𝐚 ∼ 𝐛 \ ⟺ \ \{i ∈ I : 𝐚 i = 𝐛 i\} ∈ F.
 
      The **reduced product** of 𝐌 over :math:`F` is the quotient 𝐌/~, which is sometimes denoted by
 
      .. math:: ∏_{i∈ I} 𝕄_i/F.
 
    reduct
      Given two :term:`algebras <algebraic structure>` :math:`𝔸` and :math:`𝔹`, we say that :math:`𝔹` is a **reduct** of :math:`𝔸` if both algebras have the same universe and :math:`𝔹` can be obtained from :math:`𝔸` by removing  operations.
 
    reflexive
      A binary relation :math:`R` on a set :math:`X` is called **reflexive** provided :math:`∀ x ∈ X, \ x \mathrel{R} x`.
 
    relation
      Given sets :math:`A` and :math:`B`, a **relation** from :math:`A` to :math:`B` is a subset of :math:`A × B`.
 
    relational product
      Given relations :math:`R : A → B` and :math:`S : B → C` we denote and define the **relational product** (or **composition**) of :math:`S` and :math:`R` to be :math:`S ∘ R = \{(a,c) : (∃ b ∈ B) a \mathrel{R} b ∧ b \mathrel{S} c \}`.
 
    relational signature
      A **relational signature** (or **signature** for :term:`relational structures <relational structure>`) is a pair :math:`σ = (R, ρ)` consisting of a collection :math:`R` of *relation symbols* and an :term:`arity` function :math:`ρ : R → N` that maps each operation symbol to its arity; :math:`N` denotes the arity type (which is often but not always ℕ).
 
    relational structure
      A relational structure :math:`𝔸 = ⟨A, ℛ⟩` is a set :math:`A` together with a collection :math:`ℛ` of relations on :math:`A`.
 
    relational structure homomorphism
      Let :math:`σ = (ℛ, ρ)` be a :term:`signature` for :term:`relational structures <relational structure>`.  Let :math:`𝔸 = ⟨A, ℛ^𝔸⟩` and :math:`𝔹 = ⟨B, ℛ^𝔹⟩` be relational structures in the signature σ. A function :math:`h: A → B` that "respects" or "preserves" the relations in the following sense is called a (relational structure) **homomorphism**: :math:`∀ R ∈ ℛ`, if :math:`(a_0, \dots, a_{n-1}) ∈ R^𝔸`, then :math:`(b_0, \dots, b_{n-1}) ∈ R^𝔹`.
 
    respects
      Given a function :math:`f: α → α`, we say that :math:`f` **respects** (or **preserves**) the binary relation :math:`R ⊆ α × α`, and we write :math:`f ⊧ R`, just in case :math:`∀ x, y :α \ (x \mathrel R y \ → \ f x \mathrel R f y)`.
        
      (The symbol ⊧ is produced by typing ``\models``.)
 
      If :math:`f: (β → α) → α` is a :math:`β`-ary operation on :math:`α`, we can extend the definition of ":math:`f` respects :math:`R`" in the obvious way.
      
      First, for every pair :math:`u : β → α` and :math:`v : β → α` (:math:`β`-tuples of :math:`α`), we say that :math:`(u, v)` "belongs to" :math:`R ⊆ α × α` provided
      
      .. math:: ∀ i: β \ ui \mathrel R vi
      
      Then we say :math:`f:  (β → α) → α` **respects** (or **preserves**) the binary relation :math:`R ⊆ α × α`, and we write :math:`f ⊧ R`, just in case :math:`∀ u, v, \ [(∀ i: β, \ u i \mathrel R v i) \ → \ f u \mathrel R f v]`.
        
    retract
      An object :math:`A` in a category is called a **retract** of an object :math:`B` if there are morphisms :math:`i: A → B` and :math:`r: B → A` such that :math:`r ∘ i = id_A`. In this case :math:`r` is called a **retraction** of :math:`B` onto :math:`A`.

    retraction
      See: :term:`retract`

    right module
      A **right module** :math:`M` over a :term:`ring` :math:`R` is...
 
    ring
      An algebra :math:`⟨R, \{0, -, +, ⋅\}⟩` is called a **ring** just in case the following conditions hold:
 
      #. the reduct :math:`⟨R, \{0, -,+\}⟩` is an abelian group,
      #. the reduct :math:`⟨R, ⋅ ⟩` is a semigroup, and
      #. "multiplication" :math:`⋅` distributes over "addition" :math:`+`; that is, :math:`∀ a, b, c ∈ R`, :math:`a ⋅ (b+c) = a ⋅ b + a ⋅ c` and :math:`(a+b)⋅ c = a ⋅ c + b ⋅ c`.
 
    ring of sets
      A nonempty collection :math:`R` of subsets of a set :math:`X` is said to be a **ring** if :math:`A, B ∈ R` implies :math:`A ∪ B ∈ R` and :math:`A-B ∈ R`.
 
    ring with unity
      A **ring with unity** (or **unital ring**) is an algebra :math:`⟨R, \{0, 1, -, +, ⋅\}⟩` with a ring :term:`reduct` :math:`⟨R, \{0, -, +, ⋅\}⟩` and a *multiplicative identity* :math:`1 ∈ R`; that is :math:`∀ r ∈ R`, :math:`r ⋅ 1 = r = 1 ⋅ r`.
 
    scope
      If :math:`k, n ∈ ℕ`, :math:`𝒜 = (A_0, A_1, \dots, A_{n-1})` is a list of sets, and :math:`σ: 𝐤 → 𝐧` is a :math:`k`-tuple of elements from :math:`𝐧:=\{0,1,\dots, n-1\}`, then a relation :math:`R` over 𝒜 with scope σ is a subset of the Cartesian product :math:`∏_{i:𝐤}A_{σ(i)} := A_{σ(0)} × A_{σ(1)} × \cdots × A_{σ(k-1)}`.
 
    section
      For a set :math:`E ⊆ X × Y`, the **x-section** of :math:`E` at the point :math:`t` is defined as follows:
 
      .. math:: G_t = \{y ∈ ℝ: (x,y) ∈ E \text{ and } x=t\}.
 
    semidistributive
      A lattice is called **meet-semidistributive** if it satisfies the quasiidentity
      
      .. math:: x ∧ y ≈ x ∧ z \ ⟹ \ x ∧ y ≈ x ∧ (y ∨ z).
 
      A lattice is called **join-semidistributive** if it satisfies the quasiidentity
      
      .. math:: x ∨ y ≈ x ∨ z \ ⟹ \ x ∨ y ≈ x ∨ (y ∧ z).
 
      A **semidistributive lattice** is one that is either meet- or join-semidistributive.
 
      We denote the class of meet-semidistributive lattices by SD∧, but we also use SD∧ as an adjective and write "L is SD∧" to mean "L is meet-semidistributive," i.e., L ∈ SD∧.
      
      A variety 𝒱 is called **meet-semidistributive** (or SD∧) if every algebra in 𝒱 has a meet-semidistributive congruence lattice.
      
      Idempotent SD∧ varieties are known to be Taylor :cite:`Hobby:1988`. In :cite:`Barto:2012a`, Barto and Kozik proved the following: If 𝐀 is a finite idempotent algebra in an SD∧ variety, then CSP(𝐀) is tractable.
 
    semigroup
      A :term:`magma` whose binary operation is associative is called a **semigroup**.  That is, a semigroup is a magma :math:`⟨A, ⋅⟩` whose binary operation satisfies :math:`∀ a, b, c ∈ A`, :math:`(a ⋅ b) ⋅ c = a ⋅ (b ⋅ c)`.
 
    semiring of sets
      A collection :math:`S` of subsets of a nonempty set :math:`X` is called a **semiring** if it satisfies the following properties:
      
      #. :math:`∅ ∈ S`;
      #. :math:`A, B ∈ S \; ⟹ \; A ∩ B ∈ S`;
      #. :math:`A, B ∈ S \; ⟹ \; ∃ C_1, \dots, C_n ∈ S`, :math:`A-B = ⋃_{i=1}^n C_i` and :math:`∀ i≠j, \,C_i ∩ C_j = ∅`.
 
    σ-term
      A **σ-term** is a :term:`term` in the :term:`signature` σ.
 
    signature
      In :term:`model theory`, a **signature** σ = (𝐂, 𝐅, 𝐑, ρ) consists of three (possibly empty) sets 𝐂, 𝐅, and 𝐑---called *constant symbols*, *function symbols*, and *relation symbols*, respectively---along with a function ρ: 𝐂 + 𝐅 + 𝐑 → N that assigns an :term:`arity` to each symbol. Often (but not always) N = ℕ. 
 
      By an **algebraic signature** (or **signature** for :term:`algebraic structures <algebraic structure>`) we mean a pair :math:`σ = (F, ρ)` that consists of a collection :math:`F` of *operation symbols* and an :term:`arity` function :math:`ρ : F → N` that maps each operation symbol to its arity; here, :math:`N` denotes the arity type (which is often, but not always, taken to be ℕ).
 
      A **relational signature** (or **signature** for :term:`relational structures <relational structure>`) is a pair :math:`σ = (R, ρ)` consisting of a collection :math:`R` of *relation symbols* and an :term:`arity` function :math:`ρ : R → N` that maps each operation symbol to its arity; :math:`N` denotes the arity type (which is often but not always ℕ).
 
    simplex category
      See :term:`finite ordinals`.
 
    simple algebra
      An algebra :math:`𝐀` is called **simple** if the only congruences of :math:`𝐀` are the trivial ones, :math:`0_𝐀 := \{(a,a) : a ∈ A\}` and :math:`𝐀 × 𝐀:=\{(x,y) : x,y ∈ A\}`.
 
    small category
      A category is called **small** if its collections of objects and morphisms are sets.
 
    source vertex
      Given a directed graph :math:`𝐆 = (V,E)` and an edge :math:`e=(v_1,v_2) ∈ E`, we refer to :math:`v_1` as the **source vertex** of :math:`e`.
 
    subalgebra
      Suppose :math:`𝔸 = ⟨A, F^𝔸⟩` is an algebra. If :math:`B ≠ ∅` is a :term:`subuniverse` of 𝔸, and if we let :math:`F^𝔹 = \{ f ↾ B : f ∈ F^𝔸 \}`, then :math:`𝔹 = ⟨ B, F^𝔹 ⟩` is an algebra, called a **subalgebra** of 𝔸.
 
    subdcpo
      If :math:`X` is a :term:`dcpo` then the subset :math:`A ⊆ X` is a **subdcpo** of :math:`X` if every directed subset :math:`D ⊆ A` satisfies :math:`⋁_X D ∈ A`.
 
    subdirect product
      Let :math:`σ  = (F, ρ)` be an :term:`algebraic signature`, let :math:`𝔸_i = ⟨A_i, F^{𝔸_i}⟩` be a σ-algebras, one for each :math:`i ∈ 𝐧 := \{0, 1, \dots, n-1\}`, and let :math:`𝐀 := ∏_{i:𝐧}𝔸_i` be the product σ-algebra. If :math:`R` is :term:`compatible` with 𝐀 and if the projection of :math:`R` onto each factor is surjective, then :math:`R` is called a **subdirect product** of the algebras in the list :math:`(𝔸_{σ(0)}, 𝔸_{σ(1)}, \dots, 𝔸_{σ(k-1)})`; we denote this situation by writing :math:`ℝ ≤_{sd} ∏_{j:𝐤} 𝔸_{σ(j)}`
 
    subuniverse
      Suppose :math:`𝔸 = ⟨A, F^𝔸⟩` is an algebra. If a subset :math:`B ⊆ A` is closed under :math:`F^𝔸`, then we call :math:`B` a **subuniverse** of :math:`𝔸`.
 
    symmetric
      A binary relation :math:`R` on a set :math:`X` is called **symmetric** provided :math:`∀ x, y ∈ X \ (x \mathrel{R} y \ → \ y \mathrel{R} x)`;
 
    target vertex
      Given a directed graph :math:`𝐆 = (V,E)` and an edge :math:`e=(v_1,v_2) ∈ E`, we refer to :math:`v_2` as the **target vertex** of :math:`e`.
 
    Taylor term
      An :term:`idempotent <idempotent operation>` term :math:`t` that satisfies for each :math:`i ∈ \{1,2,\dots, n\}`
 
      .. math:: t(∗, \cdots, ∗, x, ∗, \cdots, ∗) ≈ t(∗, \cdots, ∗, y, ∗, \cdots, ∗),
 
      where distinct variables :math:`x, y` appear in the :math:`i`-th position on either side of the identity is called a **Taylor term**.
 
    Taylor variety
      Walter Taylor proved in :cite:`Taylor:1977` that a variety 𝒱 satisfies some nontrivial idempotent :term:`Maltsev condition` if and only if it satisfies one of the following form: for some :math:`n`, 𝒱 has an idempotent :math:`n`-ary term  :math:`t` such that for each :math:`i∈ \{1, \dots, 2\}` there is an identity of the form
      
      .. math:: t(∗, \cdots, ∗, x, ∗, \cdots, ∗) ≈ t(∗, \cdots, ∗, y, ∗, \cdots, ∗),
 
      true in 𝒱 where distinct variables :math:`x, y` appear in the :math:`i`-th position on either side of the identity.  Such a term :math:`t` is now commonly called a :term:`Taylor term`.
 
    term
      The collection 𝒯 of **terms** in the :term:`signature` σ (or **σ-term**) is defined recursively as follows:
 
        * All *variables* are terms.
        * All *constant symbols* are terms.
        * If :math:`t: \{0, \dots, (n-1)\} → 𝒯` is an :math:`n`-tuple of terms and :math:`f ∈ 𝐅` is a function symbol of arity :math:`ρ f = n`, then :math:`f t` is a term.
        * :math:`t` is a terms if it can be obtained in finitely many steps from some combination of the three items above.
 
    terminal object
      An object :math:`\mathbf{1}` is called a **terminal** (or **bound**) **object** if for every object :math:`A` in the same category there exists a unique morphism :math:`⟨\ ⟩_A: A → \mathbf{1}`.
 
    ternary operation
      An operation :math:`f` on a set :math:`A` is called **ternary** if the arity of :math:`f` is 3; that is, :math:`f: A × A × A → A` (or, in curried form, :math:`f: A → A → A → A`).
 
    total function
      Given sets :math:`A` and :math:`B`, a **total function** :math:`f` from :math:`A` to :math:`B` is what we typically mean by a "function" from :math:`A` to :math:`B`.
 
    total order
      A **total order** relation :math:`R` on a set :math:`X` is a partial order on :math:`X` satisfying :math:`∀ x, y ∈ X \ (x ≤ y \ ⋁ \ y ≤ x)`.
 
    transitive
      A binary relation :math:`R` on a set :math:`X` is called **transitive** provided :math:`∀ x, y, z ∈ X \ (x \mathrel{R} y ∧ y \mathrel{R} z\ → \ x \mathrel{R} z)`.
 
    trivial algebra
      A **trivial algebra** is an algebra with just one element in its universe.
 
    trivial structure
      A **trivial structure** is a structure with just one element in its universe.
 
    ultrafilter
      An **ultrafilter** on a :term:`poset` P is a maximal :term:`filter` on P, that is, a proper filter on P that will become improper if it is enlarged.
 
    ultraproduct
      Let :math:`I` be an index set, and let :math:`𝕄_i` be a structure for each :math:`i ∈ I` (all of the same signature). Let :math:`U` be an :term:`ultrafilter` on :math:`I`.
      
      Define the equivalence relation ~ on the :term:`product` structure :math:`𝐌 := ∏_{i∈ I}𝕄_i` as follows: ∀ 𝐚, 𝐛 ∈ 𝐌, 
 
      .. math:: 𝐚 ∼ 𝐛 \ ⟺ \ \{i ∈ I : 𝐚 i = 𝐛 i\} ∈ U.
 
      The **ultraproduct** of 𝐌 over :math:`U` is the quotient 𝐌/~, which is sometimes denoted by
   
      (The usual choice is for I to be infinite and U to contain all cofinite subsets of I; otherwise, the ultrafilter is principal, and the ultraproduct is isomorphic to one of the factors.)
    
      More generally, the construction above can be carried out whenever :math:`U` is a filter on :math:`I` and the resulting :math:`∏_{i∈ I}𝕄_i/U` is called a :term:`reduced product`.
 
    unary operation
      An operation :math:`f` on a set :math:`A` is called **unary** if the arity of :math:`f` is 1; that is, :math:`f: A → A`.
 
    underlying set functor
      The **underlying set functor** of :math:`𝐌` is denoted by :math:`U(𝐌)`, or by :math:`|𝐌|`; it returns the *universe* of the structure :math:`𝐌`, and for each morphism :math:`f`, :math:`Uf` (or :math:`|f|`) is :math:`f` viewed simply as a function on sets.
 
    unit
      If :math:`⟨R, \{0, 1, -, +, ⋅\}⟩` is a unital ring, an element :math:`r ∈ R` is called a **unit** if it has a multiplicative inverse, that is, there exists :math:`s ∈ R` with :math:`r ⋅ s = 1 = s ⋅ r`.  (We usually denote such an :math:`s` by :math:`r^{-1}`.)
 
    unital ring
      See :term:`ring with unity`.
 
    unique morphism property
      See :term:`universal property`.
 
    universal image functor
      the functor :math:`∀ f : P(A) → P(B)` defined by :math:`∀ f (X) = \{y ∈ B : f^{-1}(\{y\}) \subseteq  X\}`, for :math:`X ∈ P(A)`.
 
    universal mapping property
      Let :math:`η_A : A → |𝔸^*|` be the function that maps :math:`a ∈ A` to the "one-letter word" :math:`a ∈ A^*`. The :term:`functors <functor>` :math:`K (= \ ^∗)` and :math:`U (= |\ |)` are related by the **universal mapping property** of monoids, which says that for every :term:`monoid` :math:`𝐌` and every function :math:`f : A → U 𝐌` there exists a unique :term:`morphism` :math:`f̂ : KA → 𝐌` such that :math:`f = f̂ ∘ η`.
 
    universal property
      The **unique morphism property** of the :term:`initial object` in a category is what we refer to as a **universal property,** and we say that the :term:`free object` in a category :math:`𝒞` is "universal" for the category :math:`𝒞`.
 
    universe
      In :term:`type theory`, everything has a type---even a type has a type.  If ``α`` is a type, then ``α``'s type is ``Type u`` for some **universe** ``u``.  More accurately, the ``u`` here is actually a variable and whatever (natural number) value it takes on will be the universe *level* of the type ``α``.
   
      In universal algebra, the **universe** of an :term:`algebra <algebraic structure>` is the set on which an algebra is defined; e.g., the universe of the algebra :math:`𝔸 = ⟨A, F^𝔸⟩` is :math:`A`.  (N.B. we sometimes use the word **carrier** to mean universe in this sense, which can be helpful when we wish to avoid confusion with the universe levels in `type theory`_.)
 
    valuation
      The `absolute value`_ for real numbers can generalised to an arbitrary field by considering the four fundamental properties of absolute value. Thus, a real-valued function :math:`ν` on a field :math:`F` is called a **valuation** if it satisfies the following four axioms:
 
      #. :math:`ν(a)≥ 0` (non-negativity); 
      #. :math:`ν(a)=0 \; ⟺ \; a= \mathbf 0` (positive-definiteness); 	
      #. :math:`ν(ab)=ν(a)ν(b)` (multiplicativity);
      #. :math:`ν(a+b)≤ ν(a)+v(b)` (:term:`subadditivity <countably subadditive>`). 	
 
      Here :math:`\mathbf 0` denotes the additive identity element of :math:`F`. It follows from properties 2 and 3 that :math:`ν(1) = \mathbf 1`, where :math:`\mathbf 1` denotes the multiplicative identity element of :math:`F`. The real and complex absolute values are examples of valuations.
 
    variety
      A **variety** (or **equational class**) of structures in the language :math:`L` is one that can be axiomatized by a set of equations in :math:`L`.
 
    vector space
      If :math:`F` is a :term:`field`, then an :math:`F`-:term:`module` is called a **vector space** over :math:`F`.

    weak near unanimity term
      An idempotent term w(x₁, ..., xₖ) satisfying w(y,x,...,x) ≈ w(x,y,x,...,x) ≈ ... ≈ w(x,...,x,y) is called a **weak near unanimity** (or **WNU**) term.

