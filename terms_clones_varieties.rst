.. include:: _static/math_macros.rst

.. _terms-clones-varieties:

============================
Terms, Clones, Varieties
============================

.. index:: ! term, ! term algebra, ! σ-term 

.. _terms:

Terms
-----

Fix a signature :math:`σ = (F, ρ)`, let :math:`X` be a set of **variables** and assume :math:`X ∩ F = ∅`.

By a **word** on :math:`X ∪ F` we mean a nonempty, finite sequence of members of :math:`X ∪ F`, and we will denote the concatenation of such sequences by simple juxtaposition.

Let :math:`F_0` denote the set of nullary operation symbols. We define by induction on :math:`n` the sets :math:`T_n` of **terms on** :math:`X ∪ F` as follows:

.. math::      T_0 &= X ∪ F_0;\\
           T_{n+1} &= T_n ∪ \{ f\, s ∣ f ∈  F, \ s: ρf → T_n \},

and we define the collection of **terms of signature** :math:`σ` **over** :math:`X` by :math:`T_σ(X) = ⋃_{n < ω}T_n`.

By a :math:`σ`-**term** we mean a term in the signature :math:`σ`. 

The definition of :math:`T_σ (X)` is recursive, indicating that

  *terms can be implemented as an inductive type*

(in Lean, for example). We confirm this in :numref:`Chapter %s <inductively-defined-types>` below.

Before doing so, let us impose an algebraic structure on :math:`T_σ (X)`, and then state and prove some basic facts about this important algebra. These will be formalized in :numref:`Chapter %s <inductively-defined-types>`, giving us a chance to show off inductively defined types in Lean.

If :math:`t` is a term, then the **height** of :math:`t` is denoted by :math:`|t|` and defined to be the least :math:`n` such that :math:`t ∈ T_n`. The height of is a useful index for recursion and induction.

.. Let :math:`ρ: T_σ(X) → ℕ` denote the **arity function for term**, defined as follows:
.. .. math:: ρ t = \min \{n ∣t ∈ T_n,\; 0≤ n < ω\}.

Notice that :math:`T_σ (X)` is nonempty iff :math:`X ∪ F_0` is nonempty.

If :math:`T_σ (X)` is nonempty, then we can impose upon it an algebraic structure, which we denote by :math:`𝕋_σ (X)` (or :math:`𝕋` when :math:`σ` and :math:`X` are clear from context).

We call :math:`𝕋_σ (X)` the **term algebra in the signature** :math:`σ` **over** :math:`X` (or, the :math:`σ`-**term algebra over** :math:`X`); it is constructed as follows:

  For every basic operation symbol :math:`f ∈ F` let :math:`f^𝕋` be the operation on :math:`T_σ (X)` that maps each tuple :math:`s: ρ f → T_σ (X)` to the formal term :math:`f\,s`; define :math:`𝕋_σ(X)` to be the algebra with universe :math:`T_σ (X)` and basic operations :math:`\{f^𝕋 | f ∈ F\}`. [1]_

Let us now prove a couple of easy but important consequences of these definitions.

.. about the :math:`σ`-term algebra over :math:`X`.

.. _obs-six:

.. proof:observation::

   #. :math:`𝕋 := 𝕋_σ(X)` is generated by :math:`X`.
 
   #. For every :math:`\sigma`-algebra :math:`𝔸 = ⟨A, F^𝔸⟩` and function :math:`g: X → A` there is a unique homomorphism :math:`h: 𝕋 → 𝔸` such that :math:`h|_X = g`.
 
   .. container:: toggle
    
      .. container:: header
     
         *Proof*.
     
      The definition of :math:`𝕋` exactly parallels the construction in :numref:`Theorem %s <thm-1-14>`. That accounts for the first assertion.
     
      For the second assertion, define :math:`h\,t` by induction on the :term:`height` of :math:`|t|`.
     
      Suppose :math:`|t| = 0`.  Then :math:`t ∈ X ∪ F_0`.
      
      If :math:`t ∈ X`, then define :math:`h\,t = g\,t`. If :math:`t ∈ F_0`, then let :math:`h\,t = t^𝔸`.
     
      For the inductive step, assume :math:`|t| = n + 1`. Then :math:`t = f\,s` for some :math:`f ∈ F` and :math:`s: ρ f → T_n`, where for each :math:`0 ≤ i< ρ f` the term :math:`s\, i` has height at most :math:`n`. We define :math:`h\,t = f^𝔸(h ∘ s) = f^𝔸(h\,s_1, \dots, h\,s_k)`.
     
      By its very definition, :math:`h` is a homomorphism that agrees with :math:`g` on :math:`X`. The uniqueness of :math:`h` follows from :numref:`Obs %s <obs-two>`. ☐

.. index:: interpretation (of a term), ! arity (of a term)

.. _interpretation-of-a-term:

Interpretation of a term
~~~~~~~~~~~~~~~~~~~~~~~~

..  and let :math:`T_n := T_σ(X_n)` be the subalgebra of :math:`T_σ(X_ω)` generated by :math:`X_n`.  Then, :math:`T_0 ⊆  T_1 ⊆ T_2 ⊆ \cdots` and :math:`T_σ(X_ω) = ⋃_{n<ω}  T_n`.

We denote and define the set :math:`X := \{x_0,x_1,\dots \}` of variable symbols, and for each natural number :math:`n` we let :math:`X_n:=\{x_0,x_1,\dots, x_{n-1}\}`.

Let :math:`σ = (F, ρ)` be a signature, :math:`𝔸` a :math:`σ`-algebra, and :math:`𝕋` the :math:`σ`-term algebra over :math:`X`; that is, 

.. math:: 𝔸 := ⟨A, F^𝔸⟩ \quad \text{ and } \quad 𝕋 := ⟨T_σ(X), F^𝕋⟩. 

Each operation symbol :math:`f ∈ F` gives rise to

#.  a :math:`ρ f`-ary operation on :math:`T_σ(X)`, denoted by :math:`f^𝕋`, which maps each :math:`ρ f`-tuple :math:`s: ρ f → T_σ(X)` to the formal term :math:`f \,s` in :math:`T_σ(X)`, and

#.  a :math:`ρ f`-ary operation on :math:`A`, denoted by :math:`f^𝔸`, which maps each :math:`ρ f`-tuple :math:`a: ρ f → A` to the element :math:`f^𝔸 \,a` in :math:`A`. The operation :math:`f^𝔸` is called the **interpretation of** :math:`f` **in the algebra** :math:`𝔸`.  

In the present section we explain how to define the interpretation of a :math:`σ`-term in a :math:`σ`-algebra.

As usual, for each :math:`0<n<ω` we identify the :math:`n`-tuple :math:`(x_0, x_1, \dots, x_{n-1})` with the function :math:`x: n → X_n` defined by :math:`x\, i = x_i` :math:`(0≤i<n)`.

Recall, a term :math:`t` is either a variable, say, :math:`t = x`, or has the form :math:`t = f \,s` for some operation symbol :math:`f ∈ F`, and some :math:`ρ f`-tuple :math:`s: ρ f → T_σ (X)` of terms.

.. and suppose :math:`|t| = n`.
..  : (n → X_n) → T_n` be an :math:`n`-ary term. 

Let :math:`t ∈ T_σ(X)` be a term. Define the **operation** :math:`t^𝔸` **on** :math:`A` by recursion on the :term:`height` :math:`|t|` of :math:`t` as follows: for each tuple :math:`a: X → A` of :math:`A`, 

#. (:math:`|t| = 0`) if :math:`t` is the variable :math:`x_i ∈ X`, then :math:`t^𝔸 \, a = π^X_i\, a = a\, i`,
#. (:math:`|t| = n+1`) if :math:`t = f\, s` where :math:`f ∈ F` is an operation symbol and :math:`s: ρ f → T_n` is a tuple of terms whose heights are at most :math:`n` (i.e., :math:`∀ i < ρf, |s\, i| ≤ n`), then :math:`t^𝔸 = f^𝔸 \, s^𝔸`.
 
.. .. Let :math:`X_ω := \{x_0, x_1, \dots\}` be a collection of variables and define :math:`X_n:=\{x_0, x_1, \dots, x_{n-1}\}`.

In the next observation, assume :math:`𝔸 = ⟨A, F^𝔸⟩` and :math:`𝔹 = ⟨B, F^𝔹⟩` are algebras in the same signature :math:`σ = (F, ρ)`, and let :math:`t ∈ T_σ (X)` be an :math:`n`-ary term.

In particular, as we just explained, :math:`t` has an interpretation in :math:`𝔸`, denoted by :math:`t^𝔸 a = t^𝔸 (a\, 0, a\, 1, \dots, a\, (n-1))`, where :math:`a: n → A`, as well as an interpretation :math:`t^𝔹: (n → B) → B` in :math:`𝔹`.
    
.. _thm-4-32:

.. _obs-seven:

.. proof:observation:: homomorphisms commute with terms

   #. :math:`g: 𝔸 → 𝔹` is a homomorphism, then :math:`g ∘ a: n → B` is the :math:`n`-tuple whose :math:`i`-th component is :math:`(g ∘ a)\, i = g(a\, i)`, and
  
      .. math:: g(t^𝔸 a) = t^𝔹(g ∘ a).

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      This is an easy induction on :math:`|t|`. ☐
    
.. _obs-eight:

.. proof:observation:: terms respect congruences

   If :math:`θ` is a congruence of :math:`𝔸` and :math:`a, a': n → A` are :math:`n`-tuples over :math:`A`, then
    
   .. math:: (a, a') ∈ θ \; ⟹  \; (t^𝔸\,a, t^𝔸\,a') ∈ θ.

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      This follows from :numref:`Obs %s <obs-seven>` by taking :math:`⟨B, F^𝔹⟩ = ⟨A, F^𝔸⟩/θ = ⟨A/θ, F^{𝔸/θ}⟩` and :math:`g=` the canonical homomorphism. ☐
    
.. _obs-nine:

.. proof:observation:: subuniverse generation as image of terms

   If :math:`Y` is a subset of :math:`A`, then

      .. math:: \Sg^{𝔸}(Y) = \{ t^𝔸 \, a ∣ t ∈ T_σ(X_n), \, n ∈ ℕ, \; a: ρ t → Y\}.

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      A straightforward induction on the height of :math:`t` shows that every subuniverse is closed under the action of :math:`t^𝔸`. Thus the right-hand side is contained in the left. On the other hand, the right-hand side is a subuniverse that contains the elements of :math:`Y` (take :math:`t = x_1`), so it contains :math:`\Sg^{𝔸}(Y)` as the latter is the smallest subuniverse containing :math:`Y`. ☐

**Formalization**. Our formal implementation (in `Lean`_) of the concepts and results of this section is described in :numref:`terms-in-lean`, and is included in the `free.lean`_, `term.lean`_, and `birkhoff.lean`_ files of the `lean-ualib`_ library.

.. todo:: complete this section (include material on free algebras)

.. .. index:: ! Malcev condition, ! Taylor term
..
.. Special terms
.. ~~~~~~~~~~~~~~
.. .. _thm-4-3:
..
.. .. proof:theorem::
..
..    Let :math:`X` be a set and :math:`σ = (F, ρ)` a signature. Define
..
..    .. math:: F_0 &= X;\\
..          F_{n+1} &= F_n ∪ \{ f g ∣ f ∈ F, g : ρf → (F_n ∩ (ρ g → X)) \}, \quad n < ω.
..
..    Then :math:`\Clo ^X(F) = ⋃_n F_n`.
..
..
.. For a nonempty set :math:`A`, we let :math:`𝖮_A` denote the set of all finitary operations on :math:`A`. That is, :math:`𝖮_A = ⋃_{n∈ ℕ} A^{A^n}` on :math:`A` is a subset of :math:`𝖮_A` that contains all projection operations and is closed under the (partial) operation of :ref:`general composition <general-composition>`.
..
.. If :math:`𝔸 = ⟨ A, F^𝔸 ⟩` denotes the algebra with universe :math:`A` and set of basic operations :math:`F`, then :math:`\Clo  (𝔸)` denotes the clone generated by :math:`F`, which is also known as the **clone of term operations** of :math:`𝔸`.
..
.. We will discuss varieties in more detail later, but for now define a :index:`variety` to be a collection of algebras of the same signature which is defined by a set of identities. [3]_ 
..   
.. In 1977, Walter Taylor showed (:cite:`Taylor1977`) that a variety 𝕍 satisfies some nontrivial :term:`idempotent` :term:`Malcev condition` if and only if it satisfies one of the following form: for some :math:`n`, 𝕍 has an idempotent :math:`n`-ary term  :math:`t` such that for each :math:`0 ≤ i < n` there is an identity of the form 
..
..    .. math:: t(∗, \cdots, ∗, x, ∗, \cdots, ∗) ≈ t(∗, \cdots, ∗, y, ∗, \cdots, ∗)
..
.. that is true in 𝕍 and is such where distinct variables :math:`x` and :math:`y` appear in the :math:`i`-th position on each side of the identity. Such a term :math:`t` now goes by the name :index:`Taylor term`.

.. .. [3]
..   We will also have much to say about Malcev conditions, but for now we ask the reader to trust us when we say that such conditions play an important role in many deep results in universal algebra.

-----------------------------------------------

.. index:: ! clone
.. index:: ! clone of projections
.. index:: ! clone of polynomial operations
.. index:: ! clone of term operations

.. _clones:

Clones
------

An **operational clone** (or just **clone**) on a nonempty set :math:`A` is a set of operations on :math:`A` that contains the projection operations and is closed under general composition.

Let :math:`𝖢 A` denote the collection of all clones on :math:`A`.

The smallest clone on :math:`A` is the **clone of projections**, which we denote and define as follows:

.. math:: \Proj  A = ⋃_{i < n < ω}  \{π^n_i : ∀ a ∈ A^n,\ π^n_i\, a = a(i)\}.

Let us set down some conventions that will help simplify notation.  Recall, the natural number :math:`k< ω` may be constructed as (or at least identified with) the set :math:`\{0,1,\dots, k-1\}`, and this will be helpful here.

For each :math:`k< ω`, denote and define the tuple :math:`\pi^k: k → ((k → A) → A)` of all :math:`k`-ary projections on :math:`A` as follows: for each :math:`0≤ i < k`,  :math:`π^k(i)` is the :math:`i`-th :math:`k`-ary projection operation that takes each :math:`k`-tuple :math:`a: k → A` to its entry at index :math:`i`:

.. math:: π^k (i) a = a(i).

Observe that if :math:`f: (k → A) → A` is a :math:`k`-ary operation on :math:`A`, then 

The **clone of term operations** of a σ-algebra 𝔸 is the smallest clone on :math:`A` containing the basic operations of 𝔸; this is
denoted and defined by

.. math:: \Clo (F^𝔸) = ⋂ \{ U ∈ 𝖢 A ∣ F^𝔸 ⊆ U\}.

The set of :math:`n`-ary members of :math:`\Clo (F^𝔸)` is sometimes denoted by :math:`\Clo _n (F^𝔸)` (despite the fact that the latter is clearly not a clone).

The **clone of polynomial operations** (or **polynomial clone**) of a σ-algebra 𝔸 is denoted by :math:`\Pol (F^𝔸)` and is defined to be the clone generated by the collection consisting of the basic operations (i.e., :math:`F^𝔸`) of 𝔸 along with the **constants** on :math:`A`. [2]_

The set of :math:`n`-ary members of :math:`\Pol (F^𝔸)` is sometimes denoted by :math:`\Pol _n (F^𝔸)`. 

.. .. [9] Lean's built-in sigma type is defined as follows: :math:`structure sigma {α : Type u} (β : α → Type v) := mk :: (fst : α) (snd : β fst)`

The clone :math:`\Clo (F^𝔸)` is associated with the algebra :math:`𝔸` only insofar as the former is constructed out of the basic operations of 𝔸 and the set :math:`A` on which those operations are defined.  However, all that is required when defining a clone is a set :math:`A` and some collection :math:`F` of operations defined on :math:`A`; from only these ingredients, we can construct the clone generated by :math:`F`, which we denote by :math:`\Clo (F)`.

Thus

  *the clone of terms operations can be implemented (e.g., in Lean) as an inductive type*.
  
The following theorem makes this more precise (cf. Theorem 4.32 of :cite:`Bergman:2012`). (See also :numref:`Chapter %s <inductively-defined-types>`, where we formalize this in Lean.)

.. We seek a "bottom-up," inductive description of the members of :math:`\Clo (F)`.  By thinking of the clone itself as a kind of algebra, a description analogous to :numref:`Obs %s <thm-1-14>` ought to be possible.  In fact, since function composition is associative, a slightly slicker formulation is available.

..  Theorem  4.3. of Bergman [1].

.. _obs-five:

.. proof:observation::

   Let :math:`A` be a set and let :math:`F ⊆ \Op (A):= ⋃_{n<ω} A^{A^n}` be a collection of operations on :math:`A`.
   
   Define :math:`F_0 := \Proj (A)` (the set of projections on :math:`A`) and for all :math:`0 ≤ n < ω` let
 
   .. math:: F_{n+1} := F_n ∪ \{ f g \mid f ∈ F, g : ρf → (F_n ∩ (ρg → A)) \}.
 
   Then :math:`\Clo (F) = ⋃_n F_n`.
 
   .. container:: toggle
    
      .. container:: header
  
         *Proof*.

      Let :math:`F̄ = ⋃_n F_n`. It is easy to argue by induction that every :math:`F_n` is a subset of :math:`\Clo (F)`. Thus, :math:`F ⊆ \Clo (F)`.
    
      For the converse, we must show that :math:`F̄` is a clone that contains :math:`F`.
    
      Obviously :math:`F̄` contains the projection operations, :math:`F_0 ⊆ F̄`.

      For every :math:`f ∈ F`, we have :math:`f π^k ∈ F_1 ⊆ F̄`, where :math:`k:= ρ f`.
 
      We are reduced to showing that :math:`F̄` is closed under generalized composition. This follows from the following claim.
 
      **Claim**. If :math:`f ∈ F_n` and :math:`g_0, \dots, g_{ρ f-1} ∈ F_m` are all :math:`k`-ary, then :math:`f g \in F_{n+m}`, where we have defined :math:`g: ρ f → (k → A) → A` to be the tuple given by :math:`g\,i = g_i` for each :math:`0 ≤ i < ρ f`.

      Note that the types match up; indeed, for each :math:`a: (k → A) → A`, we have

      .. math:: f (g ∘ a) = f(g_0(a_0, \dots, a_{k-1}), 
 
      We prove the claim by induction on :math:`n`.
      
      If :math:`n = 0` then :math:`f` is a projection, so :math:`f g = g_i ∈ F_{0+m}` for some :math:`0≤ i < ρ f`.

      Assume the claim holds for :math:`n` and that :math:`f ∈ F_{n+1} - F_n`.
      
      From the definition, there is a :math:`t`-ary operation :math:`f_i ∈ F` and a :math:`t`-tuple :math:`h = (h_0, \dots, h_{t-1}) ∈ t → F_n`, such that :math:`f = f_i h`. (Note that :math:`h: t → (ρ f → A) → A` is given by :math:`h(j) = h_j`, and that the arity of each :math:`h_i` must be equal to that of :math:`f`, namely :math:`ρ f`.)
      
      By the induction hypothesis, for each :math:`i ≤ k`, :math:`h_i' = h_i g \in F_{n+m}` (where, as above, :math:`g = (g_0, \dots, g_{k-1})`).
      
      Applying the definition, :math:`f_1 h' ∈ F_{n+m+1} = F_{(n+1)+m}`. Since 
      
      .. math:: f_1 h' = f_1 ∘ (h_1 g, \dots, h_t g) = f g,

      the claim is proved. □

**Formalization**. Our formal implementation (in `Lean`_) of the concepts and results of this section is described in :numref:`clones-in-lean`, and is included in the `clone.lean`_ and `birkhoff.lean`_ files of the `lean-ualib`_ library.


------------------------------

.. index:: ! identity, ! equation, ! σ-identity, ! σ-equation, ! model
.. index:: pair: equational base; axiomatization
.. index:: pair: equational theory; theory
.. index:: pair: equational class; variety

.. _varieties:

Models, Theories, Varieties
-----------------------------

Let :math:`σ = (F, ρ)` be a signature and :math:`X := \{x_0, x_1, \dots\}` a countable collection of variable symbols.

An **identity** (or **equation**) **in the signature** :math:`σ` (or :math:`σ`-**identity**) is an ordered pair :math:`(t,s)` of terms from :math:`T_σ (X)` of the same arity (:math:`ρ t = ρ s`).

We write :math:`p ≈ q` to indicate such a :math:`σ`-identity; here :math:`p, q ∈ T_σ (X)` and :math:`ρ p = ρ q`. [3]_

Let :math:`𝒜_σ`, resp. :math:`ℰ_σ`, denote the class of all :math:`σ`-algebras, resp. :math:`σ`-identities.

For :math:`𝔸 ∈ 𝒦 ⊆ 𝒜_σ` and :math:`p ≈ q ∈ Σ ⊆ ℰ_σ`, we say

* :math:`𝔸` **models** :math:`p ≈ q`, denoted :math:`𝔸 ⊧ p ≈ q`, just in case :math:`p^𝔸 = q^𝔸` *extensionally* (i.e., :math:`ρ t = ρ s` and :math:`∀ a: ρ p → A, \; p^𝔸 \, a = q^𝔸 \, a`.); [4]_  

* :math:`𝔸` **models** :math:`Σ`, denoted :math:`𝔸 ⊧ Σ`, just in case :math:`𝔸 ⊧ p ≈ q` for every :math:`p ≈ q` in :math:`Σ`;

* :math:`𝒦` **models** :math:`p ≈ q`, denoted :math:`𝒦 ⊧ p ≈ q`, just in case :math:`𝔸 ⊧ p ≈ q` for every :math:`𝔸` in :math:`𝒦`;

* :math:`𝒦` **models** :math:`Σ`, denoted :math:`𝒦 ⊧ Σ`, just in case :math:`𝔸 ⊧ Σ` for every :math:`𝔸 ∈ 𝒦`.

The binary relation :math:`⊧` induces an obvious :term:`Galois connection`. Indeed, the :term:`Galois pair` :math:`(\Mod, \Th)` is defined as follows: for all :math:`Σ ⊆ ℰ_σ` and :math:`𝒦 ⊆ 𝒜_σ`, 

.. math:: \Mod(Σ) := \{𝔸: 𝔸 ⊧ Σ \} \quad \text{ and } \quad \Th(𝒦) := \{Σ: 𝒦 ⊧ Σ\}.

The first of these, the class of **models** of :math:`Σ`, contains those and only those algebras modelling :math:`Σ`. It is called an **equational class** (or **variety**), and :math:`Σ` is called an **equational base** for, or an **axiomatization** of, the class.

Dually, :math:`\Th(𝒦)` is the class of identities modelled by all algebras in :math:`𝒦`.  Such a class of identities is called an **equational theory**.

Alternatively and equivalently we could define "equational class" and "equational theory" in terms of the two :term:`closure operators <closure operator>` induced by the Galois pair :math:`(\Mod, \Th)`.  Indeed, :math:`\Mod \Th: 𝒫 (𝒜) → 𝒫(𝒜)` is a closure operator on :math:`𝒜` and :math:`\Th \Mod: 𝒫 (ℰ) → 𝒫(ℰ)` is a closure operator on :math:`ℰ`, and 

* an **equational class** (or **variety**) is a :math:`\Mod \Th`-:term:`closed` set of :math:`σ`-algebras;

* an **equational theory** (or **theory**) is a :math:`\Th \Mod`-:term:`closed` set of :math:`σ`-identities.

(Here, as usual, :math:`𝒫` denotes the :term:`power set operator`.)


.. _a-variety-of-facts:

A variety of facts
~~~~~~~~~~~~~~~~~~

.. _fact-m1:

.. proof:theorem::

   For every class 𝒦, each of the classes :math:`𝖲(𝒦)`, :math:`𝖧(𝒦)`, :math:`𝖯(𝒦)`, and :math:`𝕍(𝒦)` satisfies exactly the same identities as does 𝒦.

   *Proof*. Exercise.


.. _fact-m2:

.. proof:theorem:: 

   :math:`𝒦 ⊧ p ≈ q` if and only if :math:`∀ 𝔸 ∈ 𝒦`, :math:`∀ h ∈ \Hom(𝕋(X_ω), 𝔸)`, :math:`h\, p^𝔸 = h\, q^𝔸`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      (⇒) Assume that :math:`𝒦 ⊧ p ≈ q`.
      
          Fix :math:`𝔸 ∈ 𝒦` and :math:`h ∈ \Hom(𝕋(X_ω), 𝔸)`.
      
          We must show :math:`∀ a: ρ p → A` that :math:`h(p^{𝔸}\, a) = h(q^{𝔸}\, a)`.

          Fix :math:`a: ρ p → A`.

          By :math:`𝔸 ⊧ p ≈ q` we have :math:`p^{𝔸} = q^{𝔸}` which implies :math:`p^{𝔸}(h ∘ a) = q^{𝔸}(h ∘ a)`.
      
          Since :math:`h` is a homomorphism, we obtain :math:`h(p^{𝔸}\, a) = h(q^{𝔸}\, a)`, as desired.

      (⇐) Assume :math:`∀ 𝔸 ∈ 𝒦`, :math:`∀ h ∈ \Hom(𝕋(X_ω), 𝔸)`, :math:`h\, p^𝔸 = h\, q^𝔸`.
      
          We must show :math:`𝒦 ⊧ p ≈ q`.
          
          Fix :math:`𝔸 ∈ 𝒦` and :math:`a: ρ p → A`.
          
          We must prove :math:`p^𝔸 \, a = q^𝔸\, a`.
          
          Let :math:`h_0 : X_ω → A` be a function with :math:`h_0\, x\, i = a\, i` for all :math:`0≤ i < ρ p`, for some :math:`x: ρ p → X_ω`.
          
          By :numref:`Obs %s <obs-six>`, :math:`h_0` extends to a homomorphism :math:`h` from :math:`𝕋(X_ω)` to 𝔸.
      
          By assumption :math:`h\, p^𝔸 = h\, q^𝔸`, and since :math:`h` is a homomorphism,
      
          .. math:: p^{𝔸}\, a =  p^{𝔸}(h ∘ x) = h(p^{𝔸} \, x) = h(q^𝔸 \, x) = q^𝔸 (h ∘ x) = q^𝔸 \, a,
      
          so :math:`p^{𝔸}\, a = q^𝔸 \, a`, as desired. ☐

.. _fact-m3:

.. proof:theorem:: 

   Let 𝒦 be a class of algebras and :math:`p ≈ q` an equation. The following are equivalent.

     #. :math:`𝒦 ⊧ p ≈ q`.

     #. :math:`(p, q)` belongs to the congruence :math:`λ_{𝒦}` on :math:`𝕋(X_ω)`.

     #. :math:`𝔽_{𝒦}(X_ω) ⊧ p ≈ q`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      We shall show (1) ⟹ (3) ⟹ (2) ⟹ (1). 
      
      Recall that :math:`𝔽_{𝒦}(X_ω) = 𝕋/λ ∈ 𝖲 𝖯 (𝒦)`.
      
      From (1) and Lemma 4.36 of :cite:`Bergman:2012` we have :math:`𝖲 𝖯 (𝒦) ⊧ p ≈ q`. Thus (3) holds.

      From (3), :math:`p^{𝔽} \, [x] = q^{𝔽} \, [x]`, where :math:`[x]: ρ p → 𝔽_𝒦 (X_ω)` is defined by :math:`[x]\, i = x_i/λ`.
      
      From the definition of 𝔽, :math:`p^{𝕋}\, x ≡_λ q^{𝕋} ×`, from which (2) follows since :math:`p = p^{𝕋}\, x` 
      and :math:`q = q^{𝕋}\, x`.

      Finally assume (2). We wish to apply Lemma 4.37 of :cite:`Bergman:2012`.
      
      Let :math:`𝔸 ∈ 𝒦` and :math:`h ∈ \Hom(𝕋, 𝔸)`.
      
      Then :math:`𝕋/\ker h ∈ 𝖲 (𝔸) ⊆ 𝖲(𝒦)` so :math:`\ker h ⊇ λ`.  Thus, (2) implies :math:`h\, p = h\, q` hence (1) holds, completing the proof. ☐

The last result tells us that we can determine whether an identity is true in a variety by consulting a particular algebra, namely :math:`𝔽(X_ω)`. Sometimes it is convenient to work with algebras free on other generating sets besides :math:`X_ω`. The following corollary takes care of that for us.


.. _fact-m4:

.. proof:theorem:: 

   Let :math:`𝒦` be a class of algebras, :math:`p` and :math:`q` :math:`n`-ary terms, :math:`Y` a set and :math:`y_1, \dots, y_n` distinct elements of :math:`Y`. Then :math:`𝒦 ⊧ p ≈ q` if and only if
   :math:`p^{𝔽_{𝒦}(Y)}(y_1, \dots, y_n) = q^{𝔽_{𝒦}(Y)}(y_1, \dots, y_n)`. In particular, :math:`𝒦 ⊧ p ≈ q` if and only if :math:`𝔽_{𝒦}(X_n) ⊧ p ≈ q`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Since :math:`𝔽_{𝒦}(Y) ∈ 𝖲 𝖯 (𝒦)`, the left-to-right direction uses the same argument as in Theorem 4.38 of :cite:`Bergman:2012`. (See :numref:`Thm %s <fact-m3>` above.)
      
      So assume that :math:`p^{𝔽_{𝒦}(Y)}(y_1, \dots, y_n) = q^{𝔽_{𝒦}(Y)}(y_1, \dots, y_n)`.
      
      To show that :math:`𝒦 ⊧ p ≈ q`, let :math:`𝔸 = ⟨ A, f^{𝔸} ⟩ ∈ 𝒦` and :math:`a_1, \dots, a_n ∈ A`. We must show :math:`p^{𝔸}(a_1, \dots, a_n) = q^{𝔸}(a_1, \dots, a_n)`.

      There is a homomorphism :math:`h : 𝔽_{𝒦}(Y) → (A, f^A)` such that :math:`h(y_i) = a_i` for :math:`i ≤ n`. Then

      .. math:: p^{𝔸}(a_1, \dots, a_n) &= p^{𝔸}(h (y_1), \dots, h (y_n)) = h(p^{𝔽_𝒦(Y)}(y_1, \dots, y_n))\\
                                       &= h(q^{𝔽_𝒦(Y)}(y_1, \dots, y_n)) = q^{𝔸}(h(y_1), \dots, h(y_n))\\
                                       &= q^{𝔸}(a_1, \dots, a_n).

      It now follows from :numref:`Thm %s <fact-m1>` that every equational class is a variety. The converse is **Birkhoff's HSP Theorem**. ☐

----------------------------------

.. _birkhoffs-hsp-theorem:

Birkhoff's HSP theorem
------------------------

The following is Birkhoff's celebrated HSP theorem. (See also :cite:`Bergman:2012`, Thm 4.41.)

.. proof:theorem:: 

   Every variety is an equational class.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Let 𝒲 be a variety. We must find a set of equations that axiomatizes 𝒲. The obvious choice is to use the set of all equations that hold in 𝒲.

      To this end, take :math:`Σ = \Th(𝒲)`. Let :math:`𝒲^† := \Mod(Σ)`.  
  
      Clearly, :math:`𝒲 ⊆ 𝒲^†`. We shall prove the reverse inclusion.

      Let :math:`𝔸 ∈ 𝒲^†` and :math:`Y` a set of cardinality :math:`\max(|A|, ω)`. *Choose* a surjection :math:`h_0 : Y → A`. [5]_
  
      By :numref:`Obs %s <obs-six>` (which is essentially Thm. 4.21 of :cite:`Bergman:2012`), :math:`h_0` extends to an epimorphism :math:`h: 𝕋(Y) → 𝔸`.

      Furthermore, since :math:`𝔽_𝒲(Y) = 𝕋(Y)/Θ_𝒲`, there is an epimorphism :math:`g: 𝕋(Y) → 𝔽_𝒲`. [6]_

      We claim that :math:`\ker g ⊆ \ker h`. If the claim is true, then by :numref:`Obs %s <obs-four>` there is a map :math:`f: 𝔽_𝒲(Y) → 𝔸` such that :math:`f ∘ g = h`.
   
      Since :math:`h` is epic, so is :math:`f`. Hence :math:`𝔸 ∈ 𝖧 (𝔽_{𝒲}(Y)) ⊆ 𝒲` completing the proof. ☐

Let :math:`u,v ∈ T(Y)` and assume that :math:`g(u) = g(v)`. Since :math:`𝕋(Y)` is generated by :math:`Y`, then by :numref:`Obs %s <obs-six>` there is an integer :math:`n`, terms :math:`p, q ∈ T(X_n)`, and :math:`y_1, \dots, y_n ∈ Y` such that :math:`u = p^{𝕋(Y)}(y_1, \dots, y_n)` and :math:`v = q^{𝕋(Y)}(y_1,\dots, y_n)`, by Theorem 4.32 of :cite:`Bergman:2012`.

Applying the homomorphism :math:`g`,

.. math:: p^{𝔽_{𝒲}(Y)}(y_1, \dots, y_n) = g(u) = g(v) = q^{𝔽_{𝒲}(Y)}(y_1,\dots, y_n).

Then by :numref:`Thm %s <fact-m4>` above (Corollary 4.39 of :cite:`Bergman:2012`), we have :math:`𝒲 ⊧ p ≈ q`, hence :math:`(p ≈ q) \in Σ`.

Since :math:`𝔸 ∈ 𝒲^† = \Mod(Σ)`, we obtain :math:`𝔸 ⊧ p ≈ q`. Therefore,

.. math:: h(u) = p^{𝔸}(h_0(y_1), \dots, h_0(y_n)) = q^{𝔸}(h_0(y_1), \dots, h_0(y_n)) = h(v),

as desired.

---------------------------

.. rubric:: Footnotes

.. [1]
   By "the constants on :math:`A`" we mean the **constant operations**; i.e., functions :math:`f: A → A` such that :math:`∀ a ∈ A, f(a) = c`, for some :math:`c ∈ A`.

.. [2]
   The construction of :math:`𝕋_ρ (X)` may seem to be making something out of nothing, but it plays an significant role in the theory.

.. [3]
   Produce ``≈`` with ``\approx``.

.. [4]
   Produce ⊧ with ``\models``.

.. [5]
   **AoC**. It seems we need to use some :term:`Choice` axiom here.

.. [6]
   **AoC**. *ditto*

.. include:: hyperlink_references.rst
